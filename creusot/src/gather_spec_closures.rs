use crate::{
    contracts_items::{
        get_invariant_expl, is_assertion, is_before_loop, is_loop_variant, is_snapshot_closure,
    },
    ctx::TranslationCtx,
    pearlite::Term,
};
use indexmap::{IndexMap, IndexSet};
use rustc_hir::def_id::DefId;
use rustc_middle::{
    mir::{visit::Visitor, AggregateKind, BasicBlock, Body, Location, Operand, Rvalue},
    ty::{Ty, TyCtxt, TyKind},
};

#[derive(Debug, Clone)]
pub enum LoopSpecKind {
    Invariant(String),
    Variant,
}

/// Collect spec-related special closures in a mir [`Body`].
pub(crate) struct SpecClosures<'tcx> {
    /// Closures generated by `proof_assert!`
    pub(crate) assertions: IndexMap<DefId, Term<'tcx>>,
    /// Closures generated by `snapshot!`
    pub(crate) snapshots: IndexMap<DefId, Term<'tcx>>,
}

impl<'tcx> SpecClosures<'tcx> {
    pub(crate) fn collect(ctx: &mut TranslationCtx<'tcx>, body: &Body<'tcx>) -> Self {
        let mut visitor = Closures::new(ctx.tcx);
        visitor.visit_body(body);

        let mut assertions = IndexMap::new();
        let mut snapshots = IndexMap::new();
        for clos in visitor.closures.into_iter() {
            if is_assertion(ctx.tcx, clos) {
                let term = ctx.term_fail_fast(clos).unwrap().clone();
                assertions.insert(clos, term);
            } else if is_snapshot_closure(ctx.tcx, clos) {
                let term = ctx.term_fail_fast(clos).unwrap().clone();
                snapshots.insert(clos, term);
            }
        }
        Self { assertions, snapshots }
    }
}

// Collect the closures in thir, so that we can do typechecking ourselves, and
// translate the invariant closure from thir.
struct Closures<'tcx> {
    pub tcx: TyCtxt<'tcx>,
    pub closures: IndexSet<DefId>,
}

impl<'tcx> Closures<'tcx> {
    fn new(tcx: TyCtxt<'tcx>) -> Self {
        Closures { tcx, closures: IndexSet::new() }
    }
}

fn snapshot_closure_id<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<DefId> {
    if let TyKind::Closure(def_id, _) = ty.peel_refs().kind() {
        is_snapshot_closure(tcx, *def_id).then_some(*def_id)
    } else {
        None
    }
}

impl<'tcx> Visitor<'tcx> for Closures<'tcx> {
    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, loc: Location) {
        match rvalue {
            Rvalue::Aggregate(box AggregateKind::Closure(id, _), _) => {
                self.closures.insert(*id);
            }
            Rvalue::Use(Operand::Constant(box ck)) => {
                if let Some(def_id) = snapshot_closure_id(self.tcx, ck.const_.ty()) {
                    self.closures.insert(def_id);
                }
            }
            _ => {}
        }
        self.super_rvalue(rvalue, loc);
    }
}

pub(crate) struct Invariants<'tcx> {
    pub(crate) loop_headers: IndexMap<BasicBlock, Vec<(LoopSpecKind, Term<'tcx>)>>,
    /// Invariants for which we couldn't find a loop header are translated as assertions.
    pub(crate) assertions: IndexMap<DefId, (Term<'tcx>, String)>,
}

struct InvariantsVisitor<'a, 'tcx> {
    ctx: &'a mut TranslationCtx<'tcx>,
    body: &'a Body<'tcx>,
    before_loop: IndexSet<BasicBlock>,
    invariants: Invariants<'tcx>,
}

impl<'a, 'tcx> InvariantsVisitor<'a, 'tcx> {
    // Search backwards for the loop header: it should have more than one predecessor.
    fn find_loop_header(&self, loc: Location) -> Option<BasicBlock> {
        let mut block = loc.block;
        if self.before_loop.contains(&block) {
            // Reached "before_loop" marker in the same block.
            // This assumes that statements are visited in order, so that if a block
            // contains both invariants and a "before_block" marker, the marker is not
            // in the `before_loop` set when we visit invariants before it.
            return None;
        }
        loop {
            let preds = &self.body.basic_blocks.predecessors()[block];
            if preds.len() > 1 {
                return Some(block);
            }
            let Some(pred) = preds.first() else {
                // Reached the top of the function. Impossible.
                panic!("The impossible happened: Missing 'before_loop' marker.");
            };
            if self.before_loop.contains(pred) {
                // Reached "before_loop" marker.
                return None;
            }
            block = *pred;
        }
    }
}

impl<'a, 'tcx> Visitor<'tcx> for InvariantsVisitor<'a, 'tcx> {
    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, loc: Location) {
        if let Rvalue::Aggregate(box AggregateKind::Closure(id, _), _) = rvalue {
            let kind = if let Some(expl) = get_invariant_expl(self.ctx.tcx, *id) {
                LoopSpecKind::Invariant(expl)
            } else if is_loop_variant(self.ctx.tcx, *id) {
                self.ctx.warn(self.ctx.def_span(id), "Loop variants are currently unsupported.");
                LoopSpecKind::Variant
            } else {
                if is_before_loop(self.ctx.tcx, *id) {
                    self.before_loop.insert(loc.block);
                }
                return;
            };
            let term = self.ctx.term_fail_fast(*id).unwrap().clone();
            match self.find_loop_header(loc) {
                None if let LoopSpecKind::Invariant(expl) = kind => {
                    self.ctx.warn(
                        self.ctx.def_span(id),
                        "This loop does not loop. This invariant could just be an assertion.",
                    );
                    let assertions = &mut self.invariants.assertions;
                    assertions.insert(*id, (term, expl));
                }
                None => self.ctx.warn(
                    self.ctx.def_span(id),
                    "This loop does not loop. This variant will be ignored.",
                ),
                Some(target) => {
                    let loop_headers = &mut self.invariants.loop_headers;
                    loop_headers.entry(target).or_insert_with(Vec::new).push((kind, term))
                }
            }
        }
        self.super_rvalue(rvalue, loc);
    }
}

// Calculate the *actual* location of invariants in MIR
pub(crate) fn corrected_invariant_names_and_locations<'tcx>(
    ctx: &mut TranslationCtx<'tcx>,
    body: &Body<'tcx>,
) -> Invariants<'tcx> {
    let mut invs_gather = InvariantsVisitor {
        ctx,
        body,
        before_loop: IndexSet::new(),
        invariants: Invariants { loop_headers: IndexMap::new(), assertions: IndexMap::new() },
    };
    invs_gather.visit_body(body);
    invs_gather.invariants
}
