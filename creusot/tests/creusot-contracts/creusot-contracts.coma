module M_creusot_contracts__logic__fmap__qyi9892930999379617882__subtract [#"../../../creusot-contracts/src/logic/fmap.rs" 179 4 179 46] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 171 15 171 33
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 172 14 172 36
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 173 14 173 46
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 174 14 178 5
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 160 14 164 5
  let%span sfmap5 = "../../../creusot-contracts/src/logic/fmap.rs" 180 8 180 33
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 139 12 139 89
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 132 19 132 71
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 145 15 145 35
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 146 14 152 5
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 153 14 153 54
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 185 14 185 38
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 186 14 186 83
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 188 8 188 35
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 120 8 120 35
  let%span sfmap16 = "../../../creusot-contracts/src/logic/fmap.rs" 44 14 44 25
  let%span sfmap17 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map t_K'0 (t_Option'0)) : t_FMap'0
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map t_K'0 (t_Option'0)
    
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap17] mk'0 (view'0 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
    
   =
    [%#sfmap14] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 119 4 119 39] (self : t_FMap'0) (k : t_K'0) : bool
    
   =
    [%#sfmap15] get_unsized'0 self k <> C_None'0
  
  function subset'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 137 4 137 44] (self : t_FMap'0) (other : t_FMap'0) : bool
    
   =
    [%#sfmap6] forall k : t_K'0 . contains'0 self k  -> get_unsized'0 other k = get_unsized'0 self k
  
  function disjoint'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 131 4 131 46] (self : t_FMap'0) (other : t_FMap'0) : bool
    
   =
    [%#sfmap7] forall k : t_K'0 . not contains'0 self k \/ not contains'0 other k
  
  use prelude.prelude.Int
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 45 4 45 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap16] len'0 self >= 0
  
  function union'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 154 4 154 43] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
    
  
  axiom union'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap8] disjoint'0 self other)
   -> ([%#sfmap9] forall k : t_K'0 . get_unsized'0 (union'0 self other) k
  = (if contains'0 self k then
    get_unsized'0 self k
  else
    if contains'0 other k then get_unsized'0 other k else C_None'0
  ))
  && ([%#sfmap10] len'0 (union'0 self other) = len'0 self + len'0 other)
  
  function ext_eq'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self : t_FMap'0) (other : t_FMap'0) : bool
    
   =
    [%#sfmap13] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap11] ext_eq'0 self other  -> self = other)
  && ([%#sfmap12] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function subtract_keys'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 165 4 165 51] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
    
  
  axiom subtract_keys'0_spec : forall self : t_FMap'0, other : t_FMap'0 . [%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function subtract'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 179 4 179 46] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
    
  
  goal vc_subtract'0 : ([%#sfmap0] subset'0 other self)
   -> ([%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k))
   -> (let result = subtract_keys'0 self other in ([%#sfmap1] disjoint'0 result other)
  && ([%#sfmap2] ext_eq'0 (union'0 other result) self)
  && ([%#sfmap3] forall k : t_K'0 . get_unsized'0 result k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)))
end
module M_creusot_contracts__logic__fmap__qyi9892930999379617882__ext_eq [#"../../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 185 14 185 38
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 186 14 186 83
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 188 8 188 35
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  
  type t_K'0
  
  type t_FMap'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map t_K'0 (t_Option'0)) : t_FMap'0
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map t_K'0 (t_Option'0)
    
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap2] mk'0 (view'0 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
    
   =
    [%#sfmap4] Map.get (view'0 self) k
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function ext_eq'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self : t_FMap'0) (other : t_FMap'0) : bool
    
  
  goal vc_ext_eq'0 : ([%#sfmap2] mk'0 (view'0 self) = self)
   -> ([%#sfmap2] mk'0 (view'0 other) = other)
   -> (let result = view'0 self = view'0 other in ([%#sfmap0] result  -> self = other)
  && ([%#sfmap1] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> result))
end
module M_creusot_contracts__logic__fmap__qyi9892930999379617882__contains_ghost [#"../../../creusot-contracts/src/logic/fmap.rs" 256 4 256 49] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 256 33 256 36
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 255 14 255 43
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 285 28 285 31
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 285 40 285 50
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 277 4 284 11
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 36 26 36 51
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 120 8 120 35
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 103 8 103 35
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sutil9 = "../../../creusot-contracts/src/util.rs" 32 11 32 21
  let%span sutil10 = "../../../creusot-contracts/src/util.rs" 33 10 33 28
  let%span sinvariant11 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  
  use prelude.prelude.Borrow
  
  type t_K'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_K'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_K'0) =
    [%#sinvariant11] inv'4 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_K'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_K'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_V'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_V'0) =
    [%#sinvariant11] inv'5 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_V'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  type t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map t_K'0 (t_Option'1)) : t_FMap'0
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map t_K'0 (t_Option'1)
    
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] mk'0 (view'0 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : t_K'0) : t_Option'1
    
   =
    [%#sfmap8] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 119 4 119 39] (self : t_FMap'0) (k : t_K'0) : bool
    
   =
    [%#sfmap6] get_unsized'0 self k <> C_None'1
  
  function unwrap'0 [#"../../../creusot-contracts/src/util.rs" 34 0 34 36] (op : t_Option'1) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil9] op <> C_None'1)
   -> ([%#sutil10] C_Some'1 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 102 4 102 50] (self : t_FMap'0) (k : t_K'0) : t_V'0
    
   =
    [%#sfmap7] unwrap'0 (get_unsized'0 self k)
  
  let rec get_ghost'0 (self:t_FMap'0) (key:t_K'0) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'key' type invariant] [%#sfmap2] inv'0 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap3] inv'1 result}
      {[%#sfmap4] if contains'0 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
    
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Option'0) =
    [%#sinvariant11] inv'1 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  let rec is_some'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_some 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption5] result = (self <> C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost'0 (self:t_FMap'0) (key:t_K'0) (return'  (ret:bool))= {[@expl:contains_ghost 'key' type invariant] [%#sfmap0] inv'0 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost'0 {self} {key} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some'0 {_5} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : bool = any_l () | & self : t_FMap'0 = self | & key : t_K'0 = key | & _5 : t_Option'0 = any_l () ] 
    [ return' (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap1] result = contains'0 self key}
      (! return' {result}) ]
    
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int) (y : int) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int) (y : int) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int) (y : int) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int) (y : int) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord4] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int) (y : int) (z : int) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int) (y : int) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int) (y : int) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int) (y : int) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt8.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt8.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt8.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt8.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt8.t) (y : UInt8.t) (z : UInt8.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt16.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt16.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt16.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt16.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt16.t) (y : UInt16.t) (z : UInt16.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt32.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt32.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt32.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt32.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt32.t) (y : UInt32.t) (z : UInt32.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt128.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt128.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt128.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt128.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt128.t) (y : UInt128.t) (z : UInt128.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord4] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord3] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord2] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int8.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int8.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int8.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int8.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord4] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int8.t) (y : Int8.t) (z : Int8.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord3] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord3] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord2] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int16.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int16.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int16.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int16.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord4] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int16.t) (y : Int16.t) (z : Int16.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord3] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord3] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord2] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int32.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int32.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int32.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int32.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord4] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int32.t) (y : Int32.t) (z : Int32.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord3] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord3] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord2] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord4] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord3] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord3] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int128.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int128.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int128.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int128.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord4] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int128.t) (y : Int128.t) (z : Int128.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord3] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord3] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord2] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord4] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord3] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord3] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord2] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  constant x  : bool
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord4] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 303 20 303 68
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 302 4 302 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 309 20 309 67
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 308 4 308 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 315 20 315 68
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 314 4 314 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 321 20 321 67
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 320 4 320 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : (t_A'0, t_B'0)) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord17] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord15] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Less'0)
   -> ([%#sord14] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord10] cmp_log'2 x y = o)
   -> ([%#sord11] cmp_log'2 y z = o)  -> ([%#sord12] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord9] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord8] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord4] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  constant z  : (t_A'0, t_B'0)
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) (z : (t_A'0, t_B'0)) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
    
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_le_log [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 87 14 87 64
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 85 4 85 10
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_cmp_le_log'0 : [%#scmp0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_lt_log [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 92 14 92 61
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 90 4 90 10
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_cmp_lt_log'0 : [%#scmp0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_ge_log [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 97 14 97 61
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 95 4 95 10
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_cmp_ge_log'0 : [%#scmp0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_gt_log [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 102 14 102 64
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 100 4 100 10
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_cmp_gt_log'0 : [%#scmp0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__refl [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 105 4 105 10
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  function refl'0 [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : t_Reverse'0) : ()
  
  goal vc_refl'0 : [%#scmp0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__trans [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 110 4 110 10
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp4] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  constant z  : t_Reverse'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : t_Reverse'0) (y : t_Reverse'0) (z : t_Reverse'0) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#scmp1] cmp_log'0 y z = o)  -> ([%#scmp0] cmp_log'0 x y = o)  -> ([%#scmp2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 117 4 117 10
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym1'0 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_antisym1'0 : ([%#scmp0] cmp_log'0 x y = C_Less'0)  -> ([%#scmp1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym2 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 123 4 123 10
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym2'0 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
    
  
  goal vc_antisym2'0 : ([%#scmp0] cmp_log'0 x y = C_Greater'0)  -> ([%#scmp1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__eq_cmp [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 129 4 129 10
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_eq_cmp'0 : [%#scmp0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_refl [#"../../../creusot-contracts/src/std/deque.rs" 178 4 178 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 177 14 177 45
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 175 4 175 10
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 171 12 171 66
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel5 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops6 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 155 4 155 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 169 4 169 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sdeque2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/deque.rs" 178 4 178 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sdeque0] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_trans [#"../../../creusot-contracts/src/std/deque.rs" 185 4 185 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 182 15 182 32
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 183 15 183 32
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 184 14 184 42
  let%span sdeque3 = "../../../creusot-contracts/src/std/deque.rs" 180 4 180 10
  let%span sdeque4 = "../../../creusot-contracts/src/std/deque.rs" 171 12 171 66
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 155 4 155 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 169 4 169 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sdeque4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/deque.rs" 185 4 185 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sdeque1] produces'0 b bc c)
   -> ([%#sdeque0] produces'0 a ab b)  -> ([%#sdeque2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_refl [#"../../../creusot-contracts/src/std/iter/cloned.rs" 62 4 62 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 60 15 60 24
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 61 14 61 45
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 10
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 51 12 54 79
  let%span scloned4 = "../../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq13 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant15 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant15] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed14] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq13] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned4] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] inv'2 a)
   -> ([%#siter8] inv'2 b)
   -> ([%#siter9] inv'2 c)
   -> ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter5] inv'2 self)
   -> ([%#siter6] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 49 4 49 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
    
   =
    [%#scloned3] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Cloned'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 62 4 62 26] (self : t_Cloned'0) : ()
  
  goal vc_produces_refl'0 : ([%#scloned0] inv'0 self)
   -> ([%#scloned1] produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_trans [#"../../../creusot-contracts/src/std/iter/cloned.rs" 72 4 72 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 66 15 66 21
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 67 15 67 21
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 68 15 68 21
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 69 15 69 32
  let%span scloned4 = "../../../creusot-contracts/src/std/iter/cloned.rs" 70 15 70 32
  let%span scloned5 = "../../../creusot-contracts/src/std/iter/cloned.rs" 71 14 71 42
  let%span scloned6 = "../../../creusot-contracts/src/std/iter/cloned.rs" 64 4 64 10
  let%span scloned7 = "../../../creusot-contracts/src/std/iter/cloned.rs" 51 12 54 79
  let%span scloned8 = "../../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed18 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant19] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed18] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq17] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned8] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter11] inv'2 a)
   -> ([%#siter12] inv'2 b)
   -> ([%#siter13] inv'2 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter9] inv'2 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 49 4 49 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
    
   =
    [%#scloned7] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant a  : t_Cloned'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Cloned'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Cloned'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 72 4 72 90] (a : t_Cloned'0) (ab : Seq.seq t_T'0) (b : t_Cloned'0) (bc : Seq.seq t_T'0) (c : t_Cloned'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#scloned4] produces'0 b bc c)
   -> ([%#scloned3] produces'0 a ab b)
   -> ([%#scloned2] inv'0 c)
   -> ([%#scloned1] inv'0 b)  -> ([%#scloned0] inv'0 a)  -> ([%#scloned5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_refl [#"../../../creusot-contracts/src/std/iter/copied.rs" 62 4 62 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 60 15 60 24
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 61 14 61 45
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 10
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 51 12 54 79
  let%span scopied4 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq13 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant15 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant15] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed14] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq13] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied4] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] inv'2 a)
   -> ([%#siter8] inv'2 b)
   -> ([%#siter9] inv'2 c)
   -> ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter5] inv'2 self)
   -> ([%#siter6] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 49 4 49 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
    
   =
    [%#scopied3] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Copied'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 62 4 62 26] (self : t_Copied'0) : ()
  
  goal vc_produces_refl'0 : ([%#scopied0] inv'0 self)
   -> ([%#scopied1] produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_trans [#"../../../creusot-contracts/src/std/iter/copied.rs" 72 4 72 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 66 15 66 21
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 67 15 67 21
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 68 15 68 21
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 69 15 69 32
  let%span scopied4 = "../../../creusot-contracts/src/std/iter/copied.rs" 70 15 70 32
  let%span scopied5 = "../../../creusot-contracts/src/std/iter/copied.rs" 71 14 71 42
  let%span scopied6 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 4 64 10
  let%span scopied7 = "../../../creusot-contracts/src/std/iter/copied.rs" 51 12 54 79
  let%span scopied8 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed18 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant19] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed18] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq17] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied8] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter11] inv'2 a)
   -> ([%#siter12] inv'2 b)
   -> ([%#siter13] inv'2 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter9] inv'2 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 49 4 49 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
    
   =
    [%#scopied7] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant a  : t_Copied'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Copied'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Copied'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 72 4 72 90] (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#scopied4] produces'0 b bc c)
   -> ([%#scopied3] produces'0 a ab b)
   -> ([%#scopied2] inv'0 c)
   -> ([%#scopied1] inv'0 b)  -> ([%#scopied0] inv'0 a)  -> ([%#scopied5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_refl [#"../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 18 15 18 24
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 19 14 19 45
  let%span sempty2 = "../../../creusot-contracts/src/std/iter/empty.rs" 16 4 16 10
  let%span sempty3 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Empty'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Empty'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
    
   =
    [%#sempty3] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
  
  constant self  : t_Empty'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26] (self : t_Empty'0) : ()
  
  goal vc_produces_refl'0 : ([%#sempty0] inv'0 self)  -> ([%#sempty1] produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_trans [#"../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 24 15 24 21
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 25 15 25 21
  let%span sempty2 = "../../../creusot-contracts/src/std/iter/empty.rs" 26 15 26 21
  let%span sempty3 = "../../../creusot-contracts/src/std/iter/empty.rs" 27 15 27 32
  let%span sempty4 = "../../../creusot-contracts/src/std/iter/empty.rs" 28 15 28 32
  let%span sempty5 = "../../../creusot-contracts/src/std/iter/empty.rs" 29 14 29 42
  let%span sempty6 = "../../../creusot-contracts/src/std/iter/empty.rs" 22 4 22 10
  let%span sempty7 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Empty'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Empty'0 [inv'0 x] . inv'0 x = true
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
    
   =
    [%#sempty7] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
  
  use seq.Seq
  
  constant a  : t_Empty'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Empty'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Empty'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90] (a : t_Empty'0) (ab : Seq.seq t_T'0) (b : t_Empty'0) (bc : Seq.seq t_T'0) (c : t_Empty'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sempty4] produces'0 b bc c)
   -> ([%#sempty3] produces'0 a ab b)
   -> ([%#sempty2] inv'0 c)
   -> ([%#sempty1] inv'0 b)  -> ([%#sempty0] inv'0 a)  -> ([%#sempty5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_refl [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 86 4 86 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 84 15 84 24
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 85 14 85 45
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 82 4 82 10
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 74 12 78 113
  let%span senumerate4 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate5 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 79
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq14 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed15] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] inv'2 a)
   -> ([%#siter9] inv'2 b)
   -> ([%#siter10] inv'2 c)
   -> ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter6] inv'2 self)
   -> ([%#siter7] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate5] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UInt64.to_uint v_MAX'0)
    /\ (forall i : borrowed t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 72 4 72 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
    
   =
    [%#senumerate3] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.to_uint (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  constant self  : t_Enumerate'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 86 4 86 26] (self : t_Enumerate'0) : ()
    
  
  goal vc_produces_refl'0 : ([%#senumerate0] inv'0 self)
   -> ([%#senumerate1] produces'0 self (Seq.empty  : Seq.seq (UInt64.t, t_Item'0)) self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_trans [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 96 4 96 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 90 15 90 21
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 91 15 91 21
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 92 15 92 21
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 93 15 93 32
  let%span senumerate4 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 94 15 94 32
  let%span senumerate5 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 95 14 95 42
  let%span senumerate6 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 88 4 88 10
  let%span senumerate7 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 74 12 78 113
  let%span senumerate8 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate9 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 79
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed19 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed19] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'2 a)
   -> ([%#siter13] inv'2 b)
   -> ([%#siter14] inv'2 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter10] inv'2 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate8] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate9] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UInt64.to_uint v_MAX'0)
    /\ (forall i : borrowed t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 72 4 72 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
    
   =
    [%#senumerate7] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.to_uint (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  constant a  : t_Enumerate'0
  
  constant ab  : Seq.seq (UInt64.t, t_Item'0)
  
  constant b  : t_Enumerate'0
  
  constant bc  : Seq.seq (UInt64.t, t_Item'0)
  
  constant c  : t_Enumerate'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 96 4 96 90] (a : t_Enumerate'0) (ab : Seq.seq (UInt64.t, t_Item'0)) (b : t_Enumerate'0) (bc : Seq.seq (UInt64.t, t_Item'0)) (c : t_Enumerate'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#senumerate4] produces'0 b bc c)
   -> ([%#senumerate3] produces'0 a ab b)
   -> ([%#senumerate2] inv'0 c)
   -> ([%#senumerate1] inv'0 b)  -> ([%#senumerate0] inv'0 a)  -> ([%#senumerate5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160__produces_refl [#"../../../creusot-contracts/src/std/iter/filter.rs" 106 4 106 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 104 15 104 24
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 105 14 105 45
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 102 4 102 10
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span sfilter4 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter5 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter6 = "../../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  type t_Item'0
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : bool)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter6] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'1 iter /\ inv'2 predicate'
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'2 (func'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter5] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] inv'1 a)
   -> ([%#siter17] inv'1 b)
   -> ([%#siter18] inv'1 c)
   -> ([%#siter19] produces'1 a ab b)
   -> ([%#siter20] produces'1 b bc c)  -> ([%#siter21] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter14] inv'1 self)
   -> ([%#siter15] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
    
   =
    [%#sfilter3] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 106 4 106 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : ([%#sfilter0] inv'0 self)
   -> ([%#sfilter1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160__produces_trans [#"../../../creusot-contracts/src/std/iter/filter.rs" 116 4 116 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 21
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 111 15 111 21
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 112 15 112 21
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 113 15 113 32
  let%span sfilter4 = "../../../creusot-contracts/src/std/iter/filter.rs" 114 15 114 32
  let%span sfilter5 = "../../../creusot-contracts/src/std/iter/filter.rs" 115 14 115 42
  let%span sfilter6 = "../../../creusot-contracts/src/std/iter/filter.rs" 108 4 108 10
  let%span sfilter7 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span sfilter8 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter9 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter10 = "../../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops16 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops17 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter24 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter25 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  type t_Item'0
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : bool)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops17] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops14] unnest'0 self b)
   -> ([%#sops15] unnest'0 b c)  -> ([%#sops16] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops13] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops11] postcondition_mut'0 self args res_state res)
   -> ([%#sops12] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter10] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'1 iter /\ inv'2 predicate'
    end)
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter8] inv'0 self  -> inv'2 (func'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter9] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter20] inv'1 a)
   -> ([%#siter21] inv'1 b)
   -> ([%#siter22] inv'1 c)
   -> ([%#siter23] produces'1 a ab b)
   -> ([%#siter24] produces'1 b bc c)  -> ([%#siter25] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter18] inv'1 self)
   -> ([%#siter19] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
    
   =
    [%#sfilter7] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 116 4 116 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sfilter4] produces'0 b bc c)
   -> ([%#sfilter3] produces'0 a ab b)
   -> ([%#sfilter2] inv'0 c)
   -> ([%#sfilter1] inv'0 b)  -> ([%#sfilter0] inv'0 a)  -> ([%#sfilter5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_refl [#"../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 41 15 41 24
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 42 14 42 45
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse5 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse4] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse5] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] inv'2 a)
   -> ([%#siter9] inv'2 b)
   -> ([%#siter10] inv'2 c)
   -> ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter6] inv'2 self)
   -> ([%#siter7] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse3] match view'0 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant self  : t_Fuse'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26] (self : t_Fuse'0) : ()
  
  goal vc_produces_refl'0 : ([%#sfuse0] inv'0 self)
   -> ([%#sfuse1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_trans [#"../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 21
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 48 15 48 21
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 49 15 49 21
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 50 15 50 32
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 51 15 51 32
  let%span sfuse5 = "../../../creusot-contracts/src/std/iter/fuse.rs" 52 14 52 42
  let%span sfuse6 = "../../../creusot-contracts/src/std/iter/fuse.rs" 45 4 45 10
  let%span sfuse7 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse8 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse9 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse8] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse9] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'2 a)
   -> ([%#siter13] inv'2 b)
   -> ([%#siter14] inv'2 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter10] inv'2 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse7] match view'0 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant a  : t_Fuse'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Fuse'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Fuse'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sfuse4] produces'0 b bc c)
   -> ([%#sfuse3] produces'0 a ab b)
   -> ([%#sfuse2] inv'0 c)
   -> ([%#sfuse1] inv'0 b)  -> ([%#sfuse0] inv'0 a)  -> ([%#sfuse5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi7691061398646472980__is_fused [#"../../../creusot-contracts/src/std/iter/fuse.rs" 76 4 76 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 70 15 70 24
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 71 15 71 24
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 72 15 72 25
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 73 15 73 31
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 74 15 74 44
  let%span sfuse5 = "../../../creusot-contracts/src/std/iter/fuse.rs" 75 14 75 50
  let%span sfuse6 = "../../../creusot-contracts/src/std/iter/fuse.rs" 68 4 68 10
  let%span sfuse7 = "../../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse8 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse9 = "../../../creusot-contracts/src/std/iter/fuse.rs" 41 15 41 24
  let%span sfuse10 = "../../../creusot-contracts/src/std/iter/fuse.rs" 42 14 42 45
  let%span sfuse11 = "../../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse12 = "../../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 21
  let%span sfuse13 = "../../../creusot-contracts/src/std/iter/fuse.rs" 48 15 48 21
  let%span sfuse14 = "../../../creusot-contracts/src/std/iter/fuse.rs" 49 15 49 21
  let%span sfuse15 = "../../../creusot-contracts/src/std/iter/fuse.rs" 50 15 50 32
  let%span sfuse16 = "../../../creusot-contracts/src/std/iter/fuse.rs" 51 15 51 32
  let%span sfuse17 = "../../../creusot-contracts/src/std/iter/fuse.rs" 52 14 52 42
  let%span sfuse18 = "../../../creusot-contracts/src/std/iter/fuse.rs" 45 4 45 10
  let%span smodel19 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sfuse20 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse21 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span sinvariant22 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sseq23 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span siter24 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter25 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter26 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter27 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter28 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter29 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter30 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter31 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sboxed32 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Fuse'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'4 iter
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_Fuse'0)) =
    [%#sinvariant22] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_Fuse'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Fuse'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed32] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq23] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'1_spec : forall self : t_Fuse'0 . ([%#sfuse20] inv'1 self  -> inv'4 (view'1 self))
  && ([%#sfuse21] forall other : t_Fuse'0 . view'1 self = view'1 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter26] inv'6 a)
   -> ([%#siter27] inv'6 b)
   -> ([%#siter28] inv'6 c)
   -> ([%#siter29] produces'1 a ab b)
   -> ([%#siter30] produces'1 b bc c)  -> ([%#siter31] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter24] inv'6 self)
   -> ([%#siter25] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse8] match view'1 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'1 other = view'1 self
      | C_Some'0 i -> match view'1 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
    
   =
    [%#sfuse18] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse12] inv'1 a)
   -> ([%#sfuse13] inv'1 b)
   -> ([%#sfuse14] inv'1 c)
   -> ([%#sfuse15] produces'0 a ab b)
   -> ([%#sfuse16] produces'0 b bc c)  -> ([%#sfuse17] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26] (self : t_Fuse'0) : () =
    [%#sfuse11] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . ([%#sfuse9] inv'1 self)
   -> ([%#sfuse10] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (t_Fuse'0)) : t_Option'0 =
    [%#smodel19] view'1 self.current
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant22] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_I'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : borrowed (t_Fuse'0)) =
    [%#sfuse7] (view'0 self = C_None'0
    \/ (exists it : borrowed t_I'0 . inv'3 it /\ completed'1 it /\ view'0 self = C_Some'0 (it.current)))
    /\ view'1 self.final = C_None'0
  
  constant self  : borrowed (t_Fuse'0)
  
  constant steps  : Seq.seq t_Item'0
  
  constant next  : t_Fuse'0
  
  function is_fused'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 76 4 76 62] (self : borrowed (t_Fuse'0)) (steps : Seq.seq t_Item'0) (next : t_Fuse'0) : ()
    
  
  goal vc_is_fused'0 : ([%#sfuse4] produces'0 self.final steps next)
   -> ([%#sfuse3] completed'0 self)
   -> ([%#sfuse2] inv'2 steps)
   -> ([%#sfuse1] inv'1 next)
   -> ([%#sfuse0] inv'0 self)  -> ([%#sfuse5] steps = (Seq.empty  : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791__produces_refl [#"../../../creusot-contracts/src/std/iter/map.rs" 83 4 83 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 81 15 81 24
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 82 14 82 45
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 79 4 79 10
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 64 12 75 75
  let%span smap4 = "../../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap5 = "../../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq21 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed22 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant23 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'3 iter /\ inv'4 f
    end
  
  use seq.Seq
  
  type t_B'0
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap4] inv'0 self  -> inv'4 (func'0 self)
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops12] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops9] unnest'0 self b)
   -> ([%#sops10] unnest'0 b c)  -> ([%#sops11] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops8] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops6] postcondition_mut'0 self args res_state res)
   -> ([%#sops7] unnest'0 self res_state)
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant23] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed22] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq21] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed22] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq21] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap5] inv'0 self  -> inv'3 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter15] inv'3 a)
   -> ([%#siter16] inv'3 b)
   -> ([%#siter17] inv'3 c)
   -> ([%#siter18] produces'1 a ab b)
   -> ([%#siter19] produces'1 b bc c)  -> ([%#siter20] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter13] inv'3 self)
   -> ([%#siter14] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 62 4 62 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
    
   =
    [%#smap3] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_Map'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 83 4 83 26] (self : t_Map'0) : ()
  
  goal vc_produces_refl'0 : ([%#smap0] inv'0 self)  -> ([%#smap1] produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791__produces_trans [#"../../../creusot-contracts/src/std/iter/map.rs" 93 4 93 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 87 15 87 21
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 88 15 88 21
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 89 15 89 21
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 90 15 90 32
  let%span smap4 = "../../../creusot-contracts/src/std/iter/map.rs" 91 15 91 32
  let%span smap5 = "../../../creusot-contracts/src/std/iter/map.rs" 92 14 92 42
  let%span smap6 = "../../../creusot-contracts/src/std/iter/map.rs" 85 4 85 10
  let%span smap7 = "../../../creusot-contracts/src/std/iter/map.rs" 64 12 75 75
  let%span smap8 = "../../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap9 = "../../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops16 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter24 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq25 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed26 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant27 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'3 iter /\ inv'4 f
    end
  
  type t_B'0
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap8] inv'0 self  -> inv'4 (func'0 self)
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant27] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed26] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq25] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed26] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq25] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap9] inv'0 self  -> inv'3 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter19] inv'3 a)
   -> ([%#siter20] inv'3 b)
   -> ([%#siter21] inv'3 c)
   -> ([%#siter22] produces'1 a ab b)
   -> ([%#siter23] produces'1 b bc c)  -> ([%#siter24] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter17] inv'3 self)
   -> ([%#siter18] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 62 4 62 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
    
   =
    [%#smap7] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant a  : t_Map'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_Map'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_Map'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 93 4 93 90] (a : t_Map'0) (ab : Seq.seq t_B'0) (b : t_Map'0) (bc : Seq.seq t_B'0) (c : t_Map'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#smap4] produces'0 b bc c)
   -> ([%#smap3] produces'0 a ab b)
   -> ([%#smap2] inv'0 c)
   -> ([%#smap1] inv'0 b)  -> ([%#smap0] inv'0 a)  -> ([%#smap5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi9026772487048432788__produces_refl [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 15 23 24
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span smap_inv20 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv21 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv22 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv23 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span sseq24 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv25 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sinvariant26 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed27 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  use prelude.prelude.Borrow
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant26] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_I'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter14] inv'3 a)
   -> ([%#siter15] inv'3 b)
   -> ([%#siter16] inv'3 c)
   -> ([%#siter17] produces'1 a ab b)
   -> ([%#siter18] produces'1 b bc c)  -> ([%#siter19] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter12] inv'3 self)
   -> ([%#siter13] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv23] forall e : t_Item'0, i : t_I'0 . inv'6 e /\ inv'3 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed27] inv'6 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq24] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant26] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv25] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv20] forall iter : borrowed t_I'0, func : t_F'0 . inv'5 iter /\ inv'4 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use prelude.prelude.Snapshot
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv22] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv21] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv4] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'3 iter /\ inv'4 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed27] inv'7 self
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq24] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv3] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_MapInv'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self : t_MapInv'0) : ()
  
  goal vc_produces_refl'0 : ([%#smap_inv0] inv'0 self)
   -> ([%#smap_inv1] produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi9026772487048432788__produces_trans [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 21
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 30 15 30 21
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 31 15 31 21
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 32 15 32 32
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 32
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 34 14 34 42
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 10
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span smap_inv24 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv25 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv26 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv27 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span sseq28 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv29 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sinvariant30 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed31 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  use prelude.prelude.Borrow
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant30] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_I'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter18] inv'3 a)
   -> ([%#siter19] inv'3 b)
   -> ([%#siter20] inv'3 c)
   -> ([%#siter21] produces'1 a ab b)
   -> ([%#siter22] produces'1 b bc c)  -> ([%#siter23] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter16] inv'3 self)
   -> ([%#siter17] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv27] forall e : t_Item'0, i : t_I'0 . inv'6 e /\ inv'3 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed31] inv'6 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq28] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant30] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops15] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops12] unnest'0 self b)
   -> ([%#sops13] unnest'0 b c)  -> ([%#sops14] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops11] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops9] postcondition_mut'0 self args res_state res)
   -> ([%#sops10] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv29] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv24] forall iter : borrowed t_I'0, func : t_F'0 . inv'5 iter /\ inv'4 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use prelude.prelude.Snapshot
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv26] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv25] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv8] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'3 iter /\ inv'4 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed31] inv'7 self
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq28] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv7] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant a  : t_MapInv'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_MapInv'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_MapInv'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#smap_inv4] produces'0 b bc c)
   -> ([%#smap_inv3] produces'0 a ab b)
   -> ([%#smap_inv2] inv'0 c)
   -> ([%#smap_inv1] inv'0 b)  -> ([%#smap_inv0] inv'0 a)  -> ([%#smap_inv5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi5691635635396426195__resolve_coherence [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 69 4 69 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 67 15 67 39
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 68 14 68 31
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 65 4 65 23
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 62 8 62 50
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_B'0) }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Snapshot.snap_ty (Seq.seq t_B'0))
   =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 28] (self : t_MapInv'0) =
    [%#smap_inv3] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  constant self  : t_MapInv'0
  
  function resolve_coherence'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 69 4 69 31] (self : t_MapInv'0) : ()
    
  
  goal vc_resolve_coherence'0 : ([%#smap_inv0] structural_resolve'0 self)  -> ([%#smap_inv1] resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4413682431414748756__next [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 96 4 96 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 97 39 97 58
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 100 16 100 76
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 101 31 101 71
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 105 38 105 88
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 106 32 106 63
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 111 32 111 56
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 96 17 96 21
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 96 26 96 44
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 92 14 95 5
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 158 27 158 52
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 159 26 159 71
  let%span smap_inv12 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 170 15 170 24
  let%span smap_inv13 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 171 15 171 21
  let%span smap_inv14 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 172 15 172 21
  let%span smap_inv15 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 173 15 173 21
  let%span smap_inv16 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 174 15 174 24
  let%span smap_inv17 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 175 4 175 60
  let%span smap_inv18 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 176 15 176 30
  let%span smap_inv19 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 177 15 177 64
  let%span smap_inv20 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 178 14 178 74
  let%span smap_inv21 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 75
  let%span smap_inv22 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 191 14 191 68
  let%span smap_inv23 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 194 12 199 74
  let%span smap_inv24 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv25 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv26 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv27 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span smap_inv28 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span sresolve29 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smap_inv30 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 15 23 24
  let%span smap_inv31 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv32 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv33 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 21
  let%span smap_inv34 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 30 15 30 21
  let%span smap_inv35 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 31 15 31 21
  let%span smap_inv36 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 32 15 32 32
  let%span smap_inv37 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 32
  let%span smap_inv38 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 34 14 34 42
  let%span smap_inv39 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 10
  let%span siter40 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter41 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter42 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter43 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter44 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter45 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter46 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter47 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops48 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops49 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops50 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops51 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops52 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops53 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops54 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span smap_inv55 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sinvariant56 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span smap_inv57 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span smap_inv58 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span sseq59 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed60 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Snapshot
  
  type t_I'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant56] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed t_I'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'5 x] . inv'5 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'10 a_0
    end
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter42] inv'0 a)
   -> ([%#siter43] inv'0 b)
   -> ([%#siter44] inv'0 c)
   -> ([%#siter45] produces'0 a ab b)
   -> ([%#siter46] produces'0 b bc c)  -> ([%#siter47] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter40] inv'0 self)
   -> ([%#siter41] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  use seq.Seq
  
  let rec next'1 (self:borrowed t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {inv'5 result}
      {[%#siter9] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant56] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed t_F'0 [inv'6 x] . inv'6 x = invariant'2 x
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  axiom inv_axiom'5 [@rewrite] : forall x : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)) [inv'7 x] . inv'7 x
  = (let (x0, x1) = x in inv'10 x0)
  
  type t_B'0
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops54] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'2 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops51] unnest'0 self b)
   -> ([%#sops52] unnest'0 b c)  -> ([%#sops53] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops50] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops48] postcondition_mut'0 self args res_state res)
   -> ([%#sops49] unnest'0 self res_state)
  
  let rec call_mut'0 (self:borrowed t_F'0) (args:(t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (return'  (ret:t_B'0))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops10] precondition'0 self.current args}
    any
    [ return' (result:t_B'0)-> {inv'8 result}
      {[%#sops11] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv27] forall e : t_Item'0, i : t_I'0 . inv'10 e /\ inv'0 i /\ produces'0 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed60] inv'10 self
  
  predicate inv'13 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Item'0 [inv'13 x] . inv'13 x = invariant'6 x
  
  predicate invariant'4 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq59] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'11 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'11 x] . inv'11 x = invariant'4 x
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv55] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'11 s
    /\ inv'10 e1 /\ inv'10 e2 /\ inv'6 f /\ inv'8 b /\ inv'0 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv58] forall iter : borrowed t_I'0, func : t_F'0 . inv'4 iter /\ inv'1 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv26] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'11 s
    /\ inv'10 e1 /\ inv'10 e2 /\ inv'6 f /\ inv'8 b /\ inv'0 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv25] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv57] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_MapInv'0 [inv'9 x] . inv'9 x
  = (invariant'3 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'0 iter /\ inv'1 func
    end)
  
  function produces_one_invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 73] (self : t_MapInv'0) (e : t_Item'0) (r : t_B'0) (f : borrowed t_F'0) (iter : t_I'0) : ()
    
  
  axiom produces_one_invariant'0_spec : forall self : t_MapInv'0, e : t_Item'0, r : t_B'0, f : borrowed t_F'0, iter : t_I'0 . ([%#smap_inv12] inv'9 self)
   -> ([%#smap_inv13] inv'10 e)
   -> ([%#smap_inv14] inv'8 r)
   -> ([%#smap_inv15] inv'6 f)
   -> ([%#smap_inv16] inv'0 iter)
   -> ([%#smap_inv17] produces'0 self.t_MapInv__iter'0 (Seq.singleton e) iter)
   -> ([%#smap_inv18] f.current = self.t_MapInv__func'0)
   -> ([%#smap_inv19] postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final r)
   -> ([%#smap_inv20] preservation_inv'0 iter f.final (Seq.snoc (Snapshot.inner self.t_MapInv__produced'0) e))
  && ([%#smap_inv21] next_precondition'0 iter f.final (Seq.snoc (Snapshot.inner self.t_MapInv__produced'0) e))
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'7 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed60] inv'6 self
  
  predicate inv'14 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : borrowed t_F'0 [inv'14 x] . inv'14 x = invariant'7 x
  
  predicate invariant'5 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq59] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'14 (Seq.get self i)
  
  predicate inv'12 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'12 x] . inv'12 x = invariant'5 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv28] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'12 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'11 s
    /\ Seq.length s = Seq.length visited
    /\ produces'0 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
    
   =
    [%#smap_inv39] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv33] inv'9 a)
   -> ([%#smap_inv34] inv'9 b)
   -> ([%#smap_inv35] inv'9 c)
   -> ([%#smap_inv36] produces'1 a ab b)
   -> ([%#smap_inv37] produces'1 b bc c)  -> ([%#smap_inv38] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self : t_MapInv'0) : () =
    [%#smap_inv32] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . ([%#smap_inv30] inv'9 self)
   -> ([%#smap_inv31] produces'1 self (Seq.empty  : Seq.seq t_B'0) self)
  
  predicate produces_one'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 192 4 192 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv23] exists f : borrowed t_F'0, e : t_Item'0 . inv'6 f
    /\ inv'10 e
    /\ f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'0 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.snoc (Snapshot.inner self.t_MapInv__produced'0) e
    /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
    /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv22] produces_one'0 self visited succ
  = produces'1 self (Seq.singleton visited) succ
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_MapInv'0)) =
    [%#sinvariant56] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_MapInv'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_MapInv'0) [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_MapInv'0)) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_MapInv'0)) =
    resolve'1 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_B'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'8 a_0
    end
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : borrowed (t_MapInv'0))
    
   =
    [%#smap_inv24] Snapshot.inner (self.final).t_MapInv__produced'0 = (Seq.empty  : Seq.seq t_Item'0)
    /\ completed'1 (Borrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  meta "compute_max_steps" 1000000
  
  let rec next'0 (self:borrowed (t_MapInv'0)) (return'  (ret:t_Option'1))= {[@expl:next 'self' type invariant] [%#smap_inv6] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv0] Snapshot.new self.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_MapInv__iter'0}
        Borrow.borrow_final <t_I'0> {(self.current).t_MapInv__iter'0} {Borrow.inherit_id (Borrow.get_id self) 1}
          (fun (_ret':borrowed t_I'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__iter'0 = _ret'.final } } ] 
            s1)
      | s1 = next'1 {_6} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_5 = C_None'0 } (! bb5) | br1 (x0:t_Item'0)-> {_5 = C_Some'0 x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some'0 {_5} (fun (r0'0:t_Item'0) ->  [ &v <- r0'0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv1] precondition'0 (self.current).t_MapInv__func'0 (v, (self.current).t_MapInv__produced'0)}
        s2
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = 
        [ &produced <- [%#smap_inv2] Snapshot.new (Seq.snoc (Snapshot.inner (self.current).t_MapInv__produced'0) v) ]
        
        s1
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = {inv'1 (self.current).t_MapInv__func'0}
        Borrow.borrow_final <t_F'0> {(self.current).t_MapInv__func'0} {Borrow.inherit_id (Borrow.get_id self) 2}
          (fun (_ret':borrowed t_F'0) ->
             [ &_14 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__func'0 = _ret'.final } } ] 
            s1)
      | s1 =  [ &_15 <- (v, (self.current).t_MapInv__produced'0) ] s2
      | s2 = call_mut'0 {_14} {_15} (fun (_ret':t_B'0) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = bb10
    | bb10 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv3] Snapshot.new (let _ = () in ()) ] s2
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 = {[@expl:assertion] [%#smap_inv4] produces_one'0 (Snapshot.inner old_self) r self.current} s1 | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- C_Some'1 r ] s3
      | s3 = bb13 ]
      
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv5] Snapshot.new (Seq.empty  : Seq.seq t_Item'0) ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'2 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- C_None'1 ] s4
      | s4 = bb17 ]
      
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : t_Option'1 = any_l ()
    | & self : borrowed (t_MapInv'0) = self
    | & old_self : Snapshot.snap_ty (t_MapInv'0) = any_l ()
    | & _5 : t_Option'0 = any_l ()
    | & _6 : borrowed t_I'0 = any_l ()
    | & v : t_Item'0 = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & r : t_B'0 = any_l ()
    | & _14 : borrowed t_F'0 = any_l ()
    | & _15 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)) = any_l ()
    | & _19 : Snapshot.snap_ty () = any_l ()
    | & _24 : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l () ]
    
    [ return' (result:t_Option'1)-> {[@expl:next result type invariant] [%#smap_inv7] inv'3 result}
      {[@expl:next ensures] [%#smap_inv8] match result with
        | C_None'1 -> completed'0 self
        | C_Some'1 v -> produces_one'0 self.current v self.final
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4899712594723907874__preservation_inv [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sops3 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed20 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  use prelude.prelude.Borrow
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed20] inv'1 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant19] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t_F'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use prelude.prelude.Snapshot
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'4 a)
   -> ([%#siter13] inv'4 b)
   -> ([%#siter14] inv'4 c)
   -> ([%#siter15] produces'0 a ab b)
   -> ([%#siter16] produces'0 b bc c)  -> ([%#siter17] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter10] inv'4 self)
   -> ([%#siter11] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv2] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'0 s
    /\ inv'1 e1 /\ inv'1 e2 /\ inv'2 f /\ inv'3 b /\ inv'4 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  constant iter  : t_I'0
  
  constant func  : t_F'0
  
  constant produced  : Seq.seq t_Item'0
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
  
  goal vc_preservation_inv'0 : [%#smap_inv0] produced = (Seq.empty  : Seq.seq t_Item'0)
   -> ([%#smap_inv1] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'0 s
  /\ inv'1 e1 /\ inv'1 e2 /\ inv'2 f /\ inv'3 b /\ inv'4 i /\ unnest'0 func f.current
   -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
   -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
   -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1)))
  = preservation'0 iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4899712594723907874__produces_one [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 192 4 192 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 191 14 191 68
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 194 12 199 74
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 15 23 24
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 21
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 30 15 30 21
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 31 15 31 21
  let%span smap_inv9 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 32 15 32 32
  let%span smap_inv10 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 32
  let%span smap_inv11 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 34 14 34 42
  let%span smap_inv12 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 10
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops21 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops22 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops23 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops24 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops25 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops26 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops27 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span sinvariant28 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sseq29 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv30 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span smap_inv31 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv32 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv33 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv34 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span smap_inv35 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sboxed36 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  use prelude.prelude.Borrow
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate invariant'6 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant28] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed t_I'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter15] inv'5 a)
   -> ([%#siter16] inv'5 b)
   -> ([%#siter17] inv'5 c)
   -> ([%#siter18] produces'1 a ab b)
   -> ([%#siter19] produces'1 b bc c)  -> ([%#siter20] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter13] inv'5 self)
   -> ([%#siter14] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv34] forall e : t_Item'0, i : t_I'0 . inv'1 e /\ inv'5 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed36] inv'1 self
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Item'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'8 (Seq.get self i)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant28] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_F'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops27] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops24] unnest'0 self b)
   -> ([%#sops25] unnest'0 b c)  -> ([%#sops26] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops23] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops21] postcondition_mut'0 self args res_state res)
   -> ([%#sops22] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv35] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'3 s
    /\ inv'1 e1 /\ inv'1 e2 /\ inv'0 f /\ inv'10 b /\ inv'5 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv31] forall iter : borrowed t_I'0, func : t_F'0 . inv'9 iter /\ inv'6 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use prelude.prelude.Snapshot
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv33] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'3 s
    /\ inv'1 e1 /\ inv'1 e2 /\ inv'0 f /\ inv'10 b /\ inv'5 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv32] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv30] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_MapInv'0 [inv'4 x] . inv'4 x
  = (invariant'3 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'5 iter /\ inv'6 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed36] inv'0 self
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'7 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv2] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'2 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'3 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
    
   =
    [%#smap_inv12] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv6] inv'4 a)
   -> ([%#smap_inv7] inv'4 b)
   -> ([%#smap_inv8] inv'4 c)
   -> ([%#smap_inv9] produces'0 a ab b)
   -> ([%#smap_inv10] produces'0 b bc c)  -> ([%#smap_inv11] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self : t_MapInv'0) : () =
    [%#smap_inv5] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . ([%#smap_inv3] inv'4 self)
   -> ([%#smap_inv4] produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
  
  constant self  : t_MapInv'0
  
  constant visited  : t_B'0
  
  constant succ  : t_MapInv'0
  
  predicate produces_one'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 192 4 192 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
    
  
  goal vc_produces_one'0 : [%#smap_inv0] ([%#smap_inv1] exists f : borrowed t_F'0, e : t_Item'0 . inv'0 f
  /\ inv'1 e
  /\ f.current = self.t_MapInv__func'0
  /\ f.final = succ.t_MapInv__func'0
  /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
  /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.snoc (Snapshot.inner self.t_MapInv__produced'0) e
  /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
  /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_refl [#"../../../creusot-contracts/src/std/iter/once.rs" 33 4 33 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 31 15 31 24
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 32 14 32 45
  let%span sonce2 = "../../../creusot-contracts/src/std/iter/once.rs" 29 4 29 10
  let%span sonce3 = "../../../creusot-contracts/src/std/iter/once.rs" 24 12 25 106
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'4 opt
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'3 inner
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Once'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Once'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Once__inner'0 = inner} -> inv'2 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
    
   =
    [%#sonce3] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . inv'1 e /\ view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Once'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 33 4 33 26] (self : t_Once'0) : ()
  
  goal vc_produces_refl'0 : ([%#sonce0] inv'0 self)  -> ([%#sonce1] produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_trans [#"../../../creusot-contracts/src/std/iter/once.rs" 43 4 43 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 37 15 37 21
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 38 15 38 21
  let%span sonce2 = "../../../creusot-contracts/src/std/iter/once.rs" 39 15 39 21
  let%span sonce3 = "../../../creusot-contracts/src/std/iter/once.rs" 40 15 40 32
  let%span sonce4 = "../../../creusot-contracts/src/std/iter/once.rs" 41 15 41 32
  let%span sonce5 = "../../../creusot-contracts/src/std/iter/once.rs" 42 14 42 42
  let%span sonce6 = "../../../creusot-contracts/src/std/iter/once.rs" 35 4 35 10
  let%span sonce7 = "../../../creusot-contracts/src/std/iter/once.rs" 24 12 25 106
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'4 opt
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'3 inner
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Once'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Once'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Once__inner'0 = inner} -> inv'2 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
    
   =
    [%#sonce7] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . inv'1 e /\ view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_Once'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Once'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Once'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 43 4 43 90] (a : t_Once'0) (ab : Seq.seq t_T'0) (b : t_Once'0) (bc : Seq.seq t_T'0) (c : t_Once'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sonce4] produces'0 b bc c)
   -> ([%#sonce3] produces'0 a ab b)
   -> ([%#sonce2] inv'0 c)
   -> ([%#sonce1] inv'0 b)  -> ([%#sonce0] inv'0 a)  -> ([%#sonce5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 31 4 31 10
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Range__start'0 = start ; t_Range__end'0 = end'} -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
    
   =
    [%#srange3] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  constant self  : t_Range'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (self : t_Range'0) : ()
  
  goal vc_produces_refl'0 : ([%#srange0] inv'0 self)
   -> ([%#srange1] produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange5 = "../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span srange6 = "../../../creusot-contracts/src/std/iter/range.rs" 37 4 37 10
  let%span srange7 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Range__start'0 = start ; t_Range__end'0 = end'} -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
    
   =
    [%#srange7] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  use seq.Seq
  
  constant a  : t_Range'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_Range'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_Range'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90] (a : t_Range'0) (ab : Seq.seq t_Idx'0) (b : t_Range'0) (bc : Seq.seq t_Idx'0) (c : t_Range'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#srange4] produces'0 b bc c)
   -> ([%#srange3] produces'0 a ab b)
   -> ([%#srange2] inv'0 c)
   -> ([%#srange1] inv'0 b)  -> ([%#srange0] inv'0 a)  -> ([%#srange5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92]
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span sops1 = "../../../creusot-contracts/src/std/ops.rs" 201 14 201 86
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 189 4 189 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 205 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops1] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  constant r  : t_RangeInclusive'0
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : t_RangeInclusive'0) : int
    
  
  goal vc_range_inclusive_len'0 : ([%#sops1] not is_empty_log'0 r
   -> deep_model'0 (start_log'0 r) <= deep_model'0 (end_log'0 r))
   -> (if is_empty_log'0 r then
    [%#srange0] is_empty_log'0 r = (0 = 0)
  else
    [%#srange0] is_empty_log'0 r = (deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 81 14 81 45
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 79 4 79 10
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 201 14 201 86
  
  use seq.Seq
  
  type t_Idx'0
  
  use seq.Seq
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 189 4 189 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 205 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : t_RangeInclusive'0) : int
    
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
    
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  constant self  : t_RangeInclusive'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26] (self : t_RangeInclusive'0) : ()
    
  
  goal vc_produces_refl'0 : [%#srange0] produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 86 15 86 32
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 87 15 87 32
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 88 14 88 42
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 84 4 84 10
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange5 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange6 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 201 14 201 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 189 4 189 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 205 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops7] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : t_RangeInclusive'0) : int
    
   =
    [%#srange6] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange5] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
    
   =
    [%#srange4] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  constant a  : t_RangeInclusive'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_RangeInclusive'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_RangeInclusive'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90] (a : t_RangeInclusive'0) (ab : Seq.seq t_Idx'0) (b : t_RangeInclusive'0) (bc : Seq.seq t_Idx'0) (c : t_RangeInclusive'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#srange1] produces'0 b bc c)
   -> ([%#srange0] produces'0 a ab b)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_refl [#"../../../creusot-contracts/src/std/iter/repeat.rs" 33 4 33 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 31 15 31 24
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 32 14 32 45
  let%span srepeat2 = "../../../creusot-contracts/src/std/iter/repeat.rs" 29 4 29 10
  let%span srepeat3 = "../../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Repeat'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Repeat'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Repeat__element'0 = element} -> inv'1 element
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
    
   =
    [%#srepeat3] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  constant self  : t_Repeat'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 33 4 33 26] (self : t_Repeat'0) : ()
  
  goal vc_produces_refl'0 : ([%#srepeat0] inv'0 self)
   -> ([%#srepeat1] produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_trans [#"../../../creusot-contracts/src/std/iter/repeat.rs" 43 4 43 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 37 15 37 21
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 38 15 38 21
  let%span srepeat2 = "../../../creusot-contracts/src/std/iter/repeat.rs" 39 15 39 21
  let%span srepeat3 = "../../../creusot-contracts/src/std/iter/repeat.rs" 40 15 40 32
  let%span srepeat4 = "../../../creusot-contracts/src/std/iter/repeat.rs" 41 15 41 32
  let%span srepeat5 = "../../../creusot-contracts/src/std/iter/repeat.rs" 42 14 42 42
  let%span srepeat6 = "../../../creusot-contracts/src/std/iter/repeat.rs" 35 4 35 10
  let%span srepeat7 = "../../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Repeat'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Repeat'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Repeat__element'0 = element} -> inv'1 element
    end
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
    
   =
    [%#srepeat7] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  constant a  : t_Repeat'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Repeat'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Repeat'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 43 4 43 90] (a : t_Repeat'0) (ab : Seq.seq t_T'0) (b : t_Repeat'0) (bc : Seq.seq t_T'0) (c : t_Repeat'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#srepeat4] produces'0 b bc c)
   -> ([%#srepeat3] produces'0 a ab b)
   -> ([%#srepeat2] inv'0 c)
   -> ([%#srepeat1] inv'0 b)  -> ([%#srepeat0] inv'0 a)  -> ([%#srepeat5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502__produces_refl [#"../../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 73 15 73 24
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 74 14 74 45
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 71 4 71 10
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip4 = "../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip5 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq14 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip4] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed15] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip5] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] inv'2 a)
   -> ([%#siter9] inv'2 b)
   -> ([%#siter10] inv'2 c)
   -> ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter6] inv'2 self)
   -> ([%#siter7] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
    
   =
    [%#sskip3] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant self  : t_Skip'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (self : t_Skip'0) : ()
  
  goal vc_produces_refl'0 : ([%#sskip0] inv'0 self)
   -> ([%#sskip1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502__produces_trans [#"../../../creusot-contracts/src/std/iter/skip.rs" 85 4 85 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 21
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 80 15 80 21
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 81 15 81 21
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 82 15 82 32
  let%span sskip4 = "../../../creusot-contracts/src/std/iter/skip.rs" 83 15 83 32
  let%span sskip5 = "../../../creusot-contracts/src/std/iter/skip.rs" 84 14 84 42
  let%span sskip6 = "../../../creusot-contracts/src/std/iter/skip.rs" 77 4 77 10
  let%span sskip7 = "../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip8 = "../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip9 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed19 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip8] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed19] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip9] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'2 a)
   -> ([%#siter13] inv'2 b)
   -> ([%#siter14] inv'2 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter10] inv'2 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
    
   =
    [%#sskip7] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant a  : t_Skip'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Skip'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Skip'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 85 4 85 90] (a : t_Skip'0) (ab : Seq.seq t_Item'0) (b : t_Skip'0) (bc : Seq.seq t_Item'0) (c : t_Skip'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sskip4] produces'0 b bc c)
   -> ([%#sskip3] produces'0 a ab b)
   -> ([%#sskip2] inv'0 c)
   -> ([%#sskip1] inv'0 b)  -> ([%#sskip0] inv'0 a)  -> ([%#sskip5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_refl [#"../../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 71 15 71 24
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 72 14 72 45
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 69 4 69 10
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake4 = "../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake4] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake5] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] inv'1 a)
   -> ([%#siter9] inv'1 b)
   -> ([%#siter10] inv'1 c)
   -> ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter6] inv'1 self)
   -> ([%#siter7] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
    
   =
    [%#stake3] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant self  : t_Take'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (self : t_Take'0) : ()
  
  goal vc_produces_refl'0 : ([%#stake0] inv'0 self)
   -> ([%#stake1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_trans [#"../../../creusot-contracts/src/std/iter/take.rs" 83 4 83 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 77 15 77 21
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 78 15 78 21
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 79 15 79 21
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 80 15 80 32
  let%span stake4 = "../../../creusot-contracts/src/std/iter/take.rs" 81 15 81 32
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 82 14 82 42
  let%span stake6 = "../../../creusot-contracts/src/std/iter/take.rs" 75 4 75 10
  let%span stake7 = "../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake8 = "../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake9 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake8] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake9] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'1 a)
   -> ([%#siter13] inv'1 b)
   -> ([%#siter14] inv'1 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter10] inv'1 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
    
   =
    [%#stake7] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant a  : t_Take'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Take'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Take'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 83 4 83 90] (a : t_Take'0) (ab : Seq.seq t_Item'0) (b : t_Take'0) (bc : Seq.seq t_Item'0) (c : t_Take'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#stake4] produces'0 b bc c)
   -> ([%#stake3] produces'0 a ab b)
   -> ([%#stake2] inv'0 c)
   -> ([%#stake1] inv'0 b)  -> ([%#stake0] inv'0 a)  -> ([%#stake5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844__produces_refl [#"../../../creusot-contracts/src/std/iter/zip.rs" 57 4 57 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 55 15 55 24
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 56 14 56 45
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 53 4 53 10
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip4 = "../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip5 = "../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq14 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_A'0
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'3 a
    /\ inv'4 b
    end
  
  use seq.Seq
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed15] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed15] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'1) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip4] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter8] inv'3 a)
   -> ([%#siter9] inv'3 b)
   -> ([%#siter10] inv'3 c)
   -> ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . ([%#siter6] inv'3 self)
   -> ([%#siter7] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip5] inv'0 self  -> inv'4 (iterb'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter8] inv'4 a)
   -> ([%#siter9] inv'4 b)
   -> ([%#siter10] inv'4 c)
   -> ([%#siter11] produces'2 a ab b)
   -> ([%#siter12] produces'2 b bc c)  -> ([%#siter13] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . ([%#siter6] inv'4 self)
   -> ([%#siter7] produces'2 self (Seq.empty  : Seq.seq t_Item'1) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
    
   =
    [%#szip3] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  constant self  : t_Zip'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 57 4 57 26] (self : t_Zip'0) : ()
  
  goal vc_produces_refl'0 : ([%#szip0] inv'0 self)
   -> ([%#szip1] produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844__produces_trans [#"../../../creusot-contracts/src/std/iter/zip.rs" 67 4 67 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 61 15 61 21
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 62 15 62 21
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 63 15 63 21
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 64 15 64 32
  let%span szip4 = "../../../creusot-contracts/src/std/iter/zip.rs" 65 15 65 32
  let%span szip5 = "../../../creusot-contracts/src/std/iter/zip.rs" 66 14 66 42
  let%span szip6 = "../../../creusot-contracts/src/std/iter/zip.rs" 59 4 59 10
  let%span szip7 = "../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip8 = "../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip9 = "../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed19 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_A'0
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'3 a
    /\ inv'4 b
    end
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed19] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed19] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'1) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip8] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter12] inv'3 a)
   -> ([%#siter13] inv'3 b)
   -> ([%#siter14] inv'3 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . ([%#siter10] inv'3 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip9] inv'0 self  -> inv'4 (iterb'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
    
  
  function produces_trans'2 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
    
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter12] inv'4 a)
   -> ([%#siter13] inv'4 b)
   -> ([%#siter14] inv'4 c)
   -> ([%#siter15] produces'2 a ab b)
   -> ([%#siter16] produces'2 b bc c)  -> ([%#siter17] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . ([%#siter10] inv'4 self)
   -> ([%#siter11] produces'2 self (Seq.empty  : Seq.seq t_Item'1) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
    
   =
    [%#szip7] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  constant a  : t_Zip'0
  
  constant ab  : Seq.seq (t_Item'0, t_Item'1)
  
  constant b  : t_Zip'0
  
  constant bc  : Seq.seq (t_Item'0, t_Item'1)
  
  constant c  : t_Zip'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 67 4 67 90] (a : t_Zip'0) (ab : Seq.seq (t_Item'0, t_Item'1)) (b : t_Zip'0) (bc : Seq.seq (t_Item'0, t_Item'1)) (c : t_Zip'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#szip4] produces'0 b bc c)
   -> ([%#szip3] produces'0 a ab b)
   -> ([%#szip2] inv'0 c)
   -> ([%#szip1] inv'0 b)  -> ([%#szip0] inv'0 a)  -> ([%#szip5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 103 16 105 36]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 103 43 103 44
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 103 52 103 53
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : ())
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : ()) (result : t_T'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'2 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body'0 (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
      
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_T'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = any_l ()
    | & t : t_T'0 = any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../../creusot-contracts/src/std/option.rs" 131 16 133 37]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 131 35 131 36
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 123 27 126 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 131 44 131 53
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 127 26 130 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_U'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body'0 (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_9 <- (t) ] s2
      | s2 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'1 _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = any_l ()
    | & _7 : t_U'0 = any_l ()
    | & _9 : t_T'0 = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> exists r : t_U'0 . result = C_Some'1 r /\ postcondition_once'0 f (t) r
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../../creusot-contracts/src/std/option.rs" 149 16 151 33]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 149 36 149 37
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 140 27 143 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 149 45 149 54
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 145 26 148 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant6] inv'4 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_T'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_T'0) (result : ())
    
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:()))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any [ return' (result:())-> {inv'3 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body'0 (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_ = C_None'0 } (! bb5) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- (_12) ] s3
      | s3 = call_once'0 {f} {_10} (fun (_ret':()) ->  [ &_8 <- _ret' ] s4)
      | s4 = bb8 ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = any_l ()
    | & _8 : () = any_l ()
    | & _10 : t_T'0 = any_l ()
    | & _12 : t_T'0 = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption3] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption0] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption4] match self_ with
        | C_None'0 -> true
        | C_Some'0 t -> postcondition_once'0 f (t) ()
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../../creusot-contracts/src/std/option.rs" 166 16 168 37]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 166 38 166 45
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 166 50 166 51
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 158 27 161 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 166 59 166 60
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 162 26 165 17
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_U'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_U'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_U'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_F'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'4 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_T'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'0 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use prelude.prelude.Intrinsic
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body'0 (self_:t_Option'0) (default:t_U'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption3] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_9 <- (t) ] s4
      | s4 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_U'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_U'0 = default
    | & f : t_F'0 = f
    | & t : t_T'0 = any_l ()
    | & _9 : t_T'0 = any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption4] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption5] match self_ with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 183 16 186 37]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 183 46 183 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 183 58 183 59
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 175 27 178 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 183 67 183 68
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 179 26 182 17
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_D'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_D'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_D'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_F'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = (let (x0) = x in inv'6 x0)
  
  predicate precondition'1 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_U'0)
  
  predicate postcondition_once'1 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'4 args}
    {[@expl:call_once requires] [%#sops6] precondition'1 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops6] postcondition_once'1 self args result} (! return' {result}) ]
    
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_D'0) (args : ())
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_D'0) (args : ()) (result : t_U'0)
    
  
  let rec call_once'1 (self:t_D'0) (args:()) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body'0 (self_:t_Option'0) (default:t_D'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption3] match self_ with
      | C_None'0 -> precondition'0 default ()
      | C_Some'0 t -> precondition'1 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_11 <- (t) ] s4
      | s4 = call_once'0 {f} {_11} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'1 {default} {_8} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_U'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_D'0 = default
    | & f : t_F'0 = f
    | & _8 : () = any_l ()
    | & t : t_T'0 = any_l ()
    | & _11 : t_T'0 = any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption4] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption5] match self_ with
        | C_None'0 -> postcondition_once'0 default () result
        | C_Some'0 t -> postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 204 16 206 36]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 204 42 204 45
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 204 53 204 65
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 200 26 203 17
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_E'0
  
  type t_Result'0  =
    | C_Ok'0 t_T'0
    | C_Err'0 t_E'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : ())
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_E'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : ()) (result : t_E'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_E'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_E'0)-> {inv'4 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'2 x] . inv'2 x
  = match x with
    | C_Ok'0 a_0 -> inv'5 a_0
    | C_Err'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body'0 (self_:t_Option'0) (err:t_F'0) (return'  (ret:t_Result'0))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption1] inv'0 err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 err} s1
      | s1 = -{resolve'0 err}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Ok'0 t ] s4
      | s4 = bb9 ]
      
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {err} {_8} (fun (_ret':t_E'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Err'0 _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Result'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & err : t_F'0 = err
    | & _6 : t_E'0 = any_l ()
    | & _8 : () = any_l ()
    | & t : t_T'0 = any_l () ]
    
    [ return' (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> exists r : t_E'0 . result = C_Err'0 r /\ postcondition_once'0 err () r
        | C_Some'0 t -> result = C_Ok'0 t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../../creusot-contracts/src/std/option.rs" 234 16 236 45]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 234 40 234 41
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 226 27 229 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 234 49 234 58
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 230 26 233 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'4 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_U'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_T'0) (result : t_Option'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#sops5] postcondition_once'0 self args result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body'0 (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_8 <- (t) ] s2
      | s2 = call_once'0 {f} {_8} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = any_l ()
    | & _8 : t_T'0 = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../../creusot-contracts/src/std/option.rs" 254 16 256 41]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 254 35 254 44
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 254 52 254 61
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 247 26 253 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_P'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_P'0)
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant6] inv'0 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_P'0) (args : t_T'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : bool)
  
  axiom inv_axiom'2 [@rewrite] : forall x : bool [inv'4 x] . inv'4 x = true
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_P'0) (args : t_T'0) (result : bool)
    
  
  let rec call_once'0 (self:t_P'0) (args:t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  use prelude.prelude.Intrinsic
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body'0 (self_:t_Option'0) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption1] inv'1 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 predicate' (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- (_11) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
      
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve'0 t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 predicate'} s1 | s1 = -{resolve'1 predicate'}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & predicate' : t_P'0 = predicate'
    | & t : t_T'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t_T'0 = any_l ()
    | & _11 : t_T'0 = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'0 predicate' (t) false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'0 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 273 16 275 44]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 273 36 273 37
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 273 45 273 54
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 269 26 272 17
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'2 x] . inv'2 x = true
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : ())
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : ()) (result : t_Option'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'1 result}
      {[%#sops4] postcondition_once'0 self args result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body'0 (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Some'0 t ] s4
      | s4 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = any_l ()
    | & t : t_T'0 = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../../creusot-contracts/src/std/option.rs" 311 16 313 36]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 311 52 311 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 306 27 306 63
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 311 61 311 67
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 307 26 310 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sresolve9 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sresolve10 = "../../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant11 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant11] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve9] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t_T'0) =
    resolve'4 _1
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'3 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : ())
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : ()) (result : t_T'0)
    
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'1 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'7 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve10] match self with
      | C_Some'0 x -> resolve'7 x
      | C_None'0 -> true
      end
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'5 _1
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_Option'0)) =
    [%#sinvariant11] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_Option'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Option'0) [inv'4 x] . inv'4 x = invariant'1 x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (borrowed t_T'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'1 [inv'6 x] . inv'6 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:borrowed (t_Option'0)) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {inv'6 result}
      {[%#soption6] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption7] self.current = C_None'0
      \/ (exists r : borrowed t_T'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:borrowed t_T'0))= {[@expl:unwrap 'self' type invariant] inv'6 self}
    {[@expl:unwrap requires] [%#soption8] self <> C_None'1}
    any [ return' (result:borrowed t_T'0)-> {inv'2 result} {[%#soption8] C_Some'1 result = self} (! return' {result}) ] 
  
  predicate resolve'6 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_Option'0)) =
    [%#sresolve9] self.final = self.current
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_Option'0)) =
    resolve'6 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body'0 (self_:borrowed (t_Option'0)) (f:t_F'0) (return'  (ret:borrowed t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption0] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption2] self_.current = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'1 r0'0}
            Borrow.borrow_final <t_T'0> {r0'0} {Borrow.inherit_id (Borrow.get_id self_) 1}
              (fun (_ret':borrowed t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s3))
      | s3 = {inv'1 t.current}
        Borrow.borrow_final <t_T'0> {t.current} {Borrow.get_id t}
          (fun (_ret':borrowed t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'2 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
      
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_12} (fun (_ret':t_T'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- C_Some'0 _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _9 } ] s3
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = {inv'3 self_.current}
        Borrow.borrow_final <t_Option'0> {self_.current} {Borrow.get_id self_}
          (fun (_ret':borrowed (t_Option'0)) ->
             [ &_15 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':borrowed t_T'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <t_T'0> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed t_T'0) ->
             [ &_8 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _8.current}
        Borrow.borrow_final <t_T'0> {_8.current} {Borrow.get_id _8}
          (fun (_ret':borrowed t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_8 <- { _8 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'2 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
      
    | bb14 = s0
      [ s0 = {inv'1 _6.current}
        Borrow.borrow_final <t_T'0> {_6.current} {Borrow.get_id _6}
          (fun (_ret':borrowed t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_6 <- { _6 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _3.current}
        Borrow.borrow_final <t_T'0> {_3.current} {Borrow.get_id _3}
          (fun (_ret':borrowed t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'2 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
      
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : borrowed t_T'0 = any_l ()
    | & self_ : borrowed (t_Option'0) = self_
    | & f : t_F'0 = f
    | & _3 : borrowed t_T'0 = any_l ()
    | & _6 : borrowed t_T'0 = any_l ()
    | & _8 : borrowed t_T'0 = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _10 : t_T'0 = any_l ()
    | & _12 : () = any_l ()
    | & _13 : borrowed t_T'0 = any_l ()
    | & _14 : t_Option'1 = any_l ()
    | & _15 : borrowed (t_Option'0) = any_l ()
    | & t : borrowed t_T'0 = any_l () ]
    
    [ return' (result:borrowed t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> postcondition_once'0 f () result.current /\ self_.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self_.current = C_Some'0 (result.current) /\ self_.final = C_Some'0 (result.final)
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../../creusot-contracts/src/std/option.rs" 338 16 340 45]
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 338 41 338 50
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 324 27 327 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 338 58 338 67
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 328 26 337 17
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 148 0 170 1
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sresolve7 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant8 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  type t_P'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_P'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant8] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_T'0 [inv'5 x] . inv'5 x = (let (x0) = x in inv'1 x0)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_P'0) (args : borrowed t_T'0)
    
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : bool)
  
  axiom inv_axiom'4 [@rewrite] : forall x : bool [inv'6 x] . inv'6 x = true
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_P'0) (args : borrowed t_T'0) (result : bool)
    
  
  let rec call_once'0 (self:t_P'0) (args:borrowed t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'4 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'6 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t_T'0) =
    resolve'3 _1
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_Option'0)) =
    [%#sinvariant8] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_Option'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Option'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec take'0 (self:borrowed (t_Option'0)) (return'  (ret:t_Option'0))= {[@expl:take 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#soption6] result = self.current /\ self.final = C_None'0}
      (! return' {result}) ]
    
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_Option'0)) =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_Option'0)) =
    resolve'4 _1
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body'0 (self_:borrowed (t_Option'0)) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption1] inv'4 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption2] match self_.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : borrowed t_T'0 . inv'1 b /\ b.current = t  -> precondition'0 predicate' (b)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            Borrow.borrow_mut <t_T'0> {r0'0}
              (fun (_ret':borrowed t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 t.current}
        Borrow.borrow_final <t_T'0> {t.current} {Borrow.get_id t}
          (fun (_ret':borrowed t_T'0) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_9 <- (_10) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 = {inv'2 self_.current}
        Borrow.borrow_final <t_Option'0> {self_.current} {Borrow.get_id self_}
          (fun (_ret':borrowed (t_Option'0)) ->
             [ &_11 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = take'0 {_11} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 predicate'} s1
      | s1 = -{resolve'2 predicate'}- s2
      | s2 = {[@expl:type invariant] inv'3 self_} s3
      | s3 = -{resolve'1 self_}- s4
      | s4 = bb6 ]
      
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self_ : borrowed (t_Option'0) = self_
    | & predicate' : t_P'0 = predicate'
    | & t : borrowed t_T'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : borrowed t_T'0 = any_l ()
    | & _10 : borrowed t_T'0 = any_l ()
    | & _11 : borrowed (t_Option'0) = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> result = C_None'0 /\ self_.final = C_None'0
        | C_Some'0 cur -> exists b : borrowed t_T'0, res : bool . inv'1 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' (b) res
        /\ (if res then
          self_.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self_.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : t_Option'0) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption4] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  constant z  : t_Option'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : t_Option'0) (y : t_Option'0) (z : t_Option'0) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : t_Option'0) (y : t_Option'0) : ()
    
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 477 4 477 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 476 14 476 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 474 4 474 10
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/option.rs" 477 4 477 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 484 4 484 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 481 15 481 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 482 15 482 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 483 14 483 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 479 4 479 10
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
    
   =
    [%#soption4] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/option.rs" 484 4 484 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 530 4 530 26] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 529 14 529 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 527 4 527 10
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/option.rs" 530 4 530 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 537 4 537 90] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 534 15 534 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 535 15 535 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 536 14 536 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 532 4 532 10
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
    
   =
    [%#soption4] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/option.rs" 537 4 537 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 586 4 586 26] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 585 14 585 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 583 4 583 10
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (o : t_IterMut'0)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq (borrowed t_T'0)) /\ self = o
    \/ (exists e : borrowed t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/option.rs" 586 4 586 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 593 4 593 90] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 590 15 590 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 591 15 591 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 592 14 592 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 588 4 588 10
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (o : t_IterMut'0)
    
   =
    [%#soption4] visited = (Seq.empty  : Seq.seq (borrowed t_T'0)) /\ self = o
    \/ (exists e : borrowed t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (borrowed t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (borrowed t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/option.rs" 593 4 593 90] (a : t_IterMut'0) (ab : Seq.seq (borrowed t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (borrowed t_T'0)) (c : t_IterMut'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi8256668011736225471__produces_refl [#"../../../creusot-contracts/src/std/slice.rs" 430 4 430 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 429 14 429 45
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 427 4 427 10
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 423 12 423 66
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel5 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops6 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 407 4 407 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 421 4 421 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sslice2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/slice.rs" 430 4 430 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sslice0] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi8256668011736225471__produces_trans [#"../../../creusot-contracts/src/std/slice.rs" 437 4 437 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 434 15 434 32
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 435 15 435 32
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 436 14 436 42
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 432 4 432 10
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 423 12 423 66
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 407 4 407 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 421 4 421 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sslice4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/slice.rs" 437 4 437 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sslice1] produces'0 b bc c)
   -> ([%#sslice0] produces'0 a ab b)  -> ([%#sslice2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_refl [#"../../../creusot-contracts/src/std/slice.rs" 485 4 485 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 483 15 483 24
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 484 14 484 45
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 481 4 481 10
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 477 12 477 66
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 445 14 445 50
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 105 14 105 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 106 14 106 84
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span smodel9 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sops10 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  use prelude.prelude.Slice64
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : slice t_T'0 . ([%#sslice7] Seq.length (view'1 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'1 self = Slice64.id self)
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 33] (self : t_IterMut'0) : borrowed (slice t_T'0)
    
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice4] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (slice t_T'0)) : Seq.seq t_T'0
    
   =
    [%#smodel9] view'1 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops10] Seq.get (view'1 self) ix
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 108 4 108 43] (self : borrowed (slice t_T'0)) : Seq.seq (borrowed t_T'0)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t_T'0) . ([%#sslice5] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 475 4 475 65] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (tl : t_IterMut'0)
    
   =
    [%#sslice3] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/slice.rs" 485 4 485 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : ([%#sslice0] inv'0 self)
   -> ([%#sslice1] produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_trans [#"../../../creusot-contracts/src/std/slice.rs" 495 4 495 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 489 15 489 21
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 490 15 490 21
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 491 15 491 21
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 492 15 492 32
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 493 15 493 32
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 494 14 494 42
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 487 4 487 10
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 477 12 477 66
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 445 14 445 50
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 105 14 105 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 106 14 106 84
  let%span sslice11 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sops14 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  use prelude.prelude.Slice64
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : slice t_T'0 . ([%#sslice11] Seq.length (view'1 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice12] view'1 self = Slice64.id self)
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 33] (self : t_IterMut'0) : borrowed (slice t_T'0)
    
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice8] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (slice t_T'0)) : Seq.seq t_T'0
    
   =
    [%#smodel13] view'1 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops14] Seq.get (view'1 self) ix
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 108 4 108 43] (self : borrowed (slice t_T'0)) : Seq.seq (borrowed t_T'0)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t_T'0) . ([%#sslice9] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice10] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 475 4 475 65] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (tl : t_IterMut'0)
    
   =
    [%#sslice7] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (borrowed t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (borrowed t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/slice.rs" 495 4 495 90] (a : t_IterMut'0) (ab : Seq.seq (borrowed t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (borrowed t_T'0)) (c : t_IterMut'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#sslice4] produces'0 b bc c)
   -> ([%#sslice3] produces'0 a ab b)
   -> ([%#sslice2] inv'0 c)
   -> ([%#sslice1] inv'0 b)  -> ([%#sslice0] inv'0 a)  -> ([%#sslice5] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396__produces_refl [#"../../../creusot-contracts/src/std/vec.rs" 271 4 271 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 270 14 270 45
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 268 4 268 10
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 234 4 234 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 262 4 262 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
    
   =
    [%#svec2] view'0 self = Seq.(++) visited (view'0 rhs)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/vec.rs" 271 4 271 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#svec0] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396__produces_trans [#"../../../creusot-contracts/src/std/vec.rs" 278 4 278 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 275 15 275 32
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 276 15 276 32
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 277 14 277 42
  let%span svec3 = "../../../creusot-contracts/src/std/vec.rs" 273 4 273 10
  let%span svec4 = "../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 234 4 234 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 262 4 262 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
    
   =
    [%#svec4] view'0 self = Seq.(++) visited (view'0 rhs)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/vec.rs" 278 4 278 72] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#svec1] produces'0 b bc c)
   -> ([%#svec0] produces'0 a ab b)  -> ([%#svec2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Real.real) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span snum_rational4 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational4] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Real.real) (y : Real.real) (z : Real.real) (o : t_Ordering'0) : ()
    
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span snum_rational3 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span snum_rational3 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Real.real) (y : Real.real) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__ghost__qyi17645547594388049322__clone [#"../../../creusot-contracts/src/ghost.rs" 33 4 33 27] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 33 14 33 18
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 33 23 33 27
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 32 14 32 29
  let%span sclone3 = "../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use prelude.prelude.Borrow
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed5] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  let rec clone'1 (self:t_T'0) (return'  (ret:t_T'0))= {[@expl:clone 'self' type invariant] inv'2 self}
    any [ return' (result:t_T'0)-> {inv'3 result} {[%#sclone3] result = self} (! return' {result}) ] 
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0 (self:t_GhostBox'0) (return'  (ret:t_GhostBox'0))= {[@expl:clone 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone'1 {self.t_GhostBox__0'0} (fun (_ret':t_T'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = any_l () | & self : t_GhostBox'0 = self | & _3 : t_T'0 = any_l () ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:clone result type invariant] [%#sghost1] inv'1 result}
      {[@expl:clone ensures] [%#sghost2] result = self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi1862168959261460300__deref [#"../../../creusot-contracts/src/ghost.rs" 52 4 52 36] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 52 14 52 18
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 52 23 52 36
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 51 14 51 35
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed4] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'0) =
    [%#sinvariant3] inv'2 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  meta "compute_max_steps" 1000000
  
  let rec deref'0 (self:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:deref 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self.t_GhostBox__0'0 ] s1
      | s1 =  [ &_4 <- _5 ] s2
      | s2 =  [ &_2 <- _4 ] s3
      | s3 =  [ &_0 <- _2 ] s4
      | s4 = return' {_0} ]
       ]
    )
    [ & _0 : t_T'0 = any_l ()
    | & self : t_GhostBox'0 = self
    | & _2 : t_T'0 = any_l ()
    | & _4 : t_T'0 = any_l ()
    | & _5 : t_T'0 = any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:deref result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref ensures] [%#sghost2] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi17214052996668775070__deref_mut [#"../../../creusot-contracts/src/ghost.rs" 68 4 68 48] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 68 22 68 26
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 68 31 68 48
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 67 14 67 36
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t_T'0) =
    resolve'2 _1
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed5] inv'0 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_GhostBox'0)) =
    [%#sinvariant4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostBox'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_GhostBox'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_GhostBox'0)) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_GhostBox'0)) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec deref_mut'0 (self:borrowed (t_GhostBox'0)) (return'  (ret:borrowed t_T'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_GhostBox__0'0}
        Borrow.borrow_final <t_T'0> {(self.current).t_GhostBox__0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
          (fun (_ret':borrowed t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_GhostBox__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _5.current}
        Borrow.borrow_final <t_T'0> {_5.current} {Borrow.get_id _5}
          (fun (_ret':borrowed t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'0 _4.current}
        Borrow.borrow_final <t_T'0> {_4.current} {Borrow.get_id _4}
          (fun (_ret':borrowed t_T'0) ->
             [ &_2 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_4 <- { _4 with current = _ret'.final } ] 
            s3)
      | s3 = {inv'0 _2.current}
        Borrow.borrow_final <t_T'0> {_2.current} {Borrow.get_id _2}
          (fun (_ret':borrowed t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_2 <- { _2 with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 _5} s5
      | s5 = -{resolve'0 _5}- s6
      | s6 = {[@expl:type invariant] inv'1 _4} s7
      | s7 = -{resolve'0 _4}- s8
      | s8 = {[@expl:type invariant] inv'1 _2} s9
      | s9 = -{resolve'0 _2}- s10
      | s10 = {[@expl:type invariant] inv'2 self} s11
      | s11 = -{resolve'1 self}- s12
      | s12 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed t_T'0 = any_l ()
    | & self : borrowed (t_GhostBox'0) = self
    | & _2 : borrowed t_T'0 = any_l ()
    | & _4 : borrowed t_T'0 = any_l ()
    | & _5 : borrowed t_T'0 = any_l () ]
    
    [ return' (result:borrowed t_T'0)-> {[@expl:deref_mut result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref_mut ensures] [%#sghost2] result
      = Borrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__borrow [#"../../../creusot-contracts/src/ghost.rs" 107 4 107 40] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 107 19 107 23
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 107 28 107 40
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 106 14 106 35
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_T'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_T'0 }
  
  use prelude.prelude.Borrow
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: t_T'0 }
  
  use prelude.prelude.Intrinsic
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed4] inv'6 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_GhostBox'1 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'1) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'1 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant3] inv'6 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed4] inv'5 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec borrow'0 (self:t_GhostBox'1) (return'  (ret:t_GhostBox'0))= {[@expl:borrow 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- self.t_GhostBox__0'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'1 = _5 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = any_l () | & self : t_GhostBox'1 = self | & _5 : t_T'0 = any_l () ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:borrow result type invariant] [%#sghost1] inv'1 result}
      {[@expl:borrow ensures] [%#sghost2] result.t_GhostBox__0'1 = self.t_GhostBox__0'0}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__borrow_mut [#"../../../creusot-contracts/src/ghost.rs" 121 4 121 52] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 121 27 121 31
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 121 36 121 52
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 120 14 120 39
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_T'0 }
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: borrowed t_T'0 }
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t_T'0) =
    resolve'2 _1
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed5] inv'0 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_GhostBox'1 [inv'5 x] . inv'5 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'6 a_0
    end
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_GhostBox'1)) =
    [%#sinvariant4] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostBox'1))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_GhostBox'1) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_GhostBox'1)) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_GhostBox'1)) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_T'0) =
    [%#sboxed5] inv'1 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec borrow_mut'0 (self:borrowed (t_GhostBox'1)) (return'  (ret:t_GhostBox'0))= {[@expl:borrow_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_GhostBox__0'0}
        Borrow.borrow_final <t_T'0> {(self.current).t_GhostBox__0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
          (fun (_ret':borrowed t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_GhostBox__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _5.current}
        Borrow.borrow_final <t_T'0> {_5.current} {Borrow.get_id _5}
          (fun (_ret':borrowed t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'1 = _4 } ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = return' {_0} ]
       ]
    )
    [ & _0 : t_GhostBox'0 = any_l ()
    | & self : borrowed (t_GhostBox'1) = self
    | & _4 : borrowed t_T'0 = any_l ()
    | & _5 : borrowed t_T'0 = any_l () ]
    
    [ return' (result:t_GhostBox'0)-> {[@expl:borrow_mut result type invariant] [%#sghost1] inv'3 result}
      {[@expl:borrow_mut ensures] [%#sghost2] result.t_GhostBox__0'1
      = Borrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__new [#"../../../creusot-contracts/src/ghost.rs" 147 4 147 28] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 147 15 147 16
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 147 24 147 28
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 145 14 145 28
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed3] inv'0 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec new'0 (x:t_T'0) (return'  (ret:t_GhostBox'0))= {[@expl:new 'x' type invariant] [%#sghost0] inv'0 x}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'0 = x } ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = any_l () | & x : t_T'0 = x ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:new result type invariant] [%#sghost1] inv'1 result}
      {[@expl:new ensures] [%#sghost2] result.t_GhostBox__0'0 = x}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__into_inner [#"../../../creusot-contracts/src/ghost.rs" 165 4 165 32] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 165 22 165 26
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 165 31 165 32
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 163 14 163 31
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use prelude.prelude.Intrinsic
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed3] inv'1 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec into_inner'0 (self:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:into_inner 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- self.t_GhostBox__0'0 ] s1 | s1 = bb2 ]  | bb2 = return' {_0} ] )
    [ & _0 : t_T'0 = any_l () | & self : t_GhostBox'0 = self ]
    
    [ return' (result:t_T'0)-> {[@expl:into_inner result type invariant] [%#sghost1] inv'1 result}
      {[@expl:into_inner ensures] [%#sghost2] result = self.t_GhostBox__0'0}
      (! return' {result}) ]
    
end
module M_creusot_contracts__snapshot__qyi5567339964777190687__clone [#"../../../creusot-contracts/src/snapshot.rs" 32 4 32 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../../creusot-contracts/src/snapshot.rs" 33 8 33 28
  let%span ssnapshot1 = "../../../creusot-contracts/src/snapshot.rs" 31 14 31 29
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  type t_T'0
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0 (self:Snapshot.snap_ty t_T'0) (return'  (ret:Snapshot.snap_ty t_T'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#ssnapshot0] Snapshot.new (Snapshot.inner self) ] s1 | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : Snapshot.snap_ty t_T'0 = any_l () | & self : Snapshot.snap_ty t_T'0 = self ] 
    [ return' (result:Snapshot.snap_ty t_T'0)-> {[@expl:clone ensures] [%#ssnapshot1] result = self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__are_eq [#"../../../creusot-contracts/src/ghost_ptr.rs" 68 4 70 17] (* ghost_ptr::GhostPtrToken<T> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 68 19 68 23
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 64 15 64 69
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 65 15 65 69
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 66 14 66 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 67 14 67 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 62 24 62 28
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 59 14 61 24
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 308 18 308 46
  let%span smodel8 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 120 8 120 35
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sinvariant14 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sghost_ptr16 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrToken'0
  
  use prelude.prelude.Opaque
  
  type t_T'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr10] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr11] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'2_spec : forall self : t_FMap'0 . [%#sfmap15] mk'0 (view'2 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap13] Map.get (view'2 self) k
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'1_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr12] get_unsized'0 (view'1 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr16] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'1 self) ptr = C_Some'0 x  -> inv'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostPtrToken'0) =
    [%#sinvariant14] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrToken'0) : t_FMap'0 =
    [%#smodel8] view'1 self
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 119 4 119 39] (self : t_FMap'0) (k : opaque_ptr) : bool
    
   =
    [%#sfmap9] get_unsized'0 self k <> C_None'0
  
  let rec injective_lemma'0 (self:t_GhostPtrToken'0) (return'  (ret:()))= {[@expl:injective_lemma 'self' type invariant] [%#sghost_ptr5] inv'0 self}
    any
    [ return' (result:())-> {[%#sghost_ptr6] forall ptr1 : opaque_ptr, ptr2 : opaque_ptr . contains'0 (view'0 self) ptr1
      /\ contains'0 (view'0 self) ptr2 /\ addr_logic'0 ptr1 = addr_logic'0 ptr2  -> ptr1 = ptr2}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  let rec addr'0 (self:opaque_ptr) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#sghost_ptr7] UInt64.to_uint result = addr_logic'0 self} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec are_eq'0 (self:t_GhostPtrToken'0) (ptr1:opaque_ptr) (ptr2:opaque_ptr) (return'  (ret:bool))= {[@expl:are_eq 'self' type invariant] [%#sghost_ptr0] inv'0 self}
    {[@expl:are_eq requires #0] [%#sghost_ptr1] contains'0 (view'0 self) ptr1 \/ ptr1 = null_logic'0 ()}
    {[@expl:are_eq requires #1] [%#sghost_ptr2] contains'0 (view'0 self) ptr2 \/ ptr2 = null_logic'0 ()}
    (! bb0
    [ bb0 = s0 [ s0 = injective_lemma'0 {self} (fun (_ret':()) ->  [ &_8 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = addr'0 {ptr1} (fun (_ret':UInt64.t) ->  [ &_10 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = addr'0 {ptr2} (fun (_ret':UInt64.t) ->  [ &_12 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = UInt64.eq {_10} {_12} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : bool = any_l ()
    | & self : t_GhostPtrToken'0 = self
    | & ptr1 : opaque_ptr = ptr1
    | & ptr2 : opaque_ptr = ptr2
    | & _8 : () = any_l ()
    | & _10 : UInt64.t = any_l ()
    | & _12 : UInt64.t = any_l () ]
    
    [ return' (result:bool)-> {[@expl:are_eq ensures #0] [%#sghost_ptr3] result
      = (addr_logic'0 ptr1 = addr_logic'0 ptr2)}
      {[@expl:are_eq ensures #1] [%#sghost_ptr4] result = (ptr1 = ptr2)}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__ptr_as_mut [#"../../../creusot-contracts/src/ghost_ptr.rs" 102 4 102 60] (* ghost_ptr::GhostPtrToken<T> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 102 27 102 31
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 99 15 99 34
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 102 54 102 60
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 100 14 100 54
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 101 14 101 55
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 139 27 139 31
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 137 14 137 38
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 138 14 138 38
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 254 15 254 42
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 259 52 259 61
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 255 14 255 59
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 256 14 256 56
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 257 14 257 65
  let%span sghost_ptr13 = "../../../creusot-contracts/src/ghost_ptr.rs" 258 14 258 42
  let%span smodel14 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 120 8 120 35
  let%span sghost_ptr16 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sfmap17 = "../../../creusot-contracts/src/logic/fmap.rs" 103 8 103 35
  let%span sfmap18 = "../../../creusot-contracts/src/logic/fmap.rs" 64 14 64 71
  let%span sfmap19 = "../../../creusot-contracts/src/logic/fmap.rs" 65 14 65 61
  let%span sfmap20 = "../../../creusot-contracts/src/logic/fmap.rs" 66 14 66 66
  let%span sghost_ptr21 = "../../../creusot-contracts/src/ghost_ptr.rs" 209 14 209 64
  let%span sghost_ptr22 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 14 216 64
  let%span sfmap23 = "../../../creusot-contracts/src/logic/fmap.rs" 73 14 73 55
  let%span sfmap24 = "../../../creusot-contracts/src/logic/fmap.rs" 74 14 74 84
  let%span sghost_ptr25 = "../../../creusot-contracts/src/ghost_ptr.rs" 288 8 288 32
  let%span sresolve26 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap27 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sghost_ptr28 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr29 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sutil30 = "../../../creusot-contracts/src/util.rs" 32 11 32 21
  let%span sutil31 = "../../../creusot-contracts/src/util.rs" 33 10 33 28
  let%span sfmap32 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sutil33 = "../../../creusot-contracts/src/util.rs" 14 14 14 30
  let%span sfmap34 = "../../../creusot-contracts/src/logic/fmap.rs" 44 14 44 25
  let%span sghost_ptr35 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  let%span sinvariant36 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrToken'0
  
  use prelude.prelude.Opaque
  
  type t_T'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr28] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr29] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'2_spec : forall self : t_FMap'0 . [%#sfmap32] mk'0 (view'2 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap27] Map.get (view'2 self) k
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'1_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr16] get_unsized'0 (view'1 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr35] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'1 self) ptr = C_Some'0 x  -> inv'1 x
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_GhostPtrToken'0))
    
   =
    [%#sinvariant36] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostPtrToken'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_GhostPtrToken'0) [inv'3 x] . inv'3 x = invariant'2 x
  
  type t_GhostPtrTokenMut'0
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 210 4 210 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom cur'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr21] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = C_None'0
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 217 4 217 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom fin'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr22] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = C_None'0
  
  let rec borrow_mut'0 (self:borrowed (t_GhostPtrToken'0)) (return'  (ret:t_GhostPtrTokenMut'0))= {[@expl:borrow_mut 'self' type invariant] [%#sghost_ptr5] inv'3 self}
    any
    [ return' (result:t_GhostPtrTokenMut'0)-> {[%#sghost_ptr6] cur'0 result = view'1 self.current}
      {[%#sghost_ptr7] fin'0 result = view'1 self.final}
      (! return' {result}) ]
    
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 119 4 119 39] (self : t_FMap'0) (k : opaque_ptr) : bool
    
   =
    [%#sfmap15] get_unsized'0 self k <> C_None'0
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant36] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function unwrap'0 [#"../../../creusot-contracts/src/util.rs" 34 0 34 36] (op : t_Option'0) : t_T'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil30] op <> C_None'0)
   -> ([%#sutil31] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 102 4 102 50] (self : t_FMap'0) (k : opaque_ptr) : t_T'0
    
   =
    [%#sfmap17] unwrap'0 (get_unsized'0 self k)
  
  use map.Map
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 45 4 45 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap34] len'0 self >= 0
  
  function remove'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 75 4 75 37] (self : t_FMap'0) (k : opaque_ptr) : t_FMap'0
    
  
  axiom remove'0_spec : forall self : t_FMap'0, k : opaque_ptr . ([%#sfmap23] view'2 (remove'0 self k)
  = Map.set (view'2 self) k (C_None'0))
  && ([%#sfmap24] len'0 (remove'0 self k) = (if contains'0 self k then len'0 self - 1 else len'0 self))
  
  function make_sized'0 [#"../../../creusot-contracts/src/util.rs" 15 4 15 40] (self : t_T'0) : t_T'0
  
  axiom make_sized'0_spec : forall self : t_T'0 . [%#sutil33] make_sized'0 self = self
  
  function insert'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 67 4 67 43] (self : t_FMap'0) (k : opaque_ptr) (v : t_T'0) : t_FMap'0
    
  
  axiom insert'0_spec : forall self : t_FMap'0, k : opaque_ptr, v : t_T'0 . ([%#sfmap18] view'2 (insert'0 self k v)
  = Map.set (view'2 self) k (C_Some'0 (make_sized'0 v)))
  && ([%#sfmap19] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#sfmap20] not contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self + 1)
  
  let rec take_mut'0 (self:borrowed (t_GhostPtrTokenMut'0)) (ptr:opaque_ptr) (return'  (ret:borrowed t_T'0))= {[@expl:take_mut requires] [%#sghost_ptr8] contains'0 (cur'0 self.current) ptr}
    any
    [ return' (result:borrowed t_T'0)-> {[%#sghost_ptr9] inv'2 result}
      {[%#sghost_ptr10] result.current = lookup_unsized'0 (cur'0 self.current) ptr}
      {[%#sghost_ptr11] cur'0 self.final = remove'0 (cur'0 self.current) ptr}
      {[%#sghost_ptr12] fin'0 self.current = insert'0 (fin'0 self.final) ptr result.final}
      {[%#sghost_ptr13] not contains'0 (fin'0 self.final) ptr}
      (! return' {result}) ]
    
  
  predicate resolve'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 287 4 287 28] (self : t_GhostPtrTokenMut'0) =
    [%#sghost_ptr25] cur'0 self = fin'0 self
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_GhostPtrTokenMut'0) =
    resolve'3 _1
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t_T'0) =
    resolve'4 _1
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed (t_GhostPtrToken'0)) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (t_GhostPtrToken'0)) =
    resolve'5 _1
  
  use prelude.prelude.Intrinsic
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (t_GhostPtrToken'0)) : t_FMap'0
    
   =
    [%#smodel14] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec ptr_as_mut'0 (self:borrowed (t_GhostPtrToken'0)) (ptr:opaque_ptr) (return'  (ret:borrowed t_T'0))= {[@expl:ptr_as_mut 'self' type invariant] [%#sghost_ptr0] inv'3 self}
    {[@expl:ptr_as_mut requires] [%#sghost_ptr1] contains'0 (view'0 self) ptr}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <t_GhostPtrToken'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (t_GhostPtrToken'0)) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = borrow_mut'0 {_10} (fun (_ret':t_GhostPtrTokenMut'0) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <t_GhostPtrTokenMut'0> {_9}
          (fun (_ret':borrowed (t_GhostPtrTokenMut'0)) ->  [ &_8 <- _ret' ]  [ &_9 <- _ret'.final ] s1)
      | s1 = take_mut'0 {_8} {ptr} (fun (_ret':borrowed t_T'0) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = -{resolve'0 _9}- s1
      | s1 = {inv'1 _7.current}
        Borrow.borrow_final <t_T'0> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_7 <- { _7 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'1 _3.current}
        Borrow.borrow_final <t_T'0> {_3.current} {Borrow.get_id _3}
          (fun (_ret':borrowed t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'2 _7} s4
      | s4 = -{resolve'1 _7}- s5
      | s5 = {[@expl:type invariant] inv'2 _3} s6
      | s6 = -{resolve'1 _3}- s7
      | s7 = {[@expl:type invariant] inv'3 self} s8
      | s8 = -{resolve'2 self}- s9
      | s9 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed t_T'0 = any_l ()
    | & self : borrowed (t_GhostPtrToken'0) = self
    | & ptr : opaque_ptr = ptr
    | & _3 : borrowed t_T'0 = any_l ()
    | & _7 : borrowed t_T'0 = any_l ()
    | & _8 : borrowed (t_GhostPtrTokenMut'0) = any_l ()
    | & _9 : t_GhostPtrTokenMut'0 = any_l ()
    | & _10 : borrowed (t_GhostPtrToken'0) = any_l () ]
    
    [ return' (result:borrowed t_T'0)-> {[@expl:ptr_as_mut result type invariant] [%#sghost_ptr2] inv'2 result}
      {[@expl:ptr_as_mut ensures #0] [%#sghost_ptr3] result.current = lookup_unsized'0 (view'1 self.current) ptr}
      {[@expl:ptr_as_mut ensures #1] [%#sghost_ptr4] view'1 self.final
      = insert'0 (view'1 self.current) ptr result.final}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__drop [#"../../../creusot-contracts/src/ghost_ptr.rs" 126 4 126 21] (* ghost_ptr::GhostPtrToken<T> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 126 16 126 20
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 125 15 125 31
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 126 8 126 34
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 36 14 36 31
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 37 14 37 49
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 185 14 185 38
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 186 14 186 83
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 188 8 188 35
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 44 14 44 25
  
  type t_GhostPtrToken'0
  
  use prelude.prelude.Opaque
  
  type t_T'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr4] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr5] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'1 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap13] mk'0 (view'1 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function view'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'0_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr2] get_unsized'0 (view'0 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr12] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'0 self) ptr = C_Some'0 x  -> inv'1 x
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Intrinsic
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 45 4 45 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap14] len'0 self >= 0
  
  use map.Const
  
  function empty'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 38 4 38 26] (_1 : ()) : t_FMap'0
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap7] len'0 (empty'0 _1) = 0)
  && ([%#sfmap8] view'1 (empty'0 _1) = Const.const (C_None'0))
  
  function ext_eq'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 187 4 187 44] (self : t_FMap'0) (other : t_FMap'0) : bool
    
   =
    [%#sfmap11] view'1 self = view'1 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap9] ext_eq'0 self other  -> self = other)
  && ([%#sfmap10] (forall k : opaque_ptr . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function is_empty'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 125 4 125 33] (self : t_FMap'0) : bool =
    [%#sfmap3] ext_eq'0 self (empty'0 ())
  
  meta "compute_max_steps" 1000000
  
  let rec drop'0 (self:t_GhostPtrToken'0) (return'  (ret:()))= {[@expl:drop 'self' type invariant] [%#sghost_ptr0] inv'0 self}
    {[@expl:drop requires] [%#sghost_ptr1] is_empty'0 (view'0 self)}
    (! bb0 [ bb0 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = return' {_0} ]  ] )
    [ & _0 : () = any_l () | & self : t_GhostPtrToken'0 = self ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__ghost_ptr__qyi12069901807935209935__deref [#"../../../creusot-contracts/src/ghost_ptr.rs" 175 4 175 36] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::ops::Deref> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 175 23 175 36
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 174 14 174 30
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 192 27 192 47
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 191 14 191 30
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 165 14 165 64
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sinvariant10 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrToken'0
  
  use prelude.prelude.Opaque
  
  type t_T'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr7] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr8] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'4 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'4_spec : forall self : t_FMap'0 . [%#sfmap11] mk'0 (view'4 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap9] Map.get (view'4 self) k
  
  function view'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'3_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr6] get_unsized'0 (view'3 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr12] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'3 self) ptr = C_Some'0 x  -> inv'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostPtrToken'0) =
    [%#sinvariant10] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrToken'0) : t_FMap'0 =
    [%#smodel4] view'3 self
  
  type t_GhostPtrTokenRef'0
  
  function view'2 [#"../../../creusot-contracts/src/ghost_ptr.rs" 166 4 166 33] (self : t_GhostPtrTokenRef'0) : t_FMap'0
  
  axiom view'2_spec : forall self : t_GhostPtrTokenRef'0 . [%#sghost_ptr5] get_unsized'0 (view'2 self) (null_logic'0 ())
  = C_None'0
  
  let rec to_ref'0 (self:t_GhostPtrTokenRef'0) (return'  (ret:t_GhostPtrToken'0))= any
    [ return' (result:t_GhostPtrToken'0)-> {[%#sghost_ptr2] inv'0 result}
      {[%#sghost_ptr3] view'0 result = view'2 self}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrTokenRef'0) : t_FMap'0 =
    [%#smodel4] view'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec deref'0 (self:t_GhostPtrTokenRef'0) (return'  (ret:t_GhostPtrToken'0))= (! bb0
    [ bb0 = s0 [ s0 = to_ref'0 {self} (fun (_ret':t_GhostPtrToken'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_2 <- _4 ] s1 | s1 =  [ &_0 <- _2 ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_GhostPtrToken'0 = any_l ()
    | & self : t_GhostPtrTokenRef'0 = self
    | & _2 : t_GhostPtrToken'0 = any_l ()
    | & _4 : t_GhostPtrToken'0 = any_l () ]
    
    [ return' (result:t_GhostPtrToken'0)-> {[@expl:deref result type invariant] [%#sghost_ptr0] inv'0 result}
      {[@expl:deref ensures] [%#sghost_ptr1] view'0 result = view'1 self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi10758646311866972331__clone [#"../../../creusot-contracts/src/ghost_ptr.rs" 201 4 201 27] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::clone::Clone> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 200 14 200 29
  
  type t_GhostPtrTokenRef'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0 (self:t_GhostPtrTokenRef'0) (return'  (ret:t_GhostPtrTokenRef'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_GhostPtrTokenRef'0 = any_l () | & self : t_GhostPtrTokenRef'0 = self ] 
    [ return' (result:t_GhostPtrTokenRef'0)-> {[@expl:clone ensures] [%#sghost_ptr0] result = self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__resolve__qyi4855891653524509355__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 45 15 45 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 46 14 46 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 43 4 43 23
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  use prelude.prelude.Borrow
  
  type t_T1'0
  
  type t_T2'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : (t_T1'0, t_T2'0)) =
    match _1 with
      | (x0, x1) -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : (t_T1'0, t_T2'0)) =
    [%#sresolve3] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  constant self  : (t_T1'0, t_T2'0)
  
  function resolve_coherence'0 [#"../../../creusot-contracts/src/resolve.rs" 47 4 47 31] (self : (t_T1'0, t_T2'0)) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi6740873903368268328__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 59 15 59 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 60 14 60 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 57 4 57 23
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : borrowed t_T'0) =
    _1.final = _1.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve3] self.final = self.current
  
  constant self  : borrowed t_T'0
  
  function resolve_coherence'0 [#"../../../creusot-contracts/src/resolve.rs" 61 4 61 31] (self : borrowed t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi10830812895881240411__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 73 15 73 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 74 14 74 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 71 4 71 23
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 68 8 68 23
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve3] resolve'1 self
  
  constant self  : t_T'0
  
  function resolve_coherence'0 [#"../../../creusot-contracts/src/resolve.rs" 75 4 75 31] (self : t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi12875730110607858017__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 90 15 90 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 91 14 91 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 88 4 88 23
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve3] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  constant self  : t_Option'0
  
  function resolve_coherence'0 [#"../../../creusot-contracts/src/resolve.rs" 92 4 92 31] (self : t_Option'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__util__unwrap [#"../../../creusot-contracts/src/util.rs" 34 0 34 36]
  let%span sutil0 = "../../../creusot-contracts/src/util.rs" 32 11 32 21
  let%span sutil1 = "../../../creusot-contracts/src/util.rs" 33 10 33 28
  let%span sutil2 = "../../../creusot-contracts/src/util.rs" 23 11 23 16
  let%span sutil3 = "../../../creusot-contracts/src/util.rs" 24 10 24 15
  let%span sutil4 = "../../../creusot-contracts/src/util.rs" 25 10 25 11
  let%span sutil5 = "../../../creusot-contracts/src/util.rs" 35 4 38 5
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function unreachable'0 [#"../../../creusot-contracts/src/util.rs" 26 0 26 28] (_1 : ()) : t_T'0
  
  axiom unreachable'0_spec : forall _1 : () . ([%#sutil2] false)  -> ([%#sutil3] false)
  
  constant op  : t_Option'0
  
  function unwrap'0 [#"../../../creusot-contracts/src/util.rs" 34 0 34 36] (op : t_Option'0) : t_T'0
  
  goal vc_unwrap'0 : ([%#sutil0] op <> C_None'0)
   -> match op with
    | C_Some'0 t -> [%#sutil1] C_Some'0 t = op
    | C_None'0 -> ([@expl:unreachable requires] [%#sutil2] false)
    /\ (([%#sutil3] false)  -> ([%#sutil1] C_Some'0 (unreachable'0 ()) = op))
    end
end
module M_creusot_contracts__logic__int__qyi3540547019284611154__clone__refines [#"../../../creusot-contracts/src/logic/int.rs" 19 4 19 27] (* <logic::int::Int as std::clone::Clone> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 19 4 19 27
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sint0] forall self : int . inv'0 self
   -> (forall result : int . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__ghost__qyi17645547594388049322__clone__refines [#"../../../creusot-contracts/src/ghost.rs" 33 4 33 27] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 33 4 33 27
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_GhostBox'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__snapshot__qyi5567339964777190687__clone__refines [#"../../../creusot-contracts/src/snapshot.rs" 32 4 32 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../../creusot-contracts/src/snapshot.rs" 32 4 32 27
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use prelude.prelude.Snapshot
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Snapshot.snap_ty t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Snapshot.snap_ty t_T'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Snapshot.snap_ty t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Snapshot.snap_ty t_T'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#ssnapshot0] forall self : Snapshot.snap_ty t_T'0 . inv'0 self
   -> (forall result : Snapshot.snap_ty t_T'0 . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi10758646311866972331__clone__refines [#"../../../creusot-contracts/src/ghost_ptr.rs" 201 4 201 27] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::clone::Clone> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 201 4 201 27
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrTokenRef'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrTokenRef'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrTokenRef'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrTokenRef'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostPtrTokenRef'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sghost_ptr0] forall self : t_GhostPtrTokenRef'0 . inv'0 self
   -> (forall result : t_GhostPtrTokenRef'0 . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__int__qyi3411234291730139970__add__refines [#"../../../creusot-contracts/src/logic/int.rs" 86 4 86 32] (* <logic::int::Int as std::ops::Add> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 86 4 86 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi14674898037351238599__sub__refines [#"../../../creusot-contracts/src/logic/int.rs" 97 4 97 32] (* <logic::int::Int as std::ops::Sub> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 97 4 97 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi92031444461445902__mul__refines [#"../../../creusot-contracts/src/logic/int.rs" 108 4 108 32] (* <logic::int::Int as std::ops::Mul> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 108 4 108 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi2704776725966497021__div__refines [#"../../../creusot-contracts/src/logic/int.rs" 119 4 119 32] (* <logic::int::Int as std::ops::Div> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 119 4 119 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi13390566486180286353__rem__refines [#"../../../creusot-contracts/src/logic/int.rs" 130 4 130 32] (* <logic::int::Int as std::ops::Rem> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 130 4 130 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi6972377124305281595__neg__refines [#"../../../creusot-contracts/src/logic/int.rs" 141 4 141 24] (* <logic::int::Int as std::ops::Neg> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 141 4 141 24
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sint0] forall self : int . inv'0 self  -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x >= y) = (cmp_log'0 x y <> C_Less'0)
   -> (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall result : () . cmp_log'0 x x = C_Equal'0  -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x > y)
  = (cmp_log'0 x y = C_Greater'0)  -> (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x < y) = (cmp_log'0 x y = C_Less'0)
   -> (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x = y) = (cmp_log'0 x y = C_Equal'0)
   -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x <= y)
  = (cmp_log'0 x y <> C_Greater'0)  -> (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : t_Ordering'0
    
   =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall z : int . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt8.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall z : UInt8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt8.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt8.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt8.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt8.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt16.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt16.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt16.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall z : UInt16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt16.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt16.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt32.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall z : UInt32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt32.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt32.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt32.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt128.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall z : UInt128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt128.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt128.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt128.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt128.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.uge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.ule x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ult x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.ugt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
    
   =
    [%#sord1] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int8.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int8.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall z : Int8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int8.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int8
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
    
   =
    [%#sord1] if Int8.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int8.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int16.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall z : Int16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int16.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int16.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int16.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int16
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
    
   =
    [%#sord1] if Int16.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int32.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall z : Int32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int32.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int32.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int32.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int32
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
    
   =
    [%#sord1] if Int32.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int128.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int128.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int128.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int128.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int128
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
    
   =
    [%#sord1] if Int128.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall z : Int128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.sge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.slt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.slt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sgt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.sgt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Int64
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 184 12 184 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
    
   =
    [%#sord1] if Int64.slt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.sle x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.sle x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  goal refines : [%#sord0] forall x : bool . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 275 8 280 9
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 274 4 274 41] (self : bool) (o : bool) : t_Ordering'0
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> C_Equal'0
      | (True, True) -> C_Equal'0
      | (False, True) -> C_Less'0
      | (True, False) -> C_Greater'0
      end
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall z : bool . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 321 20 321 67
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 320 4 320 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 315 20 315 68
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 314 4 314 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 303 20 303 68
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 302 4 302 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall z : (t_A'0, t_B'0) . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 309 20 309 67
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 308 4 308 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : bool
    
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 290 8 297 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_A'0) (_2 : t_A'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_A'0) (o : t_A'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_B'0) (_2 : t_B'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_B'0) (o : t_B'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 289 4 289 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_lt_log__refines [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym1__refines [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__eq_cmp__refines [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__refl__refines [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__trans__refines [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall z : t_Reverse'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym2__refines [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_le_log__refines [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_ge_log__refines [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_gt_log__refines [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
    
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_Reverse'0) (o : t_Reverse'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_Option'0) (o : t_Option'0) : bool
    
   =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t_T'0) (_2 : t_T'0) : t_Ordering'0
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
    
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t_T'0) (o : t_T'0) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
    
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall z : t_Option'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<=) x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<) x y
  = (cmp_log'0 x y = C_Less'0)  -> Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>=) x y
  = (cmp_log'0 x y <> C_Less'0)  -> Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>) x y
  = (cmp_log'0 x y = C_Greater'0)  -> Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall z : Real.real . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use prelude.prelude.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
    
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__deque__qyi8367101395671471553__resolve_coherence__refines [#"../../../creusot-contracts/src/std/deque.rs" 65 4 65 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 65 4 65 31
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 58 20 58 83
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 13 14 13 41
  let%span sdeque3 = "../../../creusot-contracts/src/std/deque.rs" 39 8 39 31
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_Cap'0  =
    { t_Cap__0'0: UInt64.t }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_VecDeque'0  =
    { t_VecDeque__head'0: UInt64.t; t_VecDeque__len'0: UInt64.t; t_VecDeque__buf'0: t_RawVec'0 }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_VecDeque'0) =
    match _1 with
      | {t_VecDeque__head'0 = x0 ; t_VecDeque__len'0 = x1 ; t_VecDeque__buf'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'2 x0
      end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_VecDeque'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_VecDeque'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 14 4 14 27] (self : t_VecDeque'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_VecDeque'0 . [%#sdeque2] Seq.length (view'0 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/deque.rs" 38 4 38 47] (self : t_VecDeque'0) (ix : int) : t_T'0
    
   =
    [%#sdeque3] Seq.get (view'0 self) ix
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/deque.rs" 57 4 57 28] (self : t_VecDeque'0) =
    [%#sdeque1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#sdeque0] forall self : t_VecDeque'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi49636360433726320__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 21 8 21 29
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Cloned'0) =
    match _1 with
      | {t_Cloned__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Cloned'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Cloned'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 20 4 20 28] (self : t_Cloned'0) =
    [%#scloned1] resolve'1 (iter'0 self)
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi4622684907952448174__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31] (* <std::iter::Copied<I> as resolve::Resolve> *)
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Copied'0) =
    match _1 with
      | {t_Copied__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Copied'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Copied'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 20 4 20 28] (self : t_Copied'0) =
    [%#scopied1] resolve'1 (iter'0 self)
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2208779330486735413__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 30 8 30 29
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Enumerate'0) =
    match _1 with
      | {t_Enumerate__iter'0 = x0 ; t_Enumerate__count'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'1 : forall x : t_Enumerate'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Enumerate'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 29 4 29 28] (self : t_Enumerate'0) =
    [%#senumerate1] resolve'2 (iter'0 self)
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi13484997498660514945__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/map.rs" 42 4 42 31] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 42 4 42 31
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 34 8 34 54
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Map'0) =
    match _1 with
      | {t_Map__iter'0 = x0 ; t_Map__f'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Map'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'3 f
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Map'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap2] inv'1 self  -> inv'2 (iter'0 self)
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap3] inv'1 self  -> inv'3 (func'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 33 4 33 28] (self : t_Map'0) =
    [%#smap1] resolve'2 (iter'0 self) /\ resolve'1 (func'0 self)
  
  goal refines : [%#smap0] forall self : t_Map'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi5691635635396426195__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 69 4 69 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 69 4 69 31
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 62 8 62 50
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_B'0) }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Snapshot.snap_ty (Seq.seq t_B'0))
   =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'1 : forall x : t_MapInv'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'2 iter /\ inv'3 func
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_MapInv'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 61 4 61 28] (self : t_MapInv'0) =
    [%#smap_inv1] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi14372835745621067113__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31] (* <std::iter::Skip<I> as resolve::Resolve> *)
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Skip'0) =
    match _1 with
      | {t_Skip__iter'0 = x0 ; t_Skip__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Skip'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Skip'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 30 4 30 28] (self : t_Skip'0) =
    [%#sskip1] resolve'2 (iter'0 self)
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi11550387566643656565__resolve_coherence__refines [#"../../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31] (* <std::iter::Take<I> as resolve::Resolve> *)
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Take'0) =
    match _1 with
      | {t_Take__iter'0 = x0 ; t_Take__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Take'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Take'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 40 4 40 28] (self : t_Take'0) =
    [%#stake1] resolve'2 (iter'0 self)
  
  goal refines : [%#stake0] forall self : t_Take'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi4472237099583716627__resolve_coherence__refines [#"../../../creusot-contracts/src/std/slice.rs" 463 4 463 31] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 463 4 463 31
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 455 20 455 36
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 445 14 445 50
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : opaque_ptr) =
    true
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IterMut'0) =
    match _1 with
      | {t_IterMut__ptr'0 = x0 ; t_IterMut__end_or_len'0 = x1 ; t_IterMut__qy95zmarker'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  use prelude.prelude.Slice64
  
  type t_T'0
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : slice t_T'0 . ([%#sslice3] Seq.length (view'1 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice4] view'1 self = Slice64.id self)
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 33] (self : t_IterMut'0) : borrowed (slice t_T'0)
    
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/slice.rs" 454 4 454 28] (self : t_IterMut'0) =
    [%#sslice1] (view'0 self).current = (view'0 self).final
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi6844585276173866460__resolve_coherence__refines [#"../../../creusot-contracts/src/std/vec.rs" 56 4 56 31] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 56 4 56 31
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 49 20 49 83
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sops3 = "../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span svec5 = "../../../creusot-contracts/src/std/vec.rs" 65 20 65 41
  let%span sseq6 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed7 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Cap'0  =
    { t_Cap__0'0: UInt64.t }
  
  type t_A'0
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: t_A'0 }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Vec'0) =
    match _1 with
      | {t_Vec__buf'0 = x0 ; t_Vec__len'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec2] Seq.length (view'0 self) <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed7] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/vec.rs" 64 4 64 30] (self : t_Vec'0) =
    [%#svec5] inv'2 (view'0 self)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Vec'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 19 4 19 47] (self : t_Vec'0) (ix : int) : t_T'0
    
   =
    [%#sops3] Seq.get (view'0 self) ix
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/vec.rs" 48 4 48 28] (self : t_Vec'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#svec0] forall self : t_Vec'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi8594830193745006303__resolve_coherence__refines [#"../../../creusot-contracts/src/std/vec.rs" 250 4 250 31] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 250 4 250 31
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 243 20 243 83
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : opaque_ptr) =
    true
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_ManuallyDrop'0) =
    true
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IntoIter'0) =
    match _1 with
      | {t_IntoIter__buf'0 = x0 ; t_IntoIter__phantom'0 = x1 ; t_IntoIter__cap'0 = x2 ; t_IntoIter__alloc'0 = x3 ; t_IntoIter__ptr'0 = x4 ; t_IntoIter__end'0 = x5} -> resolve'1 x5
      /\ resolve'2 x4 /\ resolve'3 x3 /\ resolve'4 x2 /\ resolve'5 x1 /\ resolve'2 x0
      end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_ManuallyDrop'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_ManuallyDrop'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_ManuallyDrop__value'0 = value} -> inv'3 value
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_IntoIter__buf'0 = buf ; t_IntoIter__phantom'0 = phantom ; t_IntoIter__cap'0 = cap ; t_IntoIter__alloc'0 = alloc ; t_IntoIter__ptr'0 = ptr ; t_IntoIter__end'0 = end'} -> inv'2 alloc
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_IntoIter'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 234 4 234 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate resolve'6 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/vec.rs" 242 4 242 28] (self : t_IntoIter'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'6 (Seq.get (view'0 self) i)
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi2241556416362616690__resolve_coherence__refines [#"../../../creusot-contracts/src/ghost.rs" 100 4 100 31] (* <ghost::GhostBox<T> as resolve::Resolve> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 100 4 100 31
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 93 8 93 24
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve2] resolve'3 self
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0) =
    resolve'2 _1
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_GhostBox'0) =
    match _1 with
      | {t_GhostBox__0'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed4] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate structural_resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_GhostBox'0) =
    true
  
  predicate resolve'0 [#"../../../creusot-contracts/src/ghost.rs" 92 4 92 28] (self : t_GhostBox'0) =
    [%#sghost1] resolve'1 self.t_GhostBox__0'0
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'1 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost_ptr__qyi9310404846416116048__resolve_coherence__refines [#"../../../creusot-contracts/src/ghost_ptr.rs" 295 4 295 31] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as resolve::Resolve> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 295 4 295 31
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 288 8 288 32
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 209 14 209 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 14 216 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrTokenMut'0
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_GhostPtrTokenMut'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrTokenMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrTokenMut'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Opaque
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr4] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr5] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap7] mk'0 (view'0 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap6] Map.get (view'0 self) k
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 210 4 210 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom cur'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr2] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = C_None'0
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 217 4 217 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom fin'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr3] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = C_None'0
  
  predicate resolve'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 287 4 287 28] (self : t_GhostPtrTokenMut'0) =
    [%#sghost_ptr1] cur'0 self = fin'0 self
  
  goal refines : [%#sghost_ptr0] forall self : t_GhostPtrTokenMut'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi4855891653524509355__resolve_coherence__refines [#"../../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 47 4 47 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 40 8 40 44
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_T1'0
  
  type t_T2'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : (t_T1'0, t_T2'0)) =
    match _1 with
      | (x0, x1) -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T1'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T2'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t_T1'0, t_T2'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : (t_T1'0, t_T2'0) [inv'1 x] . inv'1 x
  = (let (x0, x1) = x in inv'2 x0 /\ inv'3 x1)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : (t_T1'0, t_T2'0)) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t_T1'0, t_T2'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (t_T1'0, t_T2'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : (t_T1'0, t_T2'0)) =
    [%#sresolve1] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  goal refines : [%#sresolve0] forall self : (t_T1'0, t_T2'0) . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi6740873903368268328__resolve_coherence__refines [#"../../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 61 4 61 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : borrowed t_T'0) =
    _1.final = _1.current
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant3] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : borrowed t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : borrowed t_T'0) =
    [%#sresolve1] self.final = self.current
  
  goal refines : [%#sresolve0] forall self : borrowed t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi10830812895881240411__resolve_coherence__refines [#"../../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 75 4 75 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed3] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve1] resolve'1 self
  
  goal refines : [%#sresolve0] forall self : t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi12875730110607858017__resolve_coherence__refines [#"../../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 92 4 92 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_Option'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve1] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  goal refines : [%#sresolve0] forall self : t_Option'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_refl__refines [#"../../../creusot-contracts/src/std/deque.rs" 178 4 178 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 178 4 178 26
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 171 12 171 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops5 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 155 4 155 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 169 4 169 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sdeque0] forall self : t_Iter'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_trans__refines [#"../../../creusot-contracts/src/std/deque.rs" 185 4 185 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 185 4 185 90
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 171 12 171 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops5 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 155 4 155 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 169 4 169 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sdeque0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/cloned.rs" 72 4 72 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 72 4 72 90
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 51 12 54 79
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq11 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed12 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant13 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed12] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq11] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] inv'2 a)
   -> ([%#siter6] inv'2 b)
   -> ([%#siter7] inv'2 c)
   -> ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter3] inv'2 self)
   -> ([%#siter4] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 49 4 49 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
    
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scloned0] forall a : t_Cloned'0 . forall ab : Seq.seq t_T'0 . forall b : t_Cloned'0 . forall bc : Seq.seq t_T'0 . forall c : t_Cloned'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/cloned.rs" 62 4 62 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 62 4 62 26
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 51 12 54 79
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq11 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed12 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant13 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed12] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq11] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] inv'2 a)
   -> ([%#siter6] inv'2 b)
   -> ([%#siter7] inv'2 c)
   -> ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter3] inv'2 self)
   -> ([%#siter4] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 49 4 49 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
    
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/copied.rs" 62 4 62 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 4 62 26
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 51 12 54 79
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq11 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed12 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant13 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed12] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq11] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] inv'2 a)
   -> ([%#siter6] inv'2 b)
   -> ([%#siter7] inv'2 c)
   -> ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter3] inv'2 self)
   -> ([%#siter4] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 49 4 49 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
    
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/copied.rs" 72 4 72 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 72 4 72 90
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 51 12 54 79
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq11 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed12 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant13 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed12] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_T'0) =
    [%#sseq11] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] inv'2 a)
   -> ([%#siter6] inv'2 b)
   -> ([%#siter7] inv'2 c)
   -> ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter3] inv'2 self)
   -> ([%#siter4] produces'1 self (Seq.empty  : Seq.seq t_T'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 49 4 49 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
    
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scopied0] forall a : t_Copied'0 . forall ab : Seq.seq t_T'0 . forall b : t_Copied'0 . forall bc : Seq.seq t_T'0 . forall c : t_Copied'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Empty'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Empty'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
    
   =
    [%#sempty1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
  
  goal refines : [%#sempty0] forall self : t_Empty'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
    
   =
    [%#sempty1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Empty'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Empty'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  goal refines : [%#sempty0] forall a : t_Empty'0 . forall ab : Seq.seq t_T'0 . forall b : t_Empty'0 . forall bc : Seq.seq t_T'0 . forall c : t_Empty'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 96 4 96 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 96 4 96 90
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 74 12 78 113
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate11 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 79
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] inv'2 a)
   -> ([%#siter6] inv'2 b)
   -> ([%#siter7] inv'2 c)
   -> ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter3] inv'2 self)
   -> ([%#siter4] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate11] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UInt64.to_uint v_MAX'0)
    /\ (forall i : borrowed t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 72 4 72 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
    
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.to_uint (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  goal refines : [%#senumerate0] forall a : t_Enumerate'0 . forall ab : Seq.seq (UInt64.t, t_Item'0) . forall b : t_Enumerate'0 . forall bc : Seq.seq (UInt64.t, t_Item'0) . forall c : t_Enumerate'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 86 4 86 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 86 4 86 26
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 74 12 78 113
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 79
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'2 a)
   -> ([%#siter7] inv'2 b)
   -> ([%#siter8] inv'2 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter4] inv'2 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate3] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UInt64.to_uint v_MAX'0)
    /\ (forall i : borrowed t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 72 4 72 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
    
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.to_uint (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (UInt64.t, t_Item'0)) self
   -> produces'0 self (Seq.empty  : Seq.seq (UInt64.t, t_Item'0)) self)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/filter.rs" 106 4 106 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 106 4 106 26
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter4 = "../../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  type t_Item'0
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : bool)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter4] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'1 iter /\ inv'2 predicate'
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter2] inv'0 self  -> inv'2 (func'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter14] inv'1 a)
   -> ([%#siter15] inv'1 b)
   -> ([%#siter16] inv'1 c)
   -> ([%#siter17] produces'1 a ab b)
   -> ([%#siter18] produces'1 b bc c)  -> ([%#siter19] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter12] inv'1 self)
   -> ([%#siter13] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
    
   =
    [%#sfilter1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall self : t_Filter'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/filter.rs" 116 4 116 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 116 4 116 90
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sfilter19 = "../../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : bool)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter19] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter2] inv'0 self  -> inv'1 (func'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] inv'2 a)
   -> ([%#siter14] inv'2 b)
   -> ([%#siter15] inv'2 c)
   -> ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter11] inv'2 self)
   -> ([%#siter12] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
    
   =
    [%#sfilter1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'2 a)
   -> ([%#siter7] inv'2 b)
   -> ([%#siter8] inv'2 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter4] inv'2 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall a : t_Fuse'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Fuse'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Fuse'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'2 a)
   -> ([%#siter7] inv'2 b)
   -> ([%#siter8] inv'2 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter4] inv'2 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall self : t_Fuse'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/map.rs" 83 4 83 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 83 4 83 26
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 64 12 75 75
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq19 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed20 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant21 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'3 iter /\ inv'4 f
    end
  
  use seq.Seq
  
  type t_B'0
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'4 (func'0 self)
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant21] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed20] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq19] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed20] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq19] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'3 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] inv'3 a)
   -> ([%#siter14] inv'3 b)
   -> ([%#siter15] inv'3 c)
   -> ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter11] inv'3 self)
   -> ([%#siter12] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 62 4 62 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
    
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap0] forall self : t_Map'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/map.rs" 93 4 93 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 93 4 93 90
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 64 12 75 75
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 24 14 24 39
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 17 14 17 39
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq19 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed20 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant21 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'4 iter /\ inv'3 f
    end
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 25 4 25 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'3 (func'0 self)
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant21] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed20] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq19] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed20] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq19] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 18 4 18 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'4 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] inv'4 a)
   -> ([%#siter14] inv'4 b)
   -> ([%#siter15] inv'4 c)
   -> ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter11] inv'4 self)
   -> ([%#siter12] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 62 4 62 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
    
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  goal refines : [%#smap0] forall a : t_Map'0 . forall ab : Seq.seq t_B'0 . forall b : t_Map'0 . forall bc : Seq.seq t_B'0 . forall c : t_Map'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi9026772487048432788__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span sops3 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span smap_inv18 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv19 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv20 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv21 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span sseq22 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv23 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sinvariant24 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed25 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  use prelude.prelude.Borrow
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant24] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_I'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] inv'3 a)
   -> ([%#siter13] inv'3 b)
   -> ([%#siter14] inv'3 c)
   -> ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter10] inv'3 self)
   -> ([%#siter11] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv21] forall e : t_Item'0, i : t_I'0 . inv'6 e /\ inv'3 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed25] inv'6 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq22] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant24] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed t_F'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv23] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv18] forall iter : borrowed t_I'0, func : t_F'0 . inv'5 iter /\ inv'4 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use prelude.prelude.Snapshot
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv20] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv19] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv2] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'3 iter /\ inv'4 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed25] inv'7 self
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_F'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq22] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi9026772487048432788__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span sops2 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops3 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span smap_inv17 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv19 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv20 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv21 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv22 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span smap_inv23 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sboxed24 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant25 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  type t_B'0
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops8] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops5] unnest'0 self b)
   -> ([%#sops6] unnest'0 b c)  -> ([%#sops7] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops4] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops2] postcondition_mut'0 self args res_state res)
   -> ([%#sops3] unnest'0 self res_state)
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  predicate invariant'6 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant25] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed t_F'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed24] inv'9 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'4 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed24] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq18] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter11] inv'3 a)
   -> ([%#siter12] inv'3 b)
   -> ([%#siter13] inv'3 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter9] inv'3 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  predicate invariant'5 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant25] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed t_I'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  use seq.Seq
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv22] forall e : t_Item'0, i : t_I'0 . inv'8 e /\ inv'3 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv23] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'8 e1 /\ inv'8 e2 /\ inv'9 f /\ inv'10 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv19] forall iter : borrowed t_I'0, func : t_F'0 . inv'7 iter /\ inv'4 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv21] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'2 s
    /\ inv'8 e1 /\ inv'8 e2 /\ inv'9 f /\ inv'10 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv20] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv17] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'3 iter /\ inv'4 func
    end)
  
  use seq.Seq
  
  goal refines : [%#smap_inv0] forall a : t_MapInv'0 . forall ab : Seq.seq t_B'0 . forall b : t_MapInv'0 . forall bc : Seq.seq t_B'0 . forall c : t_MapInv'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/once.rs" 43 4 43 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 43 4 43 90
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 24 12 25 106
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
    
   =
    [%#sonce1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . inv'1 e /\ view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'4 opt
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'3 inner
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Once'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Once'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Once__inner'0 = inner} -> inv'2 inner
    end
  
  use seq.Seq
  
  goal refines : [%#sonce0] forall a : t_Once'0 . forall ab : Seq.seq t_T'0 . forall b : t_Once'0 . forall bc : Seq.seq t_T'0 . forall c : t_Once'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/once.rs" 33 4 33 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 33 4 33 26
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 24 12 25 106
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'4 opt
    end
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'3 inner
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Once'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Once'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Once__inner'0 = inner} -> inv'2 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
    
   =
    [%#sonce1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . inv'1 e /\ view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#sonce0] forall self : t_Once'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Range__start'0 = start ; t_Range__end'0 = end'} -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
    
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  goal refines : [%#srange0] forall self : t_Range'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
    
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Range__start'0 = start ; t_Range__end'0 = end'} -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_Range'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_Range'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_Range'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 201 14 201 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 189 4 189 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 205 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : t_RangeInclusive'0) : int
    
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
    
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_RangeInclusive'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_RangeInclusive'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_RangeInclusive__start'0 = start ; t_RangeInclusive__end'0 = end' ; t_RangeInclusive__exhausted'0 = exhausted} -> inv'1 start
    /\ inv'1 end'
    end
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_RangeInclusive'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_RangeInclusive'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_RangeInclusive'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 201 14 201 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Idx'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_RangeInclusive'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_RangeInclusive'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_RangeInclusive__start'0 = start ; t_RangeInclusive__end'0 = end' ; t_RangeInclusive__exhausted'0 = exhausted} -> inv'1 start
    /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 189 4 189 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : t_Idx'0) : int
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 205 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : t_RangeInclusive'0) : int
    
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
    
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  goal refines : [%#srange0] forall self : t_RangeInclusive'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Idx'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/repeat.rs" 33 4 33 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 33 4 33 26
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Repeat'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Repeat'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Repeat__element'0 = element} -> inv'1 element
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
    
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  goal refines : [%#srepeat0] forall self : t_Repeat'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/repeat.rs" 43 4 43 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 43 4 43 90
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
    
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Repeat'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Repeat'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Repeat__element'0 = element} -> inv'1 element
    end
  
  use seq.Seq
  
  goal refines : [%#srepeat0] forall a : t_Repeat'0 . forall ab : Seq.seq t_T'0 . forall b : t_Repeat'0 . forall bc : Seq.seq t_T'0 . forall c : t_Repeat'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/skip.rs" 85 4 85 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 85 4 85 90
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'2 a)
   -> ([%#siter7] inv'2 b)
   -> ([%#siter8] inv'2 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter4] inv'2 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
    
   =
    [%#sskip1] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall a : t_Skip'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Skip'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Skip'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 75 4 75 26
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'2 a)
   -> ([%#siter7] inv'2 b)
   -> ([%#siter8] inv'2 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter4] inv'2 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
    
   =
    [%#sskip1] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 73 4 73 26
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'1 a)
   -> ([%#siter7] inv'1 b)
   -> ([%#siter8] inv'1 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter4] inv'1 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
    
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall self : t_Take'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/take.rs" 83 4 83 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 83 4 83 90
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] inv'1 a)
   -> ([%#siter7] inv'1 b)
   -> ([%#siter8] inv'1 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#siter4] inv'1 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
    
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall a : t_Take'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Take'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Take'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844__produces_trans__refines [#"../../../creusot-contracts/src/std/iter/zip.rs" 67 4 67 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 67 4 67 90
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_A'0
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed13] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'1) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'3 a
    /\ inv'4 b
    end
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter6] inv'3 a)
   -> ([%#siter7] inv'3 b)
   -> ([%#siter8] inv'3 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . ([%#siter4] inv'3 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'4 (iterb'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
    
  
  function produces_trans'2 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
    
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter6] inv'4 a)
   -> ([%#siter7] inv'4 b)
   -> ([%#siter8] inv'4 c)
   -> ([%#siter9] produces'2 a ab b)
   -> ([%#siter10] produces'2 b bc c)  -> ([%#siter11] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . ([%#siter4] inv'4 self)
   -> ([%#siter5] produces'2 self (Seq.empty  : Seq.seq t_Item'1) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
    
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  goal refines : [%#szip0] forall a : t_Zip'0 . forall ab : Seq.seq (t_Item'0, t_Item'1) . forall b : t_Zip'0 . forall bc : Seq.seq (t_Item'0, t_Item'1) . forall c : t_Zip'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844__produces_refl__refines [#"../../../creusot-contracts/src/std/iter/zip.rs" 57 4 57 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 57 4 57 26
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sboxed13 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_A'0
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'3 a
    /\ inv'4 b
    end
  
  use seq.Seq
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed13] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed13] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'1) =
    [%#sseq12] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter6] inv'3 a)
   -> ([%#siter7] inv'3 b)
   -> ([%#siter8] inv'3 c)
   -> ([%#siter9] produces'1 a ab b)
   -> ([%#siter10] produces'1 b bc c)  -> ([%#siter11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . ([%#siter4] inv'3 self)
   -> ([%#siter5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'4 (iterb'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter6] inv'4 a)
   -> ([%#siter7] inv'4 b)
   -> ([%#siter8] inv'4 c)
   -> ([%#siter9] produces'2 a ab b)
   -> ([%#siter10] produces'2 b bc c)  -> ([%#siter11] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . ([%#siter4] inv'4 self)
   -> ([%#siter5] produces'2 self (Seq.empty  : Seq.seq t_Item'1) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
    
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  goal refines : [%#szip0] forall self : t_Zip'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self
   -> produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self)
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_refl__refines [#"../../../creusot-contracts/src/std/option.rs" 477 4 477 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 477 4 477 26
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IntoIter'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_trans__refines [#"../../../creusot-contracts/src/std/option.rs" 484 4 484 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 484 4 484 90
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IntoIter__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_refl__refines [#"../../../creusot-contracts/src/std/option.rs" 530 4 530 26] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 530 4 530 26
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 522 12 523 96
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant2] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Iter__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_Iter'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_trans__refines [#"../../../creusot-contracts/src/std/option.rs" 537 4 537 90] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 537 4 537 90
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 522 12 523 96
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant2] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Iter__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_trans__refines [#"../../../creusot-contracts/src/std/option.rs" 593 4 593 90] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 593 4 593 90
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 578 12 579 96
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (o : t_IterMut'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq (borrowed t_T'0)) /\ self = o
    \/ (exists e : borrowed t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant2] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_T'0 [inv'3 x] . inv'3 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IterMut__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_IterMut'0 . forall ab : Seq.seq (borrowed t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (borrowed t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_refl__refines [#"../../../creusot-contracts/src/std/option.rs" 586 4 586 26] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 586 4 586 26
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 578 12 579 96
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant2] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_T'0 [inv'3 x] . inv'3 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Item__opt'0 = opt} -> inv'2 opt
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IterMut__inner'0 = inner} -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (o : t_IterMut'0)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq (borrowed t_T'0)) /\ self = o
    \/ (exists e : borrowed t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IterMut'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self
   -> produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi8256668011736225471__produces_trans__refines [#"../../../creusot-contracts/src/std/slice.rs" 437 4 437 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 437 4 437 90
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 423 12 423 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops5 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 407 4 407 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 421 4 421 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sslice0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi8256668011736225471__produces_refl__refines [#"../../../creusot-contracts/src/std/slice.rs" 430 4 430 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 430 4 430 26
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 423 12 423 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 114 14 114 41
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 115 14 115 80
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sops5 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.Slice64
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 407 4 407 33] (self : t_Iter'0) : slice t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 116 4 116 35] (self : slice t_T'0) : Seq.seq t_T'0
    
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 421 4 421 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
    
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall self : t_Iter'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_refl__refines [#"../../../creusot-contracts/src/std/slice.rs" 485 4 485 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 485 4 485 26
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 477 12 477 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 445 14 445 50
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 105 14 105 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 106 14 106 84
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  use prelude.prelude.Slice64
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : slice t_T'0 . ([%#sslice5] Seq.length (view'1 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice6] view'1 self = Slice64.id self)
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 33] (self : t_IterMut'0) : borrowed (slice t_T'0)
    
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (slice t_T'0)) : Seq.seq t_T'0
    
   =
    [%#smodel7] view'1 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops8] Seq.get (view'1 self) ix
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 108 4 108 43] (self : borrowed (slice t_T'0)) : Seq.seq (borrowed t_T'0)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t_T'0) . ([%#sslice3] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 475 4 475 65] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (tl : t_IterMut'0)
    
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self
   -> produces'0 self (Seq.empty  : Seq.seq (borrowed t_T'0)) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_trans__refines [#"../../../creusot-contracts/src/std/slice.rs" 495 4 495 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 495 4 495 90
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 477 12 477 66
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 445 14 445 50
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 105 14 105 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 106 14 106 84
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Slice64
  
  use prelude.prelude.Slice64
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 30 4 30 33] (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : slice t_T'0 . ([%#sslice5] Seq.length (view'1 self)
  <= UInt64.to_uint (v_MAX'0 : UInt64.t))
  && ([%#sslice6] view'1 self = Slice64.id self)
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 33] (self : t_IterMut'0) : borrowed (slice t_T'0)
    
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (slice t_T'0)) : Seq.seq t_T'0
    
   =
    [%#smodel7] view'1 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t_T'0) (ix : int) : t_T'0
    
   =
    [%#sops8] Seq.get (view'1 self) ix
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 108 4 108 43] (self : borrowed (slice t_T'0)) : Seq.seq (borrowed t_T'0)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t_T'0) . ([%#sslice3] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 475 4 475 65] (self : t_IterMut'0) (visited : Seq.seq (borrowed t_T'0)) (tl : t_IterMut'0)
    
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sslice0] forall a : t_IterMut'0 . forall ab : Seq.seq (borrowed t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (borrowed t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396__produces_trans__refines [#"../../../creusot-contracts/src/std/vec.rs" 278 4 278 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 278 4 278 72
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 234 4 234 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 262 4 262 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
    
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_ManuallyDrop'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_ManuallyDrop'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_ManuallyDrop__value'0 = value} -> inv'2 value
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IntoIter__buf'0 = buf ; t_IntoIter__phantom'0 = phantom ; t_IntoIter__cap'0 = cap ; t_IntoIter__alloc'0 = alloc ; t_IntoIter__ptr'0 = ptr ; t_IntoIter__end'0 = end'} -> inv'1 alloc
    end
  
  goal refines : [%#svec0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396__produces_refl__refines [#"../../../creusot-contracts/src/std/vec.rs" 271 4 271 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 271 4 271 26
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_A'0)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_ManuallyDrop'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_ManuallyDrop'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_ManuallyDrop__value'0 = value} -> inv'2 value
    end
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_IntoIter__buf'0 = buf ; t_IntoIter__phantom'0 = phantom ; t_IntoIter__cap'0 = cap ; t_IntoIter__alloc'0 = alloc ; t_IntoIter__ptr'0 = ptr ; t_IntoIter__end'0 = end'} -> inv'1 alloc
    end
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 234 4 234 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 262 4 262 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
    
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_T'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi7691061398646472980__is_fused__refines [#"../../../creusot-contracts/src/std/iter/fuse.rs" 76 4 76 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 76 4 76 62
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 41 15 41 24
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 42 14 42 45
  let%span sfuse5 = "../../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse6 = "../../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 21
  let%span sfuse7 = "../../../creusot-contracts/src/std/iter/fuse.rs" 48 15 48 21
  let%span sfuse8 = "../../../creusot-contracts/src/std/iter/fuse.rs" 49 15 49 21
  let%span sfuse9 = "../../../creusot-contracts/src/std/iter/fuse.rs" 50 15 50 32
  let%span sfuse10 = "../../../creusot-contracts/src/std/iter/fuse.rs" 51 15 51 32
  let%span sfuse11 = "../../../creusot-contracts/src/std/iter/fuse.rs" 52 14 52 42
  let%span sfuse12 = "../../../creusot-contracts/src/std/iter/fuse.rs" 45 4 45 10
  let%span sfuse13 = "../../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse14 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq24 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span sinvariant25 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed26 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Fuse'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'4 iter
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse13] inv'1 self  -> inv'4 (view'0 self))
  && ([%#sfuse14] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter18] inv'5 a)
   -> ([%#siter19] inv'5 b)
   -> ([%#siter20] inv'5 c)
   -> ([%#siter21] produces'1 a ab b)
   -> ([%#siter22] produces'1 b bc c)  -> ([%#siter23] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter16] inv'5 self)
   -> ([%#siter17] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
    
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 53 4 53 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
    
   =
    [%#sfuse12] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse6] inv'1 a)
   -> ([%#sfuse7] inv'1 b)
   -> ([%#sfuse8] inv'1 c)
   -> ([%#sfuse9] produces'0 a ab b)
   -> ([%#sfuse10] produces'0 b bc c)  -> ([%#sfuse11] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 43 4 43 26] (self : t_Fuse'0) : () =
    [%#sfuse5] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . ([%#sfuse3] inv'1 self)
   -> ([%#sfuse4] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 105 4 105 33] (self : borrowed (t_Fuse'0)) : t_Option'0 =
    [%#smodel15] view'0 self.current
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant25] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_I'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : borrowed (t_Fuse'0)) =
    [%#sfuse2] (view'1 self = C_None'0
    \/ (exists it : borrowed t_I'0 . inv'3 it /\ completed'1 it /\ view'1 self = C_Some'0 (it.current)))
    /\ view'0 self.final = C_None'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed26] inv'7 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq24] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_Fuse'0)) =
    [%#sinvariant25] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_Fuse'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Fuse'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  goal refines : [%#sfuse0] forall self : borrowed (t_Fuse'0) . forall steps : Seq.seq t_Item'0 . forall next : t_Fuse'0 . produces'0 self.final steps next
  /\ completed'0 self /\ inv'0 steps /\ inv'1 next /\ inv'2 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ inv'0 steps
  /\ inv'1 next
  /\ inv'2 self
  /\ (forall result : () . steps = (Seq.empty  : Seq.seq t_Item'0) /\ self.final = next
   -> steps = (Seq.empty  : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4413682431414748756__next__refines [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 96 4 96 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 96 4 96 44
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 191 14 191 68
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 194 12 199 74
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 15 23 24
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 21
  let%span smap_inv9 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 30 15 30 21
  let%span smap_inv10 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 31 15 31 21
  let%span smap_inv11 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 32 15 32 32
  let%span smap_inv12 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 32
  let%span smap_inv13 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 34 14 34 42
  let%span smap_inv14 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 10
  let%span sinvariant15 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops24 = "../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops25 = "../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops26 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops27 = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops28 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops29 = "../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops30 = "../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span sseq31 = "../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span smap_inv32 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 80 12 82 73
  let%span smap_inv33 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv34 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 130 14 130 81
  let%span smap_inv35 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 133 12 138 88
  let%span smap_inv36 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span smap_inv37 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span sboxed38 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq t_Item'0) }
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_I'0)
  
  predicate invariant'7 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_I'0) =
    [%#sinvariant15] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'12 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_I'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed t_I'0 [inv'12 x] . inv'12 x = invariant'7 x
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_F'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
    
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter18] inv'8 a)
   -> ([%#siter19] inv'8 b)
   -> ([%#siter20] inv'8 c)
   -> ([%#siter21] produces'1 a ab b)
   -> ([%#siter22] produces'1 b bc c)  -> ([%#siter23] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#siter16] inv'8 self)
   -> ([%#siter17] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed t_I'0)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 73 4 73 45] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 121 4 121 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv36] forall e : t_Item'0, i : t_I'0 . inv'3 e /\ inv'8 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  type t_B'0
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed38] inv'3 self
  
  predicate inv'11 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Item'0 [inv'11 x] . inv'11 x = invariant'6 x
  
  predicate invariant'3 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq t_Item'0) =
    [%#sseq31] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'11 (Seq.get self i)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_F'0) =
    [%#sinvariant15] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed t_F'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result : t_B'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (result_state : t_F'0) (result : t_B'0)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : t_B'0) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : t_B'0 . [%#sops30] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
    
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops27] unnest'0 self b)
   -> ([%#sops28] unnest'0 b c)  -> ([%#sops29] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops26] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (self : t_F'0) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res_state : t_F'0) (res : t_B'0) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res_state : t_F'0, res : t_B'0 . ([%#sops24] postcondition_mut'0 self args res_state res)
   -> ([%#sops25] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 144 4 144 49] (iter : t_I'0) (func : t_F'0)
    
   =
    [%#smap_inv37] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'5 s
    /\ inv'3 e1 /\ inv'3 e2 /\ inv'2 f /\ inv'7 b /\ inv'8 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 157 4 157 33] (_1 : ()) =
    [%#smap_inv33] forall iter : borrowed t_I'0, func : t_F'0 . inv'12 iter /\ inv'9 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use prelude.prelude.Snapshot
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 131 4 131 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv35] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed t_F'0, b : t_B'0, i : t_I'0 . inv'5 s
    /\ inv'3 e1 /\ inv'3 e2 /\ inv'2 f /\ inv'7 b /\ inv'8 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f.current (e1, Snapshot.new (Seq.(++) produced s)) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv34] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'4 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 78 4 78 30] (self : t_MapInv'0) =
    [%#smap_inv32] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 (Snapshot.inner self.t_MapInv__produced'0)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_MapInv'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'8 iter /\ inv'9 func
    end)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_MapInv'0)) =
    [%#sinvariant15] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_MapInv'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_MapInv'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t_F'0) =
    [%#sboxed38] inv'2 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_F'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed t_F'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 450 4 450 30] (self : Seq.seq (borrowed t_F'0))
   =
    [%#sseq31] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed t_F'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq (borrowed t_F'0) [inv'4 x] . inv'4 x = invariant'2 x
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 40 4 40 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv4] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed t_F'0) . inv'4 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'5 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 35 4 35 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
    
   =
    [%#smap_inv14] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv8] inv'6 a)
   -> ([%#smap_inv9] inv'6 b)
   -> ([%#smap_inv10] inv'6 c)
   -> ([%#smap_inv11] produces'0 a ab b)
   -> ([%#smap_inv12] produces'0 b bc c)  -> ([%#smap_inv13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 25 4 25 26] (self : t_MapInv'0) : () =
    [%#smap_inv7] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . ([%#smap_inv5] inv'6 self)
   -> ([%#smap_inv6] produces'0 self (Seq.empty  : Seq.seq t_B'0) self)
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : borrowed (t_MapInv'0))
    
   =
    [%#smap_inv1] Snapshot.inner (self.final).t_MapInv__produced'0 = (Seq.empty  : Seq.seq t_Item'0)
    /\ completed'1 (Borrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  use seq.Seq
  
  predicate produces_one'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 192 4 192 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
    
   =
    [%#smap_inv3] exists f : borrowed t_F'0, e : t_Item'0 . inv'2 f
    /\ inv'3 e
    /\ f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.snoc (Snapshot.inner self.t_MapInv__produced'0) e
    /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
    /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv2] produces_one'0 self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  goal refines : [%#smap_inv0] forall self : borrowed (t_MapInv'0) . inv'0 self
   -> inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces_one'0 self.current v self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_creusot_contracts__stdqy35z1__ops__qyi14194840286170235833__unnest_trans__refines [#"../../../creusot-contracts/src/std/ops.rs" 119 4 119 43] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 119 4 119 43
  
  type t_F'0
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall b : t_F'0 . forall c : t_F'0 . unnest'0 b c /\ unnest'0 self b
   -> unnest'0 b c /\ unnest'0 self b /\ (forall result : () . unnest'0 self c  -> unnest'0 self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi14194840286170235833__unnest_refl__refines [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 112 4 112 24
  
  type t_F'0
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall result : () . unnest'0 self self  -> unnest'0 self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi14194840286170235833__fn_mut_once__refines [#"../../../creusot-contracts/src/std/ops.rs" 125 4 125 55] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 125 4 125 55
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
    
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
   -> postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi14194840286170235833__postcondition_mut_unnest__refines [#"../../../creusot-contracts/src/std/ops.rs" 107 4 107 85] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 107 4 107 85
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
    
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 99 4 99 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . postcondition_mut'0 self args res_state res
   -> postcondition_mut'0 self args res_state res
  /\ (forall result : () . unnest'0 self res_state  -> unnest'0 self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi10441027020636586103__fn_mut__refines [#"../../../creusot-contracts/src/std/ops.rs" 140 4 140 67] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 140 4 140 67
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 91 4 91 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
    
  
  predicate postcondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 133 4 133 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
    
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . forall result : () . postcondition_mut'0 self args res_state res
  = (self = res_state /\ postcondition'0 self args res)
   -> postcondition_mut'0 self args res_state res = (self = res_state /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ops__qyi10441027020636586103__fn_once__refines [#"../../../creusot-contracts/src/std/ops.rs" 145 4 145 51] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 145 4 145 51
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 81 4 81 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 133 4 133 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
    
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (resolve'0 self /\ postcondition'0 self args res)
   -> postcondition_once'0 self args res = (resolve'0 self /\ postcondition'0 self args res)
end
module M_creusot_contracts__ghost__qyi1862168959261460300__deref__refines [#"../../../creusot-contracts/src/ghost.rs" 52 4 52 36] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 52 4 52 36
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostBox'0) =
    [%#sinvariant1] inv'2 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_T'0) =
    [%#sinvariant1] inv'3 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_T'0 . self.t_GhostBox__0'0 = result /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi12069901807935209935__deref__refines [#"../../../creusot-contracts/src/ghost_ptr.rs" 175 4 175 36] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::ops::Deref> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 175 4 175 36
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 165 14 165 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sinvariant7 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrTokenRef'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrTokenRef'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrTokenRef'0 [inv'0 x] . inv'0 x = true
  
  type t_GhostPtrToken'0
  
  type t_FMap'0
  
  use prelude.prelude.Opaque
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr4] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr5] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'4 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'4_spec : forall self : t_FMap'0 . [%#sfmap8] mk'0 (view'4 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap6] Map.get (view'4 self) k
  
  function view'2 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'2_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr2] get_unsized'0 (view'2 self) (null_logic'0 ())
  = C_None'0
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrToken'0) : t_FMap'0 =
    [%#smodel1] view'2 self
  
  function view'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 166 4 166 33] (self : t_GhostPtrTokenRef'0) : t_FMap'0
  
  axiom view'3_spec : forall self : t_GhostPtrTokenRef'0 . [%#sghost_ptr3] get_unsized'0 (view'3 self) (null_logic'0 ())
  = C_None'0
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrTokenRef'0) : t_FMap'0 =
    [%#smodel1] view'3 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr9] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'2 self) ptr = C_Some'0 x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostPtrToken'0) =
    [%#sinvariant7] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  goal refines : [%#sghost_ptr0] forall self : t_GhostPtrTokenRef'0 . inv'0 self
   -> (forall result : t_GhostPtrToken'0 . view'0 result = view'1 self /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi2050065802908022022__deref__refines [#"../../../creusot-contracts/src/ghost_ptr.rs" 269 4 269 36] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as std::ops::Deref> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 269 4 269 36
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 209 14 209 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sinvariant8 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrTokenMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrTokenMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostPtrTokenMut'0 [inv'0 x] . inv'0 x = true
  
  type t_GhostPtrToken'0
  
  type t_FMap'0
  
  use prelude.prelude.Opaque
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr4] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr5] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'2_spec : forall self : t_FMap'0 . [%#sfmap7] mk'0 (view'2 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap6] Map.get (view'2 self) k
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'1_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr3] get_unsized'0 (view'1 self) (null_logic'0 ())
  = C_None'0
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 87 4 87 33] (self : t_GhostPtrToken'0) : t_FMap'0 =
    [%#smodel1] view'1 self
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 210 4 210 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom cur'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr2] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr9] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'1 self) ptr = C_Some'0 x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t_GhostPtrToken'0) =
    [%#sinvariant8] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  goal refines : [%#sghost_ptr0] forall self : t_GhostPtrTokenMut'0 . inv'0 self
   -> (forall result : t_GhostPtrToken'0 . view'0 result = cur'0 self /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost__qyi17214052996668775070__deref_mut__refines [#"../../../creusot-contracts/src/ghost.rs" 68 4 68 48] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 68 4 68 48
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_GhostBox'0)) =
    [%#sinvariant1] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostBox'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_GhostBox'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t_T'0) =
    [%#sinvariant1] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : borrowed (t_GhostBox'0) . inv'0 self
   -> inv'0 self
  /\ (forall result : borrowed t_T'0 . result
  = Borrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (Borrow.inherit_id (Borrow.get_id self) 1)
  /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi11706120906342127713__deref_mut__refines [#"../../../creusot-contracts/src/ghost_ptr.rs" 279 4 279 48] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as std::ops::DerefMut> *)
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 279 4 279 48
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 14 216 64
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 209 14 209 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 147 14 147 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 148 14 148 96
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sinvariant8 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 46 20 46 96
  
  use prelude.prelude.Borrow
  
  type t_GhostPtrTokenMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostPtrTokenMut'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_GhostPtrTokenMut'0) [inv'0 x] . inv'0 x = true
  
  type t_GhostPtrToken'0
  
  use prelude.prelude.Opaque
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 155 4 155 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 149 4 149 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr4] addr_logic'0 (null_logic'0 _1) = 0)
  && ([%#sghost_ptr5] forall ptr : opaque_ptr . addr_logic'0 ptr = addr_logic'0 (null_logic'0 _1)
   -> ptr = null_logic'0 _1)
  
  type t_FMap'0
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 51 4 51 37] (_m : Map.map opaque_ptr (t_Option'0)) : t_FMap'0
    
  
  function view'1 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 35] (self : t_FMap'0) : Map.map opaque_ptr (t_Option'0)
    
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] mk'0 (view'1 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 95 4 95 55] (self : t_FMap'0) (k : opaque_ptr) : t_Option'0
    
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 217 4 217 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom fin'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr1] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = C_None'0
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 210 4 210 44] (self : t_GhostPtrTokenMut'0) : t_FMap'0
  
  axiom cur'0_spec : forall self : t_GhostPtrTokenMut'0 . [%#sghost_ptr2] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = C_None'0
  
  function view'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 35 4 35 33] (self : t_GhostPtrToken'0) : t_FMap'0
  
  axiom view'0_spec : forall self : t_GhostPtrToken'0 . [%#sghost_ptr3] get_unsized'0 (view'0 self) (null_logic'0 ())
  = C_None'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 45 4 45 30] (self : t_GhostPtrToken'0) =
    [%#sghost_ptr9] forall ptr : opaque_ptr, x : t_T'0 . get_unsized'0 (view'0 self) ptr = C_Some'0 x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_GhostPtrToken'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostPtrToken'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (t_GhostPtrToken'0))
    
   =
    [%#sinvariant8] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (t_GhostPtrToken'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_GhostPtrToken'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  goal refines : [%#sghost_ptr0] forall self : borrowed (t_GhostPtrTokenMut'0) . inv'0 self
   -> (forall result : borrowed (t_GhostPtrToken'0) . fin'0 self.final = fin'0 self.current
  /\ cur'0 self.final = view'0 result.final /\ view'0 result.current = cur'0 self.current /\ inv'1 result
   -> inv'1 result)
end
