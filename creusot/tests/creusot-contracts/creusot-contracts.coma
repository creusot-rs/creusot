module T_creusot_contracts__logic__fmap__FMap [#"../../../creusot-contracts/src/logic/fmap.rs" 25 0 25 29]
  type t_FMap 'k 'v
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_creusot_contracts__logic__fmap__qyi9892930999379617882__ext_eq [#"../../../creusot-contracts/src/logic/fmap.rs" 190 4 190 44] (* logic::fmap::FMap<K, V> *)
  type k
  
  type v
  
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 188 14 188 38
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 189 14 189 83
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 49 8 49 14
  let%span sfmap5 = "../../../creusot-contracts/src/logic/fmap.rs" 41 8 41 14
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map k (Option'0.t_Option v)) : FMap'0.t_FMap k v
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap k v) : Map.map k (Option'0.t_Option v)
    
  
  axiom view'0_spec : forall self : FMap'0.t_FMap k v . [%#sfmap2] mk'0 (view'0 self) = self
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap k v) (k : k) : Option'0.t_Option v
    
   =
    [%#sfmap3] Map.get (view'0 self) k
  
  constant self  : FMap'0.t_FMap k v
  
  constant other  : FMap'0.t_FMap k v
  
  function ext_eq [#"../../../creusot-contracts/src/logic/fmap.rs" 190 4 190 44] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : bool
    
  
  goal vc_ext_eq : ([%#sfmap2] mk'0 (view'0 self) = self)
   -> ([%#sfmap2] mk'0 (view'0 other) = other)
   -> (let result = view'0 self = view'0 other in ([%#sfmap1] (forall k : k . get_unsized'0 self k
  = get_unsized'0 other k)  -> result)
  && ([%#sfmap0] result  -> self = other))
end
module M_creusot_contracts__logic__fmap__qyi9892930999379617882__subtract [#"../../../creusot-contracts/src/logic/fmap.rs" 182 4 182 46] (* logic::fmap::FMap<K, V> *)
  type k
  
  type v
  
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 174 15 174 33
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 175 14 175 36
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 176 14 176 46
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 177 14 181 5
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 163 14 167 5
  let%span sfmap5 = "../../../creusot-contracts/src/logic/fmap.rs" 140 12 140 89
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 133 19 133 71
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 147 15 147 35
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 148 14 154 5
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 155 14 155 54
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 157 8 157 14
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 188 14 188 38
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 189 14 189 83
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 191 8 191 35
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 112 8 112 35
  let%span sfmap16 = "../../../creusot-contracts/src/logic/fmap.rs" 169 8 169 14
  let%span sfmap17 = "../../../creusot-contracts/src/logic/fmap.rs" 32 14 32 25
  let%span sfmap18 = "../../../creusot-contracts/src/logic/fmap.rs" 34 8 34 14
  let%span sfmap19 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sfmap20 = "../../../creusot-contracts/src/logic/fmap.rs" 49 8 49 14
  let%span sfmap21 = "../../../creusot-contracts/src/logic/fmap.rs" 41 8 41 14
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map k (Option'0.t_Option v)) : FMap'0.t_FMap k v
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap k v) : Map.map k (Option'0.t_Option v)
    
  
  axiom view'0_spec : forall self : FMap'0.t_FMap k v . [%#sfmap19] mk'0 (view'0 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap k v) (k : k) : Option'0.t_Option v
    
   =
    [%#sfmap14] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 111 4 111 39] (self : FMap'0.t_FMap k v) (k : k) : bool
    
   =
    [%#sfmap15] get_unsized'0 self k <> Option'0.C_None
  
  function subtract_keys'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 168 4 168 51] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : FMap'0.t_FMap k v
    
  
  axiom subtract_keys'0_spec : forall self : FMap'0.t_FMap k v, other : FMap'0.t_FMap k v . [%#sfmap4] forall k : k . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then Option'0.C_None else get_unsized'0 self k)
  
  function ext_eq'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 190 4 190 44] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : bool
    
   =
    [%#sfmap13] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : FMap'0.t_FMap k v, other : FMap'0.t_FMap k v . ([%#sfmap12] (forall k : k . get_unsized'0 self k
  = get_unsized'0 other k)  -> ext_eq'0 self other)
  && ([%#sfmap11] ext_eq'0 self other  -> self = other)
  
  use prelude.prelude.Int
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 33 4 33 27] (self : FMap'0.t_FMap k v) : int
  
  axiom len'0_spec : forall self : FMap'0.t_FMap k v . [%#sfmap17] len'0 self >= 0
  
  function disjoint'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 132 4 132 46] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : bool
    
   =
    [%#sfmap6] forall k : k . not contains'0 self k \/ not contains'0 other k
  
  function union'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 156 4 156 43] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : FMap'0.t_FMap k v
    
  
  axiom union'0_spec : forall self : FMap'0.t_FMap k v, other : FMap'0.t_FMap k v . ([%#sfmap7] disjoint'0 self other)
   -> ([%#sfmap9] len'0 (union'0 self other) = len'0 self + len'0 other)
  && ([%#sfmap8] forall k : k . get_unsized'0 (union'0 self other) k
  = (if contains'0 self k then
    get_unsized'0 self k
  else
    if contains'0 other k then get_unsized'0 other k else Option'0.C_None
  ))
  
  function subset'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 138 4 138 44] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : bool
    
   =
    [%#sfmap5] forall k : k . contains'0 self k  -> get_unsized'0 other k = get_unsized'0 self k
  
  constant self  : FMap'0.t_FMap k v
  
  constant other  : FMap'0.t_FMap k v
  
  function subtract [#"../../../creusot-contracts/src/logic/fmap.rs" 182 4 182 46] (self : FMap'0.t_FMap k v) (other : FMap'0.t_FMap k v) : FMap'0.t_FMap k v
    
  
  goal vc_subtract : ([%#sfmap0] subset'0 other self)
   -> ([%#sfmap4] forall k : k . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then Option'0.C_None else get_unsized'0 self k))
   -> (let result = subtract_keys'0 self other in ([%#sfmap3] forall k : k . get_unsized'0 result k
  = (if contains'0 other k then Option'0.C_None else get_unsized'0 self k))
  && ([%#sfmap2] ext_eq'0 (union'0 other result) self) && ([%#sfmap1] disjoint'0 result other))
end
module T_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1 [#"../../../creusot-contracts/src/logic/fmap.rs" 203 8 203 23] (* logic::fmap::FMap<K, V> *)
  type m_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1 'k 'v =
    | M_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1
  
  let rec m_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1 < 'k > < 'v > (input:m_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1 'k 'v) (ret  )= any
    [ good -> {M_creusot_contracts__logic__fmap__qyi9892930999379617882__new__qyClosure1  = input} (! ret) ]
    
end
module M_creusot_contracts__util__unwrap [#"../../../creusot-contracts/src/util.rs" 36 0 36 36]
  type t
  
  let%span sutil0 = "../../../creusot-contracts/src/util.rs" 34 11 34 21
  let%span sutil1 = "../../../creusot-contracts/src/util.rs" 35 10 35 28
  let%span sutil2 = "../../../creusot-contracts/src/util.rs" 25 11 25 16
  let%span sutil3 = "../../../creusot-contracts/src/util.rs" 26 10 26 15
  let%span sutil4 = "../../../creusot-contracts/src/util.rs" 27 10 27 11
  let%span sutil5 = "../../../creusot-contracts/src/util.rs" 29 4 29 17
  
  function unreachable'0 [#"../../../creusot-contracts/src/util.rs" 28 0 28 28] (_1 : ()) : t
  
  axiom unreachable'0_def : forall _1 : () . unreachable'0 _1 = ([%#sutil5] unreachable'0 ())
  
  axiom unreachable'0_spec : forall _1 : () . ([%#sutil2] false)  -> ([%#sutil3] false)
  
  use T_core__option__Option as Option'0
  
  constant op  : Option'0.t_Option t
  
  function unwrap [#"../../../creusot-contracts/src/util.rs" 36 0 36 36] (op : Option'0.t_Option t) : t
  
  goal vc_unwrap : ([%#sutil0] op <> Option'0.C_None)
   -> match op with
    | Option'0.C_Some t -> [%#sutil1] Option'0.C_Some t = op
    | Option'0.C_None -> ([%#sutil2] false)
    /\ (([%#sutil3] false)  -> ([%#sutil1] Option'0.C_Some (unreachable'0 ()) = op))
    end
end
module M_creusot_contracts__logic__fmap__qyi9892930999379617882__contains_ghost [#"../../../creusot-contracts/src/logic/fmap.rs" 248 4 248 49] (* logic::fmap::FMap<K, V> *)
  type k
  
  type v
  
  let%span sfmap0 = "../../../creusot-contracts/src/logic/fmap.rs" 248 33 248 36
  let%span sfmap1 = "../../../creusot-contracts/src/logic/fmap.rs" 247 14 247 43
  let%span sfmap2 = "../../../creusot-contracts/src/logic/fmap.rs" 277 28 277 31
  let%span sfmap3 = "../../../creusot-contracts/src/logic/fmap.rs" 269 4 276 11
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 277 40 277 50
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 36 26 36 51
  let%span sfmap6 = "../../../creusot-contracts/src/logic/fmap.rs" 112 8 112 35
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 95 8 95 35
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sutil9 = "../../../creusot-contracts/src/util.rs" 34 11 34 21
  let%span sutil10 = "../../../creusot-contracts/src/util.rs" 35 10 35 28
  let%span sinvariant11 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 49 8 49 14
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 41 8 41 14
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : v)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : v) =
    [%#sinvariant11] inv'5 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : v)
  
  axiom inv_axiom'3 [@rewrite] : forall x : v [inv'3 x] . inv'3 x = invariant'2 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option v)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Option'0.t_Option v) =
    [%#sinvariant11] inv'1 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option v)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option v [inv'2 x] . inv'2 x = invariant'1 x
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option v [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : k)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : k) =
    [%#sinvariant11] inv'4 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : k)
  
  axiom inv_axiom'0 [@rewrite] : forall x : k [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map k (Option'0.t_Option v)) : FMap'0.t_FMap k v
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap k v) : Map.map k (Option'0.t_Option v)
    
  
  axiom view'0_spec : forall self : FMap'0.t_FMap k v . [%#sfmap12] mk'0 (view'0 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap k v) (k : k) : Option'0.t_Option v
    
   =
    [%#sfmap8] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 111 4 111 39] (self : FMap'0.t_FMap k v) (k : k) : bool
    
   =
    [%#sfmap6] get_unsized'0 self k <> Option'0.C_None
  
  use prelude.prelude.Intrinsic
  
  let rec is_some'0 (self:Option'0.t_Option v) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any [ return' (result:bool)-> {[%#soption5] result = (self <> Option'0.C_None)} (! return' {result}) ] 
  
  function unwrap'0 [#"../../../creusot-contracts/src/util.rs" 36 0 36 36] (op : Option'0.t_Option v) : v
  
  axiom unwrap'0_spec : forall op : Option'0.t_Option v . ([%#sutil9] op <> Option'0.C_None)
   -> ([%#sutil10] Option'0.C_Some (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 94 4 94 50] (self : FMap'0.t_FMap k v) (k : k) : v
    
   =
    [%#sfmap7] unwrap'0 (get_unsized'0 self k)
  
  let rec get_ghost'0 (self:FMap'0.t_FMap k v) (key:k) (return'  (ret:Option'0.t_Option v))= {[@expl:precondition] [%#sfmap2] inv'0 key}
    any
    [ return' (result:Option'0.t_Option v)-> {[%#sfmap4] inv'1 result}
      {[%#sfmap3] if contains'0 self key then
        match result with
          | Option'0.C_None -> false
          | Option'0.C_Some r -> lookup_unsized'0 self key = r
          end
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost (self:FMap'0.t_FMap k v) (key:k) (return'  (ret:bool))= {[%#sfmap0] inv'0 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost'0 {self} {key} (fun (_ret':Option'0.t_Option v) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some'0 {_5} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : bool = any_l ()
    | & self : FMap'0.t_FMap k v = self
    | & key : k = key
    | & _5 : Option'0.t_Option v = any_l () ]
     [ return' (result:bool)-> {[@expl:postcondition] [%#sfmap1] result = contains'0 self key} (! return' {result}) ] 
end
module T_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1 [#"../../../creusot-contracts/src/logic/fset.rs" 152 8 152 23] (* logic::fset::FSet<T> *)
  type m_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1 't =
    | M_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1
  
  let rec m_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1 < 't > (input:m_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1 't) (ret  )= any
    [ good -> {M_creusot_contracts__logic__fset__qyi12147533290214288165__new__qyClosure1  = input} (! ret) ]
    
end
module T_core__ptr__non_null__NonNull
  use prelude.prelude.Opaque
  
  type t_NonNull 't =
    | C_NonNull opaque_ptr
  
  let rec t_NonNull < 't > (input:t_NonNull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer}) ]
    
end
module T_core__marker__PhantomData
  type t_PhantomData 't =
    | C_PhantomData
  
  let rec t_PhantomData < 't > (input:t_PhantomData 't) (ret  )= any [ good -> {C_PhantomData  = input} (! ret) ] 
end
module T_core__ptr__unique__Unique
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Unique 't =
    | C_Unique (NonNull'0.t_NonNull 't) (PhantomData'0.t_PhantomData 't)
  
  let rec t_Unique < 't > (input:t_Unique 't) (ret  (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't))= any
    [ good (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker}) ]
    
end
module T_alloc__raw_vec__Cap
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Cap  =
    | C_Cap usize
  
  let rec t_Cap (input:t_Cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0}) ]
    
end
module T_alloc__raw_vec__RawVec
  use T_alloc__raw_vec__Cap as Cap'0
  
  use T_core__ptr__unique__Unique as Unique'0
  
  type t_RawVec 't 'a =
    | C_RawVec (Unique'0.t_Unique 't) (Cap'0.t_Cap) 'a
  
  let rec t_RawVec < 't > < 'a > (input:t_RawVec 't 'a) (ret  (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc}) ]
    
end
module T_alloc__vec__Vec
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  type t_Vec 't 'a =
    | C_Vec (RawVec'0.t_RawVec 't 'a) usize
  
  let rec t_Vec < 't > < 'a > (input:t_Vec 't 'a) (ret  (buf:RawVec'0.t_RawVec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_RawVec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len}) ]
    
end
module T_core__cmp__Ordering
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  let rec v_Less (input:t_Ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} (! {false} any) ]
    
  
  let rec v_Equal (input:t_Ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} (! {false} any) ]
    
  
  let rec v_Greater (input:t_Ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} (! {false} any) ]
    
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int) (y : int) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int) (y : int) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int) (y : int) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int) (y : int) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int) (y : int) (z : int) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int) (y : int) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int) (y : int) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int) (y : int) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : uint8) (y : uint8) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : uint8) (y : uint8) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : uint8) (y : uint8) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : uint8) (y : uint8) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : uint8) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  constant z  : uint8
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : uint8) (y : uint8) (z : uint8) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : uint8) (y : uint8) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : uint8) (y : uint8) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint8
  
  constant y  : uint8
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : uint8) (y : uint8) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : uint16) (y : uint16) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : uint16) (y : uint16) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : uint16) (y : uint16) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : uint16) (y : uint16) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : uint16) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  constant z  : uint16
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : uint16) (y : uint16) (z : uint16) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : uint16) (y : uint16) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : uint16) (y : uint16) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint16
  
  constant y  : uint16
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : uint16) (y : uint16) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : uint32) (y : uint32) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : uint32) (y : uint32) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : uint32) (y : uint32) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : uint32) (y : uint32) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : uint32) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  constant z  : uint32
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : uint32) (y : uint32) (z : uint32) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : uint32) (y : uint32) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : uint32) (y : uint32) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint32
  
  constant y  : uint32
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : uint32) (y : uint32) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : uint64) (y : uint64) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : uint64) (y : uint64) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : uint64) (y : uint64) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : uint64) (y : uint64) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : uint64) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  constant z  : uint64
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : uint64) (y : uint64) (z : uint64) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : uint64) (y : uint64) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : uint64) (y : uint64) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint64
  
  constant y  : uint64
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : uint64) (y : uint64) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : uint128) (y : uint128) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : uint128) (y : uint128) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : uint128) (y : uint128) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : uint128) (y : uint128) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : uint128) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  constant z  : uint128
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : uint128) (y : uint128) (z : uint128) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : uint128) (y : uint128) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : uint128) (y : uint128) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : uint128
  
  constant y  : uint128
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : uint128) (y : uint128) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : usize) (y : usize) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : usize) (y : usize) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : usize) (y : usize) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : usize) (y : usize) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : usize) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  constant z  : usize
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : usize) (y : usize) (z : usize) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : usize) (y : usize) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : usize) (y : usize) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : usize
  
  constant y  : usize
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : usize) (y : usize) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int8) (y : int8) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int8) (y : int8) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int8) (y : int8) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int8) (y : int8) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int8) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  constant z  : int8
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int8) (y : int8) (z : int8) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int8) (y : int8) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int8) (y : int8) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int8
  
  constant y  : int8
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int8) (y : int8) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int16) (y : int16) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int16) (y : int16) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int16) (y : int16) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int16) (y : int16) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int16) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  constant z  : int16
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int16) (y : int16) (z : int16) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int16) (y : int16) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int16) (y : int16) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int16
  
  constant y  : int16
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int16) (y : int16) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int32) (y : int32) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int32) (y : int32) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int32) (y : int32) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int32) (y : int32) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int32) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  constant z  : int32
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int32) (y : int32) (z : int32) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int32) (y : int32) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int32) (y : int32) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int32
  
  constant y  : int32
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int32) (y : int32) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int64) (y : int64) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int64) (y : int64) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int64) (y : int64) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int64) (y : int64) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int64) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  constant z  : int64
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int64) (y : int64) (z : int64) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int64) (y : int64) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int64) (y : int64) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int64
  
  constant y  : int64
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int64) (y : int64) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : int128) (y : int128) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : int128) (y : int128) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : int128) (y : int128) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : int128) (y : int128) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : int128) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  constant z  : int128
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : int128) (y : int128) (z : int128) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : int128) (y : int128) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : int128) (y : int128) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : int128
  
  constant y  : int128
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : int128) (y : int128) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : isize) (y : isize) : ()
  
  goal vc_cmp_le_log : [%#sord0] (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : isize) (y : isize) : ()
  
  goal vc_cmp_lt_log : [%#sord0] (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : isize) (y : isize) : ()
  
  goal vc_cmp_ge_log : [%#sord0] (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : isize) (y : isize) : ()
  
  goal vc_cmp_gt_log : [%#sord0] (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : isize) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord3] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  constant z  : isize
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : isize) (y : isize) (z : isize) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : isize) (y : isize) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord2] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : isize) (y : isize) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord1] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  constant x  : isize
  
  constant y  : isize
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : isize) (y : isize) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : () =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : bool, y : bool . [%#sord22] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : () =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : bool, y : bool . ([%#sord19] cmp_log'0 x y = Ordering'0.C_Greater)
   -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : () =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : bool, y : bool . ([%#sord16] cmp_log'0 x y = Ordering'0.C_Less)
   -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : bool, y : bool, z : bool, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y = o)
   -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : bool . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : bool) (y : bool) : () =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : bool, y : bool . [%#sord8] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : bool) (y : bool) : () =
    [%#sord7] ()
  
  axiom cmp_ge_log'1_spec : forall x : bool, y : bool . [%#sord6] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord24] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : bool) (y : bool) : () =
    [%#sord5] ()
  
  axiom cmp_lt_log'1_spec : forall x : bool, y : bool . [%#sord4] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_le_log : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : () =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : bool, y : bool . [%#sord22] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : () =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : bool, y : bool . ([%#sord19] cmp_log'0 x y = Ordering'0.C_Greater)
   -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : () =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : bool, y : bool . ([%#sord16] cmp_log'0 x y = Ordering'0.C_Less)
   -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : bool, y : bool, z : bool, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y = o)
   -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : bool . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : bool) (y : bool) : () =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : bool, y : bool . [%#sord8] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : bool) (y : bool) : () =
    [%#sord7] ()
  
  axiom cmp_ge_log'1_spec : forall x : bool, y : bool . [%#sord6] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : bool) (y : bool) : () =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : bool, y : bool . [%#sord3] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Less
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_lt_log : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : () =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : bool, y : bool . [%#sord22] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : () =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : bool, y : bool . ([%#sord19] cmp_log'0 x y = Ordering'0.C_Greater)
   -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : () =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : bool, y : bool . ([%#sord16] cmp_log'0 x y = Ordering'0.C_Less)
   -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : bool, y : bool, z : bool, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y = o)
   -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : bool . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : bool) (y : bool) : () =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : bool, y : bool . [%#sord8] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : bool) (y : bool) : () =
    [%#sord6] ()
  
  axiom cmp_lt_log'1_spec : forall x : bool, y : bool . [%#sord5] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : bool) (y : bool) : () =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : bool, y : bool . [%#sord3] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Less
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_ge_log : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : () =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : bool, y : bool . [%#sord22] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : () =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : bool, y : bool . ([%#sord19] cmp_log'0 x y = Ordering'0.C_Greater)
   -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : () =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : bool, y : bool . ([%#sord16] cmp_log'0 x y = Ordering'0.C_Less)
   -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : bool, y : bool, z : bool, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y = o)
   -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : bool . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord26] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : bool) (y : bool) : () =
    [%#sord8] ()
  
  axiom cmp_ge_log'1_spec : forall x : bool, y : bool . [%#sord7] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : bool) (y : bool) : () =
    [%#sord6] ()
  
  axiom cmp_lt_log'1_spec : forall x : bool, y : bool . [%#sord5] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : bool) (y : bool) : () =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : bool, y : bool . [%#sord3] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Greater
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_gt_log : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  constant x  : bool
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : bool) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord3] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : bool) (y : bool) (z : bool) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord2] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord1] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : bool) (y : bool) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 229 20 229 68
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'1_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'1_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'1_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'1_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'1_spec : forall x : a, y : a . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'1_spec : forall x : a, y : a . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'1_spec : forall x : a, y : a . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'1_spec : forall x : a, y : a . [%#sord3] le_log'2 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'0_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'0_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'0_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'0_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'0_spec : forall x : b, y : b . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'0_spec : forall x : b, y : b . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'0_spec : forall x : b, y : b . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'0_spec : forall x : b, y : b . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 228 4 228 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_cmp_le_log : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 235 20 235 67
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'1_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'1_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'1_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'1_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'1_spec : forall x : a, y : a . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'1_spec : forall x : a, y : a . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'1_spec : forall x : a, y : a . [%#sord4] lt_log'2 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'1_spec : forall x : a, y : a . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'0_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'0_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'0_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'0_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'0_spec : forall x : b, y : b . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'0_spec : forall x : b, y : b . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'0_spec : forall x : b, y : b . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'0_spec : forall x : b, y : b . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 234 4 234 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_cmp_lt_log : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 241 20 241 68
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'1_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'1_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'1_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'1_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'1_spec : forall x : a, y : a . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'1_spec : forall x : a, y : a . [%#sord5] ge_log'2 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'1_spec : forall x : a, y : a . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'1_spec : forall x : a, y : a . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'0_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'0_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'0_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'0_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'0_spec : forall x : b, y : b . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'0_spec : forall x : b, y : b . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'0_spec : forall x : b, y : b . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'0_spec : forall x : b, y : b . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 240 4 240 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_cmp_ge_log : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 247 20 247 67
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'1_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'1_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'1_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'1_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'1_spec : forall x : a, y : a . [%#sord6] gt_log'2 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'1_spec : forall x : a, y : a . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'1_spec : forall x : a, y : a . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'1_spec : forall x : a, y : a . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'0_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'0_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'0_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'0_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'0_spec : forall x : b, y : b . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'0_spec : forall x : b, y : b . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'0_spec : forall x : b, y : b . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'0_spec : forall x : b, y : b . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 246 4 246 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_cmp_gt_log : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'1_spec : forall x : b, y : b . [%#sord14] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'1_spec : forall x : b, y : b . ([%#sord12] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'1_spec : forall x : b, y : b . ([%#sord10] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'1_spec : forall x : b . [%#sord6] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'1_spec : forall x : b, y : b . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'1_spec : forall x : b, y : b . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'1_spec : forall x : b, y : b . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'1_spec : forall x : b, y : b . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'0_spec : forall x : a, y : a . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'0_spec : forall x : a, y : a . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'0_spec : forall x : a, y : a . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'0_spec : forall x : a . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'0_spec : forall x : a, y : a . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'0_spec : forall x : a, y : a . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'0_spec : forall x : a, y : a . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'0_spec : forall x : a, y : a . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (a, b)
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : (a, b)) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'1_spec : forall x : b, y : b . [%#sord16] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'1_spec : forall x : b, y : b . ([%#sord14] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord15] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'1_spec : forall x : b, y : b . ([%#sord12] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord13] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'1_spec : forall x : b . [%#sord8] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'1_spec : forall x : b, y : b . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'1_spec : forall x : b, y : b . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'1_spec : forall x : b, y : b . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'1_spec : forall x : b, y : b . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'0_spec : forall x : a, y : a . [%#sord16] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'0_spec : forall x : a, y : a . ([%#sord14] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord15] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'0_spec : forall x : a, y : a . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'0_spec : forall x : a . [%#sord8] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'0_spec : forall x : a, y : a . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'0_spec : forall x : a, y : a . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'0_spec : forall x : a, y : a . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'0_spec : forall x : a, y : a . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  constant z  : (a, b)
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : (a, b)) (y : (a, b)) (z : (a, b)) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'1_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'1_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'1_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'1_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'1_spec : forall x : b, y : b . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'1_spec : forall x : b, y : b . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'1_spec : forall x : b, y : b . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'1_spec : forall x : b, y : b . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'0_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'0_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'0_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'0_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'0_spec : forall x : a, y : a . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'0_spec : forall x : a, y : a . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'0_spec : forall x : a, y : a . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'0_spec : forall x : a, y : a . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'1_spec : forall x : b, y : b . [%#sord15] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'1_spec : forall x : b, y : b . ([%#sord13] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'1_spec : forall x : b, y : b . ([%#sord11] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'1_spec : forall x : b . [%#sord7] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'1_spec : forall x : b, y : b . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'1_spec : forall x : b, y : b . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'1_spec : forall x : b, y : b . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'1_spec : forall x : b, y : b . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'0_spec : forall x : a, y : a . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'0_spec : forall x : a, y : a . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'0_spec : forall x : a, y : a . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'0_spec : forall x : a . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'0_spec : forall x : a, y : a . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'0_spec : forall x : a, y : a . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'0_spec : forall x : a, y : a . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'0_spec : forall x : a, y : a . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : b) (y : b) : ()
  
  axiom eq_cmp'1_spec : forall x : b, y : b . [%#sord14] (x = y) = (cmp_log'2 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : b) (y : b) : ()
  
  axiom antisym2'1_spec : forall x : b, y : b . ([%#sord12] cmp_log'2 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'2 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : b) (y : b) : ()
  
  axiom antisym1'1_spec : forall x : b, y : b . ([%#sord10] cmp_log'2 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'2 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : b) (y : b) (z : b) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'1_spec : forall x : b, y : b, z : b, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : b) : ()
  
  axiom refl'1_spec : forall x : b . [%#sord6] cmp_log'2 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : b) (y : b) : ()
  
  axiom cmp_gt_log'1_spec : forall x : b, y : b . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : b) (y : b) : ()
  
  axiom cmp_ge_log'1_spec : forall x : b, y : b . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : b) (y : b) : ()
  
  axiom cmp_lt_log'1_spec : forall x : b, y : b . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : b) (y : b) : ()
  
  axiom cmp_le_log'1_spec : forall x : b, y : b . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> Ordering'0.C_Greater)
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : a) (y : a) : ()
  
  axiom eq_cmp'0_spec : forall x : a, y : a . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : a) (y : a) : ()
  
  axiom antisym2'0_spec : forall x : a, y : a . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : a) (y : a) : ()
  
  axiom antisym1'0_spec : forall x : a, y : a . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : a) (y : a) (z : a) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : a, y : a, z : a, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : a) : ()
  
  axiom refl'0_spec : forall x : a . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : a) (y : a) : ()
  
  axiom cmp_gt_log'0_spec : forall x : a, y : a . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : a) (o : a) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : a) (y : a) : ()
  
  axiom cmp_ge_log'0_spec : forall x : a, y : a . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : a) (y : a) : ()
  
  axiom cmp_lt_log'0_spec : forall x : a, y : a . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : a) (o : a) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : a) (y : a) : ()
  
  axiom cmp_le_log'0_spec : forall x : a, y : a . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  constant x  : (a, b)
  
  constant y  : (a, b)
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : (a, b)) (y : (a, b)) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module T_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1 [#"../../../creusot-contracts/src/logic/seq.rs" 270 8 270 23] (* logic::seq::Seq<T> *)
  type m_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1 't =
    | M_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1
  
  let rec m_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1 < 't > (input:m_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1 't) (ret  )= any
    [ good -> {M_creusot_contracts__logic__seq__qyi345269549310492227__new__qyClosure1  = input} (! ret) ]
    
end
module T_core__cmp__Reverse
  type t_Reverse 't =
    | C_Reverse 't
  
  let rec t_Reverse < 't > (input:t_Reverse 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Reverse field_0 = input} (! ret {field_0}) ]
    
  
  function t_Reverse__0 (self : t_Reverse 't) : 't =
    match self with
      | C_Reverse a -> a
      end
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_le_log [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 87 14 87 64
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 85 4 85 10
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 92 14 92 61
  let%span scmp5 = "../../../creusot-contracts/src/std/cmp.rs" 90 4 90 10
  let%span scmp6 = "../../../creusot-contracts/src/std/cmp.rs" 97 14 97 61
  let%span scmp7 = "../../../creusot-contracts/src/std/cmp.rs" 95 4 95 10
  let%span scmp8 = "../../../creusot-contracts/src/std/cmp.rs" 102 14 102 64
  let%span scmp9 = "../../../creusot-contracts/src/std/cmp.rs" 100 4 100 10
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp11 = "../../../creusot-contracts/src/std/cmp.rs" 105 4 105 10
  let%span scmp12 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp13 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp14 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp15 = "../../../creusot-contracts/src/std/cmp.rs" 110 4 110 10
  let%span scmp16 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp17 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp18 = "../../../creusot-contracts/src/std/cmp.rs" 117 4 117 10
  let%span scmp19 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp20 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp21 = "../../../creusot-contracts/src/std/cmp.rs" 123 4 123 10
  let%span scmp22 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp23 = "../../../creusot-contracts/src/std/cmp.rs" 129 4 129 10
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'1_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp23] ()
  
  axiom eq_cmp'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp21] ()
  
  axiom antisym2'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#scmp20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp18] ()
  
  axiom antisym1'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#scmp17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) (z : Reverse'0.t_Reverse t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#scmp15] ()
  
  axiom trans'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t, z : Reverse'0.t_Reverse t, o : Ordering'0.t_Ordering . ([%#scmp12] cmp_log'0 x y
  = o)  -> ([%#scmp13] cmp_log'0 y z = o)  -> ([%#scmp14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : Reverse'0.t_Reverse t) : () =
    [%#scmp11] ()
  
  axiom refl'1_spec : forall x : Reverse'0.t_Reverse t . [%#scmp10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp7] ()
  
  axiom cmp_ge_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp6] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord24] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp5] ()
  
  axiom cmp_lt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp4] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Greater
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function cmp_le_log [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_cmp_le_log : [%#scmp0] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_lt_log [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 92 14 92 61
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 87 14 87 64
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 85 4 85 10
  let%span scmp5 = "../../../creusot-contracts/src/std/cmp.rs" 90 4 90 10
  let%span scmp6 = "../../../creusot-contracts/src/std/cmp.rs" 97 14 97 61
  let%span scmp7 = "../../../creusot-contracts/src/std/cmp.rs" 95 4 95 10
  let%span scmp8 = "../../../creusot-contracts/src/std/cmp.rs" 102 14 102 64
  let%span scmp9 = "../../../creusot-contracts/src/std/cmp.rs" 100 4 100 10
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp11 = "../../../creusot-contracts/src/std/cmp.rs" 105 4 105 10
  let%span scmp12 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp13 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp14 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp15 = "../../../creusot-contracts/src/std/cmp.rs" 110 4 110 10
  let%span scmp16 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp17 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp18 = "../../../creusot-contracts/src/std/cmp.rs" 117 4 117 10
  let%span scmp19 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp20 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp21 = "../../../creusot-contracts/src/std/cmp.rs" 123 4 123 10
  let%span scmp22 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp23 = "../../../creusot-contracts/src/std/cmp.rs" 129 4 129 10
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp23] ()
  
  axiom eq_cmp'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp21] ()
  
  axiom antisym2'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#scmp20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp18] ()
  
  axiom antisym1'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#scmp17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) (z : Reverse'0.t_Reverse t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#scmp15] ()
  
  axiom trans'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t, z : Reverse'0.t_Reverse t, o : Ordering'0.t_Ordering . ([%#scmp12] cmp_log'0 x y
  = o)  -> ([%#scmp13] cmp_log'0 y z = o)  -> ([%#scmp14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : Reverse'0.t_Reverse t) : () =
    [%#scmp11] ()
  
  axiom refl'1_spec : forall x : Reverse'0.t_Reverse t . [%#scmp10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp7] ()
  
  axiom cmp_ge_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp6] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp4] ()
  
  axiom cmp_le_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Less
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function cmp_lt_log [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_cmp_lt_log : [%#scmp0] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_ge_log [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 97 14 97 61
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 87 14 87 64
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 85 4 85 10
  let%span scmp5 = "../../../creusot-contracts/src/std/cmp.rs" 92 14 92 61
  let%span scmp6 = "../../../creusot-contracts/src/std/cmp.rs" 90 4 90 10
  let%span scmp7 = "../../../creusot-contracts/src/std/cmp.rs" 95 4 95 10
  let%span scmp8 = "../../../creusot-contracts/src/std/cmp.rs" 102 14 102 64
  let%span scmp9 = "../../../creusot-contracts/src/std/cmp.rs" 100 4 100 10
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp11 = "../../../creusot-contracts/src/std/cmp.rs" 105 4 105 10
  let%span scmp12 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp13 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp14 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp15 = "../../../creusot-contracts/src/std/cmp.rs" 110 4 110 10
  let%span scmp16 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp17 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp18 = "../../../creusot-contracts/src/std/cmp.rs" 117 4 117 10
  let%span scmp19 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp20 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp21 = "../../../creusot-contracts/src/std/cmp.rs" 123 4 123 10
  let%span scmp22 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp23 = "../../../creusot-contracts/src/std/cmp.rs" 129 4 129 10
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp23] ()
  
  axiom eq_cmp'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp21] ()
  
  axiom antisym2'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#scmp20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp18] ()
  
  axiom antisym1'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#scmp17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) (z : Reverse'0.t_Reverse t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#scmp15] ()
  
  axiom trans'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t, z : Reverse'0.t_Reverse t, o : Ordering'0.t_Ordering . ([%#scmp12] cmp_log'0 x y
  = o)  -> ([%#scmp13] cmp_log'0 y z = o)  -> ([%#scmp14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : Reverse'0.t_Reverse t) : () =
    [%#scmp11] ()
  
  axiom refl'1_spec : forall x : Reverse'0.t_Reverse t . [%#scmp10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp6] ()
  
  axiom cmp_lt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp5] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp4] ()
  
  axiom cmp_le_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Less
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function cmp_ge_log [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_cmp_ge_log : [%#scmp0] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__cmp_gt_log [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 102 14 102 64
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 87 14 87 64
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 85 4 85 10
  let%span scmp5 = "../../../creusot-contracts/src/std/cmp.rs" 92 14 92 61
  let%span scmp6 = "../../../creusot-contracts/src/std/cmp.rs" 90 4 90 10
  let%span scmp7 = "../../../creusot-contracts/src/std/cmp.rs" 97 14 97 61
  let%span scmp8 = "../../../creusot-contracts/src/std/cmp.rs" 95 4 95 10
  let%span scmp9 = "../../../creusot-contracts/src/std/cmp.rs" 100 4 100 10
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp11 = "../../../creusot-contracts/src/std/cmp.rs" 105 4 105 10
  let%span scmp12 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp13 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp14 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp15 = "../../../creusot-contracts/src/std/cmp.rs" 110 4 110 10
  let%span scmp16 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp17 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp18 = "../../../creusot-contracts/src/std/cmp.rs" 117 4 117 10
  let%span scmp19 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp20 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp21 = "../../../creusot-contracts/src/std/cmp.rs" 123 4 123 10
  let%span scmp22 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp23 = "../../../creusot-contracts/src/std/cmp.rs" 129 4 129 10
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp23] ()
  
  axiom eq_cmp'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp21] ()
  
  axiom antisym2'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#scmp20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp18] ()
  
  axiom antisym1'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . ([%#scmp16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#scmp17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) (z : Reverse'0.t_Reverse t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#scmp15] ()
  
  axiom trans'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t, z : Reverse'0.t_Reverse t, o : Ordering'0.t_Ordering . ([%#scmp12] cmp_log'0 x y
  = o)  -> ([%#scmp13] cmp_log'0 y z = o)  -> ([%#scmp14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : Reverse'0.t_Reverse t) : () =
    [%#scmp11] ()
  
  axiom refl'1_spec : forall x : Reverse'0.t_Reverse t . [%#scmp10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord26] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp8] ()
  
  axiom cmp_ge_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp7] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp6] ()
  
  axiom cmp_lt_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp5] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
   =
    [%#scmp4] ()
  
  axiom cmp_le_log'1_spec : forall x : Reverse'0.t_Reverse t, y : Reverse'0.t_Reverse t . [%#scmp3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Greater
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function cmp_gt_log [#"../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_cmp_gt_log : [%#scmp0] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__refl [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 107 14 107 45
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp1] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  constant x  : Reverse'0.t_Reverse t
  
  function refl [#"../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20] (x : Reverse'0.t_Reverse t) : ()
  
  goal vc_refl : [%#scmp0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__trans [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 112 15 112 32
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 113 15 113 32
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 114 14 114 31
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord16] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord14] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord15] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord8] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp3] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  constant z  : Reverse'0.t_Reverse t
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) (z : Reverse'0.t_Reverse t) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#scmp1] cmp_log'0 y z = o)  -> ([%#scmp0] cmp_log'0 x y = o)  -> ([%#scmp2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 119 15 119 45
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 120 14 120 47
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function antisym1 [#"../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_antisym1 : ([%#scmp0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#scmp1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__antisym2 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 125 15 125 48
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 126 14 126 44
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp2] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function antisym2 [#"../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_antisym2 : ([%#scmp0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#scmp1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814__eq_cmp [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 131 14 131 59
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__cmp__Reverse as Reverse'0
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp1] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  constant x  : Reverse'0.t_Reverse t
  
  constant y  : Reverse'0.t_Reverse t
  
  function eq_cmp [#"../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31] (x : Reverse'0.t_Reverse t) (y : Reverse'0.t_Reverse t) : ()
    
  
  goal vc_eq_cmp : [%#scmp0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module T_alloc__collections__vec_deque__VecDeque
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_VecDeque 't 'a =
    | C_VecDeque usize usize (RawVec'0.t_RawVec 't 'a)
  
  let rec t_VecDeque < 't > < 'a > (input:t_VecDeque 't 'a) (ret  (head:usize) (len:usize) (buf:RawVec'0.t_RawVec 't 'a))= any
    [ good (head:usize) (len:usize) (buf:RawVec'0.t_RawVec 't 'a)-> {C_VecDeque head len buf = input}
      (! ret {head} {len} {buf}) ]
    
end
module T_alloc__alloc__Global
  type t_Global  =
    | C_Global
  
  let rec t_Global (input:t_Global) (ret  )= any [ good -> {C_Global  = input} (! ret) ] 
end
module T_core__slice__iter__Iter
  use prelude.prelude.Borrow
  
  use T_core__marker__PhantomData as PhantomData'0
  
  use prelude.prelude.Opaque
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Iter 't =
    | C_Iter (NonNull'0.t_NonNull 't) opaque_ptr (PhantomData'0.t_PhantomData 't)
  
  let rec t_Iter < 't > (input:t_Iter 't) (ret  (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData 't))= any
    [ good (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Iter ptr end_or_len _marker
      = input}
      (! ret {ptr} {end_or_len} {_marker}) ]
    
end
module T_alloc__collections__vec_deque__iter__Iter
  use T_core__slice__iter__Iter as Iter'0
  
  type t_Iter 't =
    | C_Iter (Iter'0.t_Iter 't) (Iter'0.t_Iter 't)
  
  let rec t_Iter < 't > (input:t_Iter 't) (ret  (i1:Iter'0.t_Iter 't) (i2:Iter'0.t_Iter 't))= any
    [ good (i1:Iter'0.t_Iter 't) (i2:Iter'0.t_Iter 't)-> {C_Iter i1 i2 = input} (! ret {i1} {i2}) ]
    
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_refl [#"../../../creusot-contracts/src/std/deque.rs" 182 4 182 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 181 14 181 45
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 175 12 175 66
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 160 8 160 14
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 101 14 101 80
  let%span smodel5 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sops6 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  
  use T_alloc__collections__vec_deque__iter__Iter as Iter'0
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice8] view'2 self = Slice.id self)
  && ([%#sslice7] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops6] Seq.get (view'2 self) ix
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : slice t) : Seq.seq t =
    [%#smodel5] view'2 self
  
  use seq.Seq
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 102 4 102 35] (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice4] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice3] Seq.length (to_ref_seq'0 self) = Seq.length (view'1 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 159 4 159 33] (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 173 4 173 65] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t)
    
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  constant self  : Iter'0.t_Iter t
  
  function produces_refl [#"../../../creusot-contracts/src/std/deque.rs" 182 4 182 26] (self : Iter'0.t_Iter t) : ()
  
  goal vc_produces_refl : [%#sdeque0] produces'0 self (Seq.empty  : Seq.seq t) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709__produces_trans [#"../../../creusot-contracts/src/std/deque.rs" 189 4 189 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 186 15 186 32
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 187 15 187 32
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 188 14 188 42
  let%span sdeque3 = "../../../creusot-contracts/src/std/deque.rs" 175 12 175 66
  let%span sdeque4 = "../../../creusot-contracts/src/std/deque.rs" 160 8 160 14
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 101 14 101 80
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use T_alloc__collections__vec_deque__iter__Iter as Iter'0
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice10] view'2 self = Slice.id self)
  && ([%#sslice9] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops8] Seq.get (view'2 self) ix
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : slice t) : Seq.seq t =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 102 4 102 35] (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice6] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice5] Seq.length (to_ref_seq'0 self) = Seq.length (view'1 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 159 4 159 33] (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 173 4 173 65] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t)
    
   =
    [%#sdeque3] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : Iter'0.t_Iter t
  
  constant ab  : Seq.seq t
  
  constant b  : Iter'0.t_Iter t
  
  constant bc  : Seq.seq t
  
  constant c  : Iter'0.t_Iter t
  
  function produces_trans [#"../../../creusot-contracts/src/std/deque.rs" 189 4 189 90] (a : Iter'0.t_Iter t) (ab : Seq.seq t) (b : Iter'0.t_Iter t) (bc : Seq.seq t) (c : Iter'0.t_Iter t) : ()
    
  
  goal vc_produces_trans : ([%#sdeque1] produces'0 b bc c)
   -> ([%#sdeque0] produces'0 a ab b)  -> ([%#sdeque2] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__cloned__Cloned
  type t_Cloned 'i =
    | C_Cloned 'i
  
  let rec t_Cloned < 'i > (input:t_Cloned 'i) (ret  (it:'i))= any [ good (it:'i)-> {C_Cloned it = input} (! ret {it}) ] 
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_refl [#"../../../creusot-contracts/src/std/iter/cloned.rs" 64 4 64 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 62 15 62 24
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 63 14 63 45
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 53 12 56 79
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 12 14 12 39
  let%span scloned4 = "../../../creusot-contracts/src/std/iter/cloned.rs" 14 20 14 26
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq13 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant15 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant15] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed14] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t, b : i, bc : Seq.seq t, c : i . ([%#siter7] inv'2 a)
   -> ([%#siter8] inv'2 b)
   -> ([%#siter9] inv'2 c)
   -> ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter5] inv'2 self)
   -> ([%#siter6] produces'1 self (Seq.empty  : Seq.seq t) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq13] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__cloned__Cloned as Cloned'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Cloned'0.t_Cloned i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Cloned'0.t_Cloned i [inv'0 x] . inv'0 x
  = match x with
    | Cloned'0.C_Cloned it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 13 4 13 22] (self : Cloned'0.t_Cloned i) : i
  
  axiom iter'0_spec : forall self : Cloned'0.t_Cloned i . [%#scloned3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 51 4 51 64] (self : Cloned'0.t_Cloned i) (visited : Seq.seq t) (o : Cloned'0.t_Cloned i)
    
   =
    [%#scloned2] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant self  : Cloned'0.t_Cloned i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/cloned.rs" 64 4 64 26] (self : Cloned'0.t_Cloned i) : ()
    
  
  goal vc_produces_refl : ([%#scloned0] inv'0 self)  -> ([%#scloned1] produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984__produces_trans [#"../../../creusot-contracts/src/std/iter/cloned.rs" 74 4 74 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 68 15 68 21
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 69 15 69 21
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 70 15 70 21
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 71 15 71 32
  let%span scloned4 = "../../../creusot-contracts/src/std/iter/cloned.rs" 72 15 72 32
  let%span scloned5 = "../../../creusot-contracts/src/std/iter/cloned.rs" 73 14 73 42
  let%span scloned6 = "../../../creusot-contracts/src/std/iter/cloned.rs" 53 12 56 79
  let%span scloned7 = "../../../creusot-contracts/src/std/iter/cloned.rs" 12 14 12 39
  let%span scloned8 = "../../../creusot-contracts/src/std/iter/cloned.rs" 14 20 14 26
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed18 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant19] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed18] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t, b : i, bc : Seq.seq t, c : i . ([%#siter11] inv'2 a)
   -> ([%#siter12] inv'2 b)
   -> ([%#siter13] inv'2 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter9] inv'2 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq17] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__cloned__Cloned as Cloned'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Cloned'0.t_Cloned i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Cloned'0.t_Cloned i [inv'0 x] . inv'0 x
  = match x with
    | Cloned'0.C_Cloned it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 13 4 13 22] (self : Cloned'0.t_Cloned i) : i
  
  axiom iter'0_spec : forall self : Cloned'0.t_Cloned i . [%#scloned7] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 51 4 51 64] (self : Cloned'0.t_Cloned i) (visited : Seq.seq t) (o : Cloned'0.t_Cloned i)
    
   =
    [%#scloned6] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : Cloned'0.t_Cloned i
  
  constant ab  : Seq.seq t
  
  constant b  : Cloned'0.t_Cloned i
  
  constant bc  : Seq.seq t
  
  constant c  : Cloned'0.t_Cloned i
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/cloned.rs" 74 4 74 90] (a : Cloned'0.t_Cloned i) (ab : Seq.seq t) (b : Cloned'0.t_Cloned i) (bc : Seq.seq t) (c : Cloned'0.t_Cloned i) : ()
    
  
  goal vc_produces_trans : ([%#scloned4] produces'0 b bc c)
   -> ([%#scloned3] produces'0 a ab b)
   -> ([%#scloned2] inv'0 c)
   -> ([%#scloned1] inv'0 b)  -> ([%#scloned0] inv'0 a)  -> ([%#scloned5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__copied__Copied
  type t_Copied 'i =
    | C_Copied 'i
  
  let rec t_Copied < 'i > (input:t_Copied 'i) (ret  (it:'i))= any [ good (it:'i)-> {C_Copied it = input} (! ret {it}) ] 
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_refl [#"../../../creusot-contracts/src/std/iter/copied.rs" 64 4 64 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 24
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 14 63 45
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 53 12 56 79
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 12 14 12 39
  let%span scopied4 = "../../../creusot-contracts/src/std/iter/copied.rs" 14 20 14 26
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq13 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant15 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant15] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed14] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t, b : i, bc : Seq.seq t, c : i . ([%#siter7] inv'2 a)
   -> ([%#siter8] inv'2 b)
   -> ([%#siter9] inv'2 c)
   -> ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter5] inv'2 self)
   -> ([%#siter6] produces'1 self (Seq.empty  : Seq.seq t) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq13] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__copied__Copied as Copied'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Copied'0.t_Copied i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Copied'0.t_Copied i [inv'0 x] . inv'0 x
  = match x with
    | Copied'0.C_Copied it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 13 4 13 22] (self : Copied'0.t_Copied i) : i
  
  axiom iter'0_spec : forall self : Copied'0.t_Copied i . [%#scopied3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 51 4 51 64] (self : Copied'0.t_Copied i) (visited : Seq.seq t) (o : Copied'0.t_Copied i)
    
   =
    [%#scopied2] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant self  : Copied'0.t_Copied i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/copied.rs" 64 4 64 26] (self : Copied'0.t_Copied i) : ()
    
  
  goal vc_produces_refl : ([%#scopied0] inv'0 self)  -> ([%#scopied1] produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026__produces_trans [#"../../../creusot-contracts/src/std/iter/copied.rs" 74 4 74 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 68 15 68 21
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 69 15 69 21
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 70 15 70 21
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 71 15 71 32
  let%span scopied4 = "../../../creusot-contracts/src/std/iter/copied.rs" 72 15 72 32
  let%span scopied5 = "../../../creusot-contracts/src/std/iter/copied.rs" 73 14 73 42
  let%span scopied6 = "../../../creusot-contracts/src/std/iter/copied.rs" 53 12 56 79
  let%span scopied7 = "../../../creusot-contracts/src/std/iter/copied.rs" 12 14 12 39
  let%span scopied8 = "../../../creusot-contracts/src/std/iter/copied.rs" 14 20 14 26
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed18 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant19] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed18] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t, b : i, bc : Seq.seq t, c : i . ([%#siter11] inv'2 a)
   -> ([%#siter12] inv'2 b)
   -> ([%#siter13] inv'2 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter9] inv'2 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq17] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__copied__Copied as Copied'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Copied'0.t_Copied i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Copied'0.t_Copied i [inv'0 x] . inv'0 x
  = match x with
    | Copied'0.C_Copied it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 13 4 13 22] (self : Copied'0.t_Copied i) : i
  
  axiom iter'0_spec : forall self : Copied'0.t_Copied i . [%#scopied7] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 51 4 51 64] (self : Copied'0.t_Copied i) (visited : Seq.seq t) (o : Copied'0.t_Copied i)
    
   =
    [%#scopied6] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : Copied'0.t_Copied i
  
  constant ab  : Seq.seq t
  
  constant b  : Copied'0.t_Copied i
  
  constant bc  : Seq.seq t
  
  constant c  : Copied'0.t_Copied i
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/copied.rs" 74 4 74 90] (a : Copied'0.t_Copied i) (ab : Seq.seq t) (b : Copied'0.t_Copied i) (bc : Seq.seq t) (c : Copied'0.t_Copied i) : ()
    
  
  goal vc_produces_trans : ([%#scopied4] produces'0 b bc c)
   -> ([%#scopied3] produces'0 a ab b)
   -> ([%#scopied2] inv'0 c)
   -> ([%#scopied1] inv'0 b)  -> ([%#scopied0] inv'0 a)  -> ([%#scopied5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__sources__empty__Empty
  use prelude.prelude.Opaque
  
  use T_core__marker__PhantomData as PhantomData'0
  
  type t_Empty 't =
    | C_Empty (PhantomData'0.t_PhantomData opaque_ptr)
  
  let rec t_Empty < 't > (input:t_Empty 't) (ret  (field_0:PhantomData'0.t_PhantomData opaque_ptr))= any
    [ good (field_0:PhantomData'0.t_PhantomData opaque_ptr)-> {C_Empty field_0 = input} (! ret {field_0}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_refl [#"../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type t
  
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 18 15 18 24
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 19 14 19 45
  let%span sempty2 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use T_core__iter__sources__empty__Empty as Empty'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Empty'0.t_Empty t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Empty'0.t_Empty t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : Empty'0.t_Empty t) (visited : Seq.seq t) (o : Empty'0.t_Empty t)
    
   =
    [%#sempty2] visited = (Seq.empty  : Seq.seq t) /\ self = o
  
  constant self  : Empty'0.t_Empty t
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26] (self : Empty'0.t_Empty t) : ()
    
  
  goal vc_produces_refl : ([%#sempty0] inv'0 self)  -> ([%#sempty1] produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838__produces_trans [#"../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type t
  
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 24 15 24 21
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 25 15 25 21
  let%span sempty2 = "../../../creusot-contracts/src/std/iter/empty.rs" 26 15 26 21
  let%span sempty3 = "../../../creusot-contracts/src/std/iter/empty.rs" 27 15 27 32
  let%span sempty4 = "../../../creusot-contracts/src/std/iter/empty.rs" 28 15 28 32
  let%span sempty5 = "../../../creusot-contracts/src/std/iter/empty.rs" 29 14 29 42
  let%span sempty6 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use T_core__iter__sources__empty__Empty as Empty'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Empty'0.t_Empty t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Empty'0.t_Empty t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : Empty'0.t_Empty t) (visited : Seq.seq t) (o : Empty'0.t_Empty t)
    
   =
    [%#sempty6] visited = (Seq.empty  : Seq.seq t) /\ self = o
  
  constant a  : Empty'0.t_Empty t
  
  constant ab  : Seq.seq t
  
  constant b  : Empty'0.t_Empty t
  
  constant bc  : Seq.seq t
  
  constant c  : Empty'0.t_Empty t
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90] (a : Empty'0.t_Empty t) (ab : Seq.seq t) (b : Empty'0.t_Empty t) (bc : Seq.seq t) (c : Empty'0.t_Empty t) : ()
    
  
  goal vc_produces_trans : ([%#sempty4] produces'0 b bc c)
   -> ([%#sempty3] produces'0 a ab b)
   -> ([%#sempty2] inv'0 c)
   -> ([%#sempty1] inv'0 b)  -> ([%#sempty0] inv'0 a)  -> ([%#sempty5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__enumerate__Enumerate
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Enumerate 'i =
    | C_Enumerate 'i usize
  
  let rec t_Enumerate < 'i > (input:t_Enumerate 'i) (ret  (iter:'i) (count:usize))= any
    [ good (iter:'i) (count:usize)-> {C_Enumerate iter count = input} (! ret {iter} {count}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_refl [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type i
  
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 24
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 88 14 88 45
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 77 12 81 113
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 24 8 24 14
  let%span senumerate4 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 15 14 15 39
  let%span senumerate5 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 17 8 17 14
  let%span senumerate6 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 48 12 52 79
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq15 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed16 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed16] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter9] inv'2 a)
   -> ([%#siter10] inv'2 b)
   -> ([%#siter11] inv'2 c)
   -> ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter7] inv'2 self)
   -> ([%#siter8] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq15] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use T_core__iter__adapters__enumerate__Enumerate as Enumerate'0
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self : Enumerate'0.t_Enumerate i) : int
    
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Enumerate'0.t_Enumerate i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 16 4 16 22] (self : Enumerate'0.t_Enumerate i) : i
    
  
  axiom iter'0_spec : forall self : Enumerate'0.t_Enumerate i . [%#senumerate4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 46 4 46 30] (self : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate6] (forall s : Seq.seq t_Item'0, i : i [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UIntSize.to_int v_MAX'0)
    /\ (forall i : borrowed i . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Enumerate'0.t_Enumerate i [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Enumerate'0.C_Enumerate iter count -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 75 4 75 64] (self : Enumerate'0.t_Enumerate i) (visited : Seq.seq (usize, t_Item'0)) (o : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate2] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  constant self  : Enumerate'0.t_Enumerate i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 26] (self : Enumerate'0.t_Enumerate i) : ()
    
  
  goal vc_produces_refl : ([%#senumerate0] inv'0 self)
   -> ([%#senumerate1] produces'0 self (Seq.empty  : Seq.seq (usize, t_Item'0)) self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896__produces_trans [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 99 4 99 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type i
  
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 93 15 93 21
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 94 15 94 21
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 95 15 95 21
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 96 15 96 32
  let%span senumerate4 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 97 15 97 32
  let%span senumerate5 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 98 14 98 42
  let%span senumerate6 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 77 12 81 113
  let%span senumerate7 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 24 8 24 14
  let%span senumerate8 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 15 14 15 39
  let%span senumerate9 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 17 8 17 14
  let%span senumerate10 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 48 12 52 79
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq19 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed20 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed20] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter13] inv'2 a)
   -> ([%#siter14] inv'2 b)
   -> ([%#siter15] inv'2 c)
   -> ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter11] inv'2 self)
   -> ([%#siter12] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq19] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use T_core__iter__adapters__enumerate__Enumerate as Enumerate'0
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self : Enumerate'0.t_Enumerate i) : int
    
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Enumerate'0.t_Enumerate i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 16 4 16 22] (self : Enumerate'0.t_Enumerate i) : i
    
  
  axiom iter'0_spec : forall self : Enumerate'0.t_Enumerate i . [%#senumerate8] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 46 4 46 30] (self : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate10] (forall s : Seq.seq t_Item'0, i : i [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UIntSize.to_int v_MAX'0)
    /\ (forall i : borrowed i . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Enumerate'0.t_Enumerate i [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Enumerate'0.C_Enumerate iter count -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 75 4 75 64] (self : Enumerate'0.t_Enumerate i) (visited : Seq.seq (usize, t_Item'0)) (o : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate6] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  constant a  : Enumerate'0.t_Enumerate i
  
  constant ab  : Seq.seq (usize, t_Item'0)
  
  constant b  : Enumerate'0.t_Enumerate i
  
  constant bc  : Seq.seq (usize, t_Item'0)
  
  constant c  : Enumerate'0.t_Enumerate i
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 99 4 99 90] (a : Enumerate'0.t_Enumerate i) (ab : Seq.seq (usize, t_Item'0)) (b : Enumerate'0.t_Enumerate i) (bc : Seq.seq (usize, t_Item'0)) (c : Enumerate'0.t_Enumerate i) : ()
    
  
  goal vc_produces_trans : ([%#senumerate4] produces'0 b bc c)
   -> ([%#senumerate3] produces'0 a ab b)
   -> ([%#senumerate2] inv'0 c)
   -> ([%#senumerate1] inv'0 b)  -> ([%#senumerate0] inv'0 a)  -> ([%#senumerate5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__filter__Filter
  type t_Filter 'i 'p =
    | C_Filter 'i 'p
  
  let rec t_Filter < 'i > < 'p > (input:t_Filter 'i 'p) (ret  (iter:'i) (predicate':'p))= any
    [ good (iter:'i) (predicate':'p)-> {C_Filter iter predicate' = input} (! ret {iter} {predicate'}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160__produces_refl [#"../../../creusot-contracts/src/std/iter/filter.rs" 131 4 131 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type i
  
  type f
  
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 129 15 129 24
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 130 14 130 45
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 112 12 123 17
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 27 14 27 39
  let%span sfilter4 = "../../../creusot-contracts/src/std/iter/filter.rs" 29 8 29 14
  let%span sfilter5 = "../../../creusot-contracts/src/std/iter/filter.rs" 19 14 19 39
  let%span sfilter6 = "../../../creusot-contracts/src/std/iter/filter.rs" 21 8 21 14
  let%span sfilter7 = "../../../creusot-contracts/src/std/iter/filter.rs" 48 12 57 110
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 104 15 104 48
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 105 14 105 35
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 29
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 118 15 118 26
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 119 14 119 28
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 125 14 125 133
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter17] inv'1 a)
   -> ([%#siter18] inv'1 b)
   -> ([%#siter19] inv'1 c)
   -> ([%#siter20] produces'1 a ab b)
   -> ([%#siter21] produces'1 b bc c)  -> ([%#siter22] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter15] inv'1 self)
   -> ([%#siter16] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : t_Item'0) (_3 : bool)
    
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t_Item'0) (_3 : bool)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 126 4 126 55] (self : f) (args : t_Item'0) (res : bool) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : f, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists s : borrowed f . s.current = self /\ postcondition_mut'0 s args res /\ resolve'0 s.final)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 120 4 120 43] (self : f) (b : f) (c : f) : ()
  
  axiom unnest_trans'0_spec : forall self : f, b : f, c : f . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : f) : ()
  
  axiom unnest_refl'0_spec : forall self : f . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self : borrowed f) (args : t_Item'0) (res : bool) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : borrowed f, args : t_Item'0, res : bool . ([%#sops8] postcondition_mut'0 self args res)
   -> ([%#sops9] unnest'0 self.current self.final)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t_Item'0)
  
  use T_core__iter__adapters__filter__Filter as Filter'0
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 45 4 45 30] (self : Filter'0.t_Filter i f)
   =
    [%#sfilter7] forall f : f, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : f, g : f . unnest'0 f g  -> f = g)
    /\ (forall f : borrowed f, g : borrowed f, i : t_Item'0, b : bool . f.current = g.current /\ f.final = g.final
     -> postcondition_mut'0 f (i) b = postcondition_mut'0 g (i) b)
    /\ (forall f : borrowed f, i : t_Item'0 . not (postcondition_mut'0 f (i) true /\ postcondition_mut'0 f (i) false))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Filter'0.t_Filter i f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Filter'0.t_Filter i f [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Filter'0.C_Filter iter predicate' -> inv'1 iter /\ inv'2 predicate'
    end)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 20 4 20 22] (self : Filter'0.t_Filter i f) : i
  
  axiom iter'0_spec : forall self : Filter'0.t_Filter i f . [%#sfilter5] inv'0 self  -> inv'1 (iter'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 28 4 28 22] (self : Filter'0.t_Filter i f) : f
  
  axiom func'0_spec : forall self : Filter'0.t_Filter i f . [%#sfilter3] inv'0 self  -> inv'2 (func'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 110 4 110 67] (self : Filter'0.t_Filter i f) (visited : Seq.seq t_Item'0) (succ : Filter'0.t_Filter i f)
    
   =
    [%#sfilter2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall bor_f : borrowed f, i : int . bor_f.current = func'0 self /\ bor_f.final = func'0 self
     -> 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 bor_f (Seq.get s i) true))
  
  constant self  : Filter'0.t_Filter i f
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/filter.rs" 131 4 131 26] (self : Filter'0.t_Filter i f) : ()
    
  
  goal vc_produces_refl : ([%#sfilter0] inv'0 self)
   -> ([%#sfilter1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module T_core__iter__adapters__fuse__Fuse
  use T_core__option__Option as Option'0
  
  type t_Fuse 'i =
    | C_Fuse (Option'0.t_Option 'i)
  
  let rec t_Fuse < 'i > (input:t_Fuse 'i) (ret  (iter:Option'0.t_Option 'i))= any
    [ good (iter:Option'0.t_Option 'i)-> {C_Fuse iter = input} (! ret {iter}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_refl [#"../../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type i
  
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 42 15 42 24
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 43 14 43 45
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 30 12 36 13
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 39
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 11 20 11 26
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option i [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter7] inv'2 a)
   -> ([%#siter8] inv'2 b)
   -> ([%#siter9] inv'2 c)
   -> ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter5] inv'2 self)
   -> ([%#siter6] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use T_core__iter__adapters__fuse__Fuse as Fuse'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Fuse'0.t_Fuse i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fuse'0.t_Fuse i [inv'0 x] . inv'0 x
  = match x with
    | Fuse'0.C_Fuse iter -> inv'1 iter
    end
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : Fuse'0.t_Fuse i) : Option'0.t_Option i
    
  
  axiom view'0_spec : forall self : Fuse'0.t_Fuse i . [%#sfuse3] inv'0 self  -> inv'1 (view'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 28 4 28 65] (self : Fuse'0.t_Fuse i) (prod : Seq.seq t_Item'0) (other : Fuse'0.t_Fuse i)
    
   =
    [%#sfuse2] match view'0 self with
      | Option'0.C_None -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | Option'0.C_Some i -> match view'0 other with
        | Option'0.C_Some i2 -> produces'1 i prod i2
        | Option'0.C_None -> false
        end
      end
  
  constant self  : Fuse'0.t_Fuse i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 26] (self : Fuse'0.t_Fuse i) : ()
  
  goal vc_produces_refl : ([%#sfuse0] inv'0 self)  -> ([%#sfuse1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603__produces_trans [#"../../../creusot-contracts/src/std/iter/fuse.rs" 54 4 54 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type i
  
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 48 15 48 21
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 49 15 49 21
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 50 15 50 21
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 51 15 51 32
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 52 15 52 32
  let%span sfuse5 = "../../../creusot-contracts/src/std/iter/fuse.rs" 53 14 53 42
  let%span sfuse6 = "../../../creusot-contracts/src/std/iter/fuse.rs" 30 12 36 13
  let%span sfuse7 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 39
  let%span sfuse8 = "../../../creusot-contracts/src/std/iter/fuse.rs" 11 20 11 26
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option i [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter11] inv'2 a)
   -> ([%#siter12] inv'2 b)
   -> ([%#siter13] inv'2 c)
   -> ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter9] inv'2 self)
   -> ([%#siter10] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use T_core__iter__adapters__fuse__Fuse as Fuse'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Fuse'0.t_Fuse i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fuse'0.t_Fuse i [inv'0 x] . inv'0 x
  = match x with
    | Fuse'0.C_Fuse iter -> inv'1 iter
    end
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : Fuse'0.t_Fuse i) : Option'0.t_Option i
    
  
  axiom view'0_spec : forall self : Fuse'0.t_Fuse i . [%#sfuse7] inv'0 self  -> inv'1 (view'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 28 4 28 65] (self : Fuse'0.t_Fuse i) (prod : Seq.seq t_Item'0) (other : Fuse'0.t_Fuse i)
    
   =
    [%#sfuse6] match view'0 self with
      | Option'0.C_None -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | Option'0.C_Some i -> match view'0 other with
        | Option'0.C_Some i2 -> produces'1 i prod i2
        | Option'0.C_None -> false
        end
      end
  
  constant a  : Fuse'0.t_Fuse i
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : Fuse'0.t_Fuse i
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : Fuse'0.t_Fuse i
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/fuse.rs" 54 4 54 90] (a : Fuse'0.t_Fuse i) (ab : Seq.seq t_Item'0) (b : Fuse'0.t_Fuse i) (bc : Seq.seq t_Item'0) (c : Fuse'0.t_Fuse i) : ()
    
  
  goal vc_produces_trans : ([%#sfuse4] produces'0 b bc c)
   -> ([%#sfuse3] produces'0 a ab b)
   -> ([%#sfuse2] inv'0 c)
   -> ([%#sfuse1] inv'0 b)  -> ([%#sfuse0] inv'0 a)  -> ([%#sfuse5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__map__Map
  type t_Map 'i 'f =
    | C_Map 'i 'f
  
  let rec t_Map < 'i > < 'f > (input:t_Map 'i 'f) (ret  (iter:'i) (f:'f))= any
    [ good (iter:'i) (f:'f)-> {C_Map iter f = input} (! ret {iter} {f}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791__produces_refl [#"../../../creusot-contracts/src/std/iter/map.rs" 85 4 85 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type b
  
  type i
  
  type f
  
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 83 15 83 24
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 84 14 84 45
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 66 12 77 64
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 26 14 26 39
  let%span smap4 = "../../../creusot-contracts/src/std/iter/map.rs" 28 8 28 14
  let%span smap5 = "../../../creusot-contracts/src/std/iter/map.rs" 18 14 18 39
  let%span smap6 = "../../../creusot-contracts/src/std/iter/map.rs" 20 8 20 14
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 104 15 104 48
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 105 14 105 35
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 29
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 118 15 118 26
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 119 14 119 28
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 125 14 125 133
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter20 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter21 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq22 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed23 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant24 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  use prelude.prelude.Borrow
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed f) =
    [%#sinvariant24] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed f [inv'7 x] . inv'7 x = invariant'4 x
  
  type t_Item'0
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed23] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed f) =
    [%#sboxed23] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed f [inv'5 x] . inv'5 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter16] inv'3 a)
   -> ([%#siter17] inv'3 b)
   -> ([%#siter18] inv'3 c)
   -> ([%#siter19] produces'1 a ab b)
   -> ([%#siter20] produces'1 b bc c)  -> ([%#siter21] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter14] inv'3 self)
   -> ([%#siter15] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq22] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq (borrowed f)) =
    [%#sseq22] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed f))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed f) [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : t_Item'0) (_3 : b)
    
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t_Item'0) (_3 : b)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 126 4 126 55] (self : f) (args : t_Item'0) (res : b) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : f, args : t_Item'0, res : b . [%#sops13] postcondition_once'0 self args res
  = (exists s : borrowed f . s.current = self /\ postcondition_mut'0 s args res /\ resolve'0 s.final)
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 120 4 120 43] (self : f) (b : f) (c : f) : ()
  
  axiom unnest_trans'0_spec : forall self : f, b : f, c : f . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : f) : ()
  
  axiom unnest_refl'0_spec : forall self : f . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self : borrowed f) (args : t_Item'0) (res : b) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : borrowed f, args : t_Item'0, res : b . ([%#sops7] postcondition_mut'0 self args res)
   -> ([%#sops8] unnest'0 self.current self.final)
  
  use T_core__iter__adapters__map__Map as Map'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Map'0.t_Map i f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Map'0.t_Map i f [inv'0 x] . inv'0 x
  = match x with
    | Map'0.C_Map iter f -> inv'3 iter /\ inv'4 f
    end
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 19 4 19 22] (self : Map'0.t_Map i f) : i
  
  axiom iter'0_spec : forall self : Map'0.t_Map i f . [%#smap5] inv'0 self  -> inv'3 (iter'0 self)
  
  use seq.Seq
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 27 4 27 22] (self : Map'0.t_Map i f) : f
  
  axiom func'0_spec : forall self : Map'0.t_Map i f . [%#smap3] inv'0 self  -> inv'4 (func'0 self)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 64 4 64 67] (self : Map'0.t_Map i f) (visited : Seq.seq b) (succ : Map'0.t_Map i f)
    
   =
    [%#smap2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed f) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i) (Seq.get visited i))))
  
  use seq.Seq
  
  constant self  : Map'0.t_Map i f
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/map.rs" 85 4 85 26] (self : Map'0.t_Map i f) : ()
  
  goal vc_produces_refl : ([%#smap0] inv'0 self)  -> ([%#smap1] produces'0 self (Seq.empty  : Seq.seq b) self)
end
module T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 3 0 3 26]
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv 'i 'b 'f =
    | C_MapInv 'i 'f (Snapshot.snap_ty (Seq.seq 'b))
  
  let rec t_MapInv < 'i > < 'b > < 'f > (input:t_MapInv 'i 'b 'f) (ret  (iter:'i) (func:'f) (produced:Snapshot.snap_ty (Seq.seq 'b)))= any
    [ good (iter:'i) (func:'f) (produced:Snapshot.snap_ty (Seq.seq 'b))-> {C_MapInv iter func produced = input}
      (! ret {iter} {func} {produced}) ]
    
  
  function t_MapInv__func (self : t_MapInv 'i 'b 'f) : 'f =
    match self with
      | C_MapInv _ a _ -> a
      end
  
  function t_MapInv__produced (self : t_MapInv 'i 'b 'f) : Snapshot.snap_ty (Seq.seq 'b) =
    match self with
      | C_MapInv _ _ a -> a
      end
  
  function t_MapInv__iter (self : t_MapInv 'i 'b 'f) : 'i =
    match self with
      | C_MapInv a _ _ -> a
      end
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4413682431414748756__next [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 101 4 101 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type i
  
  type b
  
  type f
  
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 102 39 102 58
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 105 16 105 76
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 106 31 106 71
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 110 38 110 88
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 111 32 111 63
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 116 32 116 56
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 101 17 101 21
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 97 14 100 5
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 101 26 101 44
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 163 27 163 52
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  let%span smap_inv12 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 177 15 177 24
  let%span smap_inv13 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 178 15 178 21
  let%span smap_inv14 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 179 15 179 21
  let%span smap_inv15 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 180 15 180 21
  let%span smap_inv16 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 181 15 181 24
  let%span smap_inv17 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 182 4 182 60
  let%span smap_inv18 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 183 15 183 30
  let%span smap_inv19 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 184 15 184 57
  let%span smap_inv20 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 185 14 185 74
  let%span smap_inv21 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 186 14 186 75
  let%span smap_inv22 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 188 8 193 9
  let%span smap_inv23 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 200 14 200 68
  let%span smap_inv24 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 203 12 208 67
  let%span smap_inv25 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv26 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 137 14 137 81
  let%span smap_inv27 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 88
  let%span smap_inv28 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 128 12 130 63
  let%span sseq29 = "../../../creusot-contracts/src/logic/seq.rs" 151 8 151 27
  let%span smap_inv30 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 45 8 58 9
  let%span sresolve31 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span smap_inv32 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 25 15 25 24
  let%span smap_inv33 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 26 14 26 45
  let%span smap_inv34 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 4 23 10
  let%span smap_inv35 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 21
  let%span smap_inv36 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 34 15 34 21
  let%span smap_inv37 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 35 15 35 21
  let%span smap_inv38 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 36 15 36 32
  let%span smap_inv39 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 37 15 37 32
  let%span smap_inv40 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 38 14 38 42
  let%span smap_inv41 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 10
  let%span siter42 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter43 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter44 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter45 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter46 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter47 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter48 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter49 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops50 = "../../../creusot-contracts/src/std/ops.rs" 104 15 104 48
  let%span sops51 = "../../../creusot-contracts/src/std/ops.rs" 105 14 105 35
  let%span sops52 = "../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops53 = "../../../creusot-contracts/src/std/ops.rs" 117 15 117 29
  let%span sops54 = "../../../creusot-contracts/src/std/ops.rs" 118 15 118 26
  let%span sops55 = "../../../creusot-contracts/src/std/ops.rs" 119 14 119 28
  let%span sops56 = "../../../creusot-contracts/src/std/ops.rs" 125 14 125 133
  let%span smap_inv57 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 158 71
  let%span sinvariant58 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span smap_inv59 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 85 12 87 73
  let%span sseq60 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span smap_inv61 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 166 12 170 47
  let%span sboxed62 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  predicate invariant'7 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed f) =
    [%#sboxed62] inv'6 self
  
  predicate inv'14 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'10 [@rewrite] : forall x : borrowed f [inv'14 x] . inv'14 x = invariant'7 x
  
  type t_Item'0
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed62] inv'10 self
  
  predicate inv'13 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Item'0 [inv'13 x] . inv'13 x = invariant'6 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'5 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq (borrowed f)) =
    [%#sseq60] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'14 (Seq.get self i)
  
  predicate inv'12 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed f))
  
  axiom inv_axiom'8 [@rewrite] : forall x : Seq.seq (borrowed f) [inv'12 x] . inv'12 x = invariant'5 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'4 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq60] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'11 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'11 x] . inv'11 x = invariant'4 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  use prelude.prelude.Snapshot
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  use seq.Seq
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 126 4 126 78] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv28] forall e : t_Item'0, i : i . inv'10 e /\ inv'0 i /\ produces'0 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (_3 : b)
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : b)
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 49] (iter : i) (func : f) =
    [%#smap_inv57] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'11 s
    /\ inv'10 e1 /\ inv'10 e2 /\ inv'6 f /\ inv'8 b /\ inv'0 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f (e1, Snapshot.new s) b  -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  use seq.Seq
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 73] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv27] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'11 s
    /\ inv'10 e1 /\ inv'10 e2 /\ inv'6 f /\ inv'8 b /\ inv'0 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f (e1, Snapshot.new (Seq.(++) produced s)) b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : i, func : f, produced : Seq.seq t_Item'0 . [%#smap_inv26] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  use prelude.prelude.Snapshot
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed i)
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 164 4 164 33] (_1 : ()) =
    [%#smap_inv61] forall iter : borrowed i, func : f . inv'4 iter /\ inv'1 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as MapInv'0
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 83 4 83 30] (self : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv59] reinitialize'0 ()
    /\ preservation_inv'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
    /\ next_precondition'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : MapInv'0.t_MapInv i t_Item'0 f)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MapInv'0.t_MapInv i t_Item'0 f [inv'9 x] . inv'9 x
  = (invariant'3 x
  /\ match x with
    | MapInv'0.C_MapInv iter func produced -> inv'0 iter /\ inv'1 func
    end)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (_3 : b)
    
  
  function fn_mut_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 126 4 126 55] (self : f) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : b) : ()
    
  
  axiom fn_mut_once'0_spec : forall self : f, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : b . [%#sops56] postcondition_once'0 self args res
  = (exists s : borrowed f . s.current = self /\ postcondition_mut'0 s args res /\ resolve'2 s.final)
  
  function unnest_trans'0 [#"../../../creusot-contracts/src/std/ops.rs" 120 4 120 43] (self : f) (b : f) (c : f) : ()
  
  axiom unnest_trans'0_spec : forall self : f, b : f, c : f . ([%#sops53] unnest'0 self b)
   -> ([%#sops54] unnest'0 b c)  -> ([%#sops55] unnest'0 self c)
  
  function unnest_refl'0 [#"../../../creusot-contracts/src/std/ops.rs" 112 4 112 24] (self : f) : ()
  
  axiom unnest_refl'0_spec : forall self : f . [%#sops52] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 106 4 106 73] (self : borrowed f) (args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (res : b) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : borrowed f, args : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)), res : b . ([%#sops50] postcondition_mut'0 self args res)
   -> ([%#sops51] unnest'0 self.current self.final)
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  axiom inv_axiom'5 [@rewrite] : forall x : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)) [inv'7 x] . inv'7 x
  = (let (a, b) = x in inv'10 a)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed f) =
    [%#sinvariant58] inv'1 self.current /\ inv'1 self.final
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed f [inv'6 x] . inv'6 x = invariant'2 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t_Item'0 [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'1_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter44] inv'0 a)
   -> ([%#siter45] inv'0 b)
   -> ([%#siter46] inv'0 c)
   -> ([%#siter47] produces'0 a ab b)
   -> ([%#siter48] produces'0 b bc c)  -> ([%#siter49] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'1_spec : forall self : i . ([%#siter42] inv'0 self)
   -> ([%#siter43] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed i) =
    [%#sinvariant58] inv'0 self.current /\ inv'0 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed i [inv'4 x] . inv'4 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option b)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option b [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'8 a_0
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  predicate produces'1 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 44 4 44 67] (self : MapInv'0.t_MapInv i t_Item'0 f) (visited : Seq.seq b) (succ : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv30] unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ)
    /\ (exists fs : Seq.seq (borrowed f) . inv'12 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'11 s
    /\ Seq.length s = Seq.length visited
    /\ produces'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) s (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    else
      (Seq.get fs 0).current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      /\ (Seq.get fs (Seq.length visited - 1)).final
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i))) (Seq.get visited i))))
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 39 4 39 90] (a : MapInv'0.t_MapInv i t_Item'0 f) (ab : Seq.seq b) (b : MapInv'0.t_MapInv i t_Item'0 f) (bc : Seq.seq b) (c : MapInv'0.t_MapInv i t_Item'0 f) : ()
    
   =
    [%#smap_inv41] ()
  
  axiom produces_trans'0_spec : forall a : MapInv'0.t_MapInv i t_Item'0 f, ab : Seq.seq b, b : MapInv'0.t_MapInv i t_Item'0 f, bc : Seq.seq b, c : MapInv'0.t_MapInv i t_Item'0 f . ([%#smap_inv35] inv'9 a)
   -> ([%#smap_inv36] inv'9 b)
   -> ([%#smap_inv37] inv'9 c)
   -> ([%#smap_inv38] produces'1 a ab b)
   -> ([%#smap_inv39] produces'1 b bc c)  -> ([%#smap_inv40] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 26] (self : MapInv'0.t_MapInv i t_Item'0 f) : ()
    
   =
    [%#smap_inv34] ()
  
  axiom produces_refl'0_spec : forall self : MapInv'0.t_MapInv i t_Item'0 f . ([%#smap_inv32] inv'9 self)
   -> ([%#smap_inv33] produces'1 self (Seq.empty  : Seq.seq b) self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    [%#sinvariant58] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (MapInv'0.t_MapInv i t_Item'0 f) [inv'2 x] . inv'2 x
  = invariant'0 x
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    [%#smap_inv25] Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self.final)
    = (Seq.empty  : Seq.seq t_Item'0)
    /\ completed'1 (Borrow.borrow_logic (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.current) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.final) (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.current
    = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.final
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    [%#sresolve31] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    resolve'1 _1
  
  use seq.Seq
  
  predicate produces_one'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 201 4 201 57] (self : MapInv'0.t_MapInv i t_Item'0 f) (visited : b) (succ : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv24] exists f : borrowed f, e : t_Item'0 . inv'6 f
    /\ inv'10 e
    /\ f.current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
    /\ f.final = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    /\ produces'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (Seq.singleton e) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.snoc (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) e
    /\ precondition'0 f.current (e, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)
    /\ postcondition_mut'0 f (e, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self) visited
  
  axiom produces_one'0_spec : forall self : MapInv'0.t_MapInv i t_Item'0 f, visited : b, succ : MapInv'0.t_MapInv i t_Item'0 f . [%#smap_inv23] produces_one'0 self visited succ
  = produces'1 self (Seq.singleton visited) succ
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function push_front'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/seq.rs" 150 4 150 41] (self : Seq.seq t_Item'0) (x : t_Item'0) : Seq.seq t_Item'0
    
   =
    [%#sseq29] Seq.cons x self
  
  function produces_one_invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 187 4 187 73] (self : MapInv'0.t_MapInv i t_Item'0 f) (e : t_Item'0) (r : b) (f : borrowed f) (iter : i) : ()
    
  
  axiom produces_one_invariant'0_spec : forall self : MapInv'0.t_MapInv i t_Item'0 f, e : t_Item'0, r : b, f : borrowed f, iter : i . ([%#smap_inv12] inv'9 self)
   -> ([%#smap_inv13] inv'10 e)
   -> ([%#smap_inv14] inv'8 r)
   -> ([%#smap_inv15] inv'6 f)
   -> ([%#smap_inv16] inv'0 iter)
   -> ([%#smap_inv17] produces'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (Seq.singleton e) iter)
   -> ([%#smap_inv18] f.current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self)
   -> ([%#smap_inv19] postcondition_mut'0 f (e, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self) r)
   -> ([%#smap_inv21] next_precondition'0 iter f.final (Seq.snoc (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) e))
  && ([%#smap_inv20] preservation_inv'0 iter f.final (Seq.snoc (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) e))
  
  let rec call_mut'0 (self:borrowed f) (args:(t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (return'  (ret:b))= {[@expl:precondition] inv'7 args}
    {[@expl:precondition] inv'6 self}
    {[@expl:precondition] [%#sops10] precondition'0 self.current args}
    any [ return' (result:b)-> {inv'8 result} {[%#sops11] postcondition_mut'0 self args result} (! return' {result}) ] 
  
  let rec next'0 (self:borrowed i) (return'  (ret:Option'0.t_Option t_Item'0))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option t_Item'0)-> {inv'5 result}
      {[%#siter9] match result with
        | Option'0.C_None -> completed'1 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec next (self:borrowed (MapInv'0.t_MapInv i t_Item'0 f)) (return'  (ret:Option'0.t_Option b))= {[%#smap_inv6] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv0] Snapshot.new self.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MapInv'0.t_MapInv <i> <t_Item'0> <f> {self.current}
          (fun (riter'0:i) (rfunc'0:f) (rproduced'0:Snapshot.snap_ty (Seq.seq t_Item'0)) ->
            {inv'0 riter'0}
            Borrow.borrow_final <i> {riter'0} {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed i) ->
                 [ &_6 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = MapInv'0.C_MapInv _ret'.final rfunc'0 rproduced'0 ; } ] 
                s1))
      | s1 = next'0 {_6} (fun (_ret':Option'0.t_Option t_Item'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_5 = Option'0.C_None } (! bb5) | br1 (a:t_Item'0)-> {_5 = Option'0.C_Some a} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = Option'0.v_Some <t_Item'0> {_5} (fun (r0'0:t_Item'0) ->  [ &v <- r0'0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv1] precondition'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.current) (v, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self.current)}
        s2
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = 
        [ &produced <- [%#smap_inv2] Snapshot.new (Seq.snoc (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self.current)) v) ]
        
        s1
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = MapInv'0.t_MapInv <i> <t_Item'0> <f> {self.current}
          (fun (riter'0:i) (rfunc'0:f) (rproduced'0:Snapshot.snap_ty (Seq.seq t_Item'0)) ->
            {inv'1 rfunc'0}
            Borrow.borrow_final <f> {rfunc'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed f) ->
                 [ &_14 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self <- { self with current = MapInv'0.C_MapInv riter'0 _ret'.final rproduced'0 ; } ] 
                s1))
      | s1 = MapInv'0.t_MapInv <i> <t_Item'0> <f> {self.current}
          (fun (riter'1:i) (rfunc'1:f) (rproduced'1:Snapshot.snap_ty (Seq.seq t_Item'0)) ->
             [ &_15 <- (v, rproduced'1) ] 
            s2)
      | s2 = call_mut'0 {_14} {_15} (fun (_ret':b) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = bb10
    | bb10 = s0
      [ s0 = MapInv'0.t_MapInv <i> <t_Item'0> <f> {self.current}
          (fun (riter'0:i) (rfunc'0:f) (rproduced'0:Snapshot.snap_ty (Seq.seq t_Item'0)) ->
             [ &self <- { self with current = MapInv'0.C_MapInv riter'0 rfunc'0 produced ; } ] 
            s1)
      | s1 =  [ &_19 <- [%#smap_inv3] Snapshot.new (let _ = () in ()) ] s2
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 = {[@expl:assertion] [%#smap_inv4] produces_one'0 (Snapshot.inner old_self) r self.current} s1 | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- Option'0.C_Some r ] s3
      | s3 = bb13 ]
      
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv5] Snapshot.new (Seq.empty  : Seq.seq t_Item'0) ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = MapInv'0.t_MapInv <i> <t_Item'0> <f> {self.current}
          (fun (riter'0:i) (rfunc'0:f) (rproduced'0:Snapshot.snap_ty (Seq.seq t_Item'0)) ->
             [ &self <- { self with current = MapInv'0.C_MapInv riter'0 rfunc'0 _24 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- Option'0.C_None ] s4
      | s4 = bb17 ]
      
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option b = any_l ()
    | & self : borrowed (MapInv'0.t_MapInv i t_Item'0 f) = self
    | & old_self : Snapshot.snap_ty (MapInv'0.t_MapInv i t_Item'0 f) = any_l ()
    | & _5 : Option'0.t_Option t_Item'0 = any_l ()
    | & _6 : borrowed i = any_l ()
    | & v : t_Item'0 = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & r : b = any_l ()
    | & _14 : borrowed f = any_l ()
    | & _15 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)) = any_l ()
    | & _19 : Snapshot.snap_ty () = any_l ()
    | & _24 : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l () ]
    
    [ return' (result:Option'0.t_Option b)-> {[@expl:postcondition] [%#smap_inv8] inv'3 result}
      {[@expl:postcondition] [%#smap_inv7] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces_one'0 self.current v self.final
        end}
      (! return' {result}) ]
    
end
module T_core__option__Item
  use T_core__option__Option as Option'0
  
  type t_Item 'a =
    | C_Item (Option'0.t_Option 'a)
  
  let rec t_Item < 'a > (input:t_Item 'a) (ret  (opt:Option'0.t_Option 'a))= any
    [ good (opt:Option'0.t_Option 'a)-> {C_Item opt = input} (! ret {opt}) ]
    
end
module T_core__option__IntoIter
  use T_core__option__Item as Item'0
  
  type t_IntoIter 'a =
    | C_IntoIter (Item'0.t_Item 'a)
  
  let rec t_IntoIter < 'a > (input:t_IntoIter 'a) (ret  (inner:Item'0.t_Item 'a))= any
    [ good (inner:Item'0.t_Item 'a)-> {C_IntoIter inner = input} (! ret {inner}) ]
    
end
module T_core__iter__sources__once__Once
  use T_core__option__IntoIter as IntoIter'0
  
  type t_Once 't =
    | C_Once (IntoIter'0.t_IntoIter 't)
  
  let rec t_Once < 't > (input:t_Once 't) (ret  (inner:IntoIter'0.t_IntoIter 't))= any
    [ good (inner:IntoIter'0.t_IntoIter 't)-> {C_Once inner = input} (! ret {inner}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_refl [#"../../../creusot-contracts/src/std/iter/once.rs" 34 4 34 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  type t
  
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 32 15 32 24
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 33 14 33 45
  let%span sonce2 = "../../../creusot-contracts/src/std/iter/once.rs" 25 12 26 106
  let%span sonce3 = "../../../creusot-contracts/src/std/iter/once.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Item'0.t_Item t [inv'3 x] . inv'3 x
  = match x with
    | Item'0.C_Item opt -> inv'4 opt
    end
  
  use T_core__option__IntoIter as IntoIter'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : IntoIter'0.t_IntoIter t [inv'2 x] . inv'2 x
  = match x with
    | IntoIter'0.C_IntoIter inner -> inv'3 inner
    end
  
  use T_core__iter__sources__once__Once as Once'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Once'0.t_Once t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Once'0.t_Once t [inv'0 x] . inv'0 x
  = match x with
    | Once'0.C_Once inner -> inv'2 inner
    end
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 9 4 9 30] (self : Once'0.t_Once t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 23 4 23 64] (self : Once'0.t_Once t) (visited : Seq.seq t) (o : Once'0.t_Once t)
    
   =
    [%#sonce2] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . inv'1 e
    /\ view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant self  : Once'0.t_Once t
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/once.rs" 34 4 34 26] (self : Once'0.t_Once t) : ()
  
  goal vc_produces_refl : ([%#sonce0] inv'0 self)  -> ([%#sonce1] produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646__produces_trans [#"../../../creusot-contracts/src/std/iter/once.rs" 44 4 44 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  type t
  
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 38 15 38 21
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 39 15 39 21
  let%span sonce2 = "../../../creusot-contracts/src/std/iter/once.rs" 40 15 40 21
  let%span sonce3 = "../../../creusot-contracts/src/std/iter/once.rs" 41 15 41 32
  let%span sonce4 = "../../../creusot-contracts/src/std/iter/once.rs" 42 15 42 32
  let%span sonce5 = "../../../creusot-contracts/src/std/iter/once.rs" 43 14 43 42
  let%span sonce6 = "../../../creusot-contracts/src/std/iter/once.rs" 25 12 26 106
  let%span sonce7 = "../../../creusot-contracts/src/std/iter/once.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Item'0.t_Item t [inv'3 x] . inv'3 x
  = match x with
    | Item'0.C_Item opt -> inv'4 opt
    end
  
  use T_core__option__IntoIter as IntoIter'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : IntoIter'0.t_IntoIter t [inv'2 x] . inv'2 x
  = match x with
    | IntoIter'0.C_IntoIter inner -> inv'3 inner
    end
  
  use T_core__iter__sources__once__Once as Once'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Once'0.t_Once t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Once'0.t_Once t [inv'0 x] . inv'0 x
  = match x with
    | Once'0.C_Once inner -> inv'2 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 9 4 9 30] (self : Once'0.t_Once t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 23 4 23 64] (self : Once'0.t_Once t) (visited : Seq.seq t) (o : Once'0.t_Once t)
    
   =
    [%#sonce6] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . inv'1 e
    /\ view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant a  : Once'0.t_Once t
  
  constant ab  : Seq.seq t
  
  constant b  : Once'0.t_Once t
  
  constant bc  : Seq.seq t
  
  constant c  : Once'0.t_Once t
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/once.rs" 44 4 44 90] (a : Once'0.t_Once t) (ab : Seq.seq t) (b : Once'0.t_Once t) (bc : Seq.seq t) (c : Once'0.t_Once t) : ()
    
  
  goal vc_produces_trans : ([%#sonce4] produces'0 b bc c)
   -> ([%#sonce3] produces'0 a ab b)
   -> ([%#sonce2] inv'0 c)
   -> ([%#sonce1] inv'0 b)  -> ([%#sonce0] inv'0 a)  -> ([%#sonce5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__ops__range__Range
  type t_Range 'idx =
    | C_Range 'idx 'idx
  
  let rec t_Range < 'idx > (input:t_Range 'idx) (ret  (start:'idx) (end':'idx))= any
    [ good (start:'idx) (end':'idx)-> {C_Range start end' = input} (! ret {start} {end'}) ]
    
  
  function t_Range__end (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range _ a -> a
      end
  
  function t_Range__start (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range a _ -> a
      end
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : idx)
  
  use T_core__ops__range__Range as Range'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Range'0.t_Range idx)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Range'0.t_Range idx [inv'0 x] . inv'0 x
  = match x with
    | Range'0.C_Range start end' -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : Range'0.t_Range idx) (visited : Seq.seq idx) (o : Range'0.t_Range idx)
    
   =
    [%#srange2] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  use seq.Seq
  
  constant self  : Range'0.t_Range idx
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26] (self : Range'0.t_Range idx) : ()
    
  
  goal vc_produces_refl : ([%#srange0] inv'0 self)  -> ([%#srange1] produces'0 self (Seq.empty  : Seq.seq idx) self)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777__produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange5 = "../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span srange6 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : idx)
  
  use T_core__ops__range__Range as Range'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Range'0.t_Range idx)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Range'0.t_Range idx [inv'0 x] . inv'0 x
  = match x with
    | Range'0.C_Range start end' -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : Range'0.t_Range idx) (visited : Seq.seq idx) (o : Range'0.t_Range idx)
    
   =
    [%#srange6] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  constant a  : Range'0.t_Range idx
  
  constant ab  : Seq.seq idx
  
  constant b  : Range'0.t_Range idx
  
  constant bc  : Seq.seq idx
  
  constant c  : Range'0.t_Range idx
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90] (a : Range'0.t_Range idx) (ab : Seq.seq idx) (b : Range'0.t_Range idx) (bc : Seq.seq idx) (c : Range'0.t_Range idx) : ()
    
  
  goal vc_produces_trans : ([%#srange4] produces'0 b bc c)
   -> ([%#srange3] produces'0 a ab b)
   -> ([%#srange2] inv'0 c)
   -> ([%#srange1] inv'0 b)  -> ([%#srange0] inv'0 a)  -> ([%#srange5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__ops__range__RangeInclusive
  type t_RangeInclusive 'idx =
    | C_RangeInclusive 'idx 'idx bool
  
  let rec t_RangeInclusive < 'idx > (input:t_RangeInclusive 'idx) (ret  (start:'idx) (end':'idx) (exhausted:bool))= any
    [ good (start:'idx) (end':'idx) (exhausted:bool)-> {C_RangeInclusive start end' exhausted = input}
      (! ret {start} {end'} {exhausted}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92]
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span sops1 = "../../../creusot-contracts/src/std/ops.rs" 209 14 209 86
  
  use T_core__ops__range__RangeInclusive as RangeInclusive'0
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 202 27] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 29] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 210 4 213 35] (self : RangeInclusive'0.t_RangeInclusive idx) : bool
    
  
  axiom is_empty_log'0_spec : forall self : RangeInclusive'0.t_RangeInclusive idx . [%#sops1] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  constant r  : RangeInclusive'0.t_RangeInclusive idx
  
  function range_inclusive_len [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : RangeInclusive'0.t_RangeInclusive idx) : int
    
  
  goal vc_range_inclusive_len : ([%#sops1] not is_empty_log'0 r
   -> deep_model'0 (start_log'0 r) <= deep_model'0 (end_log'0 r))
   -> (if is_empty_log'0 r then
    [%#srange0] is_empty_log'0 r = (0 = 0)
  else
    [%#srange0] is_empty_log'0 r = (deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 81 14 81 45
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 209 14 209 86
  
  use T_core__ops__range__RangeInclusive as RangeInclusive'0
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 29] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use seq.Seq
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 202 27] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 210 4 213 35] (self : RangeInclusive'0.t_RangeInclusive idx) : bool
    
  
  axiom is_empty_log'0_spec : forall self : RangeInclusive'0.t_RangeInclusive idx . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : RangeInclusive'0.t_RangeInclusive idx) : int
    
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : RangeInclusive'0.t_RangeInclusive idx . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : RangeInclusive'0.t_RangeInclusive idx) (visited : Seq.seq idx) (o : RangeInclusive'0.t_RangeInclusive idx)
    
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  constant self  : RangeInclusive'0.t_RangeInclusive idx
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26] (self : RangeInclusive'0.t_RangeInclusive idx) : ()
    
  
  goal vc_produces_refl : [%#srange0] produces'0 self (Seq.empty  : Seq.seq idx) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411__produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 86 15 86 32
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 87 15 87 32
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 88 14 88 42
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange5 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 209 14 209 86
  
  use seq.Seq
  
  use T_core__ops__range__RangeInclusive as RangeInclusive'0
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 29] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use seq.Seq
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 202 27] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 210 4 213 35] (self : RangeInclusive'0.t_RangeInclusive idx) : bool
    
  
  axiom is_empty_log'0_spec : forall self : RangeInclusive'0.t_RangeInclusive idx . [%#sops6] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : RangeInclusive'0.t_RangeInclusive idx) : int
    
   =
    [%#srange5] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : RangeInclusive'0.t_RangeInclusive idx . [%#srange4] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : RangeInclusive'0.t_RangeInclusive idx) (visited : Seq.seq idx) (o : RangeInclusive'0.t_RangeInclusive idx)
    
   =
    [%#srange3] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  constant a  : RangeInclusive'0.t_RangeInclusive idx
  
  constant ab  : Seq.seq idx
  
  constant b  : RangeInclusive'0.t_RangeInclusive idx
  
  constant bc  : Seq.seq idx
  
  constant c  : RangeInclusive'0.t_RangeInclusive idx
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90] (a : RangeInclusive'0.t_RangeInclusive idx) (ab : Seq.seq idx) (b : RangeInclusive'0.t_RangeInclusive idx) (bc : Seq.seq idx) (c : RangeInclusive'0.t_RangeInclusive idx) : ()
    
  
  goal vc_produces_trans : ([%#srange1] produces'0 b bc c)
   -> ([%#srange0] produces'0 a ab b)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__sources__repeat__Repeat
  type t_Repeat 'a =
    | C_Repeat 'a
  
  let rec t_Repeat < 'a > (input:t_Repeat 'a) (ret  (element:'a))= any
    [ good (element:'a)-> {C_Repeat element = input} (! ret {element}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_refl [#"../../../creusot-contracts/src/std/iter/repeat.rs" 34 4 34 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type t
  
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 32 15 32 24
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 33 14 33 45
  let%span srepeat2 = "../../../creusot-contracts/src/std/iter/repeat.rs" 25 12 26 78
  let%span srepeat3 = "../../../creusot-contracts/src/std/iter/repeat.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__iter__sources__repeat__Repeat as Repeat'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Repeat'0.t_Repeat t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Repeat'0.t_Repeat t [inv'0 x] . inv'0 x
  = match x with
    | Repeat'0.C_Repeat element -> inv'1 element
    end
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 9 4 9 22] (self : Repeat'0.t_Repeat t) : t
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 23 4 23 64] (self : Repeat'0.t_Repeat t) (visited : Seq.seq t) (o : Repeat'0.t_Repeat t)
    
   =
    [%#srepeat2] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  constant self  : Repeat'0.t_Repeat t
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/repeat.rs" 34 4 34 26] (self : Repeat'0.t_Repeat t) : ()
    
  
  goal vc_produces_refl : ([%#srepeat0] inv'0 self)  -> ([%#srepeat1] produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629__produces_trans [#"../../../creusot-contracts/src/std/iter/repeat.rs" 44 4 44 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type t
  
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 38 15 38 21
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 39 15 39 21
  let%span srepeat2 = "../../../creusot-contracts/src/std/iter/repeat.rs" 40 15 40 21
  let%span srepeat3 = "../../../creusot-contracts/src/std/iter/repeat.rs" 41 15 41 32
  let%span srepeat4 = "../../../creusot-contracts/src/std/iter/repeat.rs" 42 15 42 32
  let%span srepeat5 = "../../../creusot-contracts/src/std/iter/repeat.rs" 43 14 43 42
  let%span srepeat6 = "../../../creusot-contracts/src/std/iter/repeat.rs" 25 12 26 78
  let%span srepeat7 = "../../../creusot-contracts/src/std/iter/repeat.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__iter__sources__repeat__Repeat as Repeat'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Repeat'0.t_Repeat t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Repeat'0.t_Repeat t [inv'0 x] . inv'0 x
  = match x with
    | Repeat'0.C_Repeat element -> inv'1 element
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 9 4 9 22] (self : Repeat'0.t_Repeat t) : t
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 23 4 23 64] (self : Repeat'0.t_Repeat t) (visited : Seq.seq t) (o : Repeat'0.t_Repeat t)
    
   =
    [%#srepeat6] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  constant a  : Repeat'0.t_Repeat t
  
  constant ab  : Seq.seq t
  
  constant b  : Repeat'0.t_Repeat t
  
  constant bc  : Seq.seq t
  
  constant c  : Repeat'0.t_Repeat t
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/repeat.rs" 44 4 44 90] (a : Repeat'0.t_Repeat t) (ab : Seq.seq t) (b : Repeat'0.t_Repeat t) (bc : Seq.seq t) (c : Repeat'0.t_Repeat t) : ()
    
  
  goal vc_produces_trans : ([%#srepeat4] produces'0 b bc c)
   -> ([%#srepeat3] produces'0 a ab b)
   -> ([%#srepeat2] inv'0 c)
   -> ([%#srepeat1] inv'0 b)  -> ([%#srepeat0] inv'0 a)  -> ([%#srepeat5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__skip__Skip
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Skip 'i =
    | C_Skip 'i usize
  
  let rec t_Skip < 'i > (input:t_Skip 'i) (ret  (iter:'i) (n:usize))= any
    [ good (iter:'i) (n:usize)-> {C_Skip iter n = input} (! ret {iter} {n}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502__produces_refl [#"../../../creusot-contracts/src/std/iter/skip.rs" 78 4 78 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type i
  
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 76 15 76 24
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 77 14 77 45
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 65 12 70 74
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip4 = "../../../creusot-contracts/src/std/iter/skip.rs" 25 20 25 26
  let%span sskip5 = "../../../creusot-contracts/src/std/iter/skip.rs" 15 14 15 39
  let%span sskip6 = "../../../creusot-contracts/src/std/iter/skip.rs" 17 20 17 26
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq15 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed16 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed16] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter9] inv'2 a)
   -> ([%#siter10] inv'2 b)
   -> ([%#siter11] inv'2 c)
   -> ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter7] inv'2 self)
   -> ([%#siter8] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq15] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__skip__Skip as Skip'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Skip'0.t_Skip i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Skip'0.t_Skip i [inv'0 x] . inv'0 x
  = match x with
    | Skip'0.C_Skip iter n -> inv'2 iter
    end
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 16 4 16 22] (self : Skip'0.t_Skip i) : i
  
  axiom iter'0_spec : forall self : Skip'0.t_Skip i . [%#sskip5] inv'0 self  -> inv'2 (iter'0 self)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self : Skip'0.t_Skip i) : int
  
  axiom n'0_spec : forall self : Skip'0.t_Skip i . [%#sskip3] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 63 4 63 64] (self : Skip'0.t_Skip i) (visited : Seq.seq t_Item'0) (o : Skip'0.t_Skip i)
    
   =
    [%#sskip2] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant self  : Skip'0.t_Skip i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/skip.rs" 78 4 78 26] (self : Skip'0.t_Skip i) : ()
  
  goal vc_produces_refl : ([%#sskip0] inv'0 self)  -> ([%#sskip1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module T_core__iter__adapters__take__Take
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Take 'i =
    | C_Take 'i usize
  
  let rec t_Take < 'i > (input:t_Take 'i) (ret  (iter:'i) (n:usize))= any
    [ good (iter:'i) (n:usize)-> {C_Take iter n = input} (! ret {iter} {n}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_refl [#"../../../creusot-contracts/src/std/iter/take.rs" 77 4 77 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  type i
  
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 75 15 75 24
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 76 14 76 45
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 69 12 69 88
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 34 14 34 50
  let%span stake4 = "../../../creusot-contracts/src/std/iter/take.rs" 36 20 36 26
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 18 14 18 39
  let%span stake6 = "../../../creusot-contracts/src/std/iter/take.rs" 20 20 20 26
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter9] inv'1 a)
   -> ([%#siter10] inv'1 b)
   -> ([%#siter11] inv'1 c)
   -> ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter7] inv'1 self)
   -> ([%#siter8] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use T_core__iter__adapters__take__Take as Take'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Take'0.t_Take i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Take'0.t_Take i [inv'0 x] . inv'0 x
  = match x with
    | Take'0.C_Take iter n -> inv'1 iter
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 19 4 19 22] (self : Take'0.t_Take i) : i
  
  axiom iter'0_spec : forall self : Take'0.t_Take i . [%#stake5] inv'0 self  -> inv'1 (iter'0 self)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 35 4 35 21] (self : Take'0.t_Take i) : int
  
  axiom n'0_spec : forall self : Take'0.t_Take i . [%#stake3] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 67 4 67 64] (self : Take'0.t_Take i) (visited : Seq.seq t_Item'0) (o : Take'0.t_Take i)
    
   =
    [%#stake2] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant self  : Take'0.t_Take i
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/take.rs" 77 4 77 26] (self : Take'0.t_Take i) : ()
  
  goal vc_produces_refl : ([%#stake0] inv'0 self)  -> ([%#stake1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022__produces_trans [#"../../../creusot-contracts/src/std/iter/take.rs" 87 4 87 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  type i
  
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 81 15 81 21
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 82 15 82 21
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 83 15 83 21
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 84 15 84 32
  let%span stake4 = "../../../creusot-contracts/src/std/iter/take.rs" 85 15 85 32
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 86 14 86 42
  let%span stake6 = "../../../creusot-contracts/src/std/iter/take.rs" 69 12 69 88
  let%span stake7 = "../../../creusot-contracts/src/std/iter/take.rs" 34 14 34 50
  let%span stake8 = "../../../creusot-contracts/src/std/iter/take.rs" 36 20 36 26
  let%span stake9 = "../../../creusot-contracts/src/std/iter/take.rs" 18 14 18 39
  let%span stake10 = "../../../creusot-contracts/src/std/iter/take.rs" 20 20 20 26
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
    
  
  axiom produces_trans'0_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter13] inv'1 a)
   -> ([%#siter14] inv'1 b)
   -> ([%#siter15] inv'1 c)
   -> ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : i) : ()
  
  axiom produces_refl'0_spec : forall self : i . ([%#siter11] inv'1 self)
   -> ([%#siter12] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use T_core__iter__adapters__take__Take as Take'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Take'0.t_Take i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Take'0.t_Take i [inv'0 x] . inv'0 x
  = match x with
    | Take'0.C_Take iter n -> inv'1 iter
    end
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 19 4 19 22] (self : Take'0.t_Take i) : i
  
  axiom iter'0_spec : forall self : Take'0.t_Take i . [%#stake9] inv'0 self  -> inv'1 (iter'0 self)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 35 4 35 21] (self : Take'0.t_Take i) : int
  
  axiom n'0_spec : forall self : Take'0.t_Take i . [%#stake7] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 67 4 67 64] (self : Take'0.t_Take i) (visited : Seq.seq t_Item'0) (o : Take'0.t_Take i)
    
   =
    [%#stake6] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant a  : Take'0.t_Take i
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : Take'0.t_Take i
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : Take'0.t_Take i
  
  function produces_trans [#"../../../creusot-contracts/src/std/iter/take.rs" 87 4 87 90] (a : Take'0.t_Take i) (ab : Seq.seq t_Item'0) (b : Take'0.t_Take i) (bc : Seq.seq t_Item'0) (c : Take'0.t_Take i) : ()
    
  
  goal vc_produces_trans : ([%#stake4] produces'0 b bc c)
   -> ([%#stake3] produces'0 a ab b)
   -> ([%#stake2] inv'0 c)
   -> ([%#stake1] inv'0 b)  -> ([%#stake0] inv'0 a)  -> ([%#stake5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__iter__adapters__zip__Zip
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Zip 'a 'b =
    | C_Zip 'a 'b usize usize usize
  
  let rec t_Zip < 'a > < 'b > (input:t_Zip 'a 'b) (ret  (a:'a) (b:'b) (index:usize) (len:usize) (a_len:usize))= any
    [ good (a:'a) (b:'b) (index:usize) (len:usize) (a_len:usize)-> {C_Zip a b index len a_len = input}
      (! ret {a} {b} {index} {len} {a_len}) ]
    
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844__produces_refl [#"../../../creusot-contracts/src/std/iter/zip.rs" 59 4 59 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type a
  
  type b
  
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 57 15 57 24
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 58 14 58 45
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 48 12 51 95
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 15 14 15 39
  let%span szip4 = "../../../creusot-contracts/src/std/iter/zip.rs" 17 20 17 26
  let%span szip5 = "../../../creusot-contracts/src/std/iter/zip.rs" 23 14 23 39
  let%span szip6 = "../../../creusot-contracts/src/std/iter/zip.rs" 25 20 25 26
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sseq15 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed16 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'1
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed16] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  type t_Item'0
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed16] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : b) (visited : Seq.seq t_Item'1) (o : b)
    
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : b)
  
  function produces_trans'1 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : b) (ab : Seq.seq t_Item'1) (b : b) (bc : Seq.seq t_Item'1) (c : b) : ()
    
  
  axiom produces_trans'1_spec : forall a : b, ab : Seq.seq t_Item'1, b : b, bc : Seq.seq t_Item'1, c : b . ([%#siter9] inv'4 a)
   -> ([%#siter10] inv'4 b)
   -> ([%#siter11] inv'4 c)
   -> ([%#siter12] produces'2 a ab b)
   -> ([%#siter13] produces'2 b bc c)  -> ([%#siter14] produces'2 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'1 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : b) : ()
  
  axiom produces_refl'1_spec : forall self : b . ([%#siter7] inv'4 self)
   -> ([%#siter8] produces'2 self (Seq.empty  : Seq.seq t_Item'1) self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : a) (visited : Seq.seq t_Item'0) (o : a)
    
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : a)
  
  function produces_trans'0 [#"../../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : a) (ab : Seq.seq t_Item'0) (b : a) (bc : Seq.seq t_Item'0) (c : a) : ()
    
  
  axiom produces_trans'0_spec : forall a : a, ab : Seq.seq t_Item'0, b : a, bc : Seq.seq t_Item'0, c : a . ([%#siter9] inv'3 a)
   -> ([%#siter10] inv'3 b)
   -> ([%#siter11] inv'3 c)
   -> ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 [#"../../../creusot-contracts/src/std/iter.rs" 40 4 40 27] (self : a) : ()
  
  axiom produces_refl'0_spec : forall self : a . ([%#siter7] inv'3 self)
   -> ([%#siter8] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'1) =
    [%#sseq15] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq15] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_core__iter__adapters__zip__Zip as Zip'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Zip'0.t_Zip a b)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Zip'0.t_Zip a b [inv'0 x] . inv'0 x
  = match x with
    | Zip'0.C_Zip a b index len a_len -> inv'3 a /\ inv'4 b
    end
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 24 4 24 23] (self : Zip'0.t_Zip a b) : b
  
  axiom iterb'0_spec : forall self : Zip'0.t_Zip a b . [%#szip5] inv'0 self  -> inv'4 (iterb'0 self)
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 16 4 16 23] (self : Zip'0.t_Zip a b) : a
  
  axiom itera'0_spec : forall self : Zip'0.t_Zip a b . [%#szip3] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 45 4 45 64] (self : Zip'0.t_Zip a b) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : Zip'0.t_Zip a b)
    
   =
    [%#szip2] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  constant self  : Zip'0.t_Zip a b
  
  function produces_refl [#"../../../creusot-contracts/src/std/iter/zip.rs" 59 4 59 26] (self : Zip'0.t_Zip a b) : ()
  
  goal vc_produces_refl : ([%#szip0] inv'0 self)
   -> ([%#szip1] produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self)
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 103 16 105 36]
  type t
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 103 43 103 44
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 103 52 103 53
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : ()) (_3 : t)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : ())
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:()) (return'  (ret:t))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops4] precondition'0 self args}
    any [ return' (result:t)-> {inv'2 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body (self_:Option'0.t_Option t) (f:f) (return'  (ret:t))= {[%#soption1] inv'0 f}
    {[%#soption0] inv'1 self_}
    {[%#soption0] self_ = Option'0.C_None  -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
      
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & f : f = f
    | & _7 : () = any_l ()
    | & t : t = any_l () ]
    
    [ return' (result:t)-> {[@expl:postcondition] [%#soption3] inv'2 result}
      {[@expl:postcondition] [%#soption2] match self_ with
        | Option'0.C_None -> postcondition_once'0 f () result
        | Option'0.C_Some t -> result = t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../../creusot-contracts/src/std/option.rs" 131 16 133 37]
  type t
  
  type u
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 123 27 126 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 131 35 131 36
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 127 26 130 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 131 44 131 53
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = (let (a) = x in inv'5 a)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : u)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option u)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option u [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t) (_3 : u)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t)
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:t) (return'  (ret:u))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any [ return' (result:u)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body (self_:Option'0.t_Option t) (f:f) (return'  (ret:Option'0.t_Option u))= {[%#soption2] inv'0 f}
    {[%#soption1] inv'1 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_9 <- (t) ] s2
      | s2 = call_once'0 {f} {_9} (fun (_ret':u) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- Option'0.C_Some _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option u = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & f : f = f
    | & t : t = any_l ()
    | & _7 : u = any_l ()
    | & _9 : t = any_l () ]
    
    [ return' (result:Option'0.t_Option u)-> {[@expl:postcondition] [%#soption4] inv'2 result}
      {[@expl:postcondition] [%#soption3] match self_ with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> exists r : u . result = Option'0.C_Some r /\ postcondition_once'0 f (t) r
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../../creusot-contracts/src/std/option.rs" 149 16 151 33]
  type t
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 140 27 143 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 149 36 149 37
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 145 26 148 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 149 45 149 54
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant6] inv'4 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = (let (a) = x in inv'5 a)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t) (_3 : ())
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:t) (return'  (ret:()))= {[@expl:precondition] inv'2 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any [ return' (result:())-> {inv'3 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body (self_:Option'0.t_Option t) (f:f) (return'  (ret:Option'0.t_Option t))= {[%#soption2] inv'0 f}
    {[%#soption1] inv'1 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_ = Option'0.C_None } (! bb5) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb6) ] 
    | bb6 = s0
      [ s0 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- (_12) ] s3
      | s3 = call_once'0 {f} {_10} (fun (_ret':()) ->  [ &_8 <- _ret' ] s4)
      | s4 = bb8 ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- Option'0.C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option t = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & f : f = f
    | & t : t = any_l ()
    | & _8 : () = any_l ()
    | & _10 : t = any_l ()
    | & _12 : t = any_l () ]
    
    [ return' (result:Option'0.t_Option t)-> {[@expl:postcondition] [%#soption4] inv'1 result}
      {[@expl:postcondition] [%#soption3] match self_ with
        | Option'0.C_None -> true
        | Option'0.C_Some t -> postcondition_once'0 f (t) ()
        end}
      {[@expl:postcondition] [%#soption1] result = self_}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../../creusot-contracts/src/std/option.rs" 166 16 168 37]
  type t
  
  type u
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 158 27 161 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 166 38 166 45
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 166 50 166 51
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 162 26 165 17
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 166 59 166 60
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = (let (a) = x in inv'4 a)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t) (_3 : u)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t)
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : u)
  
  let rec call_once'0 (self:f) (args:t) (return'  (ret:u))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#sops6] precondition'0 self args}
    any [ return' (result:u)-> {inv'0 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : u)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body (self_:Option'0.t_Option t) (default:u) (f:f) (return'  (ret:u))= {[%#soption3] inv'1 f}
    {[%#soption2] inv'0 default}
    {[%#soption1] inv'2 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_9 <- (t) ] s4
      | s4 = call_once'0 {f} {_9} (fun (_ret':u) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : u = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & default : u = default
    | & f : f = f
    | & t : t = any_l ()
    | & _9 : t = any_l () ]
    
    [ return' (result:u)-> {[@expl:postcondition] [%#soption5] inv'0 result}
      {[@expl:postcondition] [%#soption4] match self_ with
        | Option'0.C_None -> result = default
        | Option'0.C_Some t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 183 16 186 37]
  type t
  
  type u
  
  type d
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 175 27 178 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 183 46 183 53
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 183 58 183 59
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 179 26 182 17
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 183 67 183 68
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = (let (a) = x in inv'6 a)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : u)
  
  predicate postcondition_once'1 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t) (_3 : u)
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : d) (_2 : ()) (_3 : u)
  
  predicate precondition'1 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : d) (_2 : ())
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : d)
  
  let rec call_once'1 (self:d) (args:()) (return'  (ret:u))= {[@expl:precondition] inv'5 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops6] precondition'0 self args}
    any [ return' (result:u)-> {inv'3 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:t) (return'  (ret:u))= {[@expl:precondition] inv'4 args}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#sops6] precondition'1 self args}
    any [ return' (result:u)-> {inv'3 result} {[%#sops6] postcondition_once'1 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : d)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body (self_:Option'0.t_Option t) (default:d) (f:f) (return'  (ret:u))= {[%#soption3] inv'1 f}
    {[%#soption2] inv'0 default}
    {[%#soption1] inv'2 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> precondition'0 default ()
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_11 <- (t) ] s4
      | s4 = call_once'0 {f} {_11} (fun (_ret':u) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'1 {default} {_8} (fun (_ret':u) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : u = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & default : d = default
    | & f : f = f
    | & _8 : () = any_l ()
    | & t : t = any_l ()
    | & _11 : t = any_l () ]
    
    [ return' (result:u)-> {[@expl:postcondition] [%#soption5] inv'3 result}
      {[@expl:postcondition] [%#soption4] match self_ with
        | Option'0.C_None -> postcondition_once'0 default () result
        | Option'0.C_Some t -> postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]
    
end
module T_core__result__Result
  type t_Result 't 'e =
    | C_Ok 't
    | C_Err 'e
  
  let rec v_Ok < 't > < 'e > (input:t_Result 't 'e) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Ok field_0 : t_Result 't 'e] . C_Ok field_0 <> input} (! {false} any) ]
    
  
  let rec v_Err < 't > < 'e > (input:t_Result 't 'e) (ret  (field_0:'e))= any
    [ good (field_0:'e)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 'e [C_Err field_0 : t_Result 't 'e] . C_Err field_0 <> input} (! {false} any) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 204 16 206 36]
  type t
  
  type e
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 204 42 204 45
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 200 26 203 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 204 53 204 65
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : e)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__result__Result as Result'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Result'0.t_Result t e)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Result'0.t_Result t e [inv'2 x] . inv'2 x
  = match x with
    | Result'0.C_Ok a_0 -> inv'5 a_0
    | Result'0.C_Err a_0 -> inv'4 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : ()) (_3 : e)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : ())
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:()) (return'  (ret:e))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops4] precondition'0 self args}
    any [ return' (result:e)-> {inv'4 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body (self_:Option'0.t_Option t) (err:f) (return'  (ret:Result'0.t_Result t e))= {[%#soption1] inv'0 err}
    {[%#soption0] inv'1 self_}
    {[%#soption0] self_ = Option'0.C_None  -> precondition'0 err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 err} s1
      | s1 = -{resolve'0 err}- s2
      | s2 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- Result'0.C_Ok t ] s4
      | s4 = bb9 ]
      
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {err} {_8} (fun (_ret':e) ->  [ &_6 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- Result'0.C_Err _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : Result'0.t_Result t e = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & err : f = err
    | & _6 : e = any_l ()
    | & _8 : () = any_l ()
    | & t : t = any_l () ]
    
    [ return' (result:Result'0.t_Result t e)-> {[@expl:postcondition] [%#soption3] inv'2 result}
      {[@expl:postcondition] [%#soption2] match self_ with
        | Option'0.C_None -> exists r : e . result = Result'0.C_Err r /\ postcondition_once'0 err () r
        | Option'0.C_Some t -> result = Result'0.C_Ok t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../../creusot-contracts/src/std/option.rs" 234 16 236 45]
  type t
  
  type u
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 226 27 229 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 234 40 234 41
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 230 26 233 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 234 49 234 58
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = (let (a) = x in inv'4 a)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : u)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option u)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option u [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : t) (_3 : Option'0.t_Option u)
    
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t)
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:t) (return'  (ret:Option'0.t_Option u))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any
    [ return' (result:Option'0.t_Option u)-> {inv'2 result}
      {[%#sops5] postcondition_once'0 self args result}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body (self_:Option'0.t_Option t) (f:f) (return'  (ret:Option'0.t_Option u))= {[%#soption2] inv'0 f}
    {[%#soption1] inv'1 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_8 <- (t) ] s2
      | s2 = call_once'0 {f} {_8} (fun (_ret':Option'0.t_Option u) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option u = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & f : f = f
    | & t : t = any_l ()
    | & _8 : t = any_l () ]
    
    [ return' (result:Option'0.t_Option u)-> {[@expl:postcondition] [%#soption4] inv'2 result}
      {[@expl:postcondition] [%#soption3] match self_ with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../../creusot-contracts/src/std/option.rs" 254 16 256 41]
  type t
  
  type p
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 254 35 254 44
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 247 26 253 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 254 52 254 61
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant6] inv'0 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : bool)
  
  axiom inv_axiom'2 [@rewrite] : forall x : bool [inv'4 x] . inv'4 x = true
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = (let (a) = x in inv'5 a)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'0 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : p) (_2 : t) (_3 : bool)
    
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : p) (_2 : t)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : p)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : p)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  let rec call_once'0 (self:p) (args:t) (return'  (ret:bool))= {[@expl:precondition] inv'3 args}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body (self_:Option'0.t_Option t) (predicate':p) (return'  (ret:Option'0.t_Option t))= {[%#soption2] inv'1 predicate'}
    {[%#soption1] inv'2 self_}
    {[%#soption0] match self_ with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 predicate' (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- (_11) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
      
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- Option'0.C_Some t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve'0 t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 predicate'} s1 | s1 = -{resolve'1 predicate'}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option t = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & predicate' : p = predicate'
    | & t : t = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t = any_l ()
    | & _11 : t = any_l () ]
    
    [ return' (result:Option'0.t_Option t)-> {[@expl:postcondition] [%#soption4] inv'2 result}
      {[@expl:postcondition] [%#soption3] match self_ with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> match result with
          | Option'0.C_None -> postcondition_once'0 predicate' (t) false /\ resolve'0 t
          | Option'0.C_Some r -> postcondition_once'0 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../../creusot-contracts/src/std/option.rs" 273 16 275 44]
  type t
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 273 36 273 37
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 269 26 272 17
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 273 45 273 54
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'2 x] . inv'2 x = true
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : ()) (_3 : Option'0.t_Option t)
    
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : ())
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:()) (return'  (ret:Option'0.t_Option t))= {[@expl:precondition] inv'2 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops4] precondition'0 self args}
    any
    [ return' (result:Option'0.t_Option t)-> {inv'1 result}
      {[%#sops4] postcondition_once'0 self args result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body (self_:Option'0.t_Option t) (f:f) (return'  (ret:Option'0.t_Option t))= {[%#soption1] inv'0 f}
    {[%#soption0] inv'1 self_}
    {[%#soption0] self_ = Option'0.C_None  -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_ = Option'0.C_Some a} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = Option'0.v_Some <t> {self_} (fun (r0'0:t) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- Option'0.C_Some t ] s4
      | s4 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':Option'0.t_Option t) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option t = any_l ()
    | & self_ : Option'0.t_Option t = self_
    | & f : f = f
    | & _7 : () = any_l ()
    | & t : t = any_l () ]
    
    [ return' (result:Option'0.t_Option t)-> {[@expl:postcondition] [%#soption3] inv'1 result}
      {[@expl:postcondition] [%#soption2] match self_ with
        | Option'0.C_None -> postcondition_once'0 f () result
        | Option'0.C_Some t -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../../creusot-contracts/src/std/option.rs" 311 16 313 36]
  type t
  
  type f
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 306 27 306 63
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 311 52 311 53
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 307 26 310 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 311 61 311 67
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sresolve9 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sresolve10 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sinvariant11 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.Borrow
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option (borrowed t))
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option (borrowed t) [inv'6 x] . inv'6 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ())
  
  axiom inv_axiom'3 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (Option'0.t_Option t))
    
   =
    [%#sinvariant11] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (Option'0.t_Option t))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Option'0.t_Option t) [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option t [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant11] inv'1 self.current /\ inv'1 self.final
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : ()) (_3 : t)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : ())
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'6 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (Option'0.t_Option t))
   =
    [%#sresolve9] self.final = self.current
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (Option'0.t_Option t)) =
    resolve'6 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed t)) (return'  (ret:borrowed t))= {[@expl:precondition] inv'6 self}
    {[@expl:precondition] [%#soption8] self <> Option'0.C_None}
    any
    [ return' (result:borrowed t)-> {inv'2 result} {[%#soption8] Option'0.C_Some result = self} (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option t)) (return'  (ret:Option'0.t_Option (borrowed t)))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed t))-> {inv'6 result}
      {[%#soption7] self.current = Option'0.C_None
      \/ (exists r : borrowed t . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption6] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate resolve'7 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 68 4 68 28] (self : Option'0.t_Option t) =
    [%#sresolve10] match self with
      | Option'0.C_Some x -> resolve'7 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Option'0.t_Option t) =
    resolve'5 _1
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  let rec call_once'0 (self:f) (args:()) (return'  (ret:t))= {[@expl:precondition] inv'5 args}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any [ return' (result:t)-> {inv'1 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve9] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t) =
    resolve'4 _1
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body (self_:borrowed (Option'0.t_Option t)) (f:f) (return'  (ret:borrowed t))= {[%#soption2] inv'0 f}
    {[%#soption1] inv'4 self_}
    {[%#soption0] self_.current = Option'0.C_None  -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any
      [ br0 -> {self_.current = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_.current = Option'0.C_Some a} (! bb5) ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = Option'0.v_Some <t> {self_.current}
          (fun (r0'0:t) ->
            {inv'1 r0'0}
            Borrow.borrow_final <t> {r0'0} {Borrow.inherit_id (Borrow.get_id self_) 1}
              (fun (_ret':borrowed t) ->
                 [ &t <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self_ <- { self_ with current = Option'0.C_Some _ret'.final ; } ] 
                s3))
      | s3 = {inv'1 t.current}
        Borrow.borrow_final <t> {t.current} {Borrow.get_id t}
          (fun (_ret':borrowed t) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &t <- { t with current = _ret'.final ; } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'2 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
      
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_12} (fun (_ret':t) ->  [ &_10 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- Option'0.C_Some _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _9 ; } ] s3
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = {inv'3 self_.current}
        Borrow.borrow_final <Option'0.t_Option t> {self_.current} {Borrow.get_id self_}
          (fun (_ret':borrowed (Option'0.t_Option t)) ->
             [ &_15 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':Option'0.t_Option (borrowed t)) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':borrowed t) ->  [ &_13 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <t> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed t) ->
             [ &_8 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final ; } ] 
            s1)
      | s1 = {inv'1 _8.current}
        Borrow.borrow_final <t> {_8.current} {Borrow.get_id _8}
          (fun (_ret':borrowed t) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_8 <- { _8 with current = _ret'.final ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'2 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
      
    | bb14 = s0
      [ s0 = {inv'1 _6.current}
        Borrow.borrow_final <t> {_6.current} {Borrow.get_id _6}
          (fun (_ret':borrowed t) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_6 <- { _6 with current = _ret'.final ; } ] 
            s1)
      | s1 = {inv'1 _3.current}
        Borrow.borrow_final <t> {_3.current} {Borrow.get_id _3}
          (fun (_ret':borrowed t) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'2 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
      
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : borrowed t = any_l ()
    | & self_ : borrowed (Option'0.t_Option t) = self_
    | & f : f = f
    | & _3 : borrowed t = any_l ()
    | & _6 : borrowed t = any_l ()
    | & _8 : borrowed t = any_l ()
    | & _9 : Option'0.t_Option t = any_l ()
    | & _10 : t = any_l ()
    | & _12 : () = any_l ()
    | & _13 : borrowed t = any_l ()
    | & _14 : Option'0.t_Option (borrowed t) = any_l ()
    | & _15 : borrowed (Option'0.t_Option t) = any_l ()
    | & t : borrowed t = any_l () ]
    
    [ return' (result:borrowed t)-> {[@expl:postcondition] [%#soption4] inv'2 result}
      {[@expl:postcondition] [%#soption3] match self_.current with
        | Option'0.C_None -> postcondition_once'0 f () result.current /\ self_.final = Option'0.C_Some (result.final)
        | Option'0.C_Some _ -> self_.current = Option'0.C_Some (result.current)
        /\ self_.final = Option'0.C_Some (result.final)
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../../creusot-contracts/src/std/option.rs" 338 16 340 45]
  type t
  
  type p
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 324 27 327 17
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 338 41 338 50
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 328 26 337 17
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 338 58 338 67
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 151 0 175 1
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sresolve7 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sinvariant8 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : bool)
  
  axiom inv_axiom'4 [@rewrite] : forall x : bool [inv'6 x] . inv'6 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t [inv'5 x] . inv'5 x = (let (a) = x in inv'1 a)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (Option'0.t_Option t))
    
   =
    [%#sinvariant8] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (Option'0.t_Option t))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Option'0.t_Option t) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'0 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant8] inv'0 self.current /\ inv'0 self.final
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : p) (_2 : borrowed t) (_3 : bool)
    
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : p) (_2 : borrowed t)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : p)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : p)
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (Option'0.t_Option t))
   =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (Option'0.t_Option t)) =
    resolve'4 _1
  
  let rec take'0 (self:borrowed (Option'0.t_Option t)) (return'  (ret:Option'0.t_Option t))= {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Option'0.t_Option t)-> {inv'2 result}
      {[%#soption6] result = self.current /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t) =
    resolve'3 _1
  
  let rec call_once'0 (self:p) (args:borrowed t) (return'  (ret:bool))= {[@expl:precondition] inv'5 args}
    {[@expl:precondition] inv'4 self}
    {[@expl:precondition] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'6 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body (self_:borrowed (Option'0.t_Option t)) (predicate':p) (return'  (ret:Option'0.t_Option t))= {[%#soption2] inv'4 predicate'}
    {[%#soption1] inv'3 self_}
    {[%#soption0] match self_.current with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> forall b : borrowed t . inv'1 b /\ b.current = t  -> precondition'0 predicate' (b)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any
      [ br0 -> {self_.current = Option'0.C_None } (! bb4) | br1 (a:t)-> {self_.current = Option'0.C_Some a} (! bb5) ]
      
    | bb5 = s0
      [ s0 = Option'0.v_Some <t> {self_.current}
          (fun (r0'0:t) ->
            {inv'0 r0'0}
            Borrow.borrow_mut <t> {r0'0}
              (fun (_ret':borrowed t) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 t.current}
        Borrow.borrow_final <t> {t.current} {Borrow.get_id t}
          (fun (_ret':borrowed t) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final ; } ] 
            s2)
      | s2 =  [ &_9 <- (_10) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 = {inv'2 self_.current}
        Borrow.borrow_final <Option'0.t_Option t> {self_.current} {Borrow.get_id self_}
          (fun (_ret':borrowed (Option'0.t_Option t)) ->
             [ &_11 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final ; } ] 
            s1)
      | s1 = take'0 {_11} (fun (_ret':Option'0.t_Option t) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 predicate'} s1
      | s1 = -{resolve'2 predicate'}- s2
      | s2 = {[@expl:type invariant] inv'3 self_} s3
      | s3 = -{resolve'1 self_}- s4
      | s4 = bb6 ]
      
    | bb6 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option t = any_l ()
    | & self_ : borrowed (Option'0.t_Option t) = self_
    | & predicate' : p = predicate'
    | & t : borrowed t = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : borrowed t = any_l ()
    | & _10 : borrowed t = any_l ()
    | & _11 : borrowed (Option'0.t_Option t) = any_l () ]
    
    [ return' (result:Option'0.t_Option t)-> {[@expl:postcondition] [%#soption4] inv'2 result}
      {[@expl:postcondition] [%#soption3] match self_.current with
        | Option'0.C_None -> result = Option'0.C_None /\ self_.final = Option'0.C_None
        | Option'0.C_Some cur -> exists b : borrowed t, res : bool . inv'1 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' (b) res
        /\ (if res then
          self_.final = Option'0.C_None /\ result = Option'0.C_Some (b.final)
        else
          self_.final = Option'0.C_Some (b.final) /\ result = Option'0.C_None
        )
        end}
      (! return' {result}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'1_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Option'0.t_Option t) (y : Option'0.t_Option t) (z : Option'0.t_Option t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t, z : Option'0.t_Option t, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Option'0.t_Option t) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : Option'0.t_Option t . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord7] ()
  
  axiom cmp_ge_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord6] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord24] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord5] ()
  
  axiom cmp_lt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord4] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Greater
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_cmp_le_log : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Option'0.t_Option t) (y : Option'0.t_Option t) (z : Option'0.t_Option t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t, z : Option'0.t_Option t, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Option'0.t_Option t) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : Option'0.t_Option t . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord25] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord7] ()
  
  axiom cmp_ge_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord6] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Less
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_cmp_lt_log : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Option'0.t_Option t) (y : Option'0.t_Option t) (z : Option'0.t_Option t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t, z : Option'0.t_Option t, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Option'0.t_Option t) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : Option'0.t_Option t . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord26] cmp_log'0 self o = Ordering'0.C_Greater
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord9] ()
  
  axiom cmp_gt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord8] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord6] ()
  
  axiom cmp_lt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord5] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord1] cmp_log'0 self o <> Ordering'0.C_Less
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_cmp_ge_log : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 76 8 76 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 81 8 81 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 86 8 86 35
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 91 8 91 35
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 96 8 96 35
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 101 8 101 35
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 108 8 108 35
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 114 8 114 35
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 120 8 120 35
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'2 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'2_spec : forall x : t, y : t . [%#sord39] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'2 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'2_spec : forall x : t, y : t . ([%#sord37] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord38] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'2 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'2_spec : forall x : t, y : t . ([%#sord35] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord36] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'2 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'2_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord32] cmp_log'1 x y = o)
   -> ([%#sord33] cmp_log'1 y z = o)  -> ([%#sord34] cmp_log'1 x z = o)
  
  function refl'2 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'2_spec : forall x : t . [%#sord31] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t, y : t . [%#sord30] gt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t, y : t . [%#sord29] ge_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t, y : t . [%#sord28] lt_log'1 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'2_spec : forall x : t, y : t . [%#sord27] le_log'1 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  function eq_cmp'1 [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord23] ()
  
  axiom eq_cmp'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord22] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'1 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord21] ()
  
  axiom antisym2'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord18] ()
  
  axiom antisym1'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . ([%#sord16] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord17] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'1 [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Option'0.t_Option t) (y : Option'0.t_Option t) (z : Option'0.t_Option t) (o : Ordering'0.t_Ordering) : ()
    
   =
    [%#sord15] ()
  
  axiom trans'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t, z : Option'0.t_Option t, o : Ordering'0.t_Ordering . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'1 [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Option'0.t_Option t) : () =
    [%#sord11] ()
  
  axiom refl'1_spec : forall x : Option'0.t_Option t . [%#sord10] cmp_log'0 x x = Ordering'0.C_Equal
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord26] cmp_log'0 self o <> Ordering'0.C_Less
  
  function cmp_ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord8] ()
  
  axiom cmp_ge_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord7] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord25] cmp_log'0 self o = Ordering'0.C_Less
  
  function cmp_lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord6] ()
  
  axiom cmp_lt_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord5] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord24] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function cmp_le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
   =
    [%#sord4] ()
  
  axiom cmp_le_log'1_spec : forall x : Option'0.t_Option t, y : Option'0.t_Option t . [%#sord3] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord1] cmp_log'0 self o = Ordering'0.C_Greater
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_cmp_gt_log : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption1] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  constant x  : Option'0.t_Option t
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Option'0.t_Option t) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord16] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord14] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord15] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord8] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption3] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  constant z  : Option'0.t_Option t
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Option'0.t_Option t) (y : Option'0.t_Option t) (z : Option'0.t_Option t) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord15] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord13] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord14] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord11] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord12] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord7] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption2] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  function eq_cmp'0 [#"../../../creusot-contracts/src/logic/ord.rs" 70 4 70 32] (x : t) (y : t) : ()
  
  axiom eq_cmp'0_spec : forall x : t, y : t . [%#sord14] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'0 [#"../../../creusot-contracts/src/logic/ord.rs" 66 4 66 34] (x : t) (y : t) : ()
  
  axiom antisym2'0_spec : forall x : t, y : t . ([%#sord12] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#sord13] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'0 [#"../../../creusot-contracts/src/logic/ord.rs" 61 4 61 34] (x : t) (y : t) : ()
  
  axiom antisym1'0_spec : forall x : t, y : t . ([%#sord10] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#sord11] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'0 [#"../../../creusot-contracts/src/logic/ord.rs" 56 4 56 53] (x : t) (y : t) (z : t) (o : Ordering'0.t_Ordering) : ()
    
  
  axiom trans'0_spec : forall x : t, y : t, z : t, o : Ordering'0.t_Ordering . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../../creusot-contracts/src/logic/ord.rs" 50 4 50 21] (x : t) : ()
  
  axiom refl'0_spec : forall x : t . [%#sord6] cmp_log'1 x x = Ordering'0.C_Equal
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : t) (o : t) : bool
  
  function cmp_gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (x : t) (y : t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t, y : t . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : t) (o : t) : bool
  
  function cmp_ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 36 4 36 36] (x : t) (y : t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t, y : t . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : t) (o : t) : bool
  
  function cmp_lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 26 4 26 36] (x : t) (y : t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t, y : t . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : t) (o : t) : bool
  
  function cmp_le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 16 4 16 36] (x : t) (y : t) : ()
  
  axiom cmp_le_log'0_spec : forall x : t, y : t . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption1] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  constant x  : Option'0.t_Option t
  
  constant y  : Option'0.t_Option t
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Option'0.t_Option t) (y : Option'0.t_Option t) : ()
    
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 478 4 478 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 477 14 477 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 470 12 471 96
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 455 20 455 26
  
  use T_core__option__IntoIter as IntoIter'0
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 454 4 454 30] (self : IntoIter'0.t_IntoIter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 468 4 468 64] (self : IntoIter'0.t_IntoIter t) (visited : Seq.seq t) (o : IntoIter'0.t_IntoIter t)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant self  : IntoIter'0.t_IntoIter t
  
  function produces_refl [#"../../../creusot-contracts/src/std/option.rs" 478 4 478 26] (self : IntoIter'0.t_IntoIter t) : ()
    
  
  goal vc_produces_refl : [%#soption0] produces'0 self (Seq.empty  : Seq.seq t) self
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 485 4 485 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 482 15 482 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 483 15 483 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 484 14 484 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 470 12 471 96
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 455 20 455 26
  
  use seq.Seq
  
  use T_core__option__IntoIter as IntoIter'0
  
  use seq.Seq
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 454 4 454 30] (self : IntoIter'0.t_IntoIter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 468 4 468 64] (self : IntoIter'0.t_IntoIter t) (visited : Seq.seq t) (o : IntoIter'0.t_IntoIter t)
    
   =
    [%#soption3] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant a  : IntoIter'0.t_IntoIter t
  
  constant ab  : Seq.seq t
  
  constant b  : IntoIter'0.t_IntoIter t
  
  constant bc  : Seq.seq t
  
  constant c  : IntoIter'0.t_IntoIter t
  
  function produces_trans [#"../../../creusot-contracts/src/std/option.rs" 485 4 485 90] (a : IntoIter'0.t_IntoIter t) (ab : Seq.seq t) (b : IntoIter'0.t_IntoIter t) (bc : Seq.seq t) (c : IntoIter'0.t_IntoIter t) : ()
    
  
  goal vc_produces_trans : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__option__Iter
  use prelude.prelude.Borrow
  
  use T_core__option__Item as Item'0
  
  type t_Iter 'a =
    | C_Iter (Item'0.t_Item 'a)
  
  let rec t_Iter < 'a > (input:t_Iter 'a) (ret  (inner:Item'0.t_Item 'a))= any
    [ good (inner:Item'0.t_Item 'a)-> {C_Iter inner = input} (! ret {inner}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 532 4 532 26] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 531 14 531 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 524 12 525 96
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 509 20 509 26
  
  use T_core__option__Iter as Iter'0
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 508 4 508 34] (self : Iter'0.t_Iter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 522 4 522 64] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (o : Iter'0.t_Iter t)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant self  : Iter'0.t_Iter t
  
  function produces_refl [#"../../../creusot-contracts/src/std/option.rs" 532 4 532 26] (self : Iter'0.t_Iter t) : ()
  
  goal vc_produces_refl : [%#soption0] produces'0 self (Seq.empty  : Seq.seq t) self
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 539 4 539 90] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 536 15 536 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 537 15 537 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 538 14 538 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 524 12 525 96
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 509 20 509 26
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use T_core__option__Iter as Iter'0
  
  use seq.Seq
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 508 4 508 34] (self : Iter'0.t_Iter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 522 4 522 64] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (o : Iter'0.t_Iter t)
    
   =
    [%#soption3] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant a  : Iter'0.t_Iter t
  
  constant ab  : Seq.seq t
  
  constant b  : Iter'0.t_Iter t
  
  constant bc  : Seq.seq t
  
  constant c  : Iter'0.t_Iter t
  
  function produces_trans [#"../../../creusot-contracts/src/std/option.rs" 539 4 539 90] (a : Iter'0.t_Iter t) (ab : Seq.seq t) (b : Iter'0.t_Iter t) (bc : Seq.seq t) (c : Iter'0.t_Iter t) : ()
    
  
  goal vc_produces_trans : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__option__IterMut
  use prelude.prelude.Borrow
  
  use T_core__option__Item as Item'0
  
  type t_IterMut 'a =
    | C_IterMut (Item'0.t_Item (borrowed 'a))
  
  let rec t_IterMut < 'a > (input:t_IterMut 'a) (ret  (inner:Item'0.t_Item (borrowed 'a)))= any
    [ good (inner:Item'0.t_Item (borrowed 'a))-> {C_IterMut inner = input} (! ret {inner}) ]
    
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_refl [#"../../../creusot-contracts/src/std/option.rs" 589 4 589 26] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 588 14 588 45
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 581 12 582 96
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 566 20 566 26
  
  use T_core__option__IterMut as IterMut'0
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 565 4 565 38] (self : IterMut'0.t_IterMut t) : Option'0.t_Option (borrowed t)
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 579 4 579 64] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (o : IterMut'0.t_IterMut t)
    
   =
    [%#soption1] visited = (Seq.empty  : Seq.seq (borrowed t)) /\ self = o
    \/ (exists e : borrowed t . view'0 self = Option'0.C_Some e
    /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant self  : IterMut'0.t_IterMut t
  
  function produces_refl [#"../../../creusot-contracts/src/std/option.rs" 589 4 589 26] (self : IterMut'0.t_IterMut t) : ()
    
  
  goal vc_produces_refl : [%#soption0] produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363__produces_trans [#"../../../creusot-contracts/src/std/option.rs" 596 4 596 90] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 593 15 593 32
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 594 15 594 32
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 595 14 595 42
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 581 12 582 96
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 566 20 566 26
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use T_core__option__IterMut as IterMut'0
  
  use seq.Seq
  
  use seq.Seq
  
  use T_core__option__Option as Option'0
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 565 4 565 38] (self : IterMut'0.t_IterMut t) : Option'0.t_Option (borrowed t)
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 579 4 579 64] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (o : IterMut'0.t_IterMut t)
    
   =
    [%#soption3] visited = (Seq.empty  : Seq.seq (borrowed t)) /\ self = o
    \/ (exists e : borrowed t . view'0 self = Option'0.C_Some e
    /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  constant a  : IterMut'0.t_IterMut t
  
  constant ab  : Seq.seq (borrowed t)
  
  constant b  : IterMut'0.t_IterMut t
  
  constant bc  : Seq.seq (borrowed t)
  
  constant c  : IterMut'0.t_IterMut t
  
  function produces_trans [#"../../../creusot-contracts/src/std/option.rs" 596 4 596 90] (a : IterMut'0.t_IterMut t) (ab : Seq.seq (borrowed t)) (b : IterMut'0.t_IterMut t) (bc : Seq.seq (borrowed t)) (c : IterMut'0.t_IterMut t) : ()
    
  
  goal vc_produces_trans : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__ops__range__RangeTo
  type t_RangeTo 'idx =
    | C_RangeTo 'idx
  
  let rec t_RangeTo < 'idx > (input:t_RangeTo 'idx) (ret  (end':'idx))= any
    [ good (end':'idx)-> {C_RangeTo end' = input} (! ret {end'}) ]
    
end
module T_core__ops__range__RangeFrom
  type t_RangeFrom 'idx =
    | C_RangeFrom 'idx
  
  let rec t_RangeFrom < 'idx > (input:t_RangeFrom 'idx) (ret  (start:'idx))= any
    [ good (start:'idx)-> {C_RangeFrom start = input} (! ret {start}) ]
    
end
module T_core__ops__range__RangeFull
  type t_RangeFull  =
    | C_RangeFull
  
  let rec t_RangeFull (input:t_RangeFull) (ret  )= any [ good -> {C_RangeFull  = input} (! ret) ] 
end
module T_core__ops__range__RangeToInclusive
  type t_RangeToInclusive 'idx =
    | C_RangeToInclusive 'idx
  
  let rec t_RangeToInclusive < 'idx > (input:t_RangeToInclusive 'idx) (ret  (end':'idx))= any
    [ good (end':'idx)-> {C_RangeToInclusive end' = input} (! ret {end'}) ]
    
end
module T_core__slice__iter__IterMut
  use prelude.prelude.Borrow
  
  use T_core__marker__PhantomData as PhantomData'0
  
  use prelude.prelude.Opaque
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_IterMut 't =
    | C_IterMut (NonNull'0.t_NonNull 't) opaque_ptr (PhantomData'0.t_PhantomData (borrowed 't))
  
  let rec t_IterMut < 't > (input:t_IterMut 't) (ret  (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData (borrowed 't)))= any
    [ good (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData (borrowed 't))-> {C_IterMut ptr end_or_len _marker
      = input}
      (! ret {ptr} {end_or_len} {_marker}) ]
    
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_refl [#"../../../creusot-contracts/src/std/slice.rs" 477 4 477 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 475 15 475 24
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 476 14 476 45
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 469 12 469 66
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 437 14 437 50
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 434 4 434 12
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 90 14 90 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 91 14 91 84
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 94 20 94 26
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 32 20 32 26
  let%span smodel11 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sops12 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use T_core__slice__iter__IterMut as IterMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IterMut'0.t_IterMut t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IterMut'0.t_IterMut t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'1_spec : forall self : slice t . ([%#sslice9] view'1 self = Slice.id self)
  && ([%#sslice8] Seq.length (view'1 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops12] Seq.get (view'1 self) ix
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 108 4 108 33] (self : borrowed (slice t)) : Seq.seq t =
    [%#smodel11] view'1 self.current
  
  use seq.Seq
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 93 4 93 43] (self : borrowed (slice t)) : Seq.seq (borrowed t)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t) . ([%#sslice6] forall i : int . 0 <= i
  /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  && ([%#sslice5] Seq.length (to_mut_seq'0 self) = Seq.length (view'2 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 438 4 438 33] (self : IterMut'0.t_IterMut t) : borrowed (slice t)
    
  
  axiom view'0_spec : forall self : IterMut'0.t_IterMut t . [%#sslice3] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 467 4 467 65] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (tl : IterMut'0.t_IterMut t)
    
   =
    [%#sslice2] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  use seq.Seq
  
  constant self  : IterMut'0.t_IterMut t
  
  function produces_refl [#"../../../creusot-contracts/src/std/slice.rs" 477 4 477 26] (self : IterMut'0.t_IterMut t) : ()
    
  
  goal vc_produces_refl : ([%#sslice0] inv'0 self)
   -> ([%#sslice1] produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169__produces_trans [#"../../../creusot-contracts/src/std/slice.rs" 487 4 487 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 481 15 481 21
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 482 15 482 21
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 483 15 483 21
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 484 15 484 32
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 485 15 485 32
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 486 14 486 42
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 469 12 469 66
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 437 14 437 50
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 434 4 434 12
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 90 14 90 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 91 14 91 84
  let%span sslice11 = "../../../creusot-contracts/src/std/slice.rs" 94 20 94 26
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice13 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice14 = "../../../creusot-contracts/src/std/slice.rs" 32 20 32 26
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sops16 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use T_core__slice__iter__IterMut as IterMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IterMut'0.t_IterMut t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IterMut'0.t_IterMut t [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'1_spec : forall self : slice t . ([%#sslice13] view'1 self = Slice.id self)
  && ([%#sslice12] Seq.length (view'1 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops16] Seq.get (view'1 self) ix
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 108 4 108 33] (self : borrowed (slice t)) : Seq.seq t =
    [%#smodel15] view'1 self.current
  
  use seq.Seq
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 93 4 93 43] (self : borrowed (slice t)) : Seq.seq (borrowed t)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t) . ([%#sslice10] forall i : int . 0 <= i
  /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  && ([%#sslice9] Seq.length (to_mut_seq'0 self) = Seq.length (view'2 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 438 4 438 33] (self : IterMut'0.t_IterMut t) : borrowed (slice t)
    
  
  axiom view'0_spec : forall self : IterMut'0.t_IterMut t . [%#sslice7] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 467 4 467 65] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (tl : IterMut'0.t_IterMut t)
    
   =
    [%#sslice6] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant a  : IterMut'0.t_IterMut t
  
  constant ab  : Seq.seq (borrowed t)
  
  constant b  : IterMut'0.t_IterMut t
  
  constant bc  : Seq.seq (borrowed t)
  
  constant c  : IterMut'0.t_IterMut t
  
  function produces_trans [#"../../../creusot-contracts/src/std/slice.rs" 487 4 487 90] (a : IterMut'0.t_IterMut t) (ab : Seq.seq (borrowed t)) (b : IterMut'0.t_IterMut t) (bc : Seq.seq (borrowed t)) (c : IterMut'0.t_IterMut t) : ()
    
  
  goal vc_produces_trans : ([%#sslice4] produces'0 b bc c)
   -> ([%#sslice3] produces'0 a ab b)
   -> ([%#sslice2] inv'0 c)
   -> ([%#sslice1] inv'0 b)  -> ([%#sslice0] inv'0 a)  -> ([%#sslice5] produces'0 a (Seq.(++) ab bc) c)
end
module T_core__time__Nanoseconds
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  type t_Nanoseconds  =
    | C_Nanoseconds uint32
  
  let rec t_Nanoseconds (input:t_Nanoseconds) (ret  (field_0:uint32))= any
    [ good (field_0:uint32)-> {C_Nanoseconds field_0 = input} (! ret {field_0}) ]
    
end
module T_core__time__Duration
  use T_core__time__Nanoseconds as Nanoseconds'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  type t_Duration  =
    | C_Duration uint64 (Nanoseconds'0.t_Nanoseconds)
  
  let rec t_Duration (input:t_Duration) (ret  (secs:uint64) (nanos:Nanoseconds'0.t_Nanoseconds))= any
    [ good (secs:uint64) (nanos:Nanoseconds'0.t_Nanoseconds)-> {C_Duration secs nanos = input} (! ret {secs} {nanos}) ]
    
end
module T_std__sys__pal__unix__time__Nanoseconds
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  type t_Nanoseconds  =
    | C_Nanoseconds uint32
  
  let rec t_Nanoseconds (input:t_Nanoseconds) (ret  (field_0:uint32))= any
    [ good (field_0:uint32)-> {C_Nanoseconds field_0 = input} (! ret {field_0}) ]
    
end
module T_std__sys__pal__unix__time__Timespec
  use T_std__sys__pal__unix__time__Nanoseconds as Nanoseconds'0
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  type t_Timespec  =
    | C_Timespec int64 (Nanoseconds'0.t_Nanoseconds)
  
  let rec t_Timespec (input:t_Timespec) (ret  (tv_sec:int64) (tv_nsec:Nanoseconds'0.t_Nanoseconds))= any
    [ good (tv_sec:int64) (tv_nsec:Nanoseconds'0.t_Nanoseconds)-> {C_Timespec tv_sec tv_nsec = input}
      (! ret {tv_sec} {tv_nsec}) ]
    
end
module T_std__sys__pal__unix__time__Instant
  use T_std__sys__pal__unix__time__Timespec as Timespec'0
  
  type t_Instant  =
    | C_Instant (Timespec'0.t_Timespec)
  
  let rec t_Instant (input:t_Instant) (ret  (t:Timespec'0.t_Timespec))= any
    [ good (t:Timespec'0.t_Timespec)-> {C_Instant t = input} (! ret {t}) ]
    
end
module T_std__time__Instant
  use T_std__sys__pal__unix__time__Instant as Instant'0
  
  type t_Instant  =
    | C_Instant (Instant'0.t_Instant)
  
  let rec t_Instant (input:t_Instant) (ret  (field_0:Instant'0.t_Instant))= any
    [ good (field_0:Instant'0.t_Instant)-> {C_Instant field_0 = input} (! ret {field_0}) ]
    
end
module T_core__mem__manually_drop__ManuallyDrop
  type t_ManuallyDrop 't =
    | C_ManuallyDrop 't
  
  let rec t_ManuallyDrop < 't > (input:t_ManuallyDrop 't) (ret  (value:'t))= any
    [ good (value:'t)-> {C_ManuallyDrop value = input} (! ret {value}) ]
    
end
module T_alloc__vec__into_iter__IntoIter
  use prelude.prelude.Opaque
  
  use T_core__mem__manually_drop__ManuallyDrop as ManuallyDrop'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_IntoIter 't 'a =
    | C_IntoIter (NonNull'0.t_NonNull 't) (PhantomData'0.t_PhantomData 't) usize (ManuallyDrop'0.t_ManuallyDrop 'a) (NonNull'0.t_NonNull 't) opaque_ptr
  
  let rec t_IntoIter < 't > < 'a > (input:t_IntoIter 't 'a) (ret  (buf:NonNull'0.t_NonNull 't) (phantom:PhantomData'0.t_PhantomData 't) (cap:usize) (alloc:ManuallyDrop'0.t_ManuallyDrop 'a) (ptr:NonNull'0.t_NonNull 't) (end':opaque_ptr))= any
    [ good (buf:NonNull'0.t_NonNull 't) (phantom:PhantomData'0.t_PhantomData 't) (cap:usize) (alloc:ManuallyDrop'0.t_ManuallyDrop 'a) (ptr:NonNull'0.t_NonNull 't) (end':opaque_ptr)-> {C_IntoIter buf phantom cap alloc ptr end'
      = input}
      (! ret {buf} {phantom} {cap} {alloc} {ptr} {end'}) ]
    
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396__produces_refl [#"../../../creusot-contracts/src/std/vec.rs" 276 4 276 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type t
  
  type a
  
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 275 14 275 45
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 269 12 269 41
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 239 8 239 14
  
  use T_alloc__vec__into_iter__IntoIter as IntoIter'0
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 238 4 238 33] (self : IntoIter'0.t_IntoIter t a) : Seq.seq t
    
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 267 4 267 57] (self : IntoIter'0.t_IntoIter t a) (visited : Seq.seq t) (rhs : IntoIter'0.t_IntoIter t a)
    
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  use seq.Seq
  
  constant self  : IntoIter'0.t_IntoIter t a
  
  function produces_refl [#"../../../creusot-contracts/src/std/vec.rs" 276 4 276 26] (self : IntoIter'0.t_IntoIter t a) : ()
    
  
  goal vc_produces_refl : [%#svec0] produces'0 self (Seq.empty  : Seq.seq t) self
end
module T_num_rational__Ratio [#"../../../../.cargo/registry/src/index.crates.io-6f17d22bba15001f/num-rational-0.3.2/src/lib.rs" 52 0 52 19]
  type t_Ratio 't =
    | C_Ratio 't 't
  
  let rec t_Ratio < 't > (input:t_Ratio 't) (ret  (numer:'t) (denom:'t))= any
    [ good (numer:'t) (denom:'t)-> {C_Ratio numer denom = input} (! ret {numer} {denom}) ]
    
end
module T_num_bigint__bigint__Sign [#"../../../../.cargo/registry/src/index.crates.io-6f17d22bba15001f/num-bigint-0.3.3/src/bigint.rs" 41 0 41 13]
  type t_Sign  =
    | C_Minus
    | C_NoSign
    | C_Plus
  
  let rec v_Minus (input:t_Sign) (ret  )= any
    [ good -> {C_Minus  = input} (! ret) | bad -> {C_Minus  <> input} (! {false} any) ]
    
  
  let rec v_NoSign (input:t_Sign) (ret  )= any
    [ good -> {C_NoSign  = input} (! ret) | bad -> {C_NoSign  <> input} (! {false} any) ]
    
  
  let rec v_Plus (input:t_Sign) (ret  )= any
    [ good -> {C_Plus  = input} (! ret) | bad -> {C_Plus  <> input} (! {false} any) ]
    
end
module T_num_bigint__biguint__BigUint [#"../../../../.cargo/registry/src/index.crates.io-6f17d22bba15001f/num-bigint-0.3.3/src/biguint.rs" 39 0 39 18]
  use T_alloc__alloc__Global as Global'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_alloc__vec__Vec as Vec'0
  
  type t_BigUint  =
    | C_BigUint (Vec'0.t_Vec uint64 (Global'0.t_Global))
  
  let rec t_BigUint (input:t_BigUint) (ret  (data:Vec'0.t_Vec uint64 (Global'0.t_Global)))= any
    [ good (data:Vec'0.t_Vec uint64 (Global'0.t_Global))-> {C_BigUint data = input} (! ret {data}) ]
    
end
module T_num_bigint__bigint__BigInt [#"../../../../.cargo/registry/src/index.crates.io-6f17d22bba15001f/num-bigint-0.3.3/src/bigint.rs" 63 0 63 17]
  use T_num_bigint__biguint__BigUint as BigUint'0
  
  use T_num_bigint__bigint__Sign as Sign'0
  
  type t_BigInt  =
    | C_BigInt (Sign'0.t_Sign) (BigUint'0.t_BigUint)
  
  let rec t_BigInt (input:t_BigInt) (ret  (sign:Sign'0.t_Sign) (data:BigUint'0.t_BigUint))= any
    [ good (sign:Sign'0.t_Sign) (data:BigUint'0.t_BigUint)-> {C_BigInt sign data = input} (! ret {sign} {data}) ]
    
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  use prelude.prelude.Real
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log [#"../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_le_log : [%#sord0] Real.(<=) x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log [#"../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_lt_log : [%#sord0] Real.(<) x y = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  use prelude.prelude.Real
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log [#"../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_ge_log : [%#sord0] Real.(>=) x y = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  use prelude.prelude.Real
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log [#"../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_gt_log : [%#sord0] Real.(>) x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  function refl [#"../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24] (x : Real.real) : ()
  
  goal vc_refl : [%#sord0] cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span snum_rational3 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational3] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : Ordering'0.t_Ordering
  
  function trans [#"../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56] (x : Real.real) (y : Real.real) (z : Real.real) (o : Ordering'0.t_Ordering) : ()
    
  
  goal vc_trans : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational2] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1 [#"../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym1 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Less)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span snum_rational2 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational2] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2 [#"../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym2 : ([%#sord0] cmp_log'0 x y = Ordering'0.C_Greater)  -> ([%#sord1] cmp_log'0 y x = Ordering'0.C_Less)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span snum_rational1 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational1] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp [#"../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35] (x : Real.real) (y : Real.real) : ()
  
  goal vc_eq_cmp : [%#sord0] (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module T_creusot_contracts__ghost__GhostBox [#"../../../creusot-contracts/src/ghost.rs" 27 0 27 22]
  type t_GhostBox 't =
    | C_GhostBox 't
  
  let rec t_GhostBox < 't > (input:t_GhostBox 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_GhostBox field_0 = input} (! ret {field_0}) ]
    
  
  function t_GhostBox__0 (self : t_GhostBox 't) : 't =
    match self with
      | C_GhostBox a -> a
      end
end
module M_creusot_contracts__ghost__qyi17645547594388049322__clone [#"../../../creusot-contracts/src/ghost.rs" 33 4 33 27] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 33 14 33 18
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 32 14 32 29
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 33 23 33 27
  let%span sclone3 = "../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed5] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'2 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'1 x] . inv'1 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'3 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Intrinsic
  
  let rec clone'0 (self:t) (return'  (ret:t))= {[@expl:precondition] inv'2 self}
    any [ return' (result:t)-> {inv'3 result} {[%#sclone3] result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:GhostBox'0.t_GhostBox t) (return'  (ret:GhostBox'0.t_GhostBox t))= {[%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = GhostBox'0.t_GhostBox <t> {self} (fun (r0'0:t) -> clone'0 {r0'0} (fun (_ret':t) ->  [ &_3 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- GhostBox'0.C_GhostBox _3 ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : GhostBox'0.t_GhostBox t = any_l () | & self : GhostBox'0.t_GhostBox t = self | & _3 : t = any_l () ] 
    [ return' (result:GhostBox'0.t_GhostBox t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] result = self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi1862168959261460300__deref [#"../../../creusot-contracts/src/ghost.rs" 52 4 52 36] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 52 14 52 18
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 51 14 51 35
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 52 23 52 36
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed4] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'2 x] . inv'2 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant3] inv'2 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec deref (self:GhostBox'0.t_GhostBox t) (return'  (ret:t))= {[%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = GhostBox'0.t_GhostBox <t> {self} (fun (r0'0:t) ->  [ &_3 <- r0'0 ] s1)
      | s1 =  [ &_0 <- _3 ] s2
      | s2 = return' {_0} ]
       ]
    ) [ & _0 : t = any_l () | & self : GhostBox'0.t_GhostBox t = self | & _3 : t = any_l () ] 
    [ return' (result:t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self = result}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi17214052996668775070__deref_mut [#"../../../creusot-contracts/src/ghost.rs" 68 4 68 48] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 68 22 68 26
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 67 14 67 36
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 68 31 68 48
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed5] inv'0 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'3 x] . inv'3 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    [%#sinvariant4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostBox'0.t_GhostBox t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (GhostBox'0.t_GhostBox t) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    resolve'3 _1
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t) =
    resolve'2 _1
  
  meta "compute_max_steps" 1000000
  
  let rec deref_mut (self:borrowed (GhostBox'0.t_GhostBox t)) (return'  (ret:borrowed t))= {[%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = GhostBox'0.t_GhostBox <t> {self.current}
          (fun (r0'0:t) ->
            {inv'0 r0'0}
            Borrow.borrow_final <t> {r0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed t) ->
                 [ &_5 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = GhostBox'0.C_GhostBox _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _5.current}
        Borrow.borrow_final <t> {_5.current} {Borrow.get_id _5}
          (fun (_ret':borrowed t) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final ; } ] 
            s2)
      | s2 = {inv'0 _4.current}
        Borrow.borrow_final <t> {_4.current} {Borrow.get_id _4}
          (fun (_ret':borrowed t) ->
             [ &_2 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_4 <- { _4 with current = _ret'.final ; } ] 
            s3)
      | s3 = {inv'0 _2.current}
        Borrow.borrow_final <t> {_2.current} {Borrow.get_id _2}
          (fun (_ret':borrowed t) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_2 <- { _2 with current = _ret'.final ; } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 _5} s5
      | s5 = -{resolve'0 _5}- s6
      | s6 = {[@expl:type invariant] inv'1 _4} s7
      | s7 = -{resolve'0 _4}- s8
      | s8 = {[@expl:type invariant] inv'1 _2} s9
      | s9 = -{resolve'0 _2}- s10
      | s10 = {[@expl:type invariant] inv'2 self} s11
      | s11 = -{resolve'1 self}- s12
      | s12 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed t = any_l ()
    | & self : borrowed (GhostBox'0.t_GhostBox t) = self
    | & _2 : borrowed t = any_l ()
    | & _4 : borrowed t = any_l ()
    | & _5 : borrowed t = any_l () ]
    
    [ return' (result:borrowed t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] result
      = Borrow.borrow_logic (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.current) (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.final) (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__borrow [#"../../../creusot-contracts/src/ghost.rs" 108 4 108 40] (* ghost::GhostBox<T> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 108 19 108 23
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 107 14 107 35
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 108 28 108 40
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant3] inv'6 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed4] inv'6 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'3 x] . inv'3 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed4] inv'5 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'1 x] . inv'1 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec borrow (self:GhostBox'0.t_GhostBox t) (return'  (ret:GhostBox'0.t_GhostBox t))= {[%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = GhostBox'0.t_GhostBox <t> {self} (fun (r0'0:t) ->  [ &_5 <- r0'0 ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- GhostBox'0.C_GhostBox _5 ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : GhostBox'0.t_GhostBox t = any_l () | & self : GhostBox'0.t_GhostBox t = self | & _5 : t = any_l () ] 
    [ return' (result:GhostBox'0.t_GhostBox t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 result
      = T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__borrow_mut [#"../../../creusot-contracts/src/ghost.rs" 122 4 122 52] (* ghost::GhostBox<T> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 122 27 122 31
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 121 14 121 39
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 122 36 122 52
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed5 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed5] inv'0 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t [inv'6 x] . inv'6 x = invariant'3 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'5 x] . inv'5 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'6 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed t) =
    [%#sboxed5] inv'1 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox (borrowed t))
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostBox'0.t_GhostBox (borrowed t) [inv'3 x] . inv'3 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    [%#sinvariant4] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostBox'0.t_GhostBox t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (GhostBox'0.t_GhostBox t) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    resolve'3 _1
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t) =
    resolve'2 _1
  
  meta "compute_max_steps" 1000000
  
  let rec borrow_mut (self:borrowed (GhostBox'0.t_GhostBox t)) (return'  (ret:GhostBox'0.t_GhostBox (borrowed t)))= {[%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = GhostBox'0.t_GhostBox <t> {self.current}
          (fun (r0'0:t) ->
            {inv'0 r0'0}
            Borrow.borrow_final <t> {r0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed t) ->
                 [ &_5 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = GhostBox'0.C_GhostBox _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _5.current}
        Borrow.borrow_final <t> {_5.current} {Borrow.get_id _5}
          (fun (_ret':borrowed t) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final ; } ] 
            s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- GhostBox'0.C_GhostBox _4 ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = return' {_0} ]
       ]
    )
    [ & _0 : GhostBox'0.t_GhostBox (borrowed t) = any_l ()
    | & self : borrowed (GhostBox'0.t_GhostBox t) = self
    | & _4 : borrowed t = any_l ()
    | & _5 : borrowed t = any_l () ]
    
    [ return' (result:GhostBox'0.t_GhostBox (borrowed t))-> {[@expl:postcondition] [%#sghost2] inv'3 result}
      {[@expl:postcondition] [%#sghost1] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 result
      = Borrow.borrow_logic (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.current) (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.final) (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__new [#"../../../creusot-contracts/src/ghost.rs" 148 4 148 28] (* ghost::GhostBox<T> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 148 15 148 16
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 146 14 146 28
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 148 24 148 28
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed3] inv'0 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'1 x] . inv'1 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'2 a_0
    end
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec new (x:t) (return'  (ret:GhostBox'0.t_GhostBox t))= {[%#sghost0] inv'0 x}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 =  [ &_0 <- GhostBox'0.C_GhostBox x ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : GhostBox'0.t_GhostBox t = any_l () | & x : t = x ] 
    [ return' (result:GhostBox'0.t_GhostBox t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 result = x}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost__qyi2175792468772189056__into_inner [#"../../../creusot-contracts/src/ghost.rs" 166 4 166 32] (* ghost::GhostBox<T> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 166 22 166 26
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 164 14 164 31
  let%span sghost2 = "../../../creusot-contracts/src/ghost.rs" 166 31 166 32
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed3] inv'1 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'2 a_0
    end
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec into_inner (self:GhostBox'0.t_GhostBox t) (return'  (ret:t))= {[%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = GhostBox'0.t_GhostBox <t> {self} (fun (r0'0:t) ->  [ &_0 <- r0'0 ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t = any_l () | & self : GhostBox'0.t_GhostBox t = self ] 
    [ return' (result:t)-> {[@expl:postcondition] [%#sghost2] inv'1 result}
      {[@expl:postcondition] [%#sghost1] result = T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__snapshot__qyi5567339964777190687__clone [#"../../../creusot-contracts/src/snapshot.rs" 33 4 33 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type t
  
  let%span ssnapshot0 = "../../../creusot-contracts/src/snapshot.rs" 34 8 34 28
  let%span ssnapshot1 = "../../../creusot-contracts/src/snapshot.rs" 32 14 32 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:Snapshot.snap_ty t) (return'  (ret:Snapshot.snap_ty t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#ssnapshot0] Snapshot.new (Snapshot.inner self) ] s1 | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : Snapshot.snap_ty t = any_l () | & self : Snapshot.snap_ty t = self ] 
    [ return' (result:Snapshot.snap_ty t)-> {[@expl:postcondition] [%#ssnapshot1] result = self} (! return' {result}) ]
    
end
module T_creusot_contracts__ghost_ptr__GhostPtrToken [#"../../../creusot-contracts/src/ghost_ptr.rs" 14 0 14 35]
  type t_GhostPtrToken 't
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__are_eq [#"../../../creusot-contracts/src/ghost_ptr.rs" 69 4 71 17] (* ghost_ptr::GhostPtrToken<T> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 65 15 65 69
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 66 15 66 69
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 69 19 69 23
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 67 14 67 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 68 14 68 38
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 63 24 63 28
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 60 14 62 24
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 315 18 315 46
  let%span smodel8 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 112 8 112 35
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sghost_ptr13 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sghost_ptr14 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr15 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sfmap16 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sfmap17 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sinvariant18 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sghost_ptr19 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'2_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap17] mk'0 (view'2 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap16] Map.get (view'2 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr11] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr10] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'1_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr14] get_unsized'0 (view'1 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr19] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'1 self) ptr = Option'0.C_Some x  -> inv'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sinvariant18] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'0 x] . inv'0 x = invariant'0 x
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 111 4 111 39] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : bool
    
   =
    [%#sfmap9] get_unsized'0 self k <> Option'0.C_None
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel8] view'1 self
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  let rec addr'0 (self:opaque_ptr) (return'  (ret:usize))= any
    [ return' (result:usize)-> {[%#sghost_ptr7] UIntSize.to_int result = addr_logic'0 self} (! return' {result}) ]
    
  
  let rec injective_lemma'0 (self:GhostPtrToken'0.t_GhostPtrToken t) (return'  (ret:()))= {[@expl:precondition] [%#sghost_ptr5] inv'0 self}
    any
    [ return' (result:())-> {[%#sghost_ptr6] forall ptr1 : opaque_ptr, ptr2 : opaque_ptr . contains'0 (view'0 self) ptr1
      /\ contains'0 (view'0 self) ptr2 /\ addr_logic'0 ptr1 = addr_logic'0 ptr2  -> ptr1 = ptr2}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec are_eq (self:GhostPtrToken'0.t_GhostPtrToken t) (ptr1:opaque_ptr) (ptr2:opaque_ptr) (return'  (ret:bool))= {[%#sghost_ptr2] inv'0 self}
    {[%#sghost_ptr1] contains'0 (view'0 self) ptr2 \/ ptr2 = null_logic'0 ()}
    {[%#sghost_ptr0] contains'0 (view'0 self) ptr1 \/ ptr1 = null_logic'0 ()}
    (! bb0
    [ bb0 = s0 [ s0 = injective_lemma'0 {self} (fun (_ret':()) ->  [ &_8 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = addr'0 {ptr1} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = addr'0 {ptr2} (fun (_ret':usize) ->  [ &_12 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = UIntSize.eq {_10} {_12} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : bool = any_l ()
    | & self : GhostPtrToken'0.t_GhostPtrToken t = self
    | & ptr1 : opaque_ptr = ptr1
    | & ptr2 : opaque_ptr = ptr2
    | & _8 : () = any_l ()
    | & _10 : usize = any_l ()
    | & _12 : usize = any_l () ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [%#sghost_ptr4] result = (ptr1 = ptr2)}
      {[@expl:postcondition] [%#sghost_ptr3] result = (addr_logic'0 ptr1 = addr_logic'0 ptr2)}
      (! return' {result}) ]
    
end
module T_creusot_contracts__ghost_ptr__GhostPtrTokenMut [#"../../../creusot-contracts/src/ghost_ptr.rs" 24 0 24 42]
  type t_GhostPtrTokenMut 't
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__ptr_as_mut [#"../../../creusot-contracts/src/ghost_ptr.rs" 103 4 103 60] (* ghost_ptr::GhostPtrToken<T> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 100 15 100 34
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 103 27 103 31
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 101 14 101 54
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 102 14 102 55
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 103 54 103 60
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 140 27 140 31
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 138 14 138 38
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 139 14 139 38
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 260 15 260 42
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 261 14 261 59
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 262 14 262 56
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 263 14 263 65
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 264 14 264 42
  let%span sghost_ptr13 = "../../../creusot-contracts/src/ghost_ptr.rs" 265 52 265 61
  let%span smodel14 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 112 8 112 35
  let%span sghost_ptr16 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr17 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sfmap18 = "../../../creusot-contracts/src/logic/fmap.rs" 95 8 95 35
  let%span sfmap19 = "../../../creusot-contracts/src/logic/fmap.rs" 55 14 55 71
  let%span sfmap20 = "../../../creusot-contracts/src/logic/fmap.rs" 56 14 56 61
  let%span sfmap21 = "../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 66
  let%span sghost_ptr22 = "../../../creusot-contracts/src/ghost_ptr.rs" 214 14 214 64
  let%span sghost_ptr23 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 8 216 14
  let%span sghost_ptr24 = "../../../creusot-contracts/src/ghost_ptr.rs" 222 14 222 64
  let%span sghost_ptr25 = "../../../creusot-contracts/src/ghost_ptr.rs" 224 8 224 14
  let%span sfmap26 = "../../../creusot-contracts/src/logic/fmap.rs" 65 14 65 55
  let%span sfmap27 = "../../../creusot-contracts/src/logic/fmap.rs" 66 14 66 84
  let%span sghost_ptr28 = "../../../creusot-contracts/src/ghost_ptr.rs" 294 8 294 32
  let%span sresolve29 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sfmap30 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sghost_ptr31 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr32 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr33 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sutil34 = "../../../creusot-contracts/src/util.rs" 34 11 34 21
  let%span sutil35 = "../../../creusot-contracts/src/util.rs" 35 10 35 28
  let%span sfmap36 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sutil37 = "../../../creusot-contracts/src/util.rs" 15 14 15 30
  let%span sfmap38 = "../../../creusot-contracts/src/logic/fmap.rs" 32 14 32 25
  let%span sghost_ptr39 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  let%span sinvariant40 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sghost_ptr41 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
   =
    [%#sinvariant40] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (GhostPtrToken'0.t_GhostPtrToken t) [inv'3 x] . inv'3 x
  = invariant'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant40] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'2_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap36] mk'0 (view'2 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap30] Map.get (view'2 self) k
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr32] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr31] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'1_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr16] get_unsized'0 (view'1 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr39] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'1 self) ptr = Option'0.C_Some x  -> inv'1 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'0 x] . inv'0 x = invariant'0 x
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 33 4 33 27] (self : FMap'0.t_FMap opaque_ptr t) : int
  
  axiom len'0_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap38] len'0 self >= 0
  
  function contains'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 111 4 111 39] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : bool
    
   =
    [%#sfmap15] get_unsized'0 self k <> Option'0.C_None
  
  use map.Map
  
  function make_sized'0 [#"../../../creusot-contracts/src/util.rs" 16 4 16 40] (self : t) : t
  
  axiom make_sized'0_spec : forall self : t . [%#sutil37] make_sized'0 self = self
  
  function insert'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 58 4 58 43] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) (v : t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom insert'0_spec : forall self : FMap'0.t_FMap opaque_ptr t, k : opaque_ptr, v : t . ([%#sfmap21] not contains'0 self k
   -> len'0 (insert'0 self k v) = len'0 self + 1)
  && ([%#sfmap20] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#sfmap19] view'2 (insert'0 self k v) = Map.set (view'2 self) k (Option'0.C_Some (make_sized'0 v)))
  
  function unwrap'0 [#"../../../creusot-contracts/src/util.rs" 36 0 36 36] (op : Option'0.t_Option t) : t
  
  axiom unwrap'0_spec : forall op : Option'0.t_Option t . ([%#sutil34] op <> Option'0.C_None)
   -> ([%#sutil35] Option'0.C_Some (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 94 4 94 50] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : t
    
   =
    [%#sfmap18] unwrap'0 (get_unsized'0 self k)
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 108 4 108 33] (self : borrowed (GhostPtrToken'0.t_GhostPtrToken t)) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel14] view'1 self.current
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
   =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
   =
    resolve'5 _1
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed t) =
    resolve'4 _1
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenMut as GhostPtrTokenMut'0
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 223 4 223 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom fin'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr24] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 215 4 215 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom cur'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr22] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate resolve'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 293 4 293 28] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
    
   =
    [%#sghost_ptr28] cur'0 self = fin'0 self
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
    
   =
    resolve'3 _1
  
  function remove'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 67 4 67 37] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom remove'0_spec : forall self : FMap'0.t_FMap opaque_ptr t, k : opaque_ptr . ([%#sfmap27] len'0 (remove'0 self k)
  = (if contains'0 self k then len'0 self - 1 else len'0 self))
  && ([%#sfmap26] view'2 (remove'0 self k) = Map.set (view'2 self) k (Option'0.C_None))
  
  let rec take_mut'0 (self:borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t)) (ptr:opaque_ptr) (return'  (ret:borrowed t))= {[@expl:precondition] [%#sghost_ptr8] contains'0 (cur'0 self.current) ptr}
    any
    [ return' (result:borrowed t)-> {[%#sghost_ptr13] inv'2 result}
      {[%#sghost_ptr12] not contains'0 (fin'0 self.final) ptr}
      {[%#sghost_ptr11] fin'0 self.current = insert'0 (fin'0 self.final) ptr result.final}
      {[%#sghost_ptr10] cur'0 self.final = remove'0 (cur'0 self.current) ptr}
      {[%#sghost_ptr9] result.current = lookup_unsized'0 (cur'0 self.current) ptr}
      (! return' {result}) ]
    
  
  let rec borrow_mut'0 (self:borrowed (GhostPtrToken'0.t_GhostPtrToken t)) (return'  (ret:GhostPtrTokenMut'0.t_GhostPtrTokenMut t))= {[@expl:precondition] [%#sghost_ptr5] inv'3 self}
    any
    [ return' (result:GhostPtrTokenMut'0.t_GhostPtrTokenMut t)-> {[%#sghost_ptr7] fin'0 result = view'1 self.final}
      {[%#sghost_ptr6] cur'0 result = view'1 self.current}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec ptr_as_mut (self:borrowed (GhostPtrToken'0.t_GhostPtrToken t)) (ptr:opaque_ptr) (return'  (ret:borrowed t))= {[%#sghost_ptr1] inv'3 self}
    {[%#sghost_ptr0] contains'0 (view'0 self) ptr}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <GhostPtrToken'0.t_GhostPtrToken t> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (GhostPtrToken'0.t_GhostPtrToken t)) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = borrow_mut'0 {_10} (fun (_ret':GhostPtrTokenMut'0.t_GhostPtrTokenMut t) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <GhostPtrTokenMut'0.t_GhostPtrTokenMut t> {_9}
          (fun (_ret':borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t)) ->
             [ &_8 <- _ret' ] 
             [ &_9 <- _ret'.final ] 
            s1)
      | s1 = take_mut'0 {_8} {ptr} (fun (_ret':borrowed t) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = -{resolve'0 _9}- s1
      | s1 = {inv'1 _7.current}
        Borrow.borrow_final <t> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed t) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_7 <- { _7 with current = _ret'.final ; } ] 
            s2)
      | s2 = {inv'1 _3.current}
        Borrow.borrow_final <t> {_3.current} {Borrow.get_id _3}
          (fun (_ret':borrowed t) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'2 _7} s4
      | s4 = -{resolve'1 _7}- s5
      | s5 = {[@expl:type invariant] inv'2 _3} s6
      | s6 = -{resolve'1 _3}- s7
      | s7 = {[@expl:type invariant] inv'3 self} s8
      | s8 = -{resolve'2 self}- s9
      | s9 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed t = any_l ()
    | & self : borrowed (GhostPtrToken'0.t_GhostPtrToken t) = self
    | & ptr : opaque_ptr = ptr
    | & _3 : borrowed t = any_l ()
    | & _7 : borrowed t = any_l ()
    | & _8 : borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t) = any_l ()
    | & _9 : GhostPtrTokenMut'0.t_GhostPtrTokenMut t = any_l ()
    | & _10 : borrowed (GhostPtrToken'0.t_GhostPtrToken t) = any_l () ]
    
    [ return' (result:borrowed t)-> {[@expl:postcondition] [%#sghost_ptr4] inv'2 result}
      {[@expl:postcondition] [%#sghost_ptr3] view'1 self.final = insert'0 (view'1 self.current) ptr result.final}
      {[@expl:postcondition] [%#sghost_ptr2] result.current = lookup_unsized'0 (view'1 self.current) ptr}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi14556734806454041375__drop [#"../../../creusot-contracts/src/ghost_ptr.rs" 127 4 127 21] (* ghost_ptr::GhostPtrToken<T> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 126 15 126 31
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 127 16 127 20
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sfmap4 = "../../../creusot-contracts/src/logic/fmap.rs" 127 8 127 34
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap8 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 118 14 118 31
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 119 14 119 49
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 188 14 188 38
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 189 14 189 83
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 191 8 191 35
  let%span sghost_ptr14 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  let%span sghost_ptr15 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap16 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sfmap17 = "../../../creusot-contracts/src/logic/fmap.rs" 32 14 32 25
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'1 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'1_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap16] mk'0 (view'1 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap8] Map.get (view'1 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr6] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr5] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'0_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr2] get_unsized'0 (view'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr14] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'0 self) ptr = Option'0.C_Some x  -> inv'1 x
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'0 x] . inv'0 x = invariant'0 x
  
  function ext_eq'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 190 4 190 44] (self : FMap'0.t_FMap opaque_ptr t) (other : FMap'0.t_FMap opaque_ptr t) : bool
    
   =
    [%#sfmap13] view'1 self = view'1 other
  
  axiom ext_eq'0_spec : forall self : FMap'0.t_FMap opaque_ptr t, other : FMap'0.t_FMap opaque_ptr t . ([%#sfmap12] (forall k : opaque_ptr . get_unsized'0 self k
  = get_unsized'0 other k)  -> ext_eq'0 self other)
  && ([%#sfmap11] ext_eq'0 self other  -> self = other)
  
  use map.Const
  
  function len'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 33 4 33 27] (self : FMap'0.t_FMap opaque_ptr t) : int
  
  axiom len'0_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap17] len'0 self >= 0
  
  function empty'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 120 4 120 26] (_1 : ()) : FMap'0.t_FMap opaque_ptr t
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap10] view'1 (empty'0 _1) = Const.const (Option'0.C_None))
  && ([%#sfmap9] len'0 (empty'0 _1) = 0)
  
  function is_empty'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 126 4 126 33] (self : FMap'0.t_FMap opaque_ptr t) : bool
    
   =
    [%#sfmap4] ext_eq'0 self (empty'0 ())
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec drop (self:GhostPtrToken'0.t_GhostPtrToken t) (return'  (ret:()))= {[%#sghost_ptr1] inv'0 self}
    {[%#sghost_ptr0] is_empty'0 (view'0 self)}
    (! bb0 [ bb0 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = return' {_0} ]  ] )
    [ & _0 : () = any_l () | & self : GhostPtrToken'0.t_GhostPtrToken t = self ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_creusot_contracts__ghost_ptr__GhostPtrTokenRef [#"../../../creusot-contracts/src/ghost_ptr.rs" 19 0 19 42]
  type t_GhostPtrTokenRef 't
end
module M_creusot_contracts__ghost_ptr__qyi12069901807935209935__deref [#"../../../creusot-contracts/src/ghost_ptr.rs" 179 4 179 36] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::ops::Deref> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 178 14 178 30
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 179 23 179 36
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 195 14 195 30
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 196 27 196 47
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 169 14 169 64
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 171 8 171 14
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sinvariant13 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sghost_ptr14 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap15 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sghost_ptr16 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'4 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'4_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap15] mk'0 (view'4 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap12] Map.get (view'4 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr10] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr9] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'3_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr7] get_unsized'0 (view'3 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr16] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'3 self) ptr = Option'0.C_Some x  -> inv'2 x
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sinvariant13] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenRef as GhostPtrTokenRef'0
  
  function view'2 [#"../../../creusot-contracts/src/ghost_ptr.rs" 170 4 170 33] (self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'2_spec : forall self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t . [%#sghost_ptr5] get_unsized'0 (view'2 self) (null_logic'0 ())
  = Option'0.C_None
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel4] view'2 self
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel4] view'3 self
  
  use prelude.prelude.Intrinsic
  
  let rec to_ref'0 (self:GhostPtrTokenRef'0.t_GhostPtrTokenRef t) (return'  (ret:GhostPtrToken'0.t_GhostPtrToken t))= any
    [ return' (result:GhostPtrToken'0.t_GhostPtrToken t)-> {[%#sghost_ptr3] inv'0 result}
      {[%#sghost_ptr2] view'0 result = view'2 self}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec deref (self:GhostPtrTokenRef'0.t_GhostPtrTokenRef t) (return'  (ret:GhostPtrToken'0.t_GhostPtrToken t))= (! bb0
    [ bb0 = s0
      [ s0 = to_ref'0 {self} (fun (_ret':GhostPtrToken'0.t_GhostPtrToken t) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- _3 ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : GhostPtrToken'0.t_GhostPtrToken t = any_l ()
    | & self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t = self
    | & _3 : GhostPtrToken'0.t_GhostPtrToken t = any_l () ]
    
    [ return' (result:GhostPtrToken'0.t_GhostPtrToken t)-> {[@expl:postcondition] [%#sghost_ptr1] inv'0 result}
      {[@expl:postcondition] [%#sghost_ptr0] view'0 result = view'1 self}
      (! return' {result}) ]
    
end
module M_creusot_contracts__ghost_ptr__qyi10758646311866972331__clone [#"../../../creusot-contracts/src/ghost_ptr.rs" 205 4 205 27] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::clone::Clone> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 204 14 204 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenRef as GhostPtrTokenRef'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:GhostPtrTokenRef'0.t_GhostPtrTokenRef t) (return'  (ret:GhostPtrTokenRef'0.t_GhostPtrTokenRef t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : GhostPtrTokenRef'0.t_GhostPtrTokenRef t = any_l ()
    | & self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t = self ]
    
    [ return' (result:GhostPtrTokenRef'0.t_GhostPtrTokenRef t)-> {[@expl:postcondition] [%#sghost_ptr0] result = self}
      (! return' {result}) ]
    
end
module T_core__cell__UnsafeCell
  type t_UnsafeCell 't =
    | C_UnsafeCell 't
  
  let rec t_UnsafeCell < 't > (input:t_UnsafeCell 't) (ret  (value:'t))= any
    [ good (value:'t)-> {C_UnsafeCell value = input} (! ret {value}) ]
    
end
module T_core__cell__Cell
  use T_core__cell__UnsafeCell as UnsafeCell'0
  
  type t_Cell 't =
    | C_Cell (UnsafeCell'0.t_UnsafeCell 't)
  
  let rec t_Cell < 't > (input:t_Cell 't) (ret  (value:UnsafeCell'0.t_UnsafeCell 't))= any
    [ good (value:UnsafeCell'0.t_UnsafeCell 't)-> {C_Cell value = input} (! ret {value}) ]
    
end
module T_alloc__rc__RcBox
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cell__Cell as Cell'0
  
  type t_RcBox 't =
    | C_RcBox (Cell'0.t_Cell usize) (Cell'0.t_Cell usize) 't
  
  let rec t_RcBox < 't > (input:t_RcBox 't) (ret  (strong:Cell'0.t_Cell usize) (weak:Cell'0.t_Cell usize) (value:'t))= any
    [ good (strong:Cell'0.t_Cell usize) (weak:Cell'0.t_Cell usize) (value:'t)-> {C_RcBox strong weak value = input}
      (! ret {strong} {weak} {value}) ]
    
end
module T_alloc__rc__Rc
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_alloc__rc__RcBox as RcBox'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Rc 't 'a =
    | C_Rc (NonNull'0.t_NonNull (RcBox'0.t_RcBox 't)) (PhantomData'0.t_PhantomData (RcBox'0.t_RcBox 't)) 'a
  
  let rec t_Rc < 't > < 'a > (input:t_Rc 't 'a) (ret  (ptr:NonNull'0.t_NonNull (RcBox'0.t_RcBox 't)) (phantom:PhantomData'0.t_PhantomData (RcBox'0.t_RcBox 't)) (alloc:'a))= any
    [ good (ptr:NonNull'0.t_NonNull (RcBox'0.t_RcBox 't)) (phantom:PhantomData'0.t_PhantomData (RcBox'0.t_RcBox 't)) (alloc:'a)-> {C_Rc ptr phantom alloc
      = input}
      (! ret {ptr} {phantom} {alloc}) ]
    
end
module T_core__sync__atomic__AtomicUsize
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__cell__UnsafeCell as UnsafeCell'0
  
  type t_AtomicUsize  =
    | C_AtomicUsize (UnsafeCell'0.t_UnsafeCell usize)
  
  let rec t_AtomicUsize (input:t_AtomicUsize) (ret  (v:UnsafeCell'0.t_UnsafeCell usize))= any
    [ good (v:UnsafeCell'0.t_UnsafeCell usize)-> {C_AtomicUsize v = input} (! ret {v}) ]
    
end
module T_alloc__sync__ArcInner
  use T_core__sync__atomic__AtomicUsize as AtomicUsize'0
  
  type t_ArcInner 't =
    | C_ArcInner (AtomicUsize'0.t_AtomicUsize) (AtomicUsize'0.t_AtomicUsize) 't
  
  let rec t_ArcInner < 't > (input:t_ArcInner 't) (ret  (strong:AtomicUsize'0.t_AtomicUsize) (weak:AtomicUsize'0.t_AtomicUsize) (data:'t))= any
    [ good (strong:AtomicUsize'0.t_AtomicUsize) (weak:AtomicUsize'0.t_AtomicUsize) (data:'t)-> {C_ArcInner strong weak data
      = input}
      (! ret {strong} {weak} {data}) ]
    
end
module T_alloc__sync__Arc
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_alloc__sync__ArcInner as ArcInner'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Arc 't 'a =
    | C_Arc (NonNull'0.t_NonNull (ArcInner'0.t_ArcInner 't)) (PhantomData'0.t_PhantomData (ArcInner'0.t_ArcInner 't)) 'a
  
  let rec t_Arc < 't > < 'a > (input:t_Arc 't 'a) (ret  (ptr:NonNull'0.t_NonNull (ArcInner'0.t_ArcInner 't)) (phantom:PhantomData'0.t_PhantomData (ArcInner'0.t_ArcInner 't)) (alloc:'a))= any
    [ good (ptr:NonNull'0.t_NonNull (ArcInner'0.t_ArcInner 't)) (phantom:PhantomData'0.t_PhantomData (ArcInner'0.t_ArcInner 't)) (alloc:'a)-> {C_Arc ptr phantom alloc
      = input}
      (! ret {ptr} {phantom} {alloc}) ]
    
end
module T_alloc__string__String
  use T_alloc__alloc__Global as Global'0
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use T_alloc__vec__Vec as Vec'0
  
  type t_String  =
    | C_String (Vec'0.t_Vec uint8 (Global'0.t_Global))
  
  let rec t_String (input:t_String) (ret  (vec:Vec'0.t_Vec uint8 (Global'0.t_Global)))= any
    [ good (vec:Vec'0.t_Vec uint8 (Global'0.t_Global))-> {C_String vec = input} (! ret {vec}) ]
    
end
module M_creusot_contracts__resolve__qyi4855891653524509355__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 34 4 34 31] (* <(T1, T2) as resolve::Resolve> *)
  type t1
  
  type t2
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 32 15 32 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 33 14 33 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 27 8 27 44
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t2)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t1)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 26 4 26 28] (self : (t1, t2)) =
    [%#sresolve2] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  predicate structural_resolve'0 (x : (t1, t2)) =
    match x with
      | (a, b) -> resolve'1 b /\ resolve'2 a
      end
  
  constant self  : (t1, t2)
  
  function resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 34 4 34 31] (self : (t1, t2)) : ()
  
  goal vc_resolve_coherence : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi6740873903368268328__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 48 4 48 31] (* <&mut T as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 46 15 46 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 47 14 47 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve2] self.final = self.current
  
  predicate structural_resolve'0 (x : borrowed t) =
    x.final = x.current
  
  constant self  : borrowed t
  
  function resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 48 4 48 31] (self : borrowed t) : ()
  
  goal vc_resolve_coherence : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi10830812895881240411__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 62 4 62 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 60 15 60 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 61 14 61 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 54 4 54 28] (self : t) =
    [%#sresolve2] resolve'1 self
  
  predicate structural_resolve'0 (x : t) =
    resolve'1 x
  
  constant self  : t
  
  function resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 62 4 62 31] (self : t) : ()
  
  goal vc_resolve_coherence : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi12875730110607858017__resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 79 4 79 31] (* <std::option::Option<T> as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 77 15 77 39
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 78 14 78 31
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 68 4 68 28] (self : Option'0.t_Option t) =
    [%#sresolve2] match self with
      | Option'0.C_Some x -> resolve'1 x
      | Option'0.C_None -> true
      end
  
  predicate structural_resolve'0 (x : Option'0.t_Option t) =
    match x with
      | Option'0.C_None -> true
      | Option'0.C_Some a -> resolve'1 a
      end
  
  constant self  : Option'0.t_Option t
  
  function resolve_coherence [#"../../../creusot-contracts/src/resolve.rs" 79 4 79 31] (self : Option'0.t_Option t) : ()
  
  goal vc_resolve_coherence : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__logic__int__qyi3540547019284611154 [#"../../../creusot-contracts/src/logic/int.rs" 15 0 15 25] (* <logic::int::Int as std::clone::Clone> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 19 4 19 27
  
  use prelude.prelude.Int
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#sint0] forall self : int . inv'0 self
   -> (forall result : int . result = self  -> inv'1 result /\ result = self)
end
module M_creusot_contracts__ghost__qyi17645547594388049322 [#"../../../creusot-contracts/src/ghost.rs" 31 0 31 45] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 33 4 33 27
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed2] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'1 x] . inv'1 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'2 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  goal clone'_refn : [%#sghost0] forall self : GhostBox'0.t_GhostBox t . inv'0 self
   -> inv'0 self
  /\ (forall result : GhostBox'0.t_GhostBox t . inv'1 result /\ result = self  -> inv'1 result /\ result = self)
end
module M_creusot_contracts__snapshot__qyi5567339964777190687 [#"../../../creusot-contracts/src/snapshot.rs" 31 0 31 37] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type t
  
  let%span ssnapshot0 = "../../../creusot-contracts/src/snapshot.rs" 33 4 33 27
  
  use prelude.prelude.Snapshot
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Snapshot.snap_ty t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Snapshot.snap_ty t [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Snapshot.snap_ty t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Snapshot.snap_ty t [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#ssnapshot0] forall self : Snapshot.snap_ty t . inv'0 self
   -> (forall result : Snapshot.snap_ty t . result = self  -> inv'1 result /\ result = self)
end
module M_creusot_contracts__ghost_ptr__qyi10758646311866972331 [#"../../../creusot-contracts/src/ghost_ptr.rs" 203 0 203 53] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::clone::Clone> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 205 4 205 27
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenRef as GhostPtrTokenRef'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrTokenRef'0.t_GhostPtrTokenRef t)
    
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostPtrTokenRef'0.t_GhostPtrTokenRef t [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrTokenRef'0.t_GhostPtrTokenRef t)
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrTokenRef'0.t_GhostPtrTokenRef t [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#sghost_ptr0] forall self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t . inv'0 self
   -> (forall result : GhostPtrTokenRef'0.t_GhostPtrTokenRef t . result = self  -> inv'1 result /\ result = self)
end
module M_creusot_contracts__logic__int__qyi17639319683369591966 [#"../../../creusot-contracts/src/logic/int.rs" 23 0 23 17] (* <logic::int::Int as std::marker::Copy> *)
  
end
module M_creusot_contracts__snapshot__qyi870557194592550824 [#"../../../creusot-contracts/src/snapshot.rs" 38 0 38 36] (* <snapshot::Snapshot<T> as std::marker::Copy> *)
  type t
end
module M_creusot_contracts__ghost_ptr__qyi4647809105529835830 [#"../../../creusot-contracts/src/ghost_ptr.rs" 201 0 201 52] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::marker::Copy> *)
  type t
end
module M_creusot_contracts__logic__int__qyi3411234291730139970 [#"../../../creusot-contracts/src/logic/int.rs" 86 0 86 21] (* <logic::int::Int as std::ops::Add> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 91 4 91 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal add_refn : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi14674898037351238599 [#"../../../creusot-contracts/src/logic/int.rs" 97 0 97 21] (* <logic::int::Int as std::ops::Sub> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 102 4 102 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal sub_refn : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi92031444461445902 [#"../../../creusot-contracts/src/logic/int.rs" 108 0 108 21] (* <logic::int::Int as std::ops::Mul> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 113 4 113 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal mul_refn : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi2704776725966497021 [#"../../../creusot-contracts/src/logic/int.rs" 119 0 119 21] (* <logic::int::Int as std::ops::Div> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 124 4 124 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal div_refn : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi13390566486180286353 [#"../../../creusot-contracts/src/logic/int.rs" 130 0 130 21] (* <logic::int::Int as std::ops::Rem> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 135 4 135 32
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal rem_refn : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__int__qyi6972377124305281595 [#"../../../creusot-contracts/src/logic/int.rs" 141 0 141 16] (* <logic::int::Int as std::ops::Neg> *)
  let%span sint0 = "../../../creusot-contracts/src/logic/int.rs" 146 4 146 24
  
  use prelude.prelude.Int
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  goal neg_refn : [%#sint0] forall self : int . inv'0 self  -> (forall result : int . inv'0 result)
end
module M_creusot_contracts__logic__ops__qyi2313892199598520391 [#"../../../creusot-contracts/src/logic/ops.rs" 13 0 13 51] (* <std::vec::Vec<T, A> as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
  
  type a
end
module M_creusot_contracts__logic__ops__qyi1610842075579391148 [#"../../../creusot-contracts/src/logic/ops.rs" 24 0 24 53] (* <std::vec::Vec<T, A> as logic::ops::IndexLogic<usize>> *)
  type t
  
  type a
end
module M_creusot_contracts__logic__ops__qyi798393316578497346 [#"../../../creusot-contracts/src/logic/ops.rs" 35 0 35 31] (* <[T] as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
end
module M_creusot_contracts__logic__ops__qyi14233936071182067080 [#"../../../creusot-contracts/src/logic/ops.rs" 46 0 46 33] (* <[T] as logic::ops::IndexLogic<usize>> *)
  type t
end
module M_creusot_contracts__logic__ops__qyi10484387153616184009 [#"../../../creusot-contracts/src/logic/ops.rs" 57 0 57 50] (* <[T; N] as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
end
module M_creusot_contracts__logic__ops__qyi2355897567732064767 [#"../../../creusot-contracts/src/logic/ops.rs" 68 0 68 52] (* <[T; N] as logic::ops::IndexLogic<usize>> *)
  type t
end
module M_creusot_contracts__logic__ops__qyi8081894680052440102 [#"../../../creusot-contracts/src/logic/ops.rs" 79 0 79 44] (* <snapshot::Snapshot<logic::seq::Seq<T>> as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
end
module M_creusot_contracts__logic__seq__qyi3475712792215173045 [#"../../../creusot-contracts/src/logic/seq.rs" 240 0 240 34] (* <logic::seq::Seq<T> as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__deque__qyi16977089573735629399 [#"../../../creusot-contracts/src/std/deque.rs" 34 0 34 56] (* <std::collections::VecDeque<T, A> as logic::ops::IndexLogic<logic::int::Int>> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__deque__qyi10402007893065000312 [#"../../../creusot-contracts/src/std/deque.rs" 45 0 45 58] (* <std::collections::VecDeque<T, A> as logic::ops::IndexLogic<usize>> *)
  type t
  
  type a
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int) (o : int) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal cmp_ge_log_refn : [%#sord0] forall x : int . forall y : int . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal refl_refn : [%#sord1] forall x : int . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_gt_log_refn : [%#sord2] forall x : int . forall y : int . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord3] forall x : int . forall y : int . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal eq_cmp_refn : [%#sord4] forall x : int . forall y : int . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym1_refn : [%#sord5] forall x : int . forall y : int . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal antisym2_refn : [%#sord6] forall x : int . forall y : int . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord7] forall x : int . forall y : int . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord8] forall x : int . forall y : int . forall z : int . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint8) (o : uint8) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal eq_cmp_refn : [%#sord0] forall x : uint8 . forall y : uint8 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_gt_log_refn : [%#sord1] forall x : uint8 . forall y : uint8 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord2] forall x : uint8 . forall y : uint8 . forall z : uint8 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal antisym2_refn : [%#sord3] forall x : uint8 . forall y : uint8 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord4] forall x : uint8 . forall y : uint8 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord5] forall x : uint8 . forall y : uint8 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord6] forall x : uint8 . forall y : uint8 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal antisym1_refn : [%#sord7] forall x : uint8 . forall y : uint8 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord8] forall x : uint8 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt16
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint16) (o : uint16) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal antisym2_refn : [%#sord0] forall x : uint16 . forall y : uint16 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord1] forall x : uint16 . forall y : uint16 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal refl_refn : [%#sord2] forall x : uint16 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_lt_log_refn : [%#sord3] forall x : uint16 . forall y : uint16 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord4] forall x : uint16 . forall y : uint16 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal antisym1_refn : [%#sord5] forall x : uint16 . forall y : uint16 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord6] forall x : uint16 . forall y : uint16 . forall z : uint16 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal eq_cmp_refn : [%#sord7] forall x : uint16 . forall y : uint16 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_gt_log_refn : [%#sord8] forall x : uint16 . forall y : uint16 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint32) (o : uint32) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal cmp_gt_log_refn : [%#sord0] forall x : uint32 . forall y : uint32 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord1] forall x : uint32 . forall y : uint32 . forall z : uint32 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal cmp_lt_log_refn : [%#sord2] forall x : uint32 . forall y : uint32 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord3] forall x : uint32 . forall y : uint32 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord4] forall x : uint32 . forall y : uint32 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal antisym2_refn : [%#sord5] forall x : uint32 . forall y : uint32 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal refl_refn : [%#sord6] forall x : uint32 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal eq_cmp_refn : [%#sord7] forall x : uint32 . forall y : uint32 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym1_refn : [%#sord8] forall x : uint32 . forall y : uint32 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint64) (o : uint64) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal trans_refn : [%#sord0] forall x : uint64 . forall y : uint64 . forall z : uint64 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal eq_cmp_refn : [%#sord1] forall x : uint64 . forall y : uint64 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym1_refn : [%#sord2] forall x : uint64 . forall y : uint64 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord3] forall x : uint64 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_le_log_refn : [%#sord4] forall x : uint64 . forall y : uint64 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_ge_log_refn : [%#sord5] forall x : uint64 . forall y : uint64 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal antisym2_refn : [%#sord6] forall x : uint64 . forall y : uint64 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord7] forall x : uint64 . forall y : uint64 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord8] forall x : uint64 . forall y : uint64 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UInt128
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : uint128) (o : uint128) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal antisym2_refn : [%#sord0] forall x : uint128 . forall y : uint128 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord1] forall x : uint128 . forall y : uint128 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal antisym1_refn : [%#sord2] forall x : uint128 . forall y : uint128 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord3] forall x : uint128 . forall y : uint128 . forall z : uint128 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal refl_refn : [%#sord4] forall x : uint128 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_ge_log_refn : [%#sord5] forall x : uint128 . forall y : uint128 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal eq_cmp_refn : [%#sord6] forall x : uint128 . forall y : uint128 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_gt_log_refn : [%#sord7] forall x : uint128 . forall y : uint128 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord8] forall x : uint128 . forall y : uint128 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : usize) (o : usize) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal antisym1_refn : [%#sord0] forall x : usize . forall y : usize . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal cmp_ge_log_refn : [%#sord1] forall x : usize . forall y : usize . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord2] forall x : usize . forall y : usize . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord3] forall x : usize . forall y : usize . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord4] forall x : usize . forall y : usize . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord5] forall x : usize . forall y : usize . forall z : usize . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal eq_cmp_refn : [%#sord6] forall x : usize . forall y : usize . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym2_refn : [%#sord7] forall x : usize . forall y : usize . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal refl_refn : [%#sord8] forall x : usize . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int8) (o : int8) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal cmp_lt_log_refn : [%#sord0] forall x : int8 . forall y : int8 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord1] forall x : int8 . forall y : int8 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal trans_refn : [%#sord2] forall x : int8 . forall y : int8 . forall z : int8 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal refl_refn : [%#sord3] forall x : int8 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal antisym1_refn : [%#sord4] forall x : int8 . forall y : int8 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal cmp_gt_log_refn : [%#sord5] forall x : int8 . forall y : int8 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal eq_cmp_refn : [%#sord6] forall x : int8 . forall y : int8 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym2_refn : [%#sord7] forall x : int8 . forall y : int8 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord8] forall x : int8 . forall y : int8 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int16
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int16) (o : int16) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal cmp_ge_log_refn : [%#sord0] forall x : int16 . forall y : int16 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal trans_refn : [%#sord1] forall x : int16 . forall y : int16 . forall z : int16 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal cmp_le_log_refn : [%#sord2] forall x : int16 . forall y : int16 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord3] forall x : int16 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal eq_cmp_refn : [%#sord4] forall x : int16 . forall y : int16 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_lt_log_refn : [%#sord5] forall x : int16 . forall y : int16 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal antisym2_refn : [%#sord6] forall x : int16 . forall y : int16 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord7] forall x : int16 . forall y : int16 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal antisym1_refn : [%#sord8] forall x : int16 . forall y : int16 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int32) (o : int32) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal cmp_le_log_refn : [%#sord0] forall x : int32 . forall y : int32 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord1] forall x : int32 . forall y : int32 . forall z : int32 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal cmp_gt_log_refn : [%#sord2] forall x : int32 . forall y : int32 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord3] forall x : int32 . forall y : int32 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord4] forall x : int32 . forall y : int32 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal antisym1_refn : [%#sord5] forall x : int32 . forall y : int32 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal antisym2_refn : [%#sord6] forall x : int32 . forall y : int32 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal refl_refn : [%#sord7] forall x : int32 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal eq_cmp_refn : [%#sord8] forall x : int32 . forall y : int32 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int64
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int64) (o : int64) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal refl_refn : [%#sord0] forall x : int64 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_lt_log_refn : [%#sord1] forall x : int64 . forall y : int64 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal antisym1_refn : [%#sord2] forall x : int64 . forall y : int64 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord3] forall x : int64 . forall y : int64 . forall z : int64 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal eq_cmp_refn : [%#sord4] forall x : int64 . forall y : int64 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym2_refn : [%#sord5] forall x : int64 . forall y : int64 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord6] forall x : int64 . forall y : int64 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_le_log_refn : [%#sord7] forall x : int64 . forall y : int64 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_ge_log_refn : [%#sord8] forall x : int64 . forall y : int64 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Int128
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : int128) (o : int128) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal antisym1_refn : [%#sord0] forall x : int128 . forall y : int128 . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal eq_cmp_refn : [%#sord1] forall x : int128 . forall y : int128 . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym2_refn : [%#sord2] forall x : int128 . forall y : int128 . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord3] forall x : int128 . forall y : int128 . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord4] forall x : int128 . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_ge_log_refn : [%#sord5] forall x : int128 . forall y : int128 . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_lt_log_refn : [%#sord6] forall x : int128 . forall y : int128 . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord7] forall x : int128 . forall y : int128 . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal trans_refn : [%#sord8] forall x : int128 . forall y : int128 . forall z : int128 . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848 [#"../../../creusot-contracts/src/logic/ord.rs" 131 8 131 28] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 134 12 134 49] (self : isize) (o : isize) : Ordering'0.t_Ordering
    
   =
    [%#sord9] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  goal antisym1_refn : [%#sord0] forall x : isize . forall y : isize . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal antisym2_refn : [%#sord1] forall x : isize . forall y : isize . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord2] forall x : isize . forall y : isize . forall result : () . (x >= y)
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> (x >= y) = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_lt_log_refn : [%#sord3] forall x : isize . forall y : isize . forall result : () . (x < y)
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> (x < y) = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal trans_refn : [%#sord4] forall x : isize . forall y : isize . forall z : isize . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal eq_cmp_refn : [%#sord5] forall x : isize . forall y : isize . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal refl_refn : [%#sord6] forall x : isize . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal cmp_gt_log_refn : [%#sord7] forall x : isize . forall y : isize . forall result : () . (x > y)
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> (x > y) = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_le_log_refn : [%#sord8] forall x : isize . forall y : isize . forall result : () . (x <= y)
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> (x <= y) = (cmp_log'0 x y <> Ordering'0.C_Greater)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586 [#"../../../creusot-contracts/src/logic/ord.rs" 197 0 197 22] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 201 8 206 9
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 200 4 200 41] (self : bool) (o : bool) : Ordering'0.t_Ordering
    
   =
    [%#sord10] match (self, o) with
      | (False, False) -> Ordering'0.C_Equal
      | (True, True) -> Ordering'0.C_Equal
      | (False, True) -> Ordering'0.C_Less
      | (True, False) -> Ordering'0.C_Greater
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : bool) (o : bool) : bool =
    [%#sord13] cmp_log'0 self o = Ordering'0.C_Less
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : bool) (o : bool) : bool =
    [%#sord12] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : bool) (o : bool) : bool =
    [%#sord11] cmp_log'0 self o = Ordering'0.C_Greater
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : bool) (o : bool) : bool =
    [%#sord9] cmp_log'0 self o <> Ordering'0.C_Less
  
  goal cmp_ge_log_refn : [%#sord0] forall x : bool . forall y : bool . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal refl_refn : [%#sord1] forall x : bool . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal antisym1_refn : [%#sord2] forall x : bool . forall y : bool . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal cmp_gt_log_refn : [%#sord3] forall x : bool . forall y : bool . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_le_log_refn : [%#sord4] forall x : bool . forall y : bool . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_lt_log_refn : [%#sord5] forall x : bool . forall y : bool . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal eq_cmp_refn : [%#sord6] forall x : bool . forall y : bool . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal antisym2_refn : [%#sord7] forall x : bool . forall y : bool . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal trans_refn : [%#sord8] forall x : bool . forall y : bool . forall z : bool . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi1910662420989811789 [#"../../../creusot-contracts/src/logic/ord.rs" 212 0 212 50] (* <(A, B) as logic::ord::OrdLogic> *)
  type a
  
  type b
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 247 20 247 67
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 241 20 241 68
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 229 20 229 68
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 235 20 235 67
  
  function lt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : a) (o : a) : bool
  
  function lt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : b) (o : b) : bool
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 234 4 234 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord13] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'1 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function le_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : b) (o : b) : bool
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 228 4 228 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord12] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'1 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function gt_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : a) (o : a) : bool
  
  function ge_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : b) (o : b) : bool
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 240 4 240 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord11] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'2 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : b) (_2 : b) : Ordering'0.t_Ordering
    
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : a) (_2 : a) : Ordering'0.t_Ordering
    
  
  function cmp_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 215 4 215 41] (self : (a, b)) (o : (a, b)) : Ordering'0.t_Ordering
    
   =
    [%#sord10] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function gt_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : b) (o : b) : bool
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 246 4 246 36] (self : (a, b)) (o : (a, b)) : bool =
    [%#sord9] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  goal cmp_gt_log_refn : [%#sord0] forall x : (a, b) . forall y : (a, b) . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal cmp_ge_log_refn : [%#sord1] forall x : (a, b) . forall y : (a, b) . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal antisym2_refn : [%#sord2] forall x : (a, b) . forall y : (a, b) . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal eq_cmp_refn : [%#sord3] forall x : (a, b) . forall y : (a, b) . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_le_log_refn : [%#sord4] forall x : (a, b) . forall y : (a, b) . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord5] forall x : (a, b) . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal trans_refn : [%#sord6] forall x : (a, b) . forall y : (a, b) . forall z : (a, b) . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal cmp_lt_log_refn : [%#sord7] forall x : (a, b) . forall y : (a, b) . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal antisym1_refn : [%#sord8] forall x : (a, b) . forall y : (a, b) . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi16241606109483467814 [#"../../../creusot-contracts/src/std/cmp.rs" 74 0 74 41] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span scmp0 = "../../../creusot-contracts/src/std/cmp.rs" 93 4 93 35
  let%span scmp1 = "../../../creusot-contracts/src/std/cmp.rs" 121 4 121 33
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 132 4 132 31
  let%span scmp3 = "../../../creusot-contracts/src/std/cmp.rs" 108 4 108 20
  let%span scmp4 = "../../../creusot-contracts/src/std/cmp.rs" 115 4 115 52
  let%span scmp5 = "../../../creusot-contracts/src/std/cmp.rs" 127 4 127 33
  let%span scmp6 = "../../../creusot-contracts/src/std/cmp.rs" 88 4 88 35
  let%span scmp7 = "../../../creusot-contracts/src/std/cmp.rs" 98 4 98 35
  let%span scmp8 = "../../../creusot-contracts/src/std/cmp.rs" 103 4 103 35
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 78 8 82 9
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  use T_core__cmp__Reverse as T_core__cmp__Reverse
  
  use T_core__cmp__Reverse as Reverse'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/cmp.rs" 77 4 77 41] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : Ordering'0.t_Ordering
    
   =
    [%#scmp10] match cmp_log'1 (T_core__cmp__Reverse.t_Reverse__0 self) (T_core__cmp__Reverse.t_Reverse__0 o) with
      | Ordering'0.C_Equal -> Ordering'0.C_Equal
      | Ordering'0.C_Less -> Ordering'0.C_Greater
      | Ordering'0.C_Greater -> Ordering'0.C_Less
      end
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord13] cmp_log'0 self o = Ordering'0.C_Greater
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord12] cmp_log'0 self o <> Ordering'0.C_Less
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord11] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Reverse'0.t_Reverse t) (o : Reverse'0.t_Reverse t) : bool
    
   =
    [%#sord9] cmp_log'0 self o = Ordering'0.C_Less
  
  goal cmp_lt_log_refn : [%#scmp0] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal antisym1_refn : [%#scmp1] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . cmp_log'0 x y
  = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal eq_cmp_refn : [%#scmp2] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall result : () . (x
  = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal refl_refn : [%#scmp3] forall x : Reverse'0.t_Reverse t . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal trans_refn : [%#scmp4] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall z : Reverse'0.t_Reverse t . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal antisym2_refn : [%#scmp5] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . cmp_log'0 x y
  = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#scmp6] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_ge_log_refn : [%#scmp7] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#scmp8] forall x : Reverse'0.t_Reverse t . forall y : Reverse'0.t_Reverse t . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
end
module M_creusot_contracts__stdqy35z1__option__qyi10751279649878241649 [#"../../../creusot-contracts/src/std/option.rs" 433 0 433 40] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type t
  
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 31 20 31 53
  let%span soption10 = "../../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 11 20 11 56
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 41 20 41 56
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 21 20 21 53
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 [#"../../../creusot-contracts/src/logic/ord.rs" 6 4 6 42] (self : t) (_2 : t) : Ordering'0.t_Ordering
    
  
  use T_core__option__Option as Option'0
  
  function cmp_log'0 [#"../../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : Ordering'0.t_Ordering
    
   =
    [%#soption10] match (self, o) with
      | (Option'0.C_None, Option'0.C_None) -> Ordering'0.C_Equal
      | (Option'0.C_None, Option'0.C_Some _) -> Ordering'0.C_Less
      | (Option'0.C_Some _, Option'0.C_None) -> Ordering'0.C_Greater
      | (Option'0.C_Some x, Option'0.C_Some y) -> cmp_log'1 x y
      end
  
  function lt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 20 4 20 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord13] cmp_log'0 self o = Ordering'0.C_Less
  
  function gt_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 40 4 40 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord12] cmp_log'0 self o = Ordering'0.C_Greater
  
  function le_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 10 4 10 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord11] cmp_log'0 self o <> Ordering'0.C_Greater
  
  function ge_log'0 [#"../../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (self : Option'0.t_Option t) (o : Option'0.t_Option t) : bool
    
   =
    [%#sord9] cmp_log'0 self o <> Ordering'0.C_Less
  
  goal cmp_ge_log_refn : [%#sord0] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> ge_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_le_log_refn : [%#sord1] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> le_log'0 x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal cmp_gt_log_refn : [%#sord2] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> gt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal eq_cmp_refn : [%#sord3] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall result : () . (x
  = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_lt_log_refn : [%#sord4] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> lt_log'0 x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal antisym2_refn : [%#sord5] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . cmp_log'0 x y
  = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal antisym1_refn : [%#sord6] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . cmp_log'0 x y
  = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord7] forall x : Option'0.t_Option t . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
  
  goal trans_refn : [%#sord8] forall x : Option'0.t_Option t . forall y : Option'0.t_Option t . forall z : Option'0.t_Option t . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841 [#"../../../creusot-contracts/src/num_rational.rs" 32 0 32 22] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../../creusot-contracts/src/logic/ord.rs" 79 8 79 39
  let%span sord1 = "../../../creusot-contracts/src/logic/ord.rs" 123 8 123 35
  let%span sord2 = "../../../creusot-contracts/src/logic/ord.rs" 84 8 84 39
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 89 8 89 39
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 94 8 94 39
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 118 8 118 37
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 106 8 106 56
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 112 8 112 37
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 99 8 99 24
  let%span snum_rational9 = "../../../creusot-contracts/src/num_rational.rs" 33 4 33 12
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  use prelude.prelude.Real
  
  use T_core__cmp__Ordering as Ordering'0
  
  use prelude.prelude.Real
  
  function cmp_log'0 [#"../../../creusot-contracts/src/num_rational.rs" 35 4 35 41] (self : Real.real) (o : Real.real) : Ordering'0.t_Ordering
    
   =
    [%#snum_rational9] if Real.(<) self o then
      Ordering'0.C_Less
    else
      if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
    
  
  use prelude.prelude.Real
  
  goal cmp_le_log_refn : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<=) x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)  -> Real.(<=) x y = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  goal eq_cmp_refn : [%#sord1] forall x : Real.real . forall y : Real.real . forall result : () . (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)  -> (x = y) = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  goal cmp_lt_log_refn : [%#sord2] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<) x y
  = (cmp_log'0 x y = Ordering'0.C_Less)  -> Real.(<) x y = (cmp_log'0 x y = Ordering'0.C_Less)
  
  goal cmp_ge_log_refn : [%#sord3] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>=) x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)  -> Real.(>=) x y = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  goal cmp_gt_log_refn : [%#sord4] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>) x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)  -> Real.(>) x y = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  goal antisym2_refn : [%#sord5] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = Ordering'0.C_Greater
   -> cmp_log'0 x y = Ordering'0.C_Greater
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Less  -> cmp_log'0 y x = Ordering'0.C_Less)
  
  goal trans_refn : [%#sord6] forall x : Real.real . forall y : Real.real . forall z : Real.real . forall o : Ordering'0.t_Ordering . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
  
  goal antisym1_refn : [%#sord7] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = Ordering'0.C_Less
   -> cmp_log'0 x y = Ordering'0.C_Less
  /\ (forall result : () . cmp_log'0 y x = Ordering'0.C_Greater  -> cmp_log'0 y x = Ordering'0.C_Greater)
  
  goal refl_refn : [%#sord8] forall x : Real.real . forall result : () . cmp_log'0 x x = Ordering'0.C_Equal
   -> cmp_log'0 x x = Ordering'0.C_Equal
end
module M_creusot_contracts__logic__seq__qyi11415422055223021362 [#"../../../creusot-contracts/src/logic/seq.rs" 453 0 453 36] (* <logic::seq::Seq<T> as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__stdqy35z1__array__qyi3266718356972430272 [#"../../../creusot-contracts/src/std/array.rs" 3 0 3 44] (* <[T; N] as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__stdqy35z1__boxed__qyi14030954864601294471 [#"../../../creusot-contracts/src/std/boxed.rs" 22 0 22 53] (* <std::boxed::Box<T, A> as invariant::Invariant> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi475855317763719688 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 43 0 43 44] (* <std::iter::Enumerate<I> as invariant::Invariant> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi14027088409956777806 [#"../../../creusot-contracts/src/std/iter/filter.rs" 42 0 42 72] (* <std::iter::Filter<I, F> as invariant::Invariant> *)
  type i
  
  type f
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi5815150052455853461 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 77 0 78 29] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as invariant::Invariant> *)
  type i
  
  type b
  
  type f
end
module M_creusot_contracts__stdqy35z1__slice__qyi1274009792248558409 [#"../../../creusot-contracts/src/std/slice.rs" 12 0 12 25] (* <[T] as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__stdqy35z1__vec__qyi17435493896800110490 [#"../../../creusot-contracts/src/std/vec.rs" 62 0 62 45] (* <std::vec::Vec<T, A> as invariant::Invariant> *)
  type t
  
  type a
end
module M_creusot_contracts__ghost_ptr__qyi18216970908838873096 [#"../../../creusot-contracts/src/ghost_ptr.rs" 41 0 41 46] (* <ghost_ptr::GhostPtrToken<T> as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__invariant__qyi18346118373867264643 [#"../../../creusot-contracts/src/invariant.rs" 9 0 9 20] (* <! as invariant::Invariant> *)
  
end
module M_creusot_contracts__invariant__qyi4722187969488722333 [#"../../../creusot-contracts/src/invariant.rs" 18 0 18 32] (* <&T as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__invariant__qyi1866818523498774596 [#"../../../creusot-contracts/src/invariant.rs" 28 0 28 36] (* <&mut T as invariant::Invariant> *)
  type t
end
module M_creusot_contracts__stdqy35z1__array__qyi8418119750458110475 [#"../../../creusot-contracts/src/std/array.rs" 13 0 13 39] (* <[T; N] as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__boxed__qyi4834868520041114427 [#"../../../creusot-contracts/src/std/boxed.rs" 13 0 13 55] (* <std::boxed::Box<T, A> as model::View> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__deque__qyi4531477903278466177 [#"../../../creusot-contracts/src/std/deque.rs" 8 0 8 45] (* <std::collections::VecDeque<T, A> as model::View> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__deque__qyi14108135644044654308 [#"../../../creusot-contracts/src/std/deque.rs" 153 0 153 32] (* <std::collections::vec_deque::Iter<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi14689230007539118487 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 3 0 3 34] (* <std::iter::Fuse<I> as model::View> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi18364796073567306597 [#"../../../creusot-contracts/src/std/iter/once.rs" 3 0 3 24] (* <std::iter::Once<T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8272614202207635492 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 3 0 3 26] (* <std::iter::Repeat<T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__num__qyi3012000906173553385 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <u8 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi1094869650810654678 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <u16 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi14576385738279895371 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <u32 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi16929996284936743259 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <u64 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi2810742655240912690 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <u128 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi17189085819229473095 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <usize as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi3504959296210127047 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <i8 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi2387335707800498133 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <i16 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi12945155172798422382 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <i32 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi1579027902848976220 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <i64 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi10365595074762074383 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <i128 as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi9511100432512157179 [#"../../../creusot-contracts/src/std/num.rs" 6 8 6 24] (* <isize as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__option__qyi519998017727284488 [#"../../../creusot-contracts/src/std/option.rs" 448 0 448 28] (* <std::option::IntoIter<T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__option__qyi3826978558129217360 [#"../../../creusot-contracts/src/std/option.rs" 502 0 502 32] (* <std::option::Iter<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__option__qyi15544229237996906374 [#"../../../creusot-contracts/src/std/option.rs" 559 0 559 35] (* <std::option::IterMut<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi10921673319039983348 [#"../../../creusot-contracts/src/std/slice.rs" 22 0 22 20] (* <[T] as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi1204824604400838362 [#"../../../creusot-contracts/src/std/slice.rs" 388 0 388 32] (* <std::slice::Iter<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi2911248941160393691 [#"../../../creusot-contracts/src/std/slice.rs" 431 0 431 35] (* <std::slice::IterMut<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__stdqy35z1__time__qyi637609893998028436 [#"../../../creusot-contracts/src/std/time.rs" 7 0 7 22] (* <std::time::Duration as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__time__qyi18172412292931921208 [#"../../../creusot-contracts/src/std/time.rs" 52 0 52 21] (* <std::time::Instant as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__vec__qyi7586516632011728198 [#"../../../creusot-contracts/src/std/vec.rs" 13 0 13 40] (* <std::vec::Vec<T, A> as model::View> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__vec__qyi11778995496275549214 [#"../../../creusot-contracts/src/std/vec.rs" 232 0 232 55] (* <std::vec::IntoIter<T, A> as model::View> *)
  type t
  
  type a
end
module M_creusot_contracts__ghost__qyi10108700411840712429 [#"../../../creusot-contracts/src/ghost.rs" 80 0 80 43] (* <ghost::GhostBox<T> as model::View> *)
  type t
end
module M_creusot_contracts__snapshot__qyi7162904353832931705 [#"../../../creusot-contracts/src/snapshot.rs" 21 0 21 43] (* <snapshot::Snapshot<T> as model::View> *)
  type t
end
module M_creusot_contracts__ghost_ptr__qyi4018816780745005555 [#"../../../creusot-contracts/src/ghost_ptr.rs" 29 0 29 41] (* <ghost_ptr::GhostPtrToken<T> as model::View> *)
  type t
end
module M_creusot_contracts__ghost_ptr__qyi7047809918608850402 [#"../../../creusot-contracts/src/ghost_ptr.rs" 163 0 163 52] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as model::View> *)
  type t
end
module M_creusot_contracts__model__qyi11748947887262756568 [#"../../../creusot-contracts/src/model.rs" 37 0 37 22] (* <std::rc::Rc<T> as model::View> *)
  type t
end
module M_creusot_contracts__model__qyi13291823503020045857 [#"../../../creusot-contracts/src/model.rs" 47 0 47 17] (* <str as model::View> *)
  
end
module M_creusot_contracts__model__qyi11117646996345941568 [#"../../../creusot-contracts/src/model.rs" 67 0 67 23] (* <std::sync::Arc<T> as model::View> *)
  type t
end
module M_creusot_contracts__model__qyi9893947593064265014 [#"../../../creusot-contracts/src/model.rs" 86 0 86 34] (* <&T as model::View> *)
  type t
end
module M_creusot_contracts__model__qyi3078654635475940044 [#"../../../creusot-contracts/src/model.rs" 104 0 104 38] (* <&mut T as model::View> *)
  type t
end
module M_creusot_contracts__model__qyi10879461237922946551 [#"../../../creusot-contracts/src/model.rs" 123 0 123 20] (* <std::string::String as model::View> *)
  
end
module M_creusot_contracts__stdqy35z1__array__qyi17040902840628807596 [#"../../../creusot-contracts/src/std/array.rs" 28 0 28 55] (* <[T; N] as model::DeepModel> *)
  type t
end
module M_creusot_contracts__stdqy35z1__boxed__qyi8616778597759411768 [#"../../../creusot-contracts/src/std/boxed.rs" 4 0 4 65] (* <std::boxed::Box<T, A> as model::DeepModel> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__cmp__qyi2205037048206378435 [#"../../../creusot-contracts/src/std/cmp.rs" 64 0 64 43] (* <std::cmp::Reverse<T> as model::DeepModel> *)
  type t
end
module M_creusot_contracts__stdqy35z1__deque__qyi13651116511862177784 [#"../../../creusot-contracts/src/std/deque.rs" 20 0 20 61] (* <std::collections::VecDeque<T, A> as model::DeepModel> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__num__qyi5509520205416905494 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <u8 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi15598543441589090361 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <u16 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi9958256227803441253 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <u32 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi84996635097738116 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <u64 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi17813023206115965277 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <u128 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi7810183315631044940 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <usize as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi8318054935269598622 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <i8 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi17398649972306243158 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <i16 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi9698681010023253078 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <i32 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi12787005891252270832 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <i64 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi5069791995567637240 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <i128 as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi2402867801069927633 [#"../../../creusot-contracts/src/std/num.rs" 17 8 17 29] (* <isize as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__option__qyi6965512564798623696 [#"../../../creusot-contracts/src/std/option.rs" 5 0 5 42] (* <std::option::Option<T> as model::DeepModel> *)
  type t
end
module M_creusot_contracts__stdqy35z1__result__qyi3967914460640950369 [#"../../../creusot-contracts/src/std/result.rs" 5 0 5 59] (* <std::result::Result<T, E> as model::DeepModel> *)
  type t
  
  type e
end
module M_creusot_contracts__stdqy35z1__slice__qyi17421206483919660993 [#"../../../creusot-contracts/src/std/slice.rs" 36 0 36 36] (* <[T] as model::DeepModel> *)
  type t
end
module M_creusot_contracts__stdqy35z1__time__qyi14378293966971591813 [#"../../../creusot-contracts/src/std/time.rs" 19 0 19 27] (* <std::time::Duration as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__time__qyi3552052091783742881 [#"../../../creusot-contracts/src/std/time.rs" 64 0 64 26] (* <std::time::Instant as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__tuples__qyi7414971278148237795 [#"../../../creusot-contracts/src/std/tuples.rs" 3 0 3 21] (* <() as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__tuples__qyi4793624462434827657 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A,) as model::DeepModel> *)
  type a
end
module M_creusot_contracts__stdqy35z1__tuples__qyi14836969747056927440 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B) as model::DeepModel> *)
  type a
  
  type b
end
module M_creusot_contracts__stdqy35z1__tuples__qyi17146400961521716133 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C) as model::DeepModel> *)
  type a
  
  type b
  
  type c
end
module M_creusot_contracts__stdqy35z1__tuples__qyi1993113202698050188 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
end
module M_creusot_contracts__stdqy35z1__tuples__qyi10643119910596261180 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
end
module M_creusot_contracts__stdqy35z1__tuples__qyi13291600075545424024 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
end
module M_creusot_contracts__stdqy35z1__tuples__qyi13600727314120230151 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
end
module M_creusot_contracts__stdqy35z1__tuples__qyi4877795427108035056 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G, H) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
end
module M_creusot_contracts__stdqy35z1__tuples__qyi11563109979965819166 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G, H, I) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
end
module M_creusot_contracts__stdqy35z1__tuples__qyi7350650595931808887 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G, H, I, J) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
end
module M_creusot_contracts__stdqy35z1__tuples__qyi13833217758070461024 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G, H, I, J, K) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
  
  type k
end
module M_creusot_contracts__stdqy35z1__tuples__qyi3933603423187416028 [#"../../../creusot-contracts/src/std/tuples.rs" 23 8 23 62] (* <(A, B, C, D, E, F, G, H, I, J, K, L) as model::DeepModel> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
  
  type k
  
  type l
end
module M_creusot_contracts__stdqy35z1__vec__qyi15747341533438794311 [#"../../../creusot-contracts/src/std/vec.rs" 25 0 25 56] (* <std::vec::Vec<T, A> as model::DeepModel> *)
  type t
  
  type a
end
module M_creusot_contracts__num_rational__qyi9198168917468502810 [#"../../../creusot-contracts/src/num_rational.rs" 12 0 12 30] (* <num_rational::Ratio<num_bigint::bigint::BigInt> as model::DeepModel> *)
  
end
module M_creusot_contracts__model__qyi5350816231460220300 [#"../../../creusot-contracts/src/model.rs" 28 0 28 38] (* <std::rc::Rc<T> as model::DeepModel> *)
  type t
end
module M_creusot_contracts__model__qyi10968135284336962726 [#"../../../creusot-contracts/src/model.rs" 58 0 58 39] (* <std::sync::Arc<T> as model::DeepModel> *)
  type t
end
module M_creusot_contracts__model__qyi15405663996922129562 [#"../../../creusot-contracts/src/model.rs" 77 0 77 44] (* <&T as model::DeepModel> *)
  type t
end
module M_creusot_contracts__model__qyi3107610430536194964 [#"../../../creusot-contracts/src/model.rs" 95 0 95 48] (* <&mut T as model::DeepModel> *)
  type t
end
module M_creusot_contracts__model__qyi16816007493992454917 [#"../../../creusot-contracts/src/model.rs" 113 0 113 23] (* <bool as model::DeepModel> *)
  
end
module M_creusot_contracts__stdqy35z1__default__qyi6146529039708718884 [#"../../../creusot-contracts/src/std/default.rs" 20 0 20 21] (* <bool as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi3496778564530912247 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <u8 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi16170533646487482255 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <u16 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi5315588111720859863 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <u32 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi13807171494265719638 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <u64 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi9788002824748450723 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <u128 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi1565318960416071864 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <usize as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi1322623648420999856 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <i8 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi17543903365146850202 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <i16 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi14609249951135960484 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <i32 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi16453104719360759867 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <i64 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi10374261158439973058 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <i128 as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__num__qyi14686010783128563011 [#"../../../creusot-contracts/src/std/num.rs" 26 8 26 27] (* <isize as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__option__qyi7689847276072358857 [#"../../../creusot-contracts/src/std/option.rs" 425 0 425 29] (* <std::option::Option<T> as std::default::Default> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi774782105978516300 [#"../../../creusot-contracts/src/std/slice.rs" 62 0 62 28] (* <&mut [T] as std::default::Default> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi244190501142650266 [#"../../../creusot-contracts/src/std/slice.rs" 70 0 70 24] (* <&[T] as std::default::Default> *)
  type t
end
module M_creusot_contracts__stdqy35z1__tuples__qyi10405744666371888989 [#"../../../creusot-contracts/src/std/tuples.rs" 13 0 13 19] (* <() as std::default::Default> *)
  
end
module M_creusot_contracts__stdqy35z1__tuples__qyi9485454731400144266 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A,) as std::default::Default> *)
  type a
end
module M_creusot_contracts__stdqy35z1__tuples__qyi14358019852195198780 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B) as std::default::Default> *)
  type a
  
  type b
end
module M_creusot_contracts__stdqy35z1__tuples__qyi4440769692758617636 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C) as std::default::Default> *)
  type a
  
  type b
  
  type c
end
module M_creusot_contracts__stdqy35z1__tuples__qyi14737743208616240308 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
end
module M_creusot_contracts__stdqy35z1__tuples__qyi4612641539659385500 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
end
module M_creusot_contracts__stdqy35z1__tuples__qyi14209956599627471332 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
end
module M_creusot_contracts__stdqy35z1__tuples__qyi15880391439104857927 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
end
module M_creusot_contracts__stdqy35z1__tuples__qyi1591454689995820642 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G, H) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
end
module M_creusot_contracts__stdqy35z1__tuples__qyi15604151023139073652 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G, H, I) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
end
module M_creusot_contracts__stdqy35z1__tuples__qyi11659963151940504640 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G, H, I, J) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
end
module M_creusot_contracts__stdqy35z1__tuples__qyi12314377552740687789 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G, H, I, J, K) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
  
  type k
end
module M_creusot_contracts__stdqy35z1__tuples__qyi4688837260385524687 [#"../../../creusot-contracts/src/std/tuples.rs" 33 8 33 58] (* <(A, B, C, D, E, F, G, H, I, J, K, L) as std::default::Default> *)
  type a
  
  type b
  
  type c
  
  type d
  
  type e
  
  type f
  
  type g
  
  type h
  
  type i
  
  type j
  
  type k
  
  type l
end
module M_creusot_contracts__stdqy35z1__vec__qyi6763940330815922261 [#"../../../creusot-contracts/src/std/vec.rs" 39 0 39 26] (* <std::vec::Vec<T> as std::default::Default> *)
  type t
end
module M_creusot_contracts__stdqy35z1__deque__qyi8367101395671471553 [#"../../../creusot-contracts/src/std/deque.rs" 56 0 56 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  type t
  
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 68 4 68 31
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 60 20 60 83
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 14 14 14 41
  let%span sdeque3 = "../../../creusot-contracts/src/std/deque.rs" 16 20 16 26
  let%span sdeque4 = "../../../creusot-contracts/src/std/deque.rs" 41 8 41 31
  
  use T_alloc__alloc__Global as Global'0
  
  use T_alloc__collections__vec_deque__VecDeque as VecDeque'0
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : VecDeque'0.t_VecDeque t (Global'0.t_Global))
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : VecDeque'0.t_VecDeque t (Global'0.t_Global) [inv'0 x] . inv'0 x = true
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 15 4 15 27] (self : VecDeque'0.t_VecDeque t (Global'0.t_Global)) : Seq.seq t
    
  
  axiom view'0_spec : forall self : VecDeque'0.t_VecDeque t (Global'0.t_Global) . [%#sdeque2] Seq.length (view'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/deque.rs" 40 4 40 47] (self : VecDeque'0.t_VecDeque t (Global'0.t_Global)) (ix : int) : t
    
   =
    [%#sdeque4] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/deque.rs" 59 4 59 28] (self : VecDeque'0.t_VecDeque t (Global'0.t_Global))
    
   =
    [%#sdeque1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : RawVec'0.t_RawVec t (Global'0.t_Global))
    
   =
    true
  
  predicate structural_resolve'0 (x : VecDeque'0.t_VecDeque t (Global'0.t_Global)) =
    match x with
      | VecDeque'0.C_VecDeque a b c -> resolve'1 c /\ resolve'2 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#sdeque0] forall self : VecDeque'0.t_VecDeque t (Global'0.t_Global) . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi49636360433726320 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 18 0 18 29] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  type i
  
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 30 4 30 31
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 22 8 22 29
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 12 14 12 39
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 14 20 14 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__cloned__Cloned as Cloned'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Cloned'0.t_Cloned i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Cloned'0.t_Cloned i [inv'1 x] . inv'1 x
  = match x with
    | Cloned'0.C_Cloned it -> inv'2 it
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Cloned'0.t_Cloned i) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Cloned'0.t_Cloned i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Cloned'0.t_Cloned i [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 13 4 13 22] (self : Cloned'0.t_Cloned i) : i
  
  axiom iter'0_spec : forall self : Cloned'0.t_Cloned i . [%#scloned2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 21 4 21 28] (self : Cloned'0.t_Cloned i) =
    [%#scloned1] resolve'1 (iter'0 self)
  
  predicate structural_resolve'0 (x : Cloned'0.t_Cloned i) =
    match x with
      | Cloned'0.C_Cloned a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#scloned0] forall self : Cloned'0.t_Cloned i . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi4622684907952448174 [#"../../../creusot-contracts/src/std/iter/copied.rs" 18 0 18 29] (* <std::iter::Copied<I> as resolve::Resolve> *)
  type i
  
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 30 4 30 31
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 22 8 22 29
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 12 14 12 39
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 14 20 14 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__copied__Copied as Copied'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Copied'0.t_Copied i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Copied'0.t_Copied i [inv'1 x] . inv'1 x
  = match x with
    | Copied'0.C_Copied it -> inv'2 it
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Copied'0.t_Copied i) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Copied'0.t_Copied i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Copied'0.t_Copied i [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 13 4 13 22] (self : Copied'0.t_Copied i) : i
  
  axiom iter'0_spec : forall self : Copied'0.t_Copied i . [%#scopied2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 21 4 21 28] (self : Copied'0.t_Copied i) =
    [%#scopied1] resolve'1 (iter'0 self)
  
  predicate structural_resolve'0 (x : Copied'0.t_Copied i) =
    match x with
      | Copied'0.C_Copied a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#scopied0] forall self : Copied'0.t_Copied i . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2208779330486735413 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 28 0 28 32] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  type i
  
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 40 4 40 31
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 32 8 32 29
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 15 14 15 39
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 17 8 17 14
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__enumerate__Enumerate as Enumerate'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Enumerate'0.t_Enumerate i)
  
  axiom inv_axiom'1 : forall x : Enumerate'0.t_Enumerate i [inv'1 x] . inv'1 x
   -> match x with
    | Enumerate'0.C_Enumerate iter count -> inv'2 iter
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Enumerate'0.t_Enumerate i) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Enumerate'0.t_Enumerate i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Enumerate'0.t_Enumerate i [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 16 4 16 22] (self : Enumerate'0.t_Enumerate i) : i
    
  
  axiom iter'0_spec : forall self : Enumerate'0.t_Enumerate i . [%#senumerate2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 31 4 31 28] (self : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate1] resolve'2 (iter'0 self)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  predicate structural_resolve'0 (x : Enumerate'0.t_Enumerate i) =
    match x with
      | Enumerate'0.C_Enumerate a b -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#senumerate0] forall self : Enumerate'0.t_Enumerate i . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi13484997498660514945 [#"../../../creusot-contracts/src/std/iter/map.rs" 32 0 32 32] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  type i
  
  type f
  
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 44 4 44 31
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 36 8 36 54
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 18 14 18 39
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 20 8 20 14
  let%span smap4 = "../../../creusot-contracts/src/std/iter/map.rs" 26 14 26 39
  let%span smap5 = "../../../creusot-contracts/src/std/iter/map.rs" 28 8 28 14
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__map__Map as Map'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Map'0.t_Map i f)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Map'0.t_Map i f [inv'1 x] . inv'1 x
  = match x with
    | Map'0.C_Map iter f -> inv'2 iter /\ inv'3 f
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Map'0.t_Map i f) =
    [%#sinvariant6] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Map'0.t_Map i f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Map'0.t_Map i f [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 27 4 27 22] (self : Map'0.t_Map i f) : f
  
  axiom func'0_spec : forall self : Map'0.t_Map i f . [%#smap4] inv'1 self  -> inv'3 (func'0 self)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 19 4 19 22] (self : Map'0.t_Map i f) : i
  
  axiom iter'0_spec : forall self : Map'0.t_Map i f . [%#smap2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 35 4 35 28] (self : Map'0.t_Map i f) =
    [%#smap1] resolve'2 (iter'0 self) /\ resolve'1 (func'0 self)
  
  predicate structural_resolve'0 (x : Map'0.t_Map i f) =
    match x with
      | Map'0.C_Map a b -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#smap0] forall self : Map'0.t_Map i f . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi5691635635396426195 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 62 0 62 41] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  type i
  
  type b
  
  type f
  
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 74 4 74 31
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 66 8 66 50
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as MapInv'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : MapInv'0.t_MapInv i b f)
  
  axiom inv_axiom'1 : forall x : MapInv'0.t_MapInv i b f [inv'1 x] . inv'1 x
   -> match x with
    | MapInv'0.C_MapInv iter func produced -> inv'2 iter /\ inv'3 func
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : MapInv'0.t_MapInv i b f) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : MapInv'0.t_MapInv i b f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MapInv'0.t_MapInv i b f [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 65 4 65 28] (self : MapInv'0.t_MapInv i b f)
    
   =
    [%#smap_inv1] resolve'3 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self)
    /\ resolve'2 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Snapshot.snap_ty (Seq.seq b)) =
    true
  
  predicate structural_resolve'0 (x : MapInv'0.t_MapInv i b f) =
    match x with
      | MapInv'0.C_MapInv a b c -> resolve'1 c /\ resolve'2 b /\ resolve'3 a
      end
  
  goal resolve_coherence_refn : [%#smap_inv0] forall self : MapInv'0.t_MapInv i b f . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi14372835745621067113 [#"../../../creusot-contracts/src/std/iter/skip.rs" 29 0 29 27] (* <std::iter::Skip<I> as resolve::Resolve> *)
  type i
  
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 43 4 43 31
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 34 12 34 33
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 15 14 15 39
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 17 20 17 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__skip__Skip as Skip'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Skip'0.t_Skip i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Skip'0.t_Skip i [inv'1 x] . inv'1 x
  = match x with
    | Skip'0.C_Skip iter n -> inv'2 iter
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Skip'0.t_Skip i) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Skip'0.t_Skip i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Skip'0.t_Skip i [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 16 4 16 22] (self : Skip'0.t_Skip i) : i
  
  axiom iter'0_spec : forall self : Skip'0.t_Skip i . [%#sskip2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 32 4 32 28] (self : Skip'0.t_Skip i) =
    [%#sskip1] resolve'2 (iter'0 self)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  predicate structural_resolve'0 (x : Skip'0.t_Skip i) =
    match x with
      | Skip'0.C_Skip a b -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#sskip0] forall self : Skip'0.t_Skip i . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi11550387566643656565 [#"../../../creusot-contracts/src/std/iter/take.rs" 40 0 40 27] (* <std::iter::Take<I> as resolve::Resolve> *)
  type i
  
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 52 4 52 31
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 44 8 44 29
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 18 14 18 39
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 20 20 20 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__take__Take as Take'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Take'0.t_Take i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Take'0.t_Take i [inv'1 x] . inv'1 x
  = match x with
    | Take'0.C_Take iter n -> inv'2 iter
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Take'0.t_Take i) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Take'0.t_Take i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Take'0.t_Take i [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 19 4 19 22] (self : Take'0.t_Take i) : i
  
  axiom iter'0_spec : forall self : Take'0.t_Take i . [%#stake2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 43 4 43 28] (self : Take'0.t_Take i) =
    [%#stake1] resolve'2 (iter'0 self)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  predicate structural_resolve'0 (x : Take'0.t_Take i) =
    match x with
      | Take'0.C_Take a b -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#stake0] forall self : Take'0.t_Take i . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi4472237099583716627 [#"../../../creusot-contracts/src/std/slice.rs" 443 0 443 38] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  type t
  
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 455 4 455 31
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 447 20 447 36
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 437 14 437 50
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 434 4 434 12
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 32 20 32 26
  
  use T_core__slice__iter__IterMut as IterMut'0
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IterMut'0.t_IterMut t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IterMut'0.t_IterMut t [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'1_spec : forall self : slice t . ([%#sslice5] view'1 self = Slice.id self)
  && ([%#sslice4] Seq.length (view'1 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 438 4 438 33] (self : IterMut'0.t_IterMut t) : borrowed (slice t)
    
  
  axiom view'0_spec : forall self : IterMut'0.t_IterMut t . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/slice.rs" 446 4 446 28] (self : IterMut'0.t_IterMut t) =
    [%#sslice1] (view'0 self).current = (view'0 self).final
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : NonNull'0.t_NonNull t) =
    true
  
  use prelude.prelude.Opaque
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : opaque_ptr) =
    true
  
  use T_core__marker__PhantomData as PhantomData'0
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : PhantomData'0.t_PhantomData (borrowed t))
    
   =
    true
  
  predicate structural_resolve'0 (x : IterMut'0.t_IterMut t) =
    match x with
      | IterMut'0.C_IterMut a b c -> resolve'1 c /\ resolve'2 b /\ resolve'3 a
      end
  
  goal resolve_coherence_refn : [%#sslice0] forall self : IterMut'0.t_IterMut t . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi6844585276173866460 [#"../../../creusot-contracts/src/std/vec.rs" 47 0 47 43] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  type t
  
  type a
  
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 59 4 59 31
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 51 20 51 83
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 19 14 19 41
  let%span svec3 = "../../../creusot-contracts/src/std/vec.rs" 21 20 21 26
  let%span sops4 = "../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  let%span sinvariant5 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span svec6 = "../../../creusot-contracts/src/std/vec.rs" 68 20 68 41
  let%span sseq7 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed8] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'3 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t [inv'2 x] . inv'2 x = invariant'2 x
  
  use T_alloc__vec__Vec as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 20 4 20 27] (self : Vec'0.t_Vec t a) : Seq.seq t
  
  axiom view'0_spec : forall self : Vec'0.t_Vec t a . [%#svec2] Seq.length (view'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/vec.rs" 67 4 67 30] (self : Vec'0.t_Vec t a) =
    [%#svec6] inv'2 (view'0 self)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Vec'0.t_Vec t a)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Vec'0.t_Vec t a [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Vec'0.t_Vec t a) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Vec'0.t_Vec t a)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Vec'0.t_Vec t a [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 19 4 19 47] (self : Vec'0.t_Vec t a) (ix : int) : t
    
   =
    [%#sops4] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/vec.rs" 50 4 50 28] (self : Vec'0.t_Vec t a) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : RawVec'0.t_RawVec t a) =
    true
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  predicate structural_resolve'0 (x : Vec'0.t_Vec t a) =
    match x with
      | Vec'0.C_Vec a b -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#svec0] forall self : Vec'0.t_Vec t a . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi8594830193745006303 [#"../../../creusot-contracts/src/std/vec.rs" 243 0 243 58] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  type t
  
  type a
  
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 255 4 255 31
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 247 20 247 83
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 239 8 239 14
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : a)
  
  use T_core__mem__manually_drop__ManuallyDrop as ManuallyDrop'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ManuallyDrop'0.t_ManuallyDrop a)
  
  axiom inv_axiom'2 [@rewrite] : forall x : ManuallyDrop'0.t_ManuallyDrop a [inv'2 x] . inv'2 x
  = match x with
    | ManuallyDrop'0.C_ManuallyDrop value -> inv'3 value
    end
  
  use T_alloc__vec__into_iter__IntoIter as IntoIter'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t a)
  
  axiom inv_axiom'1 [@rewrite] : forall x : IntoIter'0.t_IntoIter t a [inv'1 x] . inv'1 x
  = match x with
    | IntoIter'0.C_IntoIter buf phantom cap alloc ptr end' -> inv'2 alloc
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : IntoIter'0.t_IntoIter t a) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t a)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IntoIter'0.t_IntoIter t a [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'6 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 238 4 238 33] (self : IntoIter'0.t_IntoIter t a) : Seq.seq t
    
  
  use prelude.prelude.Int
  
  predicate resolve'0 [#"../../../creusot-contracts/src/std/vec.rs" 246 4 246 28] (self : IntoIter'0.t_IntoIter t a) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'6 (Seq.get (view'0 self) i)
  
  use T_core__marker__PhantomData as PhantomData'0
  
  predicate resolve'5 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : PhantomData'0.t_PhantomData t) =
    true
  
  use prelude.prelude.UIntSize
  
  predicate resolve'4 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : usize) =
    true
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ManuallyDrop'0.t_ManuallyDrop a) =
    true
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : NonNull'0.t_NonNull t) =
    true
  
  use prelude.prelude.Opaque
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : opaque_ptr) =
    true
  
  predicate structural_resolve'0 (x : IntoIter'0.t_IntoIter t a) =
    match x with
      | IntoIter'0.C_IntoIter a b c d e f -> resolve'1 f
      /\ resolve'2 e /\ resolve'3 d /\ resolve'4 c /\ resolve'5 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#svec0] forall self : IntoIter'0.t_IntoIter t a . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi2241556416362616690 [#"../../../creusot-contracts/src/ghost.rs" 89 0 89 39] (* <ghost::GhostBox<T> as resolve::Resolve> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 101 4 101 31
  let%span sghost1 = "../../../creusot-contracts/src/ghost.rs" 93 8 93 24
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed4 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed4] inv'3 self
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'1 x] . inv'1 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'2 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 54 4 54 28] (self : t) =
    [%#sresolve2] resolve'3 self
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t) =
    resolve'2 _1
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  predicate resolve'0 [#"../../../creusot-contracts/src/ghost.rs" 92 4 92 28] (self : GhostBox'0.t_GhostBox t) =
    [%#sghost1] resolve'1 (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self)
  
  predicate structural_resolve'1 (x : GhostBox'0.t_GhostBox t) =
    true
  
  predicate structural_resolve'0 (x : GhostBox'0.t_GhostBox t) =
    match x with
      | GhostBox'0.C_GhostBox a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#sghost0] forall self : GhostBox'0.t_GhostBox t . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'1 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost_ptr__qyi9310404846416116048 [#"../../../creusot-contracts/src/ghost_ptr.rs" 290 0 290 55] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as resolve::Resolve> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 302 4 302 31
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 294 8 294 32
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 214 14 214 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 8 216 14
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 222 14 222 64
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 224 8 224 14
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sghost_ptr10 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenMut as GhostPtrTokenMut'0
  
  use prelude.prelude.Borrow
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrTokenMut'0.t_GhostPtrTokenMut t [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'0_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap11] mk'0 (view'0 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap9] Map.get (view'0 self) k
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr7] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr6] addr_logic'0 (null_logic'0 _1) = 0)
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 223 4 223 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom fin'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr4] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 215 4 215 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom cur'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr2] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate resolve'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 293 4 293 28] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
    
   =
    [%#sghost_ptr1] cur'0 self = fin'0 self
  
  predicate structural_resolve'0 (x : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
  
  goal resolve_coherence_refn : [%#sghost_ptr0] forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi4855891653524509355 [#"../../../creusot-contracts/src/resolve.rs" 23 0 23 41] (* <(T1, T2) as resolve::Resolve> *)
  type t1
  
  type t2
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 34 4 34 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 27 8 27 44
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t2)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t1)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t1, t2))
  
  axiom inv_axiom'1 [@rewrite] : forall x : (t1, t2) [inv'1 x] . inv'1 x = (let (a, b) = x in inv'2 a /\ inv'3 b)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : (t1, t2)) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : (t1, t2))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (t1, t2) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t2)
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t1)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 26 4 26 28] (self : (t1, t2)) =
    [%#sresolve1] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  predicate structural_resolve'0 (x : (t1, t2)) =
    match x with
      | (a, b) -> resolve'1 b /\ resolve'2 a
      end
  
  goal resolve_coherence_refn : [%#sresolve0] forall self : (t1, t2) . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi6740873903368268328 [#"../../../creusot-contracts/src/resolve.rs" 37 0 37 34] (* <&mut T as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 48 4 48 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sinvariant3 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant3] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : borrowed t) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed t [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed t) =
    [%#sresolve1] self.final = self.current
  
  predicate structural_resolve'0 (x : borrowed t) =
    x.final = x.current
  
  goal resolve_coherence_refn : [%#sresolve0] forall self : borrowed t . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi10830812895881240411 [#"../../../creusot-contracts/src/resolve.rs" 51 0 51 34] (* <std::boxed::Box<T> as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 62 4 62 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed3 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed3] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 54 4 54 28] (self : t) =
    [%#sresolve1] resolve'1 self
  
  predicate structural_resolve'0 (x : t) =
    resolve'1 x
  
  goal resolve_coherence_refn : [%#sresolve0] forall self : t . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi12875730110607858017 [#"../../../creusot-contracts/src/resolve.rs" 65 0 65 29] (* <std::option::Option<T> as resolve::Resolve> *)
  type t
  
  let%span sresolve0 = "../../../creusot-contracts/src/resolve.rs" 79 4 79 31
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option t [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : Option'0.t_Option t) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option t [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t)
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 68 4 68 28] (self : Option'0.t_Option t) =
    [%#sresolve1] match self with
      | Option'0.C_Some x -> resolve'1 x
      | Option'0.C_None -> true
      end
  
  predicate structural_resolve'0 (x : Option'0.t_Option t) =
    match x with
      | Option'0.C_None -> true
      | Option'0.C_Some a -> resolve'1 a
      end
  
  goal resolve_coherence_refn : [%#sresolve0] forall self : Option'0.t_Option t . structural_resolve'0 self
  /\ inv'0 self  -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__deque__qyi16907586659712195996 [#"../../../creusot-contracts/src/std/deque.rs" 139 0 139 54] (* <&std::collections::VecDeque<T, A> as std::iter::IntoIterator> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__iter__qyi6770442272219753668 [#"../../../creusot-contracts/src/std/iter.rs" 82 0 82 36] (* <I as std::iter::IntoIterator> *)
  type i
end
module M_creusot_contracts__stdqy35z1__option__qyi13467112980140118199 [#"../../../creusot-contracts/src/std/option.rs" 488 0 488 34] (* <std::option::Option<T> as std::iter::IntoIterator> *)
  type t
end
module M_creusot_contracts__stdqy35z1__option__qyi9824751260828342828 [#"../../../creusot-contracts/src/std/option.rs" 542 0 542 42] (* <&'a std::option::Option<T> as std::iter::IntoIterator> *)
  type t
end
module M_creusot_contracts__stdqy35z1__option__qyi9965653975562606866 [#"../../../creusot-contracts/src/std/option.rs" 599 0 599 46] (* <&'a mut std::option::Option<T> as std::iter::IntoIterator> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi11249112580390374037 [#"../../../creusot-contracts/src/std/slice.rs" 360 0 360 29] (* <&[T] as std::iter::IntoIterator> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi14330313721220735751 [#"../../../creusot-contracts/src/std/slice.rs" 374 0 374 33] (* <&mut [T] as std::iter::IntoIterator> *)
  type t
end
module M_creusot_contracts__stdqy35z1__vec__qyi14051213719328841137 [#"../../../creusot-contracts/src/std/vec.rs" 190 0 190 48] (* <std::vec::Vec<T, A> as std::iter::IntoIterator> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__vec__qyi5004262220832076457 [#"../../../creusot-contracts/src/std/vec.rs" 204 0 204 49] (* <&std::vec::Vec<T, A> as std::iter::IntoIterator> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__vec__qyi903601277405239446 [#"../../../creusot-contracts/src/std/vec.rs" 218 0 218 53] (* <&mut std::vec::Vec<T, A> as std::iter::IntoIterator> *)
  type t
  
  type a
end
module M_creusot_contracts__stdqy35z1__deque__qyi3159098507555769709 [#"../../../creusot-contracts/src/std/deque.rs" 164 0 164 36] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sdeque0 = "../../../creusot-contracts/src/std/deque.rs" 182 4 182 26
  let%span sdeque1 = "../../../creusot-contracts/src/std/deque.rs" 189 4 189 90
  let%span sdeque2 = "../../../creusot-contracts/src/std/deque.rs" 175 12 175 66
  let%span sdeque3 = "../../../creusot-contracts/src/std/deque.rs" 160 8 160 14
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 101 14 101 80
  let%span smodel6 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sops7 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  
  use T_alloc__collections__vec_deque__iter__Iter as Iter'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Iter'0.t_Iter t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Iter'0.t_Iter t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice9] view'2 self = Slice.id self)
  && ([%#sslice8] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops7] Seq.get (view'2 self) ix
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : slice t) : Seq.seq t =
    [%#smodel6] view'2 self
  
  use seq.Seq
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 102 4 102 35] (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice5] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice4] Seq.length (to_ref_seq'0 self) = Seq.length (view'1 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/deque.rs" 159 4 159 33] (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/deque.rs" 173 4 173 65] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t)
    
   =
    [%#sdeque2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  goal produces_refl_refn : [%#sdeque0] forall self : Iter'0.t_Iter t . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#sdeque1] forall a : Iter'0.t_Iter t . forall ab : Seq.seq t . forall b : Iter'0.t_Iter t . forall bc : Seq.seq t . forall c : Iter'0.t_Iter t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi10472681371035856984 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 33 0 36 13] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scloned0 = "../../../creusot-contracts/src/std/iter/cloned.rs" 74 4 74 90
  let%span scloned1 = "../../../creusot-contracts/src/std/iter/cloned.rs" 64 4 64 26
  let%span scloned2 = "../../../creusot-contracts/src/std/iter/cloned.rs" 53 12 56 79
  let%span scloned3 = "../../../creusot-contracts/src/std/iter/cloned.rs" 12 14 12 39
  let%span scloned4 = "../../../creusot-contracts/src/std/iter/cloned.rs" 14 20 14 26
  let%span sseq5 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed6 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant7 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant7] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed6] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq5] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__cloned__Cloned as Cloned'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Cloned'0.t_Cloned i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Cloned'0.t_Cloned i [inv'0 x] . inv'0 x
  = match x with
    | Cloned'0.C_Cloned it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 13 4 13 22] (self : Cloned'0.t_Cloned i) : i
  
  axiom iter'0_spec : forall self : Cloned'0.t_Cloned i . [%#scloned3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 51 4 51 64] (self : Cloned'0.t_Cloned i) (visited : Seq.seq t) (o : Cloned'0.t_Cloned i)
    
   =
    [%#scloned2] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal produces_trans_refn : [%#scloned0] forall a : Cloned'0.t_Cloned i . forall ab : Seq.seq t . forall b : Cloned'0.t_Cloned i . forall bc : Seq.seq t . forall c : Cloned'0.t_Cloned i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#scloned1] forall self : Cloned'0.t_Cloned i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi18224474876607687026 [#"../../../creusot-contracts/src/std/iter/copied.rs" 33 0 36 12] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  type i
  
  type t
  
  let%span scopied0 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 4 64 26
  let%span scopied1 = "../../../creusot-contracts/src/std/iter/copied.rs" 74 4 74 90
  let%span scopied2 = "../../../creusot-contracts/src/std/iter/copied.rs" 53 12 56 79
  let%span scopied3 = "../../../creusot-contracts/src/std/iter/copied.rs" 12 14 12 39
  let%span scopied4 = "../../../creusot-contracts/src/std/iter/copied.rs" 14 20 14 26
  let%span sseq5 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed6 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant7 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant7] inv'5 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed6] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t) =
    [%#sseq5] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__copied__Copied as Copied'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Copied'0.t_Copied i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Copied'0.t_Copied i [inv'0 x] . inv'0 x
  = match x with
    | Copied'0.C_Copied it -> inv'2 it
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 13 4 13 22] (self : Copied'0.t_Copied i) : i
  
  axiom iter'0_spec : forall self : Copied'0.t_Copied i . [%#scopied3] inv'0 self  -> inv'2 (iter'0 self)
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/copied.rs" 51 4 51 64] (self : Copied'0.t_Copied i) (visited : Seq.seq t) (o : Copied'0.t_Copied i)
    
   =
    [%#scopied2] exists s : Seq.seq t . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal produces_refl_refn : [%#scopied0] forall self : Copied'0.t_Copied i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#scopied1] forall a : Copied'0.t_Copied i . forall ab : Seq.seq t . forall b : Copied'0.t_Copied i . forall bc : Seq.seq t . forall c : Copied'0.t_Copied i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10605201058978801838 [#"../../../creusot-contracts/src/std/iter/empty.rs" 3 0 3 29] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  type t
  
  let%span sempty0 = "../../../creusot-contracts/src/std/iter/empty.rs" 20 4 20 26
  let%span sempty1 = "../../../creusot-contracts/src/std/iter/empty.rs" 30 4 30 90
  let%span sempty2 = "../../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use T_core__iter__sources__empty__Empty as Empty'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Empty'0.t_Empty t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Empty'0.t_Empty t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : Empty'0.t_Empty t) (visited : Seq.seq t) (o : Empty'0.t_Empty t)
    
   =
    [%#sempty2] visited = (Seq.empty  : Seq.seq t) /\ self = o
  
  goal produces_refl_refn : [%#sempty0] forall self : Empty'0.t_Empty t . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#sempty1] forall a : Empty'0.t_Empty t . forall ab : Seq.seq t . forall b : Empty'0.t_Empty t . forall bc : Seq.seq t . forall c : Empty'0.t_Empty t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi2718914205750388896 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 57 0 59 16] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  type i
  
  let%span senumerate0 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 99 4 99 90
  let%span senumerate1 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 89 4 89 26
  let%span senumerate2 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 77 12 81 113
  let%span senumerate3 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 24 8 24 14
  let%span senumerate4 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 15 14 15 39
  let%span senumerate5 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 17 8 17 14
  let%span senumerate6 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 48 12 52 79
  let%span sseq7 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed8] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use T_core__iter__adapters__enumerate__Enumerate as Enumerate'0
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 23 4 23 21] (self : Enumerate'0.t_Enumerate i) : int
    
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Enumerate'0.t_Enumerate i)
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 16 4 16 22] (self : Enumerate'0.t_Enumerate i) : i
    
  
  axiom iter'0_spec : forall self : Enumerate'0.t_Enumerate i . [%#senumerate4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 46 4 46 30] (self : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate6] (forall s : Seq.seq t_Item'0, i : i [produces'1 (iter'0 self) s i] . inv'1 s
    /\ inv'2 i /\ produces'1 (iter'0 self) s i  -> n'0 self + Seq.length s < UIntSize.to_int v_MAX'0)
    /\ (forall i : borrowed i . completed'0 i  -> produces'1 i.current (Seq.empty  : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Enumerate'0.t_Enumerate i [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Enumerate'0.C_Enumerate iter count -> inv'2 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 75 4 75 64] (self : Enumerate'0.t_Enumerate i) (visited : Seq.seq (usize, t_Item'0)) (o : Enumerate'0.t_Enumerate i)
    
   =
    [%#senumerate2] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  goal produces_trans_refn : [%#senumerate0] forall a : Enumerate'0.t_Enumerate i . forall ab : Seq.seq (usize, t_Item'0) . forall b : Enumerate'0.t_Enumerate i . forall bc : Seq.seq (usize, t_Item'0) . forall c : Enumerate'0.t_Enumerate i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#senumerate1] forall self : Enumerate'0.t_Enumerate i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (usize, t_Item'0)) self
   -> produces'0 self (Seq.empty  : Seq.seq (usize, t_Item'0)) self)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi9573749579793237160 [#"../../../creusot-contracts/src/std/iter/filter.rs" 93 0 96 31] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  type i
  
  type f
  
  let%span sfilter0 = "../../../creusot-contracts/src/std/iter/filter.rs" 131 4 131 26
  let%span sfilter1 = "../../../creusot-contracts/src/std/iter/filter.rs" 143 4 143 90
  let%span sfilter2 = "../../../creusot-contracts/src/std/iter/filter.rs" 112 12 123 17
  let%span sfilter3 = "../../../creusot-contracts/src/std/iter/filter.rs" 27 14 27 39
  let%span sfilter4 = "../../../creusot-contracts/src/std/iter/filter.rs" 29 8 29 14
  let%span sfilter5 = "../../../creusot-contracts/src/std/iter/filter.rs" 19 14 19 39
  let%span sfilter6 = "../../../creusot-contracts/src/std/iter/filter.rs" 21 8 21 14
  let%span sfilter7 = "../../../creusot-contracts/src/std/iter/filter.rs" 48 12 57 110
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  type t_Item'0
  
  use prelude.prelude.Borrow
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : t_Item'0) (_3 : bool)
    
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t_Item'0)
  
  use T_core__iter__adapters__filter__Filter as Filter'0
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 45 4 45 30] (self : Filter'0.t_Filter i f)
   =
    [%#sfilter7] forall f : f, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : f, g : f . unnest'0 f g  -> f = g)
    /\ (forall f : borrowed f, g : borrowed f, i : t_Item'0, b : bool . f.current = g.current /\ f.final = g.final
     -> postcondition_mut'0 f (i) b = postcondition_mut'0 g (i) b)
    /\ (forall f : borrowed f, i : t_Item'0 . not (postcondition_mut'0 f (i) true /\ postcondition_mut'0 f (i) false))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Filter'0.t_Filter i f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Filter'0.t_Filter i f [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Filter'0.C_Filter iter predicate' -> inv'1 iter /\ inv'2 predicate'
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 20 4 20 22] (self : Filter'0.t_Filter i f) : i
  
  axiom iter'0_spec : forall self : Filter'0.t_Filter i f . [%#sfilter5] inv'0 self  -> inv'1 (iter'0 self)
  
  use prelude.prelude.Int
  
  use map.Map
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 28 4 28 22] (self : Filter'0.t_Filter i f) : f
  
  axiom func'0_spec : forall self : Filter'0.t_Filter i f . [%#sfilter3] inv'0 self  -> inv'2 (func'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/filter.rs" 110 4 110 67] (self : Filter'0.t_Filter i f) (visited : Seq.seq t_Item'0) (succ : Filter'0.t_Filter i f)
    
   =
    [%#sfilter2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall bor_f : borrowed f, i : int . bor_f.current = func'0 self /\ bor_f.final = func'0 self
     -> 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 bor_f (Seq.get s i) true))
  
  use seq.Seq
  
  goal produces_refl_refn : [%#sfilter0] forall self : Filter'0.t_Filter i f . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  goal produces_trans_refn : [%#sfilter1] forall a : Filter'0.t_Filter i f . forall ab : Seq.seq t_Item'0 . forall b : Filter'0.t_Filter i f . forall bc : Seq.seq t_Item'0 . forall c : Filter'0.t_Filter i f . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi10730559947553418603 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 15 0 15 38] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  type i
  
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 54 4 54 90
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 26
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 30 12 36 13
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 39
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 11 20 11 26
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option i)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option i [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  use T_core__iter__adapters__fuse__Fuse as Fuse'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Fuse'0.t_Fuse i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fuse'0.t_Fuse i [inv'0 x] . inv'0 x
  = match x with
    | Fuse'0.C_Fuse iter -> inv'1 iter
    end
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : Fuse'0.t_Fuse i) : Option'0.t_Option i
    
  
  axiom view'0_spec : forall self : Fuse'0.t_Fuse i . [%#sfuse3] inv'0 self  -> inv'1 (view'0 self)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 28 4 28 65] (self : Fuse'0.t_Fuse i) (prod : Seq.seq t_Item'0) (other : Fuse'0.t_Fuse i)
    
   =
    [%#sfuse2] match view'0 self with
      | Option'0.C_None -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | Option'0.C_Some i -> match view'0 other with
        | Option'0.C_Some i2 -> produces'1 i prod i2
        | Option'0.C_None -> false
        end
      end
  
  goal produces_trans_refn : [%#sfuse0] forall a : Fuse'0.t_Fuse i . forall ab : Seq.seq t_Item'0 . forall b : Fuse'0.t_Fuse i . forall bc : Seq.seq t_Item'0 . forall c : Fuse'0.t_Fuse i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#sfuse1] forall self : Fuse'0.t_Fuse i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi6597778842032428791 [#"../../../creusot-contracts/src/std/iter/map.rs" 47 0 51 27] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  type b
  
  type i
  
  type f
  
  let%span smap0 = "../../../creusot-contracts/src/std/iter/map.rs" 85 4 85 26
  let%span smap1 = "../../../creusot-contracts/src/std/iter/map.rs" 97 4 97 90
  let%span smap2 = "../../../creusot-contracts/src/std/iter/map.rs" 66 12 77 64
  let%span smap3 = "../../../creusot-contracts/src/std/iter/map.rs" 26 14 26 39
  let%span smap4 = "../../../creusot-contracts/src/std/iter/map.rs" 28 8 28 14
  let%span smap5 = "../../../creusot-contracts/src/std/iter/map.rs" 18 14 18 39
  let%span smap6 = "../../../creusot-contracts/src/std/iter/map.rs" 20 8 20 14
  let%span sseq7 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant9 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  use prelude.prelude.Borrow
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed f) =
    [%#sinvariant9] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed f [inv'7 x] . inv'7 x = invariant'4 x
  
  type t_Item'0
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed8] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed f) =
    [%#sboxed8] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed f [inv'5 x] . inv'5 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq (borrowed f)) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed f))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed f) [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__map__Map as Map'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Map'0.t_Map i f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Map'0.t_Map i f [inv'0 x] . inv'0 x
  = match x with
    | Map'0.C_Map iter f -> inv'3 iter /\ inv'4 f
    end
  
  use seq.Seq
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : t_Item'0) (_3 : b)
    
  
  use seq.Seq
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 19 4 19 22] (self : Map'0.t_Map i f) : i
  
  axiom iter'0_spec : forall self : Map'0.t_Map i f . [%#smap5] inv'0 self  -> inv'3 (iter'0 self)
  
  use seq.Seq
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  function func'0 [#"../../../creusot-contracts/src/std/iter/map.rs" 27 4 27 22] (self : Map'0.t_Map i f) : f
  
  axiom func'0_spec : forall self : Map'0.t_Map i f . [%#smap3] inv'0 self  -> inv'4 (func'0 self)
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map.rs" 64 4 64 67] (self : Map'0.t_Map i f) (visited : Seq.seq b) (succ : Map'0.t_Map i f)
    
   =
    [%#smap2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (borrowed f) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i) (Seq.get visited i))))
  
  use seq.Seq
  
  goal produces_refl_refn : [%#smap0] forall self : Map'0.t_Map i f . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq b) self
   -> produces'0 self (Seq.empty  : Seq.seq b) self)
  
  goal produces_trans_refn : [%#smap1] forall a : Map'0.t_Map i f . forall ab : Seq.seq b . forall b : Map'0.t_Map i f . forall bc : Seq.seq b . forall c : Map'0.t_Map i f . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi9026772487048432788 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 9 0 10 29] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type i
  
  type b
  
  type f
  
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 27 4 27 26
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 39 4 39 90
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 45 8 58 9
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 85 12 87 73
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 166 12 170 47
  let%span smap_inv5 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 137 14 137 81
  let%span smap_inv6 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 88
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 128 12 130 63
  let%span sseq8 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span smap_inv9 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 158 71
  let%span sinvariant10 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed11 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed11] inv'6 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  use prelude.prelude.Borrow
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed f) =
    [%#sboxed11] inv'7 self
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed f [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  predicate invariant'4 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed f) =
    [%#sinvariant10] inv'4 self.current /\ inv'4 self.final
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed f [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed i) =
    [%#sinvariant10] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed i)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed i [inv'5 x] . inv'5 x = invariant'3 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq8] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq (borrowed f)) =
    [%#sseq8] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed f))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed f) [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  use prelude.prelude.Snapshot
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  use seq.Seq
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 126 4 126 78] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv7] forall e : t_Item'0, i : i . inv'6 e /\ inv'3 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (_3 : b)
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : b)
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 49] (iter : i) (func : f) =
    [%#smap_inv9] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f (e1, Snapshot.new s) b  -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  use seq.Seq
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 73] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv6] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'2 s
    /\ inv'6 e1 /\ inv'6 e2 /\ inv'7 f /\ inv'8 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f (e1, Snapshot.new (Seq.(++) produced s)) b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : i, func : f, produced : Seq.seq t_Item'0 . [%#smap_inv5] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  use prelude.prelude.Snapshot
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 164 4 164 33] (_1 : ()) =
    [%#smap_inv4] forall iter : borrowed i, func : f . inv'5 iter /\ inv'4 func
     -> completed'0 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as MapInv'0
  
  predicate invariant'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 83 4 83 30] (self : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv3] reinitialize'0 ()
    /\ preservation_inv'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
    /\ next_precondition'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : MapInv'0.t_MapInv i t_Item'0 f)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MapInv'0.t_MapInv i t_Item'0 f [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | MapInv'0.C_MapInv iter func produced -> inv'3 iter /\ inv'4 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 44 4 44 67] (self : MapInv'0.t_MapInv i t_Item'0 f) (visited : Seq.seq b) (succ : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv2] unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ)
    /\ (exists fs : Seq.seq (borrowed f) . inv'1 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'2 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) s (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    else
      (Seq.get fs 0).current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      /\ (Seq.get fs (Seq.length visited - 1)).final
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i))) (Seq.get visited i))))
  
  use seq.Seq
  
  goal produces_refl_refn : [%#smap_inv0] forall self : MapInv'0.t_MapInv i t_Item'0 f . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq b) self
   -> produces'0 self (Seq.empty  : Seq.seq b) self)
  
  goal produces_trans_refn : [%#smap_inv1] forall a : MapInv'0.t_MapInv i t_Item'0 f . forall ab : Seq.seq b . forall b : MapInv'0.t_MapInv i t_Item'0 f . forall bc : Seq.seq b . forall c : MapInv'0.t_MapInv i t_Item'0 f . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi8116812009287608646 [#"../../../creusot-contracts/src/std/iter/once.rs" 14 0 14 28] (* <std::iter::Once<T> as std::iter::Iterator> *)
  type t
  
  let%span sonce0 = "../../../creusot-contracts/src/std/iter/once.rs" 44 4 44 90
  let%span sonce1 = "../../../creusot-contracts/src/std/iter/once.rs" 34 4 34 26
  let%span sonce2 = "../../../creusot-contracts/src/std/iter/once.rs" 25 12 26 106
  let%span sonce3 = "../../../creusot-contracts/src/std/iter/once.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Item'0.t_Item t [inv'3 x] . inv'3 x
  = match x with
    | Item'0.C_Item opt -> inv'4 opt
    end
  
  use T_core__option__IntoIter as IntoIter'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : IntoIter'0.t_IntoIter t [inv'2 x] . inv'2 x
  = match x with
    | IntoIter'0.C_IntoIter inner -> inv'3 inner
    end
  
  use T_core__iter__sources__once__Once as Once'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Once'0.t_Once t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Once'0.t_Once t [inv'0 x] . inv'0 x
  = match x with
    | Once'0.C_Once inner -> inv'2 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 9 4 9 30] (self : Once'0.t_Once t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/once.rs" 23 4 23 64] (self : Once'0.t_Once t) (visited : Seq.seq t) (o : Once'0.t_Once t)
    
   =
    [%#sonce2] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . inv'1 e
    /\ view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  goal produces_trans_refn : [%#sonce0] forall a : Once'0.t_Once t . forall ab : Seq.seq t . forall b : Once'0.t_Once t . forall bc : Seq.seq t . forall c : Once'0.t_Once t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#sonce1] forall self : Once'0.t_Once t . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi16860283617022118777 [#"../../../creusot-contracts/src/std/iter/range.rs" 10 0 10 70] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 35 4 35 26
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 45 4 45 90
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : idx)
  
  use T_core__ops__range__Range as Range'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Range'0.t_Range idx)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Range'0.t_Range idx [inv'0 x] . inv'0 x
  = match x with
    | Range'0.C_Range start end' -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 21 4 21 64] (self : Range'0.t_Range idx) (visited : Seq.seq idx) (o : Range'0.t_Range idx)
    
   =
    [%#srange2] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  use seq.Seq
  
  goal produces_refl_refn : [%#srange0] forall self : Range'0.t_Range idx . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq idx) self
   -> produces'0 self (Seq.empty  : Seq.seq idx) self)
  
  goal produces_trans_refn : [%#srange1] forall a : Range'0.t_Range idx . forall ab : Seq.seq idx . forall b : Range'0.t_Range idx . forall bc : Seq.seq idx . forall c : Range'0.t_Range idx . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi11108913944999844411 [#"../../../creusot-contracts/src/std/iter/range.rs" 58 0 58 79] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  type idx
  
  let%span srange0 = "../../../creusot-contracts/src/std/iter/range.rs" 89 4 89 90
  let%span srange1 = "../../../creusot-contracts/src/std/iter/range.rs" 82 4 82 26
  let%span srange2 = "../../../creusot-contracts/src/std/iter/range.rs" 71 12 75 76
  let%span srange3 = "../../../creusot-contracts/src/std/iter/range.rs" 50 10 50 43
  let%span srange4 = "../../../creusot-contracts/src/std/iter/range.rs" 52 4 55 5
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 209 14 209 86
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : idx)
  
  use T_core__ops__range__RangeInclusive as RangeInclusive'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : RangeInclusive'0.t_RangeInclusive idx)
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : RangeInclusive'0.t_RangeInclusive idx [inv'0 x] . inv'0 x
  = match x with
    | RangeInclusive'0.C_RangeInclusive start end' exhausted -> inv'1 start /\ inv'1 end'
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function start_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 195 4 195 29] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  use prelude.prelude.Int
  
  function deep_model'0 [#"../../../creusot-contracts/src/model.rs" 25 4 25 45] (self : idx) : int
  
  use seq.Seq
  
  function end_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 202 4 202 27] (self : RangeInclusive'0.t_RangeInclusive idx) : idx
    
  
  function is_empty_log'0 [#"../../../creusot-contracts/src/std/ops.rs" 210 4 213 35] (self : RangeInclusive'0.t_RangeInclusive idx) : bool
    
  
  axiom is_empty_log'0_spec : forall self : RangeInclusive'0.t_RangeInclusive idx . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 51 0 51 92] (r : RangeInclusive'0.t_RangeInclusive idx) : int
    
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : RangeInclusive'0.t_RangeInclusive idx . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/range.rs" 69 4 69 64] (self : RangeInclusive'0.t_RangeInclusive idx) (visited : Seq.seq idx) (o : RangeInclusive'0.t_RangeInclusive idx)
    
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  goal produces_trans_refn : [%#srange0] forall a : RangeInclusive'0.t_RangeInclusive idx . forall ab : Seq.seq idx . forall b : RangeInclusive'0.t_RangeInclusive idx . forall bc : Seq.seq idx . forall c : RangeInclusive'0.t_RangeInclusive idx . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#srange1] forall self : RangeInclusive'0.t_RangeInclusive idx . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq idx) self
   -> produces'0 self (Seq.empty  : Seq.seq idx) self)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi8658929399712466629 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 14 0 14 37] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  type t
  
  let%span srepeat0 = "../../../creusot-contracts/src/std/iter/repeat.rs" 34 4 34 26
  let%span srepeat1 = "../../../creusot-contracts/src/std/iter/repeat.rs" 44 4 44 90
  let%span srepeat2 = "../../../creusot-contracts/src/std/iter/repeat.rs" 25 12 26 78
  let%span srepeat3 = "../../../creusot-contracts/src/std/iter/repeat.rs" 10 20 10 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__iter__sources__repeat__Repeat as Repeat'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Repeat'0.t_Repeat t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Repeat'0.t_Repeat t [inv'0 x] . inv'0 x
  = match x with
    | Repeat'0.C_Repeat element -> inv'1 element
    end
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 9 4 9 22] (self : Repeat'0.t_Repeat t) : t
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/repeat.rs" 23 4 23 64] (self : Repeat'0.t_Repeat t) (visited : Seq.seq t) (o : Repeat'0.t_Repeat t)
    
   =
    [%#srepeat2] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  goal produces_refl_refn : [%#srepeat0] forall self : Repeat'0.t_Repeat t . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#srepeat1] forall a : Repeat'0.t_Repeat t . forall ab : Seq.seq t . forall b : Repeat'0.t_Repeat t . forall bc : Seq.seq t . forall c : Repeat'0.t_Repeat t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi3195031491774060502 [#"../../../creusot-contracts/src/std/iter/skip.rs" 46 0 46 38] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  type i
  
  let%span sskip0 = "../../../creusot-contracts/src/std/iter/skip.rs" 90 4 90 90
  let%span sskip1 = "../../../creusot-contracts/src/std/iter/skip.rs" 78 4 78 26
  let%span sskip2 = "../../../creusot-contracts/src/std/iter/skip.rs" 65 12 70 74
  let%span sskip3 = "../../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip4 = "../../../creusot-contracts/src/std/iter/skip.rs" 25 20 25 26
  let%span sskip5 = "../../../creusot-contracts/src/std/iter/skip.rs" 15 14 15 39
  let%span sskip6 = "../../../creusot-contracts/src/std/iter/skip.rs" 17 20 17 26
  let%span sseq7 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed8] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Item'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__skip__Skip as Skip'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Skip'0.t_Skip i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Skip'0.t_Skip i [inv'0 x] . inv'0 x
  = match x with
    | Skip'0.C_Skip iter n -> inv'2 iter
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 16 4 16 22] (self : Skip'0.t_Skip i) : i
  
  axiom iter'0_spec : forall self : Skip'0.t_Skip i . [%#sskip5] inv'0 self  -> inv'2 (iter'0 self)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 24 4 24 21] (self : Skip'0.t_Skip i) : int
  
  axiom n'0_spec : forall self : Skip'0.t_Skip i . [%#sskip3] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/skip.rs" 63 4 63 64] (self : Skip'0.t_Skip i) (visited : Seq.seq t_Item'0) (o : Skip'0.t_Skip i)
    
   =
    [%#sskip2] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'1 s
    /\ Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal produces_trans_refn : [%#sskip0] forall a : Skip'0.t_Skip i . forall ab : Seq.seq t_Item'0 . forall b : Skip'0.t_Skip i . forall bc : Seq.seq t_Item'0 . forall c : Skip'0.t_Skip i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#sskip1] forall self : Skip'0.t_Skip i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi12344256497067751022 [#"../../../creusot-contracts/src/std/iter/take.rs" 55 0 55 38] (* <std::iter::Take<I> as std::iter::Iterator> *)
  type i
  
  let%span stake0 = "../../../creusot-contracts/src/std/iter/take.rs" 77 4 77 26
  let%span stake1 = "../../../creusot-contracts/src/std/iter/take.rs" 87 4 87 90
  let%span stake2 = "../../../creusot-contracts/src/std/iter/take.rs" 69 12 69 88
  let%span stake3 = "../../../creusot-contracts/src/std/iter/take.rs" 34 14 34 50
  let%span stake4 = "../../../creusot-contracts/src/std/iter/take.rs" 36 20 36 26
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 18 14 18 39
  let%span stake6 = "../../../creusot-contracts/src/std/iter/take.rs" 20 20 20 26
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__iter__adapters__take__Take as Take'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Take'0.t_Take i)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Take'0.t_Take i [inv'0 x] . inv'0 x
  = match x with
    | Take'0.C_Take iter n -> inv'1 iter
    end
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  function iter'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 19 4 19 22] (self : Take'0.t_Take i) : i
  
  axiom iter'0_spec : forall self : Take'0.t_Take i . [%#stake5] inv'0 self  -> inv'1 (iter'0 self)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 35 4 35 21] (self : Take'0.t_Take i) : int
  
  axiom n'0_spec : forall self : Take'0.t_Take i . [%#stake3] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/take.rs" 67 4 67 64] (self : Take'0.t_Take i) (visited : Seq.seq t_Item'0) (o : Take'0.t_Take i)
    
   =
    [%#stake2] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  use seq.Seq
  
  goal produces_refl_refn : [%#stake0] forall self : Take'0.t_Take i . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  goal produces_trans_refn : [%#stake1] forall a : Take'0.t_Take i . forall ab : Seq.seq t_Item'0 . forall b : Take'0.t_Take i . forall bc : Seq.seq t_Item'0 . forall c : Take'0.t_Take i . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi2281060687216883844 [#"../../../creusot-contracts/src/std/iter/zip.rs" 29 0 29 53] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  type a
  
  type b
  
  let%span szip0 = "../../../creusot-contracts/src/std/iter/zip.rs" 71 4 71 90
  let%span szip1 = "../../../creusot-contracts/src/std/iter/zip.rs" 59 4 59 26
  let%span szip2 = "../../../creusot-contracts/src/std/iter/zip.rs" 48 12 51 95
  let%span szip3 = "../../../creusot-contracts/src/std/iter/zip.rs" 15 14 15 39
  let%span szip4 = "../../../creusot-contracts/src/std/iter/zip.rs" 17 20 17 26
  let%span szip5 = "../../../creusot-contracts/src/std/iter/zip.rs" 23 14 23 39
  let%span szip6 = "../../../creusot-contracts/src/std/iter/zip.rs" 25 20 25 26
  let%span sseq7 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'1
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'1) =
    [%#sboxed8] inv'8 self
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'1 [inv'6 x] . inv'6 x = invariant'3 x
  
  type t_Item'0
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed8] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'1 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'1) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'6 (Seq.get self i)
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_Item'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq7] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : b)
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : a)
  
  use T_core__iter__adapters__zip__Zip as Zip'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Zip'0.t_Zip a b)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Zip'0.t_Zip a b [inv'0 x] . inv'0 x
  = match x with
    | Zip'0.C_Zip a b index len a_len -> inv'3 a /\ inv'4 b
    end
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : b) (visited : Seq.seq t_Item'1) (o : b)
    
  
  function iterb'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 24 4 24 23] (self : Zip'0.t_Zip a b) : b
  
  axiom iterb'0_spec : forall self : Zip'0.t_Zip a b . [%#szip5] inv'0 self  -> inv'4 (iterb'0 self)
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : a) (visited : Seq.seq t_Item'0) (o : a)
    
  
  function itera'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 16 4 16 23] (self : Zip'0.t_Zip a b) : a
  
  axiom itera'0_spec : forall self : Zip'0.t_Zip a b . [%#szip3] inv'0 self  -> inv'3 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/zip.rs" 45 4 45 64] (self : Zip'0.t_Zip a b) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : Zip'0.t_Zip a b)
    
   =
    [%#szip2] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . inv'1 p1
    /\ inv'2 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  goal produces_trans_refn : [%#szip0] forall a : Zip'0.t_Zip a b . forall ab : Seq.seq (t_Item'0, t_Item'1) . forall b : Zip'0.t_Zip a b . forall bc : Seq.seq (t_Item'0, t_Item'1) . forall c : Zip'0.t_Zip a b . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#szip1] forall self : Zip'0.t_Zip a b . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self
   -> produces'0 self (Seq.empty  : Seq.seq (t_Item'0, t_Item'1)) self)
end
module M_creusot_contracts__stdqy35z1__option__qyi15354566128244900690 [#"../../../creusot-contracts/src/std/option.rs" 459 0 459 32] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 478 4 478 26
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 485 4 485 90
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 470 12 471 96
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 455 20 455 26
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Item'0.t_Item t [inv'1 x] . inv'1 x
  = match x with
    | Item'0.C_Item opt -> inv'2 opt
    end
  
  use T_core__option__IntoIter as IntoIter'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IntoIter'0.t_IntoIter t [inv'0 x] . inv'0 x
  = match x with
    | IntoIter'0.C_IntoIter inner -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 454 4 454 30] (self : IntoIter'0.t_IntoIter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 468 4 468 64] (self : IntoIter'0.t_IntoIter t) (visited : Seq.seq t) (o : IntoIter'0.t_IntoIter t)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  goal produces_refl_refn : [%#soption0] forall self : IntoIter'0.t_IntoIter t . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#soption1] forall a : IntoIter'0.t_IntoIter t . forall ab : Seq.seq t . forall b : IntoIter'0.t_IntoIter t . forall bc : Seq.seq t . forall c : IntoIter'0.t_IntoIter t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi15411423289202690388 [#"../../../creusot-contracts/src/std/option.rs" 513 0 513 36] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 532 4 532 26
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 539 4 539 90
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 524 12 525 96
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 509 20 509 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant4] inv'4 self
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'3 x] . inv'3 x = invariant'0 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option t [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Item'0.t_Item t [inv'1 x] . inv'1 x
  = match x with
    | Item'0.C_Item opt -> inv'2 opt
    end
  
  use T_core__option__Iter as Iter'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Iter'0.t_Iter t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Iter'0.t_Iter t [inv'0 x] . inv'0 x
  = match x with
    | Iter'0.C_Iter inner -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 508 4 508 34] (self : Iter'0.t_Iter t) : Option'0.t_Option t
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 522 4 522 64] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (o : Iter'0.t_Iter t)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq t) /\ self = o
    \/ (exists e : t . view'0 self = Option'0.C_Some e /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  goal produces_refl_refn : [%#soption0] forall self : Iter'0.t_Iter t . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
  
  goal produces_trans_refn : [%#soption1] forall a : Iter'0.t_Iter t . forall ab : Seq.seq t . forall b : Iter'0.t_Iter t . forall bc : Seq.seq t . forall c : Iter'0.t_Iter t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi6601631924869095363 [#"../../../creusot-contracts/src/std/option.rs" 570 0 570 39] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span soption0 = "../../../creusot-contracts/src/std/option.rs" 596 4 596 90
  let%span soption1 = "../../../creusot-contracts/src/std/option.rs" 589 4 589 26
  let%span soption2 = "../../../creusot-contracts/src/std/option.rs" 581 12 582 96
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 566 20 566 26
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant4] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t [inv'3 x] . inv'3 x = invariant'0 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option (borrowed t))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (borrowed t) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use T_core__option__Item as Item'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Item'0.t_Item (borrowed t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Item'0.t_Item (borrowed t) [inv'1 x] . inv'1 x
  = match x with
    | Item'0.C_Item opt -> inv'2 opt
    end
  
  use T_core__option__IterMut as IterMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IterMut'0.t_IterMut t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IterMut'0.t_IterMut t [inv'0 x] . inv'0 x
  = match x with
    | IterMut'0.C_IterMut inner -> inv'1 inner
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/option.rs" 565 4 565 38] (self : IterMut'0.t_IterMut t) : Option'0.t_Option (borrowed t)
    
  
  use seq.Seq
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/option.rs" 579 4 579 64] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (o : IterMut'0.t_IterMut t)
    
   =
    [%#soption2] visited = (Seq.empty  : Seq.seq (borrowed t)) /\ self = o
    \/ (exists e : borrowed t . view'0 self = Option'0.C_Some e
    /\ visited = Seq.singleton e /\ view'0 o = Option'0.C_None)
  
  goal produces_trans_refn : [%#soption0] forall a : IterMut'0.t_IterMut t . forall ab : Seq.seq (borrowed t) . forall b : IterMut'0.t_IterMut t . forall bc : Seq.seq (borrowed t) . forall c : IterMut'0.t_IterMut t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#soption1] forall self : IterMut'0.t_IterMut t . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self
   -> produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi8256668011736225471 [#"../../../creusot-contracts/src/std/slice.rs" 399 0 399 36] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 428 4 428 90
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 419 4 419 26
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 410 12 410 66
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 395 8 395 14
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 101 14 101 80
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 103 20 103 26
  let%span smodel7 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sops8 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice11 = "../../../creusot-contracts/src/std/slice.rs" 32 20 32 26
  
  use T_core__slice__iter__Iter as Iter'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Iter'0.t_Iter t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Iter'0.t_Iter t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice10] view'2 self = Slice.id self)
  && ([%#sslice9] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops8] Seq.get (view'2 self) ix
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : slice t) : Seq.seq t =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  function to_ref_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 102 4 102 35] (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice5] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice4] Seq.length (to_ref_seq'0 self) = Seq.length (view'1 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 394 4 394 33] (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 408 4 408 65] (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t)
    
   =
    [%#sslice2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal produces_trans_refn : [%#sslice0] forall a : Iter'0.t_Iter t . forall ab : Seq.seq t . forall b : Iter'0.t_Iter t . forall bc : Seq.seq t . forall c : Iter'0.t_Iter t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#sslice1] forall self : Iter'0.t_Iter t . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi7128337469104663169 [#"../../../creusot-contracts/src/std/slice.rs" 458 0 458 39] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  type t
  
  let%span sslice0 = "../../../creusot-contracts/src/std/slice.rs" 477 4 477 26
  let%span sslice1 = "../../../creusot-contracts/src/std/slice.rs" 487 4 487 90
  let%span sslice2 = "../../../creusot-contracts/src/std/slice.rs" 469 12 469 66
  let%span sslice3 = "../../../creusot-contracts/src/std/slice.rs" 437 14 437 50
  let%span sslice4 = "../../../creusot-contracts/src/std/slice.rs" 434 4 434 12
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 90 14 90 41
  let%span sslice6 = "../../../creusot-contracts/src/std/slice.rs" 91 14 91 84
  let%span sslice7 = "../../../creusot-contracts/src/std/slice.rs" 94 20 94 26
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 32 20 32 26
  let%span smodel11 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sops12 = "../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use T_core__slice__iter__IterMut as IterMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IterMut'0.t_IterMut t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IterMut'0.t_IterMut t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'1 [#"../../../creusot-contracts/src/std/slice.rs" 31 4 31 33] (self : slice t) : Seq.seq t
  
  axiom view'1_spec : forall self : slice t . ([%#sslice9] view'1 self = Slice.id self)
  && ([%#sslice8] Seq.length (view'1 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/ops.rs" 41 4 41 47] (self : slice t) (ix : int) : t
    
   =
    [%#sops12] Seq.get (view'1 self) ix
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  function view'2 [#"../../../creusot-contracts/src/model.rs" 108 4 108 33] (self : borrowed (slice t)) : Seq.seq t =
    [%#smodel11] view'1 self.current
  
  use seq.Seq
  
  function to_mut_seq'0 [#"../../../creusot-contracts/src/std/slice.rs" 93 4 93 43] (self : borrowed (slice t)) : Seq.seq (borrowed t)
    
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice t) . ([%#sslice6] forall i : int . 0 <= i
  /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  && ([%#sslice5] Seq.length (to_mut_seq'0 self) = Seq.length (view'2 self))
  
  function view'0 [#"../../../creusot-contracts/src/std/slice.rs" 438 4 438 33] (self : IterMut'0.t_IterMut t) : borrowed (slice t)
    
  
  axiom view'0_spec : forall self : IterMut'0.t_IterMut t . [%#sslice3] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/slice.rs" 467 4 467 65] (self : IterMut'0.t_IterMut t) (visited : Seq.seq (borrowed t)) (tl : IterMut'0.t_IterMut t)
    
   =
    [%#sslice2] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  use seq.Seq
  
  goal produces_refl_refn : [%#sslice0] forall self : IterMut'0.t_IterMut t . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self
   -> produces'0 self (Seq.empty  : Seq.seq (borrowed t)) self)
  
  goal produces_trans_refn : [%#sslice1] forall a : IterMut'0.t_IterMut t . forall ab : Seq.seq (borrowed t) . forall b : IterMut'0.t_IterMut t . forall bc : Seq.seq (borrowed t) . forall c : IterMut'0.t_IterMut t . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi12862303518309667396 [#"../../../creusot-contracts/src/std/vec.rs" 258 0 258 59] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  type t
  
  type a
  
  let%span svec0 = "../../../creusot-contracts/src/std/vec.rs" 285 4 285 72
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 276 4 276 26
  let%span svec2 = "../../../creusot-contracts/src/std/vec.rs" 269 12 269 41
  let%span svec3 = "../../../creusot-contracts/src/std/vec.rs" 239 8 239 14
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : a)
  
  use T_core__mem__manually_drop__ManuallyDrop as ManuallyDrop'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : ManuallyDrop'0.t_ManuallyDrop a)
  
  axiom inv_axiom'1 [@rewrite] : forall x : ManuallyDrop'0.t_ManuallyDrop a [inv'1 x] . inv'1 x
  = match x with
    | ManuallyDrop'0.C_ManuallyDrop value -> inv'2 value
    end
  
  use T_alloc__vec__into_iter__IntoIter as IntoIter'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : IntoIter'0.t_IntoIter t a)
  
  axiom inv_axiom'0 [@rewrite] : forall x : IntoIter'0.t_IntoIter t a [inv'0 x] . inv'0 x
  = match x with
    | IntoIter'0.C_IntoIter buf phantom cap alloc ptr end' -> inv'1 alloc
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/vec.rs" 238 4 238 33] (self : IntoIter'0.t_IntoIter t a) : Seq.seq t
    
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/vec.rs" 267 4 267 57] (self : IntoIter'0.t_IntoIter t a) (visited : Seq.seq t) (rhs : IntoIter'0.t_IntoIter t a)
    
   =
    [%#svec2] view'0 self = Seq.(++) visited (view'0 rhs)
  
  goal produces_trans_refn : [%#svec0] forall a : IntoIter'0.t_IntoIter t a . forall ab : Seq.seq t . forall b : IntoIter'0.t_IntoIter t a . forall bc : Seq.seq t . forall c : IntoIter'0.t_IntoIter t a . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
  
  goal produces_refl_refn : [%#svec1] forall self : IntoIter'0.t_IntoIter t a . inv'0 self
   -> (forall result : () . produces'0 self (Seq.empty  : Seq.seq t) self
   -> produces'0 self (Seq.empty  : Seq.seq t) self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi6712012543989784202 [#"../../../creusot-contracts/src/std/iter/cloned.rs" 8 0 8 34] (* <std::iter::Cloned<I> as std::iter::cloned::ClonedExt<I>> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10247388707705003770 [#"../../../creusot-contracts/src/std/iter/copied.rs" 8 0 8 34] (* <std::iter::Copied<I> as std::iter::copied::CopiedExt<I>> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17513132599508154932 [#"../../../creusot-contracts/src/std/iter/enumerate.rs" 11 0 11 40] (* <std::iter::Enumerate<I> as std::iter::enumerate::EnumerateExt<I>> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi2480673807958349380 [#"../../../creusot-contracts/src/std/iter/filter.rs" 15 0 15 43] (* <std::iter::Filter<I, F> as std::iter::filter::FilterExt<I, F>> *)
  type i
  
  type f
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi7691061398646472980 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 68 0 68 43] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type i
  
  let%span sfuse0 = "../../../creusot-contracts/src/std/iter/fuse.rs" 79 4 79 62
  let%span sfuse1 = "../../../creusot-contracts/src/std/iter/fuse.rs" 30 12 36 13
  let%span sfuse2 = "../../../creusot-contracts/src/std/iter/fuse.rs" 20 12 22 76
  let%span sfuse3 = "../../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 39
  let%span sfuse4 = "../../../creusot-contracts/src/std/iter/fuse.rs" 11 20 11 26
  let%span smodel5 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sseq6 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span sinvariant7 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed8 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'3 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed8] inv'7 self
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Item'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option i)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option i [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed i) =
    [%#sinvariant7] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed i)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed i [inv'3 x] . inv'3 x = invariant'2 x
  
  use T_core__iter__adapters__fuse__Fuse as Fuse'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Fuse'0.t_Fuse i)
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (Fuse'0.t_Fuse i))
   =
    [%#sinvariant7] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (Fuse'0.t_Fuse i))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Fuse'0.t_Fuse i) [inv'2 x] . inv'2 x = invariant'1 x
  
  axiom inv_axiom'1 [@rewrite] : forall x : Fuse'0.t_Fuse i [inv'1 x] . inv'1 x
  = match x with
    | Fuse'0.C_Fuse iter -> inv'4 iter
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use seq.Seq
  
  function view'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : Fuse'0.t_Fuse i) : Option'0.t_Option i
    
  
  axiom view'0_spec : forall self : Fuse'0.t_Fuse i . [%#sfuse3] inv'1 self  -> inv'4 (view'0 self)
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 108 4 108 33] (self : borrowed (Fuse'0.t_Fuse i)) : Option'0.t_Option i
    
   =
    [%#smodel5] view'0 self.current
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : borrowed (Fuse'0.t_Fuse i))
    
   =
    [%#sfuse2] (view'1 self = Option'0.C_None
    \/ (exists it : borrowed i . inv'3 it /\ completed'1 it /\ view'1 self = Option'0.C_Some (it.current)))
    /\ view'0 self.final = Option'0.C_None
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  predicate produces'0 [#"../../../creusot-contracts/src/std/iter/fuse.rs" 28 4 28 65] (self : Fuse'0.t_Fuse i) (prod : Seq.seq t_Item'0) (other : Fuse'0.t_Fuse i)
    
   =
    [%#sfuse1] match view'0 self with
      | Option'0.C_None -> prod = (Seq.empty  : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | Option'0.C_Some i -> match view'0 other with
        | Option'0.C_Some i2 -> produces'1 i prod i2
        | Option'0.C_None -> false
        end
      end
  
  goal is_fused_refn : [%#sfuse0] forall self : borrowed (Fuse'0.t_Fuse i) . forall steps : Seq.seq t_Item'0 . forall next : Fuse'0.t_Fuse i . produces'0 self.final steps next
  /\ completed'0 self /\ inv'0 steps /\ inv'1 next /\ inv'2 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ inv'0 steps
  /\ inv'1 next
  /\ inv'2 self
  /\ (forall result : () . steps = (Seq.empty  : Seq.seq t_Item'0) /\ self.final = next
   -> steps = (Seq.empty  : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi18081562764877493131 [#"../../../creusot-contracts/src/std/iter/map.rs" 14 0 14 37] (* <std::iter::Map<I, F> as std::iter::map::MapExt<I, F>> *)
  type i
  
  type f
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi4413682431414748756 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 92 0 93 29] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  type i
  
  type b
  
  type f
  
  let%span smap_inv0 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 101 4 101 44
  let%span smap_inv1 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv2 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 200 14 200 68
  let%span smap_inv3 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 203 12 208 67
  let%span smap_inv4 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 45 8 58 9
  let%span sinvariant5 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sseq6 = "../../../creusot-contracts/src/logic/seq.rs" 459 20 459 95
  let%span smap_inv7 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 85 12 87 73
  let%span smap_inv8 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 166 12 170 47
  let%span smap_inv9 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 137 14 137 81
  let%span smap_inv10 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 88
  let%span smap_inv11 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 128 12 130 63
  let%span sboxed12 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span smap_inv13 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 158 71
  
  predicate inv'11 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : i)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed i) =
    [%#sinvariant5] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'12 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed i)
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed i [inv'12 x] . inv'12 x = invariant'7 x
  
  type t_Item'0
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  predicate invariant'6 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t_Item'0) =
    [%#sboxed12] inv'3 self
  
  predicate inv'10 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  predicate invariant'5 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : borrowed f) =
    [%#sboxed12] inv'2 self
  
  predicate inv'9 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed f)
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed f [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate inv'8 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : f)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 71 4 71 42] (self : f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0)))
    
  
  use prelude.prelude.Snapshot
  
  predicate produces'1 [#"../../../creusot-contracts/src/std/iter.rs" 32 4 32 65] (self : i) (visited : Seq.seq t_Item'0) (o : i)
    
  
  use seq.Seq
  
  predicate next_precondition'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 126 4 126 78] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv11] forall e : t_Item'0, i : i . inv'3 e /\ inv'11 i /\ produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : (t_Item'0, Snapshot.snap_ty (Seq.seq t_Item'0))) (_3 : b)
    
  
  use seq.Seq
  
  use seq.Seq
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  predicate inv'6 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : b)
  
  predicate inv'5 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq t_Item'0)
  
  predicate preservation'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 49] (iter : i) (func : f) =
    [%#smap_inv13] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'5 s
    /\ inv'3 e1 /\ inv'3 e2 /\ inv'2 f /\ inv'6 b /\ inv'11 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f (e1, Snapshot.new s) b  -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  use seq.Seq
  
  predicate preservation_inv'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 73] (iter : i) (func : f) (produced : Seq.seq t_Item'0)
    
   =
    [%#smap_inv10] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : borrowed f, b : b, i : i . inv'5 s
    /\ inv'3 e1 /\ inv'3 e2 /\ inv'2 f /\ inv'6 b /\ inv'11 i /\ unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new (Seq.(++) produced s))
     -> postcondition_mut'0 f (e1, Snapshot.new (Seq.(++) produced s)) b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc (Seq.(++) produced s) e1))
  
  axiom preservation_inv'0_spec : forall iter : i, func : f, produced : Seq.seq t_Item'0 . [%#smap_inv9] produced
  = (Seq.empty  : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  use prelude.prelude.Snapshot
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate completed'1 [#"../../../creusot-contracts/src/std/iter.rs" 35 4 35 36] (self : borrowed i)
  
  predicate reinitialize'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 164 4 164 33] (_1 : ()) =
    [%#smap_inv8] forall iter : borrowed i, func : f . inv'12 iter /\ inv'8 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as MapInv'0
  
  predicate invariant'4 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 83 4 83 30] (self : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv7] reinitialize'0 ()
    /\ preservation_inv'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
    /\ next_precondition'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self))
  
  predicate inv'7 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : MapInv'0.t_MapInv i t_Item'0 f)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MapInv'0.t_MapInv i t_Item'0 f [inv'7 x] . inv'7 x
  = (invariant'4 x
  /\ match x with
    | MapInv'0.C_MapInv iter func produced -> inv'11 iter /\ inv'8 func
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  predicate invariant'3 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq t_Item'0) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'2 [#"../../../creusot-contracts/src/logic/seq.rs" 458 4 458 30] (self : Seq.seq (borrowed f)) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Seq.seq (borrowed f))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq (borrowed f) [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed f) =
    [%#sinvariant5] inv'8 self.current /\ inv'8 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed f [inv'2 x] . inv'2 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : Option'0.t_Option b)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option b [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    [%#sinvariant5] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (MapInv'0.t_MapInv i t_Item'0 f) [inv'0 x] . inv'0 x
  = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 44 4 44 67] (self : MapInv'0.t_MapInv i t_Item'0 f) (visited : Seq.seq b) (succ : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv4] unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ)
    /\ (exists fs : Seq.seq (borrowed f) . inv'4 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . inv'5 s
    /\ Seq.length s = Seq.length visited
    /\ produces'1 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) s (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    else
      (Seq.get fs 0).current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      /\ (Seq.get fs (Seq.length visited - 1)).final
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i))) (Seq.get visited i))))
  
  use seq.Seq
  
  predicate produces_one'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 201 4 201 57] (self : MapInv'0.t_MapInv i t_Item'0 f) (visited : b) (succ : MapInv'0.t_MapInv i t_Item'0 f)
    
   =
    [%#smap_inv3] exists f : borrowed f, e : t_Item'0 . inv'2 f
    /\ inv'3 e
    /\ f.current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
    /\ f.final = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    /\ produces'1 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) (Seq.singleton e) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.snoc (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) e
    /\ precondition'0 f.current (e, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)
    /\ postcondition_mut'0 f (e, T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self) visited
  
  axiom produces_one'0_spec : forall self : MapInv'0.t_MapInv i t_Item'0 f, visited : b, succ : MapInv'0.t_MapInv i t_Item'0 f . [%#smap_inv2] produces_one'0 self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate completed'0 [#"../../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : borrowed (MapInv'0.t_MapInv i t_Item'0 f))
    
   =
    [%#smap_inv1] Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self.final)
    = (Seq.empty  : Seq.seq t_Item'0)
    /\ completed'1 (Borrow.borrow_logic (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.current) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.final) (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.current
    = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.final
  
  goal next_refn : [%#smap_inv0] forall self : borrowed (MapInv'0.t_MapInv i t_Item'0 f) . inv'0 self
   -> inv'0 self
  /\ (forall result : Option'0.t_Option b . inv'1 result
  /\ match result with
    | Option'0.C_None -> completed'0 self
    | Option'0.C_Some v -> produces_one'0 self.current v self.final
    end
   -> inv'1 result
  /\ match result with
    | Option'0.C_None -> completed'0 self
    | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
    end)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi12614629843961634939 [#"../../../creusot-contracts/src/std/iter/skip.rs" 11 0 11 30] (* <std::iter::Skip<I> as std::iter::skip::SkipExt<I>> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi16119091645280769998 [#"../../../creusot-contracts/src/std/iter/take.rs" 14 0 14 30] (* <std::iter::Take<I> as std::iter::take::TakeExt<I>> *)
  type i
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi10244840876673122742 [#"../../../creusot-contracts/src/std/iter/zip.rs" 11 0 11 57] (* <std::iter::Zip<A, B> as std::iter::zip::ZipExt<A, B>> *)
  type a
  
  type b
end
module M_creusot_contracts__stdqy35z1__ops__qyi4493280661083386610 [#"../../../creusot-contracts/src/std/ops.rs" 66 0 66 56] (* <F as std::ops::FnOnceExt<Args>> *)
  type args
  
  type f
end
module M_creusot_contracts__stdqy35z1__ops__qyi14194840286170235833 [#"../../../creusot-contracts/src/std/ops.rs" 84 0 84 54] (* <F as std::ops::FnMutExt<Args>> *)
  type args
  
  type f
  
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 120 4 120 43
  let%span sops1 = "../../../creusot-contracts/src/std/ops.rs" 112 4 112 24
  let%span sops2 = "../../../creusot-contracts/src/std/ops.rs" 126 4 126 55
  let%span sops3 = "../../../creusot-contracts/src/std/ops.rs" 106 4 106 73
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 98 8 98 14
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 80 8 80 14
  let%span sops6 = "../../../creusot-contracts/src/std/ops.rs" 90 8 90 14
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : args) (_3 : t_Output'0)
    
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : args) (_3 : t_Output'0)
    
  
  predicate unnest'0 [#"../../../creusot-contracts/src/std/ops.rs" 97 4 97 36] (self : f) (_2 : f)
  
  goal unnest_trans_refn : [%#sops0] forall self : f . forall b : f . forall c : f . unnest'0 b c /\ unnest'0 self b
   -> unnest'0 b c /\ unnest'0 self b /\ (forall result : () . unnest'0 self c  -> unnest'0 self c)
  
  goal unnest_refl_refn : [%#sops1] forall self : f . forall result : () . unnest'0 self self  -> unnest'0 self self
  
  goal fn_mut_once_refn : [%#sops2] forall self : f . forall args : args . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (exists s : borrowed f . s.current = self /\ postcondition_mut'0 s args res /\ resolve'0 s.final)
   -> postcondition_once'0 self args res
  = (exists s : borrowed f . s.current = self /\ postcondition_mut'0 s args res /\ resolve'0 s.final)
  
  goal postcondition_mut_unnest_refn : [%#sops3] forall self : borrowed f . forall args : args . forall res : t_Output'0 . postcondition_mut'0 self args res
   -> postcondition_mut'0 self args res
  /\ (forall result : () . unnest'0 self.current self.final  -> unnest'0 self.current self.final)
end
module M_creusot_contracts__stdqy35z1__ops__qyi10441027020636586103 [#"../../../creusot-contracts/src/std/ops.rs" 129 0 129 48] (* <F as std::ops::FnExt<Args>> *)
  type args
  
  type f
  
  let%span sops0 = "../../../creusot-contracts/src/std/ops.rs" 142 4 142 55
  let%span sops1 = "../../../creusot-contracts/src/std/ops.rs" 148 4 148 51
  let%span sops2 = "../../../creusot-contracts/src/std/ops.rs" 90 8 90 14
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sops4 = "../../../creusot-contracts/src/std/ops.rs" 135 8 135 14
  let%span sops5 = "../../../creusot-contracts/src/std/ops.rs" 80 8 80 14
  
  use prelude.prelude.Borrow
  
  predicate resolve'2 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : f)
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../../creusot-contracts/src/std/ops.rs" 79 4 79 65] (self : f) (_2 : args) (_3 : t_Output'0)
    
  
  predicate resolve'0 [#"../../../creusot-contracts/src/resolve.rs" 40 4 40 28] (self : borrowed f) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : borrowed f) =
    resolve'0 _1
  
  predicate postcondition'0 [#"../../../creusot-contracts/src/std/ops.rs" 134 4 134 61] (self : f) (_2 : args) (_3 : t_Output'0)
    
  
  predicate postcondition_mut'0 [#"../../../creusot-contracts/src/std/ops.rs" 89 4 89 69] (self : borrowed f) (_2 : args) (_3 : t_Output'0)
    
  
  goal fn_mut_refn : [%#sops0] forall self : borrowed f . forall args : args . forall res : t_Output'0 . forall result : () . postcondition_mut'0 self args res
  = (resolve'0 self /\ postcondition'0 self.current args res)
   -> postcondition_mut'0 self args res = (resolve'1 self /\ postcondition'0 self.current args res)
  
  goal fn_once_refn : [%#sops1] forall self : f . forall args : args . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (resolve'2 self /\ postcondition'0 self args res)
   -> postcondition_once'0 self args res = (resolve'2 self /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ops__qyi2719475894322958352 [#"../../../creusot-contracts/src/std/ops.rs" 191 0 191 56] (* <std::ops::RangeInclusive<Idx> as std::ops::RangeInclusiveExt<Idx>> *)
  type idx
end
module M_creusot_contracts__stdqy35z1__slice__qyi5116818466776309241 [#"../../../creusot-contracts/src/std/slice.rs" 86 0 86 27] (* <[T] as std::slice::SliceExt<T>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi1105331053294498344 [#"../../../creusot-contracts/src/std/slice.rs" 121 0 121 33] (* <usize as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi8398939604525980490 [#"../../../creusot-contracts/src/std/slice.rs" 144 0 144 40] (* <std::ops::Range<usize> as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi16636464002483151879 [#"../../../creusot-contracts/src/std/slice.rs" 167 0 167 42] (* <std::ops::RangeTo<usize> as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi10228779843881721486 [#"../../../creusot-contracts/src/std/slice.rs" 187 0 187 44] (* <std::ops::RangeFrom<usize> as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi8643379208497449840 [#"../../../creusot-contracts/src/std/slice.rs" 209 0 209 37] (* <std::ops::RangeFull as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__slice__qyi4146566963751639754 [#"../../../creusot-contracts/src/std/slice.rs" 229 0 229 51] (* <std::ops::RangeToInclusive<usize> as std::slice::SliceIndex<[T]>> *)
  type t
end
module M_creusot_contracts__stdqy35z1__vec__qyi13118139699091775493 [#"../../../creusot-contracts/src/std/vec.rs" 288 0 288 34] (* <std::vec::Vec<T> as std::iter::FromIterator<T>> *)
  type t
end
module M_creusot_contracts__ghost__qyi1862168959261460300 [#"../../../creusot-contracts/src/ghost.rs" 45 0 45 37] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 52 4 52 36
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'2 x] . inv'2 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : t) =
    [%#sinvariant1] inv'3 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostBox'0.t_GhostBox t) =
    [%#sinvariant1] inv'2 self
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  goal deref_refn : [%#sghost0] forall self : GhostBox'0.t_GhostBox t . inv'0 self
   -> inv'0 self
  /\ (forall result : t . inv'1 result /\ T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self = result
   -> inv'1 result)
end
module M_creusot_contracts__snapshot__qyi15280887721803926406 [#"../../../creusot-contracts/src/snapshot.rs" 8 0 8 37] (* <snapshot::Snapshot<T> as std::ops::Deref> *)
  type t
end
module M_creusot_contracts__ghost_ptr__qyi12069901807935209935 [#"../../../creusot-contracts/src/ghost_ptr.rs" 175 0 175 53] (* <ghost_ptr::GhostPtrTokenRef<'a, T> as std::ops::Deref> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 179 4 179 36
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 169 14 169 64
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 171 8 171 14
  let%span sinvariant6 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sghost_ptr13 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'4 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'4_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap12] mk'0 (view'4 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap10] Map.get (view'4 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr8] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr7] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'2 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'2_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr2] get_unsized'0 (view'2 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr13] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'2 self) ptr = Option'0.C_Some x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'2 x] . inv'2 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sinvariant6] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenRef as GhostPtrTokenRef'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrTokenRef'0.t_GhostPtrTokenRef t)
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrTokenRef'0.t_GhostPtrTokenRef t [inv'0 x] . inv'0 x = true
  
  function view'3 [#"../../../creusot-contracts/src/ghost_ptr.rs" 170 4 170 33] (self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'3_spec : forall self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t . [%#sghost_ptr4] get_unsized'0 (view'3 self) (null_logic'0 ())
  = Option'0.C_None
  
  function view'1 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel1] view'3 self
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel1] view'2 self
  
  goal deref_refn : [%#sghost_ptr0] forall self : GhostPtrTokenRef'0.t_GhostPtrTokenRef t . inv'0 self
   -> (forall result : GhostPtrToken'0.t_GhostPtrToken t . inv'1 result /\ view'0 result = view'1 self  -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi2050065802908022022 [#"../../../creusot-contracts/src/ghost_ptr.rs" 270 0 270 53] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as std::ops::Deref> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 275 4 275 36
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 214 14 214 64
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 8 216 14
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sinvariant10 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sghost_ptr11 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap12 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sghost_ptr13 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'2 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'2_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap12] mk'0 (view'2 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap9] Map.get (view'2 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr7] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr6] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'1_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr4] get_unsized'0 (view'1 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr13] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'1 self) ptr = Option'0.C_Some x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'2 x] . inv'2 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 23 4 23 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sinvariant10] inv'2 self
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'1 x] . inv'1 x = invariant'0 x
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenMut as GhostPtrTokenMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrTokenMut'0.t_GhostPtrTokenMut t)
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : GhostPtrTokenMut'0.t_GhostPtrTokenMut t [inv'0 x] . inv'0 x = true
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 215 4 215 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom cur'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr2] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  function view'0 [#"../../../creusot-contracts/src/model.rs" 90 4 90 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
   =
    [%#smodel1] view'1 self
  
  goal deref_refn : [%#sghost_ptr0] forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . inv'0 self
   -> (forall result : GhostPtrToken'0.t_GhostPtrToken t . inv'1 result /\ view'0 result = cur'0 self  -> inv'1 result)
end
module M_creusot_contracts__ghost__qyi17214052996668775070 [#"../../../creusot-contracts/src/ghost.rs" 63 0 63 40] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  type t
  
  let%span sghost0 = "../../../creusot-contracts/src/ghost.rs" 68 4 68 48
  let%span sinvariant1 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed2 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  predicate invariant'2 [#"../../../creusot-contracts/src/std/boxed.rs" 27 4 27 30] (self : t) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostBox'0.t_GhostBox t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostBox'0.t_GhostBox t [inv'2 x] . inv'2 x
  = match x with
    | GhostBox'0.C_GhostBox a_0 -> inv'4 a_0
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed t) =
    [%#sinvariant1] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed t [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (GhostBox'0.t_GhostBox t))
    
   =
    [%#sinvariant1] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostBox'0.t_GhostBox t))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (GhostBox'0.t_GhostBox t) [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  goal deref_mut_refn : [%#sghost0] forall self : borrowed (GhostBox'0.t_GhostBox t) . inv'0 self
   -> inv'0 self
  /\ (forall result : borrowed t . inv'1 result
  /\ result
  = Borrow.borrow_logic (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.current) (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.final) (Borrow.inherit_id (Borrow.get_id self) 1)
   -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi11706120906342127713 [#"../../../creusot-contracts/src/ghost_ptr.rs" 280 0 280 56] (* <ghost_ptr::GhostPtrTokenMut<'a, T> as std::ops::DerefMut> *)
  type t
  
  let%span sghost_ptr0 = "../../../creusot-contracts/src/ghost_ptr.rs" 285 4 285 48
  let%span sghost_ptr1 = "../../../creusot-contracts/src/ghost_ptr.rs" 222 14 222 64
  let%span sghost_ptr2 = "../../../creusot-contracts/src/ghost_ptr.rs" 224 8 224 14
  let%span sghost_ptr3 = "../../../creusot-contracts/src/ghost_ptr.rs" 214 14 214 64
  let%span sghost_ptr4 = "../../../creusot-contracts/src/ghost_ptr.rs" 216 8 216 14
  let%span sghost_ptr5 = "../../../creusot-contracts/src/ghost_ptr.rs" 34 14 34 64
  let%span sghost_ptr6 = "../../../creusot-contracts/src/ghost_ptr.rs" 37 8 37 14
  let%span sghost_ptr7 = "../../../creusot-contracts/src/ghost_ptr.rs" 149 14 149 38
  let%span sghost_ptr8 = "../../../creusot-contracts/src/ghost_ptr.rs" 150 14 150 96
  let%span sghost_ptr9 = "../../../creusot-contracts/src/ghost_ptr.rs" 152 8 152 14
  let%span sfmap10 = "../../../creusot-contracts/src/logic/fmap.rs" 88 8 88 26
  let%span sinvariant11 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sghost_ptr12 = "../../../creusot-contracts/src/ghost_ptr.rs" 159 8 159 14
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span sghost_ptr14 = "../../../creusot-contracts/src/ghost_ptr.rs" 47 20 47 96
  
  predicate inv'3 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : t)
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use prelude.prelude.Opaque
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  function mk'0 [#"../../../creusot-contracts/src/logic/fmap.rs" 40 4 40 37] (_m : Map.map opaque_ptr (Option'0.t_Option t)) : FMap'0.t_FMap opaque_ptr t
    
  
  function view'1 [#"../../../creusot-contracts/src/logic/fmap.rs" 48 4 48 35] (self : FMap'0.t_FMap opaque_ptr t) : Map.map opaque_ptr (Option'0.t_Option t)
    
  
  axiom view'1_spec : forall self : FMap'0.t_FMap opaque_ptr t . [%#sfmap13] mk'0 (view'1 self) = self
  
  function get_unsized'0 [@inline:trivial] [#"../../../creusot-contracts/src/logic/fmap.rs" 87 4 87 55] (self : FMap'0.t_FMap opaque_ptr t) (k : opaque_ptr) : Option'0.t_Option t
    
   =
    [%#sfmap10] Map.get (view'1 self) k
  
  use T_creusot_contracts__ghost_ptr__GhostPtrToken as GhostPtrToken'0
  
  use prelude.prelude.Int
  
  function addr_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 158 4 158 30] (self : opaque_ptr) : int
  
  function null_logic'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 151 4 151 27] (_1 : ()) : opaque_ptr
  
  axiom null_logic'0_spec : forall _1 : () . ([%#sghost_ptr8] forall ptr : opaque_ptr . addr_logic'0 ptr
  = addr_logic'0 (null_logic'0 _1)  -> ptr = null_logic'0 _1)
  && ([%#sghost_ptr7] addr_logic'0 (null_logic'0 _1) = 0)
  
  function view'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 36 4 36 33] (self : GhostPtrToken'0.t_GhostPtrToken t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom view'0_spec : forall self : GhostPtrToken'0.t_GhostPtrToken t . [%#sghost_ptr5] get_unsized'0 (view'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  predicate invariant'1 [#"../../../creusot-contracts/src/ghost_ptr.rs" 46 4 46 30] (self : GhostPtrToken'0.t_GhostPtrToken t)
    
   =
    [%#sghost_ptr14] forall ptr : opaque_ptr, x : t . get_unsized'0 (view'0 self) ptr = Option'0.C_Some x  -> inv'3 x
  
  predicate inv'2 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : GhostPtrToken'0.t_GhostPtrToken t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : GhostPtrToken'0.t_GhostPtrToken t [inv'2 x] . inv'2 x = invariant'1 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 [#"../../../creusot-contracts/src/invariant.rs" 33 4 33 30] (self : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
   =
    [%#sinvariant11] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostPtrToken'0.t_GhostPtrToken t))
    
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (GhostPtrToken'0.t_GhostPtrToken t) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  use T_creusot_contracts__ghost_ptr__GhostPtrTokenMut as GhostPtrTokenMut'0
  
  predicate inv'0 [#"../../../creusot-contracts/src/invariant.rs" 41 0 41 35] (_1 : borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t))
    
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t) [inv'0 x] . inv'0 x
  = true
  
  function cur'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 215 4 215 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom cur'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr3] get_unsized'0 (cur'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  function fin'0 [#"../../../creusot-contracts/src/ghost_ptr.rs" 223 4 223 44] (self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t) : FMap'0.t_FMap opaque_ptr t
    
  
  axiom fin'0_spec : forall self : GhostPtrTokenMut'0.t_GhostPtrTokenMut t . [%#sghost_ptr1] get_unsized'0 (fin'0 self) (null_logic'0 ())
  = Option'0.C_None
  
  goal deref_mut_refn : [%#sghost_ptr0] forall self : borrowed (GhostPtrTokenMut'0.t_GhostPtrTokenMut t) . inv'0 self
   -> (forall result : borrowed (GhostPtrToken'0.t_GhostPtrToken t) . inv'1 result
  /\ fin'0 self.final = fin'0 self.current
  /\ cur'0 self.final = view'0 result.final /\ view'0 result.current = cur'0 self.current  -> inv'1 result)
end
module M_creusot_contracts__ghost_ptr__qyi2907104573689134347 [#"../../../creusot-contracts/src/ghost_ptr.rs" 145 0 145 46] (* <*const T as ghost_ptr::GhostPtrExt<T>> *)
  type t
end
module M_creusot_contracts__util__qyi2295509035132574236 [#"../../../creusot-contracts/src/util.rs" 11 0 11 31] (* <T as util::MakeSized> *)
  type t
end
module M_creusot_contracts__well_founded__qyi9310745643810688590 [#"../../../creusot-contracts/src/well_founded.rs" 9 0 9 24] (* <logic::int::Int as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi14438938773511278076 [#"../../../creusot-contracts/src/well_founded.rs" 12 0 12 23] (* <u8 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi15465756156088115448 [#"../../../creusot-contracts/src/well_founded.rs" 14 0 14 24] (* <u16 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi9638351460870142599 [#"../../../creusot-contracts/src/well_founded.rs" 16 0 16 24] (* <u32 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi6347394689205276921 [#"../../../creusot-contracts/src/well_founded.rs" 18 0 18 24] (* <u64 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi3202706400091273105 [#"../../../creusot-contracts/src/well_founded.rs" 20 0 20 25] (* <u128 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi5144186910077244316 [#"../../../creusot-contracts/src/well_founded.rs" 22 0 22 26] (* <usize as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi8603373305131464426 [#"../../../creusot-contracts/src/well_founded.rs" 25 0 25 23] (* <i8 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi13433421712097793401 [#"../../../creusot-contracts/src/well_founded.rs" 27 0 27 24] (* <i16 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi5625578033759360989 [#"../../../creusot-contracts/src/well_founded.rs" 29 0 29 24] (* <i32 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi9403382943699858826 [#"../../../creusot-contracts/src/well_founded.rs" 31 0 31 24] (* <i64 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi9609909904270418013 [#"../../../creusot-contracts/src/well_founded.rs" 33 0 33 25] (* <i128 as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi15923855770017652186 [#"../../../creusot-contracts/src/well_founded.rs" 35 0 35 26] (* <isize as well_founded::WellFounded> *)
  
end
module M_creusot_contracts__well_founded__qyi8351725930864072297 [#"../../../creusot-contracts/src/well_founded.rs" 38 0 38 39] (* <&T as well_founded::WellFounded> *)
  type t
end
module M_creusot_contracts__well_founded__qyi4381592598837673088 [#"../../../creusot-contracts/src/well_founded.rs" 41 0 41 43] (* <&mut T as well_founded::WellFounded> *)
  type t
end
