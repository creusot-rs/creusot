module M_878__test [#"878.rs" 4 0 4 13]
  let%span s8780 = "878.rs" 5 21 5 22
  let%span s8781 = "878.rs" 5 24 5 25
  let%span s8782 = "878.rs" 5 27 5 28
  let%span s8783 = "878.rs" 5 30 5 31
  let%span s8784 = "878.rs" 6 4 6 13
  let%span sslice5 = "../../../../creusot-contracts/src/std/slice.rs" 332 18 332 35
  let%span svec6 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sboxed7 = "../../../../creusot-contracts/src/std/boxed.rs" 18 8 18 22
  let%span sslice8 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice9 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Int32
  
  predicate inv'0 (_1 : slice int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : slice int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  predicate inv'1 (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq int32
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec6] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  use prelude.prelude.Slice
  
  function view'2 (self : slice int32) : Seq.seq int32
  
  axiom view'2_spec : forall self : slice int32 . ([%#sslice8] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice9] view'2 self = Slice.id self)
  
  function view'1 (self : slice int32) : Seq.seq int32 =
    [%#sboxed7] view'2 self
  
  let rec into_vec'0 (self:slice int32) (return'  (ret:t_Vec'0))= {[@expl:into_vec 'self' type invariant] inv'0 self}
    any [ return' (result:t_Vec'0)-> {inv'1 result} {[%#sslice5] view'0 result = view'1 self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:array int32)-> (! -{Seq.get __arr_temp.elts 0 = ([%#s8780] (1 : int32))
          /\ Seq.get __arr_temp.elts 1 = ([%#s8781] (2 : int32))
          /\ Seq.get __arr_temp.elts 2 = ([%#s8782] (2 : int32))
          /\ Seq.get __arr_temp.elts 3 = ([%#s8783] (3 : int32)) /\ Seq.length __arr_temp.elts = 4}-
           [ &_4 <- __arr_temp ] 
          s1) ]
        
      | s1 = bb1 ]
      
    | bb1 = bb2
    | bb2 = s0 [ s0 = into_vec'0 {_4} (fun (_ret':t_Vec'0) ->  [ &v <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = Borrow.borrow_mut <t_Vec'0> {v}
          (fun (_ret':borrowed (t_Vec'0)) ->  [ &_6 <- _ret' ]  [ &v <- _ret'.final ] s1)
      | s1 = {[%#s8784] false} any ]
       ]
    )
    [ & _0 : () = any_l ()
    | & v : t_Vec'0 = any_l ()
    | & _4 : array int32 = any_l ()
    | & _6 : borrowed (t_Vec'0) = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_878__test2 [#"878.rs" 19 0 19 14]
  let%span s8780 = "878.rs" 20 19 20 20
  let%span s8781 = "878.rs" 21 13 21 25
  let%span sslice2 = "../../../../creusot-contracts/src/std/slice.rs" 332 18 332 35
  let%span svec3 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sboxed4 = "../../../../creusot-contracts/src/std/boxed.rs" 18 8 18 22
  let%span sslice5 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice6 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sboxed7 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 65 20 65 41
  let%span sslice9 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span sseq10 = "../../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span s87811 = "878.rs" 15 8 15 22
  
  use prelude.prelude.UInt32
  
  type t_S'0  =
    { t_S__0'0: uint32 }
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  function view'2 (self : slice (t_S'0)) : Seq.seq (t_S'0)
  
  axiom view'2_spec : forall self : slice (t_S'0) . ([%#sslice5] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice6] view'2 self = Slice.id self)
  
  use seq.Seq
  
  predicate invariant'5 [#"878.rs" 14 4 14 30] (self : t_S'0) =
    [%#s87811] self.t_S__0'0 = (0 : uint32)
  
  predicate inv'5 (_1 : t_S'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_S'0 [inv'5 x] . inv'5 x
  = (invariant'5 x
  /\ match x with
    | {t_S__0'0 = a_0} -> true
    end)
  
  predicate invariant'4 (self : t_S'0) =
    [%#sboxed7] inv'5 self
  
  predicate inv'4 (_1 : t_S'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_S'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  predicate invariant'3 (self : Seq.seq (t_S'0)) =
    [%#sseq10] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq (t_S'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq (t_S'0) [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : slice (t_S'0)) =
    [%#sslice9] inv'3 (view'2 self)
  
  predicate inv'2 (_1 : slice (t_S'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice (t_S'0) [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'0 (self : slice (t_S'0)) =
    [%#sboxed7] inv'2 self
  
  predicate inv'0 (_1 : slice (t_S'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : slice (t_S'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  function view'0 (self : t_Vec'0) : Seq.seq (t_S'0)
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec3] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#svec8] inv'3 (view'0 self)
  
  predicate inv'1 (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function view'1 (self : slice (t_S'0)) : Seq.seq (t_S'0) =
    [%#sboxed4] view'2 self
  
  let rec into_vec'0 (self:slice (t_S'0)) (return'  (ret:t_Vec'0))= {[@expl:into_vec 'self' type invariant] inv'0 self}
    any [ return' (result:t_Vec'0)-> {inv'1 result} {[%#sslice2] view'0 result = view'1 self} (! return' {result}) ] 
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test2'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- { t_S__0'0 = ([%#s8780] (0 : uint32)) } ] s1
      | s1 = any
        [ any_ (__arr_temp:array (t_S'0))-> (! -{Seq.get __arr_temp.elts 0 = _5 /\ Seq.length __arr_temp.elts = 1}-
           [ &_4 <- __arr_temp ] 
          s2) ]
        
      | s2 = bb1 ]
      
    | bb1 = bb2
    | bb2 = s0 [ s0 = into_vec'0 {_4} (fun (_ret':t_Vec'0) ->  [ &v <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = {[%#s8781] false} any ]
    )
    [ & _0 : () = any_l ()
    | & v : t_Vec'0 = any_l ()
    | & _4 : array (t_S'0) = any_l ()
    | & _5 : t_S'0 = any_l ()
    | & b : bool = any_l ()
    | & _7 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_878__test3 [#"878.rs" 25 0 25 14]
  let%span s8780 = "878.rs" 26 19 26 20
  let%span s8781 = "878.rs" 27 20 27 35
  let%span sslice2 = "../../../../creusot-contracts/src/std/slice.rs" 332 18 332 35
  let%span svec3 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sboxed4 = "../../../../creusot-contracts/src/std/boxed.rs" 18 8 18 22
  let%span sslice5 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice6 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sboxed7 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 65 20 65 41
  let%span sslice9 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span sseq10 = "../../../../creusot-contracts/src/logic/seq.rs" 451 20 451 95
  let%span s87811 = "878.rs" 15 8 15 22
  
  use prelude.prelude.UInt32
  
  type t_S'0  =
    { t_S__0'0: uint32 }
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  function view'2 (self : slice (t_S'0)) : Seq.seq (t_S'0)
  
  axiom view'2_spec : forall self : slice (t_S'0) . ([%#sslice5] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice6] view'2 self = Slice.id self)
  
  use seq.Seq
  
  predicate invariant'5 [#"878.rs" 14 4 14 30] (self : t_S'0) =
    [%#s87811] self.t_S__0'0 = (0 : uint32)
  
  predicate inv'5 (_1 : t_S'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_S'0 [inv'5 x] . inv'5 x
  = (invariant'5 x
  /\ match x with
    | {t_S__0'0 = a_0} -> true
    end)
  
  predicate invariant'4 (self : t_S'0) =
    [%#sboxed7] inv'5 self
  
  predicate inv'4 (_1 : t_S'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_S'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  predicate invariant'3 (self : Seq.seq (t_S'0)) =
    [%#sseq10] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq (t_S'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq (t_S'0) [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : slice (t_S'0)) =
    [%#sslice9] inv'3 (view'2 self)
  
  predicate inv'2 (_1 : slice (t_S'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice (t_S'0) [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'0 (self : slice (t_S'0)) =
    [%#sboxed7] inv'2 self
  
  predicate inv'0 (_1 : slice (t_S'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : slice (t_S'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  function view'0 (self : t_Vec'0) : Seq.seq (t_S'0)
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec3] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#svec8] inv'3 (view'0 self)
  
  predicate inv'1 (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function view'1 (self : slice (t_S'0)) : Seq.seq (t_S'0) =
    [%#sboxed4] view'2 self
  
  let rec into_vec'0 (self:slice (t_S'0)) (return'  (ret:t_Vec'0))= {[@expl:into_vec 'self' type invariant] inv'0 self}
    any [ return' (result:t_Vec'0)-> {inv'1 result} {[%#sslice2] view'0 result = view'1 self} (! return' {result}) ] 
  
  use seq.Seq
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test3'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- { t_S__0'0 = ([%#s8780] (0 : uint32)) } ] s1
      | s1 = any
        [ any_ (__arr_temp:array (t_S'0))-> (! -{Seq.get __arr_temp.elts 0 = _5 /\ Seq.length __arr_temp.elts = 1}-
           [ &_4 <- __arr_temp ] 
          s2) ]
        
      | s2 = bb1 ]
      
    | bb1 = bb2
    | bb2 = s0 [ s0 = into_vec'0 {_4} (fun (_ret':t_Vec'0) ->  [ &v <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = {[@expl:assertion] [%#s8781] (Seq.get (view'0 v) 0).t_S__0'0 = (0 : uint32)} s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = return' {_0} ]
    ) [ & _0 : () = any_l () | & v : t_Vec'0 = any_l () | & _4 : array (t_S'0) = any_l () | & _5 : t_S'0 = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
