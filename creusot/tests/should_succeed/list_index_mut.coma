module M_list_index_mut__index_mut [#"list_index_mut.rs" 37 0 37 61]
  let%span slist_index_mut0 = "list_index_mut.rs" 38 16 38 31
  let%span slist_index_mut1 = "list_index_mut.rs" 39 17 39 33
  let%span slist_index_mut2 = "list_index_mut.rs" 45 8 47 48
  let%span slist_index_mut3 = "list_index_mut.rs" 43 16 43 76
  let%span slist_index_mut4 = "list_index_mut.rs" 42 16 42 55
  let%span slist_index_mut5 = "list_index_mut.rs" 41 16 41 52
  let%span slist_index_mut6 = "list_index_mut.rs" 40 16 40 45
  let%span slist_index_mut7 = "list_index_mut.rs" 49 15 49 16
  let%span slist_index_mut8 = "list_index_mut.rs" 52 14 52 15
  let%span slist_index_mut9 = "list_index_mut.rs" 32 11 32 24
  let%span slist_index_mut10 = "list_index_mut.rs" 33 10 33 37
  let%span slist_index_mut11 = "list_index_mut.rs" 34 10 34 40
  let%span slist_index_mut12 = "list_index_mut.rs" 35 10 35 34
  let%span slist_index_mut13 = "list_index_mut.rs" 36 10 36 85
  let%span slist_index_mut14 = "list_index_mut.rs" 6 4 6 12
  let%span slist_index_mut15 = "list_index_mut.rs" 17 4 17 12
  let%span ssnapshot16 = "../../../creusot-contracts/src/snapshot.rs" 52 20 52 39
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption18 = "../../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption19 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span smodel20 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sresolve21 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt32
  
  type t_Option'0  =
    | C_None'0
    | C_Some'1 (t_List'0)
  with t_List'0  =
    { t_List__0'0: uint32; t_List__1'0: t_Option'0 }
  
  function len'0 [#"list_index_mut.rs" 7 4 7 29] (self : t_List'0) : int =
    [%#slist_index_mut14] let {t_List__1'0 = ls} = self in 1
    + match ls with
      | C_Some'1 ls -> len'0 ls
      | C_None'0 -> 0
      end
  
  use prelude.prelude.UIntSize
  
  type t_Option'2  =
    | C_None'1
    | C_Some'0 uint32
  
  function get'0 [#"list_index_mut.rs" 18 4 18 46] (self : t_List'0) (ix : int) : t_Option'2 =
    [%#slist_index_mut15] let {t_List__0'0 = i ; t_List__1'0 = ls} = self in if ix > 0 then
      match ls with
        | C_Some'1 ls -> get'0 ls (ix - 1)
        | C_None'0 -> C_None'1
        end
    else
      C_Some'0 i
  
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  function view'1 (self : usize) : int =
    [%#smodel20] UIntSize.to_int self
  
  function view'0 (self : Snapshot.snap_ty usize) : int =
    [%#ssnapshot16] view'1 (Snapshot.inner self)
  
  predicate inv'0 (_1 : borrowed (t_Option'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Option'0) [inv'0 x] . inv'0 x = true
  
  type t_Option'1  =
    | C_None'2
    | C_Some'2 (borrowed (t_List'0))
  
  predicate inv'1 (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x = true
  
  let rec as_mut'0 (self:borrowed (t_Option'0)) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'0 self}
    any
    [ return' (result:t_Option'1)-> {inv'1 result}
      {[%#soption17] self.current = C_None'0  -> result = C_None'2 /\ self.final = C_None'0}
      {[%#soption18] self.current = C_None'0
      \/ (exists r : borrowed (t_List'0) . result = C_Some'2 r
      /\ self.current = C_Some'1 (r.current) /\ self.final = C_Some'1 (r.final))}
      (! return' {result}) ]
  
  
  predicate inv'2 (_1 : borrowed (t_List'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_List'0) [inv'2 x] . inv'2 x = true
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:borrowed (t_List'0)))= {[@expl:unwrap 'self' type invariant] inv'1 self}
    {[@expl:unwrap requires] [%#soption19] self <> C_None'2}
    any
    [ return' (result:borrowed (t_List'0))-> {inv'2 result}
      {[%#soption19] C_Some'2 result = self}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : borrowed (t_List'0)) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_List'0)) =
    resolve'3 _1
  
  predicate resolve'4 (self : borrowed (t_List'0)) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (t_List'0)) =
    resolve'4 _1
  
  predicate resolve'5 (self : borrowed uint32) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed uint32) =
    resolve'5 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec index_mut'0 (l:borrowed (t_List'0)) (ix:usize) (return'  (ret:borrowed uint32))= {[@expl:index_mut requires] [%#slist_index_mut9] UIntSize.to_int ix
    < len'0 l.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_l <- [%#slist_index_mut0] Snapshot.new l ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &old_ix <- [%#slist_index_mut1] Snapshot.new ix ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] [%#slist_index_mut6] (0 : usize) <= ix /\ UIntSize.to_int ix < len'0 l.current}
        {[@expl:loop invariant #1] [%#slist_index_mut5] get'0 l.current (UIntSize.to_int ix)
        = get'0 (Snapshot.inner old_l).current (view'0 old_ix)}
        {[@expl:loop invariant #2] [%#slist_index_mut4] get'0 l.final (UIntSize.to_int ix)
        = get'0 (Snapshot.inner old_l).final (view'0 old_ix)}
        {[@expl:loop invariant #3] [%#slist_index_mut3] len'0 l.final = len'0 l.current
         -> len'0 (Snapshot.inner old_l).final = len'0 (Snapshot.inner old_l).current}
        {[@expl:loop invariant #4] [%#slist_index_mut2] (forall i : int . 0 <= i
        /\ i < len'0 l.current /\ i <> UIntSize.to_int ix  -> get'0 l.final i = get'0 l.current i)
         -> (forall i : int . 0 <= i /\ i < len'0 (Snapshot.inner old_l).current /\ i <> view'0 old_ix
         -> get'0 (Snapshot.inner old_l).final i = get'0 (Snapshot.inner old_l).current i)}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = UIntSize.gt {ix} {[%#slist_index_mut7] (0 : usize)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
          | s1 = any [ br0 -> {_21 = false} (! bb8) | br1 -> {_21} (! bb5) ]  ]
        
        | bb5 = s0
          [ s0 = Borrow.borrow_final <t_Option'0> {(l.current).t_List__1'0} {Borrow.inherit_id (Borrow.get_id l) 2}
              (fun (_ret':borrowed (t_Option'0)) ->
                 [ &_26 <- _ret' ] 
                 [ &l <- { l with current = { l.current with t_List__1'0 = _ret'.final } } ] 
                s1)
          | s1 = as_mut'0 {_26} (fun (_ret':t_Option'1) ->  [ &_25 <- _ret' ] s2)
          | s2 = bb6 ]
        
        | bb6 = s0 [ s0 = unwrap'0 {_25} (fun (_ret':borrowed (t_List'0)) ->  [ &_24 <- _ret' ] s1) | s1 = bb7 ] 
        | bb7 = s0
          [ s0 = Borrow.borrow_final <t_List'0> {_24.current} {Borrow.get_id _24}
              (fun (_ret':borrowed (t_List'0)) ->  [ &_23 <- _ret' ]  [ &_24 <- { _24 with current = _ret'.final } ] s1)
          | s1 = -{resolve'0 l}- s2
          | s2 =  [ &l <- _23 ] s3
          | s3 = -{resolve'1 _24}- s4
          | s4 = UIntSize.sub {ix} {[%#slist_index_mut8] (1 : usize)} (fun (_ret':usize) ->  [ &ix <- _ret' ] s5)
          | s5 = bb3 ]
         ]
       ]
    
    | bb8 = s0
      [ s0 = Borrow.borrow_final <uint32> {(l.current).t_List__0'0} {Borrow.inherit_id (Borrow.get_id l) 1}
          (fun (_ret':borrowed uint32) ->
             [ &_28 <- _ret' ] 
             [ &l <- { l with current = { l.current with t_List__0'0 = _ret'.final } } ] 
            s1)
      | s1 = Borrow.borrow_final <uint32> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed uint32) ->  [ &_3 <- _ret' ]  [ &_28 <- { _28 with current = _ret'.final } ] s2)
      | s2 = Borrow.borrow_final <uint32> {_3.current} {Borrow.get_id _3}
          (fun (_ret':borrowed uint32) ->  [ &_0 <- _ret' ]  [ &_3 <- { _3 with current = _ret'.final } ] s3)
      | s3 = -{resolve'2 _28}- s4
      | s4 = -{resolve'2 _3}- s5
      | s5 = -{resolve'0 l}- s6
      | s6 = return' {_0} ]
     ]
    )
    [ & _0 : borrowed uint32 = any_l ()
    | & l : borrowed (t_List'0) = l
    | & ix : usize = ix
    | & _3 : borrowed uint32 = any_l ()
    | & old_l : Snapshot.snap_ty (borrowed (t_List'0)) = any_l ()
    | & old_ix : Snapshot.snap_ty usize = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : borrowed (t_List'0) = any_l ()
    | & _24 : borrowed (t_List'0) = any_l ()
    | & _25 : t_Option'1 = any_l ()
    | & _26 : borrowed (t_Option'0) = any_l ()
    | & _28 : borrowed uint32 = any_l () ]
    
    [ return' (result:borrowed uint32)-> {[@expl:index_mut ensures #0] [%#slist_index_mut10] C_Some'0 (result.current)
      = get'0 l.current (UIntSize.to_int ix)}
      {[@expl:index_mut ensures #1] [%#slist_index_mut11] C_Some'0 (result.final) = get'0 l.final (UIntSize.to_int ix)}
      {[@expl:index_mut ensures #2] [%#slist_index_mut12] len'0 l.final = len'0 l.current}
      {[@expl:index_mut ensures #3] [%#slist_index_mut13] forall i : int . 0 <= i
      /\ i < len'0 l.current /\ i <> UIntSize.to_int ix  -> get'0 l.current i = get'0 l.final i}
      (! return' {result}) ]

end
module M_list_index_mut__write [#"list_index_mut.rs" 63 0 63 45]
  let%span slist_index_mut0 = "list_index_mut.rs" 59 11 59 24
  let%span slist_index_mut1 = "list_index_mut.rs" 60 10 60 34
  let%span slist_index_mut2 = "list_index_mut.rs" 61 10 61 31
  let%span slist_index_mut3 = "list_index_mut.rs" 62 10 62 85
  let%span slist_index_mut4 = "list_index_mut.rs" 32 11 32 24
  let%span slist_index_mut5 = "list_index_mut.rs" 33 10 33 37
  let%span slist_index_mut6 = "list_index_mut.rs" 34 10 34 40
  let%span slist_index_mut7 = "list_index_mut.rs" 35 10 35 34
  let%span slist_index_mut8 = "list_index_mut.rs" 36 10 36 85
  let%span slist_index_mut9 = "list_index_mut.rs" 6 4 6 12
  let%span slist_index_mut10 = "list_index_mut.rs" 17 4 17 12
  let%span sresolve11 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt32
  
  type t_Option'0  =
    | C_None'0
    | C_Some'1 (t_List'0)
  with t_List'0  =
    { t_List__0'0: uint32; t_List__1'0: t_Option'0 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  function len'0 [#"list_index_mut.rs" 7 4 7 29] (self : t_List'0) : int =
    [%#slist_index_mut9] let {t_List__1'0 = ls} = self in 1
    + match ls with
      | C_Some'1 ls -> len'0 ls
      | C_None'0 -> 0
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'0 uint32
  
  function get'0 [#"list_index_mut.rs" 18 4 18 46] (self : t_List'0) (ix : int) : t_Option'1 =
    [%#slist_index_mut10] let {t_List__0'0 = i ; t_List__1'0 = ls} = self in if ix > 0 then
      match ls with
        | C_Some'1 ls -> get'0 ls (ix - 1)
        | C_None'0 -> C_None'1
        end
    else
      C_Some'0 i
  
  
  use prelude.prelude.UIntSize
  
  let rec index_mut'0 (l:borrowed (t_List'0)) (ix:usize) (return'  (ret:borrowed uint32))= {[@expl:index_mut requires] [%#slist_index_mut4] UIntSize.to_int ix
    < len'0 l.current}
    any
    [ return' (result:borrowed uint32)-> {[%#slist_index_mut5] C_Some'0 (result.current)
      = get'0 l.current (UIntSize.to_int ix)}
      {[%#slist_index_mut6] C_Some'0 (result.final) = get'0 l.final (UIntSize.to_int ix)}
      {[%#slist_index_mut7] len'0 l.final = len'0 l.current}
      {[%#slist_index_mut8] forall i : int . 0 <= i /\ i < len'0 l.current /\ i <> UIntSize.to_int ix
       -> get'0 l.current i = get'0 l.final i}
      (! return' {result}) ]
  
  
  predicate resolve'2 (self : borrowed uint32) =
    [%#sresolve11] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed uint32) =
    resolve'2 _1
  
  predicate resolve'3 (self : borrowed (t_List'0)) =
    [%#sresolve11] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (t_List'0)) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec write'0 (l:borrowed (t_List'0)) (ix:usize) (v:uint32) (return'  (ret:()))= {[@expl:write requires] [%#slist_index_mut0] UIntSize.to_int ix
    < len'0 l.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <t_List'0> {l.current} {Borrow.get_id l}
          (fun (_ret':borrowed (t_List'0)) ->  [ &_10 <- _ret' ]  [ &l <- { l with current = _ret'.final } ] s1)
      | s1 = index_mut'0 {_10} {ix} (fun (_ret':borrowed uint32) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- { _9 with current = v } ] s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = -{resolve'1 l}- s3
      | s3 = return' {_0} ]
     ]
    )
    [ & _0 : () = any_l ()
    | & l : borrowed (t_List'0) = l
    | & ix : usize = ix
    | & v : uint32 = v
    | & _9 : borrowed uint32 = any_l ()
    | & _10 : borrowed (t_List'0) = any_l () ]
    
    [ return' (result:())-> {[@expl:write ensures #0] [%#slist_index_mut1] C_Some'0 v
      = get'0 l.final (UIntSize.to_int ix)}
      {[@expl:write ensures #1] [%#slist_index_mut2] len'0 l.final = len'0 l.current}
      {[@expl:write ensures #2] [%#slist_index_mut3] forall i : int . 0 <= i
      /\ i < len'0 l.current /\ i <> UIntSize.to_int ix  -> get'0 l.current i = get'0 l.final i}
      (! return' {result}) ]

end
module M_list_index_mut__f [#"list_index_mut.rs" 67 0 67 10]
  let%span slist_index_mut0 = "list_index_mut.rs" 68 43 68 45
  let%span slist_index_mut1 = "list_index_mut.rs" 68 21 68 22
  let%span slist_index_mut2 = "list_index_mut.rs" 69 18 69 19
  let%span slist_index_mut3 = "list_index_mut.rs" 69 21 69 22
  let%span slist_index_mut4 = "list_index_mut.rs" 59 11 59 24
  let%span slist_index_mut5 = "list_index_mut.rs" 60 10 60 34
  let%span slist_index_mut6 = "list_index_mut.rs" 61 10 61 31
  let%span slist_index_mut7 = "list_index_mut.rs" 62 10 62 85
  let%span slist_index_mut8 = "list_index_mut.rs" 6 4 6 12
  let%span slist_index_mut9 = "list_index_mut.rs" 17 4 17 12
  let%span sresolve10 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.UInt32
  
  type t_List'0  =
    { t_List__0'0: uint32; t_List__1'0: t_Option'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 (t_List'0)
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  function len'0 [#"list_index_mut.rs" 7 4 7 29] (self : t_List'0) : int =
    [%#slist_index_mut8] let {t_List__1'0 = ls} = self in 1
    + match ls with
      | C_Some'0 ls -> len'0 ls
      | C_None'0 -> 0
      end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 uint32
  
  function get'0 [#"list_index_mut.rs" 18 4 18 46] (self : t_List'0) (ix : int) : t_Option'1 =
    [%#slist_index_mut9] let {t_List__0'0 = i ; t_List__1'0 = ls} = self in if ix > 0 then
      match ls with
        | C_Some'0 ls -> get'0 ls (ix - 1)
        | C_None'0 -> C_None'1
        end
    else
      C_Some'1 i
  
  
  let rec write'0 (l:borrowed (t_List'0)) (ix:usize) (v:uint32) (return'  (ret:()))= {[@expl:write requires] [%#slist_index_mut4] UIntSize.to_int ix
    < len'0 l.current}
    any
    [ return' (result:())-> {[%#slist_index_mut5] C_Some'1 v = get'0 l.final (UIntSize.to_int ix)}
      {[%#slist_index_mut6] len'0 l.final = len'0 l.current}
      {[%#slist_index_mut7] forall i : int . 0 <= i /\ i < len'0 l.current /\ i <> UIntSize.to_int ix
       -> get'0 l.current i = get'0 l.final i}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : borrowed (t_List'0)) =
    [%#sresolve10] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_List'0)) =
    resolve'1 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec f'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- C_None'0 ] s1
      | s1 =  [ &_4 <- { t_List__0'0 = ([%#slist_index_mut0] (10 : uint32)); t_List__1'0 = _5 } ] s2
      | s2 = bb1 ]
    
    | bb1 = bb2
    | bb2 = s0 [ s0 =  [ &_2 <- C_Some'0 _4 ] s1 | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &l <- { t_List__0'0 = ([%#slist_index_mut1] (1 : uint32)); t_List__1'0 = _2 } ] s1 | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 = Borrow.borrow_mut <t_List'0> {l}
          (fun (_ret':borrowed (t_List'0)) ->  [ &_8 <- _ret' ]  [ &l <- _ret'.final ] s1)
      | s1 = Borrow.borrow_final <t_List'0> {_8.current} {Borrow.get_id _8}
          (fun (_ret':borrowed (t_List'0)) ->  [ &_7 <- _ret' ]  [ &_8 <- { _8 with current = _ret'.final } ] s2)
      | s2 = write'0 {_7} {[%#slist_index_mut2] (0 : usize)} {[%#slist_index_mut3] (2 : uint32)}
          (fun (_ret':()) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0 [ s0 = -{resolve'0 _8}- s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & l : t_List'0 = any_l ()
    | & _2 : t_Option'0 = any_l ()
    | & _4 : t_List'0 = any_l ()
    | & _5 : t_Option'0 = any_l ()
    | & _6 : () = any_l ()
    | & _7 : borrowed (t_List'0) = any_l ()
    | & _8 : borrowed (t_List'0) = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
