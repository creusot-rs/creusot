
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Core_Num_Impl6_Min_Stub
  use prelude.Int
  use prelude.UInt8
  val constant mIN'  : uint8
end
module Core_Num_Impl6_Min
  use prelude.Int
  use prelude.UInt8
  let constant mIN'  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
end
module Core_Num_Impl6_Max_Stub
  use prelude.Int
  use prelude.UInt8
  val constant mAX'  : uint8
end
module Core_Num_Impl6_Max
  use prelude.Int
  use prelude.UInt8
  let constant mAX'  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
end
module Core_Num_Impl6_CheckedAdd_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Core_Option_Impl0_Unwrap_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  val unwrap (self : Core_Option_Option_Type.t_option t) : t
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { Inv1.inv result }
    
end
module Core_Option_Impl0_IsNone_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  val is_none (self : Core_Option_Option_Type.t_option t) : bool
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
end
module Core_Num_Impl6_Bits_Stub
  use prelude.Int
  use prelude.UInt32
  val constant bITS'  : uint32
end
module Core_Num_Impl6_Bits
  use prelude.Int
  use prelude.UInt32
  let constant bITS'  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
end
module Core_Num_Impl6_WrappingAdd_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val wrapping_add (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl6_SaturatingAdd_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  val saturating_add (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> UInt8.to_int result = UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int Max0.mAX' }
    
end
module Core_Num_Impl6_OverflowingAdd_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val overflowing_add (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CheckedOps_TestU8AddExample_Interface
  val test_u8_add_example [#"../checked_ops.rs" 5 0 5 28] (_1 : ()) : ()
end
module CheckedOps_TestU8AddExample
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingAdd_Interface as SaturatingAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv2.inv
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl6_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_add_example [#"../checked_ops.rs" 5 0 5 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 6 12 6 31] CheckedAdd0.checked_add ([#"../checked_ops.rs" 6 12 6 15] (5 : uint8)) ([#"../checked_ops.rs" 6 28 6 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 6 12 6 40] Unwrap0.unwrap _5);
    _5 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 6 12 6 46] _4 = ([#"../checked_ops.rs" 6 44 6 46] (15 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 7 12 7 33] CheckedAdd0.checked_add ([#"../checked_ops.rs" 7 12 7 17] (250 : uint8)) ([#"../checked_ops.rs" 7 30 7 32] (10 : uint8)));
    goto BB5
  }
  BB5 {
    _9 <- ([#"../checked_ops.rs" 7 12 7 43] IsNone0.is_none _11);
    goto BB6
  }
  BB6 {
    switch (not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _16 <- ([#"../checked_ops.rs" 9 12 9 32] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 9 12 9 15] (5 : uint8)) ([#"../checked_ops.rs" 9 29 9 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch (not ([#"../checked_ops.rs" 9 12 9 38] _16 = ([#"../checked_ops.rs" 9 36 9 38] (15 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _21 <- ([#"../checked_ops.rs" 10 12 10 34] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 10 12 10 17] (250 : uint8)) ([#"../checked_ops.rs" 10 31 10 33] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch (not ([#"../checked_ops.rs" 10 12 10 39] _21 = ([#"../checked_ops.rs" 10 38 10 39] (4 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _26 <- ([#"../checked_ops.rs" 12 12 12 34] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 12 12 12 15] (5 : uint8)) ([#"../checked_ops.rs" 12 31 12 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch (not ([#"../checked_ops.rs" 12 12 12 40] _26 = ([#"../checked_ops.rs" 12 38 12 40] (15 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _31 <- ([#"../checked_ops.rs" 13 12 13 36] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 13 12 13 17] (250 : uint8)) ([#"../checked_ops.rs" 13 33 13 35] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch (not ([#"../checked_ops.rs" 13 12 13 43] _31 = ([#"../checked_ops.rs" 13 40 13 43] (255 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    res <- ([#"../checked_ops.rs" 15 14 15 37] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 15 14 15 17] (5 : uint8)) ([#"../checked_ops.rs" 15 34 15 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 16 12 16 23] (let (a, _) = res in a) = ([#"../checked_ops.rs" 16 21 16 23] (15 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 16 12 16 41] false);
    goto BB24
  }
  BB23 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 16 27 16 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 16 36 16 41] false));
    goto BB24
  }
  BB24 {
    switch (not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    res1 <- ([#"../checked_ops.rs" 17 14 17 39] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 17 14 17 19] (250 : uint8)) ([#"../checked_ops.rs" 17 36 17 38] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 18 12 18 22] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 18 21 18 22] (4 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 18 12 18 39] false);
    goto BB30
  }
  BB29 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 18 26 18 39] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 18 35 18 39] true));
    goto BB30
  }
  BB30 {
    switch (not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8AddOverflow_Interface
  use prelude.UInt8
  use prelude.Int
  val test_u8_add_overflow [#"../checked_ops.rs" 23 0 23 34] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    
end
module CheckedOps_TestU8AddOverflow
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingAdd_Interface as SaturatingAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_add_overflow [#"../checked_ops.rs" 23 0 23 34] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _21 : uint8;
  var res : (uint8, bool);
  var _28 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 24 12 24 32] CheckedAdd0.checked_add ([#"../checked_ops.rs" 24 12 24 17] (255 : uint8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 24 12 24 42] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 25 12 25 33] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 25 12 25 17] (255 : uint8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 25 12 25 42] _13 = ([#"../checked_ops.rs" 25 37 25 42] a - ([#"../checked_ops.rs" 25 41 25 42] (1 : uint8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _21 <- ([#"../checked_ops.rs" 26 12 26 35] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 26 12 26 17] (255 : uint8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 26 12 26 42] _21 = ([#"../checked_ops.rs" 26 39 26 42] (255 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 27 14 27 38] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 27 14 27 19] (255 : uint8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 28 12 28 26] (let (a, _) = res in a) = ([#"../checked_ops.rs" 28 21 28 26] a - ([#"../checked_ops.rs" 28 25 28 26] (1 : uint8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _28 <- ([#"../checked_ops.rs" 28 12 28 43] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _28 <- ([#"../checked_ops.rs" 28 30 28 43] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 28 39 28 43] true));
    goto BB14
  }
  BB14 {
    switch (not _28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8WrappingAdd_Interface
  use prelude.UInt8
  use prelude.Int
  val test_u8_wrapping_add [#"../checked_ops.rs" 34 0 34 47] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result = UInt8.to_int a + UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256 }
    
end
module CheckedOps_TestU8WrappingAdd
  use prelude.Int
  use prelude.UInt8
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_wrapping_add [#"../checked_ops.rs" 34 0 34 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result = UInt8.to_int a + UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a : uint8 = a;
  var b : uint8 = b;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../checked_ops.rs" 35 4 35 21] WrappingAdd0.wrapping_add a b);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingAdd_Interface
  use prelude.Int
  use prelude.UInt8
  val test_u8_overflowing_add [#"../checked_ops.rs" 39 0 39 44] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingAdd
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_overflowing_add [#"../checked_ops.rs" 39 0 39 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 40 12 40 32] OverflowingAdd0.overflowing_add a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 40 38 40 55] WrappingAdd0.wrapping_add a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 40 12 40 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 41 12 41 32] OverflowingAdd0.overflowing_add a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 41 38 41 54] CheckedAdd0.checked_add a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 41 38 41 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 41 12 41 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl6_CheckedSub_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
end
module Core_Num_Impl6_WrappingSub_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val wrapping_sub (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl6_SaturatingSub_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  val saturating_sub (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> UInt8.to_int result = UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int Max0.mAX' }
    
end
module Core_Num_Impl6_OverflowingSub_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val overflowing_sub (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    
end
module CheckedOps_TestU8SubExample_Interface
  val test_u8_sub_example [#"../checked_ops.rs" 45 0 45 28] (_1 : ()) : ()
end
module CheckedOps_TestU8SubExample
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = uint8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingSub_Interface as SaturatingSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_sub_example [#"../checked_ops.rs" 45 0 45 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 46 12 46 31] CheckedSub0.checked_sub ([#"../checked_ops.rs" 46 12 46 15] (5 : uint8)) ([#"../checked_ops.rs" 46 28 46 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    _3 <- ([#"../checked_ops.rs" 46 12 46 41] IsNone0.is_none _5);
    goto BB2
  }
  BB2 {
    switch (not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 47 12 47 33] CheckedSub0.checked_sub ([#"../checked_ops.rs" 47 12 47 17] (250 : uint8)) ([#"../checked_ops.rs" 47 30 47 32] (10 : uint8)));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 47 12 47 42] Unwrap0.unwrap _11);
    _11 <- any Core_Option_Option_Type.t_option uint8;
    goto BB6
  }
  BB6 {
    switch (not ([#"../checked_ops.rs" 47 12 47 49] _10 = ([#"../checked_ops.rs" 47 46 47 49] (240 : uint8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _16 <- ([#"../checked_ops.rs" 49 12 49 32] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 49 12 49 15] (5 : uint8)) ([#"../checked_ops.rs" 49 29 49 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch (not ([#"../checked_ops.rs" 49 12 49 39] _16 = ([#"../checked_ops.rs" 49 36 49 39] (251 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _21 <- ([#"../checked_ops.rs" 50 12 50 34] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 50 12 50 17] (250 : uint8)) ([#"../checked_ops.rs" 50 31 50 33] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch (not ([#"../checked_ops.rs" 50 12 50 41] _21 = ([#"../checked_ops.rs" 50 38 50 41] (240 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _26 <- ([#"../checked_ops.rs" 52 12 52 34] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 52 12 52 15] (5 : uint8)) ([#"../checked_ops.rs" 52 31 52 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch (not ([#"../checked_ops.rs" 52 12 52 39] _26 = ([#"../checked_ops.rs" 52 38 52 39] (0 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _31 <- ([#"../checked_ops.rs" 53 12 53 36] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 53 12 53 17] (250 : uint8)) ([#"../checked_ops.rs" 53 33 53 35] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch (not ([#"../checked_ops.rs" 53 12 53 43] _31 = ([#"../checked_ops.rs" 53 40 53 43] (240 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    res <- ([#"../checked_ops.rs" 55 14 55 37] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 55 14 55 17] (5 : uint8)) ([#"../checked_ops.rs" 55 34 55 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 56 12 56 24] (let (a, _) = res in a) = ([#"../checked_ops.rs" 56 21 56 24] (251 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 56 12 56 41] false);
    goto BB24
  }
  BB23 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 56 28 56 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 56 37 56 41] true));
    goto BB24
  }
  BB24 {
    switch (not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    res1 <- ([#"../checked_ops.rs" 57 14 57 39] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 57 14 57 19] (250 : uint8)) ([#"../checked_ops.rs" 57 36 57 38] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 58 12 58 24] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 58 21 58 24] (240 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 58 12 58 42] false);
    goto BB30
  }
  BB29 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 58 28 58 42] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 58 37 58 42] false));
    goto BB30
  }
  BB30 {
    switch (not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8SubOverflow_Interface
  use prelude.UInt8
  use prelude.Int
  val test_u8_sub_overflow [#"../checked_ops.rs" 63 0 63 34] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    
end
module CheckedOps_TestU8SubOverflow
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingSub_Interface as SaturatingSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_sub_overflow [#"../checked_ops.rs" 63 0 63 34] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _22 : uint8;
  var res : (uint8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 64 12 64 30] CheckedSub0.checked_sub ([#"../checked_ops.rs" 64 12 64 15] (0 : uint8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 64 12 64 40] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 65 12 65 31] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 65 12 65 15] (0 : uint8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 65 12 65 46] _13 = ([#"../checked_ops.rs" 65 35 65 46] ([#"../checked_ops.rs" 65 35 65 42] ([#"../checked_ops.rs" 65 35 65 38] (255 : uint8)) - a) + ([#"../checked_ops.rs" 65 45 65 46] (1 : uint8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _22 <- ([#"../checked_ops.rs" 66 12 66 33] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 66 12 66 15] (0 : uint8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 66 12 66 38] _22 = ([#"../checked_ops.rs" 66 37 66 38] (0 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 67 14 67 36] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 67 14 67 17] (0 : uint8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 68 12 68 32] (let (a, _) = res in a) = ([#"../checked_ops.rs" 68 21 68 32] ([#"../checked_ops.rs" 68 21 68 28] ([#"../checked_ops.rs" 68 21 68 24] (255 : uint8)) - a) + ([#"../checked_ops.rs" 68 31 68 32] (1 : uint8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 68 12 68 49] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 68 36 68 49] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 68 45 68 49] true));
    goto BB14
  }
  BB14 {
    switch (not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8WrappingSub_Interface
  use prelude.UInt8
  use prelude.Int
  val test_u8_wrapping_sub [#"../checked_ops.rs" 74 0 74 47] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result = UInt8.to_int a - UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256 }
    
end
module CheckedOps_TestU8WrappingSub
  use prelude.Int
  use prelude.UInt8
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_wrapping_sub [#"../checked_ops.rs" 74 0 74 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result = UInt8.to_int a - UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a : uint8 = a;
  var b : uint8 = b;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../checked_ops.rs" 75 4 75 21] WrappingSub0.wrapping_sub a b);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingSub_Interface
  use prelude.Int
  use prelude.UInt8
  val test_u8_overflowing_sub [#"../checked_ops.rs" 79 0 79 44] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingSub
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_overflowing_sub [#"../checked_ops.rs" 79 0 79 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 80 12 80 32] OverflowingSub0.overflowing_sub a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 80 38 80 55] WrappingSub0.wrapping_sub a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 80 12 80 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 81 12 81 32] OverflowingSub0.overflowing_sub a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 81 38 81 54] CheckedSub0.checked_sub a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 81 38 81 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 81 12 81 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl6_CheckedMul_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
end
module Core_Num_Impl6_WrappingMul_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val wrapping_mul (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl6_SaturatingMul_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  val saturating_mul (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> UInt8.to_int result = UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> UInt8.to_int result = UInt8.to_int Max0.mAX' }
    
end
module Core_Num_Impl6_OverflowingMul_Interface
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl6_Max_Stub as Max0
  clone Core_Num_Impl6_Min_Stub as Min0
  clone Core_Num_Impl6_Bits_Stub as Bits0
  val overflowing_mul (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int Min0.mIN' /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int Max0.mAX' -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int Max0.mAX' - UInt8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int Min0.mIN' \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int Max0.mAX') }
    
end
module CheckedOps_TestU8MulExample_Interface
  val test_u8_mul_example [#"../checked_ops.rs" 85 0 85 28] (_1 : ()) : ()
end
module CheckedOps_TestU8MulExample
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingMul_Interface as SaturatingMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv2.inv
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl6_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_mul_example [#"../checked_ops.rs" 85 0 85 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 86 12 86 31] CheckedMul0.checked_mul ([#"../checked_ops.rs" 86 12 86 15] (5 : uint8)) ([#"../checked_ops.rs" 86 28 86 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 86 12 86 40] Unwrap0.unwrap _5);
    _5 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 86 12 86 46] _4 = ([#"../checked_ops.rs" 86 44 86 46] (50 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 87 12 87 32] CheckedMul0.checked_mul ([#"../checked_ops.rs" 87 12 87 16] (50 : uint8)) ([#"../checked_ops.rs" 87 29 87 31] (10 : uint8)));
    goto BB5
  }
  BB5 {
    _9 <- ([#"../checked_ops.rs" 87 12 87 42] IsNone0.is_none _11);
    goto BB6
  }
  BB6 {
    switch (not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _16 <- ([#"../checked_ops.rs" 89 12 89 32] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 89 12 89 15] (5 : uint8)) ([#"../checked_ops.rs" 89 29 89 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch (not ([#"../checked_ops.rs" 89 12 89 38] _16 = ([#"../checked_ops.rs" 89 36 89 38] (50 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _21 <- ([#"../checked_ops.rs" 90 12 90 33] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 90 12 90 16] (50 : uint8)) ([#"../checked_ops.rs" 90 30 90 32] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch (not ([#"../checked_ops.rs" 90 12 90 40] _21 = ([#"../checked_ops.rs" 90 37 90 40] (244 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _26 <- ([#"../checked_ops.rs" 92 12 92 34] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 92 12 92 15] (5 : uint8)) ([#"../checked_ops.rs" 92 31 92 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch (not ([#"../checked_ops.rs" 92 12 92 40] _26 = ([#"../checked_ops.rs" 92 38 92 40] (50 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _31 <- ([#"../checked_ops.rs" 93 12 93 35] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 93 12 93 16] (50 : uint8)) ([#"../checked_ops.rs" 93 32 93 34] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch (not ([#"../checked_ops.rs" 93 12 93 42] _31 = ([#"../checked_ops.rs" 93 39 93 42] (255 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    res <- ([#"../checked_ops.rs" 95 14 95 37] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 95 14 95 17] (5 : uint8)) ([#"../checked_ops.rs" 95 34 95 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 96 12 96 23] (let (a, _) = res in a) = ([#"../checked_ops.rs" 96 21 96 23] (50 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 96 12 96 41] false);
    goto BB24
  }
  BB23 {
    assume { Resolve0.resolve res };
    _36 <- ([#"../checked_ops.rs" 96 27 96 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 96 36 96 41] false));
    goto BB24
  }
  BB24 {
    switch (not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    res1 <- ([#"../checked_ops.rs" 97 14 97 38] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 97 14 97 18] (50 : uint8)) ([#"../checked_ops.rs" 97 35 97 37] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 98 12 98 24] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 98 21 98 24] (244 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 98 12 98 41] false);
    goto BB30
  }
  BB29 {
    assume { Resolve0.resolve res1 };
    _45 <- ([#"../checked_ops.rs" 98 28 98 41] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 98 37 98 41] true));
    goto BB30
  }
  BB30 {
    switch (not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8MulZero_Interface
  use prelude.Int
  use prelude.UInt8
  val test_u8_mul_zero [#"../checked_ops.rs" 102 0 102 30] (a : uint8) : ()
end
module CheckedOps_TestU8MulZero
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_SaturatingMul_Interface as SaturatingMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl6_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_mul_zero [#"../checked_ops.rs" 102 0 102 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : uint8;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _12 : uint8;
  var _18 : uint8;
  var res : (uint8, bool);
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../checked_ops.rs" 103 12 103 30] CheckedMul0.checked_mul ([#"../checked_ops.rs" 103 12 103 15] (0 : uint8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 103 12 103 39] Unwrap0.unwrap _6);
    _6 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 103 12 103 44] _5 = ([#"../checked_ops.rs" 103 43 103 44] (0 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _12 <- ([#"../checked_ops.rs" 104 12 104 31] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 104 12 104 15] (0 : uint8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 104 12 104 36] _12 = ([#"../checked_ops.rs" 104 35 104 36] (0 : uint8))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _18 <- ([#"../checked_ops.rs" 105 12 105 33] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 105 12 105 15] (0 : uint8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 105 12 105 38] _18 = ([#"../checked_ops.rs" 105 37 105 38] (0 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 106 14 106 36] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 106 14 106 17] (0 : uint8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 107 12 107 22] (let (a, _) = res in a) = ([#"../checked_ops.rs" 107 21 107 22] (0 : uint8)))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _25 <- ([#"../checked_ops.rs" 107 12 107 40] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _25 <- ([#"../checked_ops.rs" 107 26 107 40] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 107 35 107 40] false));
    goto BB14
  }
  BB14 {
    switch (not _25)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingMul_Interface
  use prelude.Int
  use prelude.UInt8
  val test_u8_overflowing_mul [#"../checked_ops.rs" 111 0 111 44] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingMul
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Max as Max0
  clone Core_Num_Impl6_Min as Min0
  clone Core_Num_Impl6_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl6_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_u8_overflowing_mul [#"../checked_ops.rs" 111 0 111 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 112 12 112 32] OverflowingMul0.overflowing_mul a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 112 38 112 55] WrappingMul0.wrapping_mul a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 112 12 112 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 113 12 113 32] OverflowingMul0.overflowing_mul a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 113 38 113 54] CheckedMul0.checked_mul a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 113 38 113 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 113 12 113 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl6_CheckedDiv_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl6_WrappingDiv_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Min_Stub as Min0
  val wrapping_div (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl6_SaturatingDiv_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Min_Stub as Min0
  val saturating_div (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl6_OverflowingDiv_Interface
  use prelude.UInt8
  use prelude.Int
  clone Core_Num_Impl6_Min_Stub as Min0
  val overflowing_div (self : uint8) (rhs : uint8) : (uint8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (UInt8.to_int self = UInt8.to_int Min0.mIN' /\ UInt8.to_int rhs = - 1) }
    
end
module CheckedOps_TestU8DivExample_Interface
  val test_u8_div_example [#"../checked_ops.rs" 117 0 117 28] (_1 : ()) : ()
end
module CheckedOps_TestU8DivExample
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = uint8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingDiv_Interface as OverflowingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl6_SaturatingDiv_Interface as SaturatingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl6_WrappingDiv_Interface as WrappingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_u8_div_example [#"../checked_ops.rs" 117 0 117 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var res : (uint8, bool);
  var _26 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 118 12 118 30] CheckedDiv0.checked_div ([#"../checked_ops.rs" 118 12 118 15] (5 : uint8)) ([#"../checked_ops.rs" 118 28 118 29] (0 : uint8)));
    goto BB1
  }
  BB1 {
    _3 <- ([#"../checked_ops.rs" 118 12 118 40] IsNone0.is_none _5);
    goto BB2
  }
  BB2 {
    switch (not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 119 12 119 30] CheckedDiv0.checked_div ([#"../checked_ops.rs" 119 12 119 15] (5 : uint8)) ([#"../checked_ops.rs" 119 28 119 29] (2 : uint8)));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 119 12 119 39] Unwrap0.unwrap _11);
    _11 <- any Core_Option_Option_Type.t_option uint8;
    goto BB6
  }
  BB6 {
    switch (not ([#"../checked_ops.rs" 119 12 119 44] _10 = ([#"../checked_ops.rs" 119 43 119 44] (2 : uint8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _16 <- ([#"../checked_ops.rs" 120 12 120 31] WrappingDiv0.wrapping_div ([#"../checked_ops.rs" 120 12 120 15] (5 : uint8)) ([#"../checked_ops.rs" 120 29 120 30] (2 : uint8)));
    goto BB9
  }
  BB9 {
    switch (not ([#"../checked_ops.rs" 120 12 120 36] _16 = ([#"../checked_ops.rs" 120 35 120 36] (2 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _21 <- ([#"../checked_ops.rs" 121 12 121 33] SaturatingDiv0.saturating_div ([#"../checked_ops.rs" 121 12 121 15] (5 : uint8)) ([#"../checked_ops.rs" 121 31 121 32] (2 : uint8)));
    goto BB12
  }
  BB12 {
    switch (not ([#"../checked_ops.rs" 121 12 121 38] _21 = ([#"../checked_ops.rs" 121 37 121 38] (2 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    res <- ([#"../checked_ops.rs" 122 14 122 36] OverflowingDiv0.overflowing_div ([#"../checked_ops.rs" 122 14 122 17] (5 : uint8)) ([#"../checked_ops.rs" 122 34 122 35] (2 : uint8)));
    goto BB15
  }
  BB15 {
    switch ([#"../checked_ops.rs" 123 12 123 22] (let (a, _) = res in a) = ([#"../checked_ops.rs" 123 21 123 22] (2 : uint8)))
      | False -> goto BB16
      | True -> goto BB17
      end
  }
  BB16 {
    assume { Resolve0.resolve res };
    _26 <- ([#"../checked_ops.rs" 123 12 123 40] false);
    goto BB18
  }
  BB17 {
    assume { Resolve0.resolve res };
    _26 <- ([#"../checked_ops.rs" 123 26 123 40] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 123 35 123 40] false));
    goto BB18
  }
  BB18 {
    switch (not _26)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8DivNoOverflow_Interface
  use prelude.UInt8
  use prelude.Int
  val test_u8_div_no_overflow [#"../checked_ops.rs" 128 0 128 44] (a : uint8) (b : uint8) : ()
    requires {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b <> 0}
    
end
module CheckedOps_TestU8DivNoOverflow
  use prelude.Int
  use prelude.UInt8
  use prelude.Bool
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = uint8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = uint8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Num_Impl6_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl6_OverflowingDiv_Interface as OverflowingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl6_SaturatingDiv_Interface as SaturatingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl6_WrappingDiv_Interface as WrappingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl6_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_u8_div_no_overflow [#"../checked_ops.rs" 128 0 128 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    requires {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : uint8;
  var _8 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _14 : bool;
  var _19 : uint8;
  var _24 : uint8;
  var _25 : bool;
  var _30 : uint8;
  var _35 : uint8;
  var _36 : bool;
  var res : (uint8, bool);
  var _43 : bool;
  var _48 : uint8;
  var _49 : bool;
  {
    goto BB0
  }
  BB0 {
    _8 <- ([#"../checked_ops.rs" 129 12 129 28] CheckedDiv0.checked_div a b);
    goto BB1
  }
  BB1 {
    _7 <- ([#"../checked_ops.rs" 129 12 129 37] Unwrap0.unwrap _8);
    _8 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    _13 <- b;
    _14 <- ([#"../checked_ops.rs" 129 41 129 46] _13 = ([#"../checked_ops.rs" 129 41 129 46] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 129 41 129 46] not _14 };
    goto BB3
  }
  BB3 {
    switch (not ([#"../checked_ops.rs" 129 12 129 46] _7 = ([#"../checked_ops.rs" 129 41 129 46] a / _13)))
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    absurd
  }
  BB5 {
    _19 <- ([#"../checked_ops.rs" 130 12 130 29] WrappingDiv0.wrapping_div a b);
    goto BB6
  }
  BB6 {
    _24 <- b;
    _25 <- ([#"../checked_ops.rs" 130 33 130 38] _24 = ([#"../checked_ops.rs" 130 33 130 38] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 130 33 130 38] not _25 };
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 130 12 130 38] _19 = ([#"../checked_ops.rs" 130 33 130 38] a / _24)))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _30 <- ([#"../checked_ops.rs" 131 12 131 31] SaturatingDiv0.saturating_div a b);
    goto BB10
  }
  BB10 {
    _35 <- b;
    _36 <- ([#"../checked_ops.rs" 131 35 131 40] _35 = ([#"../checked_ops.rs" 131 35 131 40] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 131 35 131 40] not _36 };
    goto BB11
  }
  BB11 {
    switch (not ([#"../checked_ops.rs" 131 12 131 40] _30 = ([#"../checked_ops.rs" 131 35 131 40] a / _35)))
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB12 {
    absurd
  }
  BB13 {
    res <- ([#"../checked_ops.rs" 132 14 132 34] OverflowingDiv0.overflowing_div a b);
    goto BB14
  }
  BB14 {
    _48 <- b;
    _49 <- ([#"../checked_ops.rs" 133 21 133 26] _48 = ([#"../checked_ops.rs" 133 21 133 26] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 133 21 133 26] not _49 };
    goto BB18
  }
  BB15 {
    assume { Resolve0.resolve res };
    _43 <- ([#"../checked_ops.rs" 133 12 133 44] false);
    goto BB17
  }
  BB16 {
    assume { Resolve0.resolve res };
    _43 <- ([#"../checked_ops.rs" 133 30 133 44] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 133 39 133 44] false));
    goto BB17
  }
  BB17 {
    switch (not _43)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB18 {
    switch ([#"../checked_ops.rs" 133 12 133 26] (let (a, _) = res in a) = ([#"../checked_ops.rs" 133 21 133 26] a / _48))
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8DivZero_Interface
  use prelude.Int
  use prelude.UInt8
  val test_u8_div_zero [#"../checked_ops.rs" 137 0 137 30] (a : uint8) : ()
end
module CheckedOps_TestU8DivZero
  use prelude.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option uint8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option uint8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl6_Min as Min0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl6_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_u8_div_zero [#"../checked_ops.rs" 137 0 137 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _4 : bool;
  var _6 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../checked_ops.rs" 138 12 138 28] CheckedDiv0.checked_div a ([#"../checked_ops.rs" 138 26 138 27] (0 : uint8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 138 12 138 38] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    switch (not _4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl0_Min_Stub
  use prelude.Int
  use prelude.Int8
  val constant mIN'  : int8
end
module Core_Num_Impl0_Min
  use prelude.Int
  use prelude.Int8
  let constant mIN'  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
end
module Core_Num_Impl0_Max_Stub
  use prelude.Int
  use prelude.Int8
  val constant mAX'  : int8
end
module Core_Num_Impl0_Max
  use prelude.Int
  use prelude.Int8
  let constant mAX'  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
end
module Core_Num_Impl0_CheckedAdd_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
end
module Core_Num_Impl0_Bits_Stub
  use prelude.Int
  use prelude.UInt32
  val constant bITS'  : uint32
end
module Core_Num_Impl0_Bits
  use prelude.Int
  use prelude.UInt32
  let constant bITS'  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
end
module Core_Num_Impl0_WrappingAdd_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val wrapping_add (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl0_SaturatingAdd_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  val saturating_add (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self + Int8.to_int rhs < Int8.to_int Min0.mIN' -> Int8.to_int result = Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self + Int8.to_int rhs > Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int Max0.mAX' }
    
end
module Core_Num_Impl0_OverflowingAdd_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val overflowing_add (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int Max0.mAX') }
    
end
module CheckedOps_TestI8AddExample_Interface
  val test_i8_add_example [#"../checked_ops.rs" 142 0 142 28] (_1 : ()) : ()
end
module CheckedOps_TestI8AddExample
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingAdd_Interface as SaturatingAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv2.inv
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl0_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_add_example [#"../checked_ops.rs" 142 0 142 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 143 12 143 31] CheckedAdd0.checked_add ([#"../checked_ops.rs" 143 12 143 15] (5 : int8)) ([#"../checked_ops.rs" 143 28 143 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 143 12 143 40] Unwrap0.unwrap _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 143 12 143 46] _4 = ([#"../checked_ops.rs" 143 44 143 46] (15 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 144 12 144 33] CheckedAdd0.checked_add ([#"../checked_ops.rs" 144 12 144 17] (120 : int8)) ([#"../checked_ops.rs" 144 30 144 32] (10 : int8)));
    goto BB5
  }
  BB5 {
    _9 <- ([#"../checked_ops.rs" 144 12 144 43] IsNone0.is_none _11);
    goto BB6
  }
  BB6 {
    switch (not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 145 12 145 37] CheckedAdd0.checked_add ([#"../checked_ops.rs" 145 12 145 20] (-120 : int8)) ([#"../checked_ops.rs" 145 33 145 36] (-10 : int8)));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 145 12 145 47] IsNone0.is_none _17);
    goto BB10
  }
  BB10 {
    switch (not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _22 <- ([#"../checked_ops.rs" 147 12 147 32] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 147 12 147 15] (5 : int8)) ([#"../checked_ops.rs" 147 29 147 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch (not ([#"../checked_ops.rs" 147 12 147 38] _22 = ([#"../checked_ops.rs" 147 36 147 38] (15 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _27 <- ([#"../checked_ops.rs" 148 12 148 34] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 148 12 148 17] (120 : int8)) ([#"../checked_ops.rs" 148 31 148 33] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch (not ([#"../checked_ops.rs" 148 12 148 42] _27 = ([#"../checked_ops.rs" 148 38 148 42] (-126 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _32 <- ([#"../checked_ops.rs" 149 12 149 38] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 149 12 149 20] (-120 : int8)) ([#"../checked_ops.rs" 149 34 149 37] (-10 : int8)));
    goto BB19
  }
  BB19 {
    switch (not ([#"../checked_ops.rs" 149 12 149 45] _32 = ([#"../checked_ops.rs" 149 42 149 45] (126 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _37 <- ([#"../checked_ops.rs" 151 12 151 34] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 151 12 151 15] (5 : int8)) ([#"../checked_ops.rs" 151 31 151 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch (not ([#"../checked_ops.rs" 151 12 151 40] _37 = ([#"../checked_ops.rs" 151 38 151 40] (15 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _42 <- ([#"../checked_ops.rs" 152 12 152 36] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 152 12 152 17] (120 : int8)) ([#"../checked_ops.rs" 152 33 152 35] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch (not ([#"../checked_ops.rs" 152 12 152 43] _42 = ([#"../checked_ops.rs" 152 40 152 43] (127 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _47 <- ([#"../checked_ops.rs" 153 12 153 40] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 153 12 153 20] (-120 : int8)) ([#"../checked_ops.rs" 153 36 153 39] (-10 : int8)));
    goto BB28
  }
  BB28 {
    switch (not ([#"../checked_ops.rs" 153 12 153 48] _47 = ([#"../checked_ops.rs" 153 44 153 48] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    res <- ([#"../checked_ops.rs" 155 14 155 37] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 155 14 155 17] (5 : int8)) ([#"../checked_ops.rs" 155 34 155 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 156 12 156 23] (let (a, _) = res in a) = ([#"../checked_ops.rs" 156 21 156 23] (15 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 156 12 156 41] false);
    goto BB34
  }
  BB33 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 156 27 156 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 156 36 156 41] false));
    goto BB34
  }
  BB34 {
    switch (not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    res1 <- ([#"../checked_ops.rs" 157 14 157 39] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 157 14 157 19] (120 : int8)) ([#"../checked_ops.rs" 157 36 157 38] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 158 12 158 25] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 158 21 158 25] (-126 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 158 12 158 42] false);
    goto BB40
  }
  BB39 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 158 29 158 42] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 158 38 158 42] true));
    goto BB40
  }
  BB40 {
    switch (not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    res2 <- ([#"../checked_ops.rs" 159 14 159 43] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 159 14 159 22] (-120 : int8)) ([#"../checked_ops.rs" 159 39 159 42] (-10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 160 12 160 24] (let (a, _) = res2 in a) = ([#"../checked_ops.rs" 160 21 160 24] (126 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 160 12 160 41] false);
    goto BB46
  }
  BB45 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 160 28 160 41] Bool.eqb (let (_, a) = res2 in a) ([#"../checked_ops.rs" 160 37 160 41] true));
    goto BB46
  }
  BB46 {
    switch (not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowPos_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_add_overflow_pos [#"../checked_ops.rs" 165 0 165 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a > 0}
    
end
module CheckedOps_TestI8AddOverflowPos
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingAdd_Interface as SaturatingAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_add_overflow_pos [#"../checked_ops.rs" 165 0 165 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 166 12 166 32] CheckedAdd0.checked_add ([#"../checked_ops.rs" 166 12 166 17] (127 : int8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 166 12 166 42] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 167 12 167 33] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 167 12 167 17] (127 : int8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 167 12 167 48] _13 = ([#"../checked_ops.rs" 167 37 167 48] ([#"../checked_ops.rs" 167 37 167 44] a - ([#"../checked_ops.rs" 167 41 167 44] (127 : int8))) - ([#"../checked_ops.rs" 167 47 167 48] (2 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _22 <- ([#"../checked_ops.rs" 168 12 168 35] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 168 12 168 17] (127 : int8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 168 12 168 42] _22 = ([#"../checked_ops.rs" 168 39 168 42] (127 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 169 14 169 38] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 169 14 169 19] (127 : int8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 170 12 170 32] (let (a, _) = res in a) = ([#"../checked_ops.rs" 170 21 170 32] ([#"../checked_ops.rs" 170 21 170 28] a - ([#"../checked_ops.rs" 170 25 170 28] (127 : int8))) - ([#"../checked_ops.rs" 170 31 170 32] (2 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 170 12 170 49] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 170 36 170 49] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 170 45 170 49] true));
    goto BB14
  }
  BB14 {
    switch (not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowNeg_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_add_overflow_neg [#"../checked_ops.rs" 175 0 175 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a < 0}
    
end
module CheckedOps_TestI8AddOverflowNeg
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingAdd_Interface as SaturatingAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_add_overflow_neg [#"../checked_ops.rs" 175 0 175 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 176 12 176 35] CheckedAdd0.checked_add ([#"../checked_ops.rs" 176 12 176 20] (-128 : int8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 176 12 176 45] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 177 12 177 36] WrappingAdd0.wrapping_add ([#"../checked_ops.rs" 177 12 177 20] (-128 : int8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 177 12 177 51] _13 = ([#"../checked_ops.rs" 177 40 177 51] ([#"../checked_ops.rs" 177 40 177 47] a + ([#"../checked_ops.rs" 177 44 177 47] (127 : int8))) + ([#"../checked_ops.rs" 177 50 177 51] (1 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _22 <- ([#"../checked_ops.rs" 178 12 178 38] SaturatingAdd0.saturating_add ([#"../checked_ops.rs" 178 12 178 20] (-128 : int8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 178 12 178 46] _22 = ([#"../checked_ops.rs" 178 42 178 46] (-128 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 179 14 179 41] OverflowingAdd0.overflowing_add ([#"../checked_ops.rs" 179 14 179 22] (-128 : int8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 180 12 180 32] (let (a, _) = res in a) = ([#"../checked_ops.rs" 180 21 180 32] ([#"../checked_ops.rs" 180 21 180 28] a + ([#"../checked_ops.rs" 180 25 180 28] (127 : int8))) + ([#"../checked_ops.rs" 180 31 180 32] (1 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 180 12 180 49] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 180 36 180 49] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 180 45 180 49] true));
    goto BB14
  }
  BB14 {
    switch (not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8WrappingAdd_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_wrapping_add [#"../checked_ops.rs" 186 0 186 47] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result = Int8.to_int a + Int8.to_int b \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256 \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256 }
    
end
module CheckedOps_TestI8WrappingAdd
  use prelude.Int
  use prelude.Int8
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_wrapping_add [#"../checked_ops.rs" 186 0 186 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result = Int8.to_int a + Int8.to_int b \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256 \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a : int8 = a;
  var b : int8 = b;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../checked_ops.rs" 187 4 187 21] WrappingAdd0.wrapping_add a b);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingAdd_Interface
  use prelude.Int
  use prelude.Int8
  val test_i8_overflowing_add [#"../checked_ops.rs" 191 0 191 44] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingAdd
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedAdd_Interface as CheckedAdd0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingAdd_Interface as OverflowingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_overflowing_add [#"../checked_ops.rs" 191 0 191 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 192 12 192 32] OverflowingAdd0.overflowing_add a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 192 38 192 55] WrappingAdd0.wrapping_add a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 192 12 192 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 193 12 193 32] OverflowingAdd0.overflowing_add a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 193 38 193 54] CheckedAdd0.checked_add a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 193 38 193 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 193 12 193 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl0_CheckedSub_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
end
module Core_Num_Impl0_WrappingSub_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val wrapping_sub (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl0_SaturatingSub_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  val saturating_sub (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self - Int8.to_int rhs < Int8.to_int Min0.mIN' -> Int8.to_int result = Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self - Int8.to_int rhs > Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int Max0.mAX' }
    
end
module Core_Num_Impl0_OverflowingSub_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val overflowing_sub (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int Max0.mAX') }
    
end
module CheckedOps_TestI8SubExample_Interface
  val test_i8_sub_example [#"../checked_ops.rs" 197 0 197 28] (_1 : ()) : ()
end
module CheckedOps_TestI8SubExample
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingSub_Interface as SaturatingSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv2.inv
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl0_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_sub_example [#"../checked_ops.rs" 197 0 197 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 198 12 198 31] CheckedSub0.checked_sub ([#"../checked_ops.rs" 198 12 198 15] (5 : int8)) ([#"../checked_ops.rs" 198 28 198 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 198 12 198 40] Unwrap0.unwrap _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 198 12 198 46] _4 = ([#"../checked_ops.rs" 198 44 198 46] (-5 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 199 12 199 33] CheckedSub0.checked_sub ([#"../checked_ops.rs" 199 12 199 17] (120 : int8)) ([#"../checked_ops.rs" 199 30 199 32] (10 : int8)));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 199 12 199 42] Unwrap0.unwrap _11);
    _11 <- any Core_Option_Option_Type.t_option int8;
    goto BB6
  }
  BB6 {
    switch (not ([#"../checked_ops.rs" 199 12 199 49] _10 = ([#"../checked_ops.rs" 199 46 199 49] (110 : int8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 200 12 200 36] CheckedSub0.checked_sub ([#"../checked_ops.rs" 200 12 200 20] (-120 : int8)) ([#"../checked_ops.rs" 200 33 200 35] (10 : int8)));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 200 12 200 46] IsNone0.is_none _17);
    goto BB10
  }
  BB10 {
    switch (not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _22 <- ([#"../checked_ops.rs" 202 12 202 32] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 202 12 202 15] (5 : int8)) ([#"../checked_ops.rs" 202 29 202 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch (not ([#"../checked_ops.rs" 202 12 202 38] _22 = ([#"../checked_ops.rs" 202 36 202 38] (-5 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _27 <- ([#"../checked_ops.rs" 203 12 203 34] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 203 12 203 17] (120 : int8)) ([#"../checked_ops.rs" 203 31 203 33] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch (not ([#"../checked_ops.rs" 203 12 203 41] _27 = ([#"../checked_ops.rs" 203 38 203 41] (110 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _32 <- ([#"../checked_ops.rs" 204 12 204 37] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 204 12 204 20] (-120 : int8)) ([#"../checked_ops.rs" 204 34 204 36] (10 : int8)));
    goto BB19
  }
  BB19 {
    switch (not ([#"../checked_ops.rs" 204 12 204 44] _32 = ([#"../checked_ops.rs" 204 41 204 44] (126 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _37 <- ([#"../checked_ops.rs" 206 12 206 34] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 206 12 206 15] (5 : int8)) ([#"../checked_ops.rs" 206 31 206 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch (not ([#"../checked_ops.rs" 206 12 206 40] _37 = ([#"../checked_ops.rs" 206 38 206 40] (-5 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _42 <- ([#"../checked_ops.rs" 207 12 207 36] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 207 12 207 17] (120 : int8)) ([#"../checked_ops.rs" 207 33 207 35] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch (not ([#"../checked_ops.rs" 207 12 207 43] _42 = ([#"../checked_ops.rs" 207 40 207 43] (110 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _47 <- ([#"../checked_ops.rs" 208 12 208 39] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 208 12 208 20] (-120 : int8)) ([#"../checked_ops.rs" 208 36 208 38] (10 : int8)));
    goto BB28
  }
  BB28 {
    switch (not ([#"../checked_ops.rs" 208 12 208 47] _47 = ([#"../checked_ops.rs" 208 43 208 47] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    res <- ([#"../checked_ops.rs" 210 14 210 37] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 210 14 210 17] (5 : int8)) ([#"../checked_ops.rs" 210 34 210 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 211 12 211 23] (let (a, _) = res in a) = ([#"../checked_ops.rs" 211 21 211 23] (-5 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 211 12 211 41] false);
    goto BB34
  }
  BB33 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 211 27 211 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 211 36 211 41] false));
    goto BB34
  }
  BB34 {
    switch (not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    res1 <- ([#"../checked_ops.rs" 212 14 212 39] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 212 14 212 19] (120 : int8)) ([#"../checked_ops.rs" 212 36 212 38] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 213 12 213 24] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 213 21 213 24] (110 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 213 12 213 42] false);
    goto BB40
  }
  BB39 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 213 28 213 42] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 213 37 213 42] false));
    goto BB40
  }
  BB40 {
    switch (not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    res2 <- ([#"../checked_ops.rs" 214 14 214 42] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 214 14 214 22] (-120 : int8)) ([#"../checked_ops.rs" 214 39 214 41] (10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 215 12 215 24] (let (a, _) = res2 in a) = ([#"../checked_ops.rs" 215 21 215 24] (126 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 215 12 215 41] false);
    goto BB46
  }
  BB45 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 215 28 215 41] Bool.eqb (let (_, a) = res2 in a) ([#"../checked_ops.rs" 215 37 215 41] true));
    goto BB46
  }
  BB46 {
    switch (not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowPos_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_sub_overflow_pos [#"../checked_ops.rs" 220 0 220 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a > 0}
    
end
module CheckedOps_TestI8SubOverflowPos
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingSub_Interface as SaturatingSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_sub_overflow_pos [#"../checked_ops.rs" 220 0 220 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 221 12 221 35] CheckedSub0.checked_sub ([#"../checked_ops.rs" 221 12 221 20] (-128 : int8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 221 12 221 45] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 222 12 222 36] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 222 12 222 20] (-128 : int8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 222 12 222 51] _13 = ([#"../checked_ops.rs" 222 40 222 51] ([#"../checked_ops.rs" 222 40 222 47] ([#"../checked_ops.rs" 222 40 222 43] (127 : int8)) - a) + ([#"../checked_ops.rs" 222 50 222 51] (1 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _22 <- ([#"../checked_ops.rs" 223 12 223 38] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 223 12 223 20] (-128 : int8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 223 12 223 46] _22 = ([#"../checked_ops.rs" 223 42 223 46] (-128 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 224 14 224 41] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 224 14 224 22] (-128 : int8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 225 12 225 32] (let (a, _) = res in a) = ([#"../checked_ops.rs" 225 21 225 32] ([#"../checked_ops.rs" 225 21 225 28] ([#"../checked_ops.rs" 225 21 225 24] (127 : int8)) - a) + ([#"../checked_ops.rs" 225 31 225 32] (1 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 225 12 225 49] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _29 <- ([#"../checked_ops.rs" 225 36 225 49] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 225 45 225 49] true));
    goto BB14
  }
  BB14 {
    switch (not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowNeg_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_sub_overflow_neg [#"../checked_ops.rs" 230 0 230 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a < 0}
    
end
module CheckedOps_TestI8SubOverflowNeg
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingSub_Interface as SaturatingSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_sub_overflow_neg [#"../checked_ops.rs" 230 0 230 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _23 : int8;
  var res : (int8, bool);
  var _30 : bool;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 231 12 231 32] CheckedSub0.checked_sub ([#"../checked_ops.rs" 231 12 231 17] (127 : int8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 231 12 231 42] IsNone0.is_none _7);
    goto BB2
  }
  BB2 {
    switch (not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _13 <- ([#"../checked_ops.rs" 232 12 232 33] WrappingSub0.wrapping_sub ([#"../checked_ops.rs" 232 12 232 17] (127 : int8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 232 12 232 51] _13 = ([#"../checked_ops.rs" 232 37 232 51] - ([#"../checked_ops.rs" 232 38 232 45] ([#"../checked_ops.rs" 232 39 232 40] (2 : int8)) + a) - ([#"../checked_ops.rs" 232 48 232 51] (127 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _23 <- ([#"../checked_ops.rs" 233 12 233 35] SaturatingSub0.saturating_sub ([#"../checked_ops.rs" 233 12 233 17] (127 : int8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 233 12 233 42] _23 = ([#"../checked_ops.rs" 233 39 233 42] (127 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 234 14 234 38] OverflowingSub0.overflowing_sub ([#"../checked_ops.rs" 234 14 234 19] (127 : int8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 235 12 235 35] (let (a, _) = res in a) = ([#"../checked_ops.rs" 235 21 235 35] - ([#"../checked_ops.rs" 235 22 235 29] ([#"../checked_ops.rs" 235 23 235 24] (2 : int8)) + a) - ([#"../checked_ops.rs" 235 32 235 35] (127 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _30 <- ([#"../checked_ops.rs" 235 12 235 52] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _30 <- ([#"../checked_ops.rs" 235 39 235 52] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 235 48 235 52] true));
    goto BB14
  }
  BB14 {
    switch (not _30)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8WrappingSub_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_wrapping_sub [#"../checked_ops.rs" 241 0 241 47] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result = Int8.to_int a - Int8.to_int b \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256 \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256 }
    
end
module CheckedOps_TestI8WrappingSub
  use prelude.Int
  use prelude.Int8
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_wrapping_sub [#"../checked_ops.rs" 241 0 241 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result = Int8.to_int a - Int8.to_int b \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256 \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a : int8 = a;
  var b : int8 = b;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../checked_ops.rs" 242 4 242 21] WrappingSub0.wrapping_sub a b);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingSub_Interface
  use prelude.Int
  use prelude.Int8
  val test_i8_overflowing_sub [#"../checked_ops.rs" 246 0 246 44] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingSub
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedSub_Interface as CheckedSub0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingSub_Interface as WrappingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingSub_Interface as OverflowingSub0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_overflowing_sub [#"../checked_ops.rs" 246 0 246 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 247 12 247 32] OverflowingSub0.overflowing_sub a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 247 38 247 55] WrappingSub0.wrapping_sub a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 247 12 247 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 248 12 248 32] OverflowingSub0.overflowing_sub a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 248 38 248 54] CheckedSub0.checked_sub a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 248 38 248 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 248 12 248 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl0_CheckedMul_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int Max0.mAX') }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
end
module Core_Num_Impl0_WrappingMul_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val wrapping_mul (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl0_SaturatingMul_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  val saturating_mul (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self * Int8.to_int rhs < Int8.to_int Min0.mIN' -> Int8.to_int result = Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self * Int8.to_int rhs > Int8.to_int Max0.mAX' -> Int8.to_int result = Int8.to_int Max0.mAX' }
    
end
module Core_Num_Impl0_OverflowingMul_Interface
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl0_Max_Stub as Max0
  clone Core_Num_Impl0_Min_Stub as Min0
  clone Core_Num_Impl0_Bits_Stub as Bits0
  val overflowing_mul (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int Min0.mIN' /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int Max0.mAX' -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int Min0.mIN' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int Max0.mAX' -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int Max0.mAX' - Int8.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int Min0.mIN' \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int Max0.mAX') }
    
end
module CheckedOps_TestI8MulExample_Interface
  val test_i8_mul_example [#"../checked_ops.rs" 252 0 252 28] (_1 : ()) : ()
end
module CheckedOps_TestI8MulExample
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingMul_Interface as SaturatingMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv2.inv
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl0_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_mul_example [#"../checked_ops.rs" 252 0 252 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 253 12 253 31] CheckedMul0.checked_mul ([#"../checked_ops.rs" 253 12 253 15] (5 : int8)) ([#"../checked_ops.rs" 253 28 253 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 253 12 253 40] Unwrap0.unwrap _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 253 12 253 46] _4 = ([#"../checked_ops.rs" 253 44 253 46] (50 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 254 12 254 32] CheckedMul0.checked_mul ([#"../checked_ops.rs" 254 12 254 16] (50 : int8)) ([#"../checked_ops.rs" 254 29 254 31] (10 : int8)));
    goto BB5
  }
  BB5 {
    _9 <- ([#"../checked_ops.rs" 254 12 254 42] IsNone0.is_none _11);
    goto BB6
  }
  BB6 {
    switch (not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 255 12 255 33] CheckedMul0.checked_mul ([#"../checked_ops.rs" 255 12 255 16] (50 : int8)) ([#"../checked_ops.rs" 255 29 255 32] (-10 : int8)));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 255 12 255 43] IsNone0.is_none _17);
    goto BB10
  }
  BB10 {
    switch (not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _22 <- ([#"../checked_ops.rs" 257 12 257 32] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 257 12 257 15] (5 : int8)) ([#"../checked_ops.rs" 257 29 257 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch (not ([#"../checked_ops.rs" 257 12 257 38] _22 = ([#"../checked_ops.rs" 257 36 257 38] (50 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _27 <- ([#"../checked_ops.rs" 258 12 258 33] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 258 12 258 16] (50 : int8)) ([#"../checked_ops.rs" 258 30 258 32] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch (not ([#"../checked_ops.rs" 258 12 258 40] _27 = ([#"../checked_ops.rs" 258 37 258 40] (-12 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _32 <- ([#"../checked_ops.rs" 259 12 259 34] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 259 12 259 16] (50 : int8)) ([#"../checked_ops.rs" 259 30 259 33] (-10 : int8)));
    goto BB19
  }
  BB19 {
    switch (not ([#"../checked_ops.rs" 259 12 259 40] _32 = ([#"../checked_ops.rs" 259 38 259 40] (12 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _37 <- ([#"../checked_ops.rs" 261 12 261 34] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 261 12 261 15] (5 : int8)) ([#"../checked_ops.rs" 261 31 261 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch (not ([#"../checked_ops.rs" 261 12 261 40] _37 = ([#"../checked_ops.rs" 261 38 261 40] (50 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _42 <- ([#"../checked_ops.rs" 262 12 262 35] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 262 12 262 16] (50 : int8)) ([#"../checked_ops.rs" 262 32 262 34] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch (not ([#"../checked_ops.rs" 262 12 262 42] _42 = ([#"../checked_ops.rs" 262 39 262 42] (127 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _47 <- ([#"../checked_ops.rs" 263 12 263 36] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 263 12 263 16] (50 : int8)) ([#"../checked_ops.rs" 263 32 263 35] (-10 : int8)));
    goto BB28
  }
  BB28 {
    switch (not ([#"../checked_ops.rs" 263 12 263 44] _47 = ([#"../checked_ops.rs" 263 40 263 44] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    res <- ([#"../checked_ops.rs" 265 14 265 37] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 265 14 265 17] (5 : int8)) ([#"../checked_ops.rs" 265 34 265 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 266 12 266 23] (let (a, _) = res in a) = ([#"../checked_ops.rs" 266 21 266 23] (50 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 266 12 266 41] false);
    goto BB34
  }
  BB33 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 266 27 266 41] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 266 36 266 41] false));
    goto BB34
  }
  BB34 {
    switch (not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    res1 <- ([#"../checked_ops.rs" 267 14 267 38] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 267 14 267 18] (50 : int8)) ([#"../checked_ops.rs" 267 35 267 37] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 268 12 268 24] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 268 21 268 24] (-12 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 268 12 268 41] false);
    goto BB40
  }
  BB39 {
    assume { Resolve0.resolve res1 };
    _61 <- ([#"../checked_ops.rs" 268 28 268 41] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 268 37 268 41] true));
    goto BB40
  }
  BB40 {
    switch (not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    res2 <- ([#"../checked_ops.rs" 269 14 269 39] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 269 14 269 18] (50 : int8)) ([#"../checked_ops.rs" 269 35 269 38] (-10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 270 12 270 23] (let (a, _) = res2 in a) = ([#"../checked_ops.rs" 270 21 270 23] (12 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 270 12 270 40] false);
    goto BB46
  }
  BB45 {
    assume { Resolve0.resolve res2 };
    _70 <- ([#"../checked_ops.rs" 270 27 270 40] Bool.eqb (let (_, a) = res2 in a) ([#"../checked_ops.rs" 270 36 270 40] true));
    goto BB46
  }
  BB46 {
    switch (not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8MulZero_Interface
  use prelude.Int
  use prelude.Int8
  val test_i8_mul_zero [#"../checked_ops.rs" 274 0 274 30] (a : int8) : ()
end
module CheckedOps_TestI8MulZero
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_SaturatingMul_Interface as SaturatingMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl0_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_mul_zero [#"../checked_ops.rs" 274 0 274 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : int8;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _12 : int8;
  var _18 : int8;
  var res : (int8, bool);
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../checked_ops.rs" 275 12 275 30] CheckedMul0.checked_mul ([#"../checked_ops.rs" 275 12 275 15] (0 : int8)) a);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 275 12 275 39] Unwrap0.unwrap _6);
    _6 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 275 12 275 44] _5 = ([#"../checked_ops.rs" 275 43 275 44] (0 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _12 <- ([#"../checked_ops.rs" 276 12 276 31] WrappingMul0.wrapping_mul ([#"../checked_ops.rs" 276 12 276 15] (0 : int8)) a);
    goto BB5
  }
  BB5 {
    switch (not ([#"../checked_ops.rs" 276 12 276 36] _12 = ([#"../checked_ops.rs" 276 35 276 36] (0 : int8))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _18 <- ([#"../checked_ops.rs" 277 12 277 33] SaturatingMul0.saturating_mul ([#"../checked_ops.rs" 277 12 277 15] (0 : int8)) a);
    goto BB8
  }
  BB8 {
    switch (not ([#"../checked_ops.rs" 277 12 277 38] _18 = ([#"../checked_ops.rs" 277 37 277 38] (0 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    res <- ([#"../checked_ops.rs" 278 14 278 36] OverflowingMul0.overflowing_mul ([#"../checked_ops.rs" 278 14 278 17] (0 : int8)) a);
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 279 12 279 22] (let (a, _) = res in a) = ([#"../checked_ops.rs" 279 21 279 22] (0 : int8)))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res };
    _25 <- ([#"../checked_ops.rs" 279 12 279 40] false);
    goto BB14
  }
  BB13 {
    assume { Resolve0.resolve res };
    _25 <- ([#"../checked_ops.rs" 279 26 279 40] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 279 35 279 40] false));
    goto BB14
  }
  BB14 {
    switch (not _25)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingMul_Interface
  use prelude.Int
  use prelude.Int8
  val test_i8_overflowing_mul [#"../checked_ops.rs" 283 0 283 44] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingMul
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Max as Max0
  clone Core_Num_Impl0_Min as Min0
  clone Core_Num_Impl0_Bits as Bits0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedMul_Interface as CheckedMul0 with
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl0_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingMul_Interface as OverflowingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_i8_overflowing_mul [#"../checked_ops.rs" 283 0 283 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    _7 <- ([#"../checked_ops.rs" 284 12 284 32] OverflowingMul0.overflowing_mul a b);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    _10 <- ([#"../checked_ops.rs" 284 38 284 55] WrappingMul0.wrapping_mul a b);
    goto BB2
  }
  BB2 {
    switch (not ([#"../checked_ops.rs" 284 12 284 55] (let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _18 <- ([#"../checked_ops.rs" 285 12 285 32] OverflowingMul0.overflowing_mul a b);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve _18 };
    _23 <- ([#"../checked_ops.rs" 285 38 285 54] CheckedMul0.checked_mul a b);
    goto BB6
  }
  BB6 {
    _21 <- ([#"../checked_ops.rs" 285 38 285 64] IsNone0.is_none _23);
    goto BB7
  }
  BB7 {
    switch (not ([#"../checked_ops.rs" 285 12 285 64] Bool.eqb (let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl0_CheckedDiv_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Min_Stub as Min0
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl0_WrappingDiv_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Min_Stub as Min0
  val wrapping_div (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl0_SaturatingDiv_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Min_Stub as Min0
  val saturating_div (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl0_OverflowingDiv_Interface
  use prelude.Int8
  use prelude.Int
  clone Core_Num_Impl0_Min_Stub as Min0
  val overflowing_div (self : int8) (rhs : int8) : (int8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1 \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (Int8.to_int self = Int8.to_int Min0.mIN' /\ Int8.to_int rhs = - 1) }
    
end
module CheckedOps_TestI8DivExample_Interface
  val test_i8_div_example [#"../checked_ops.rs" 289 0 289 28] (_1 : ()) : ()
end
module CheckedOps_TestI8DivExample
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = int8,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingDiv_Interface as OverflowingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl0_SaturatingDiv_Interface as SaturatingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl0_WrappingDiv_Interface as WrappingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_i8_div_example [#"../checked_ops.rs" 289 0 289 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _16 : int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _28 : int8;
  var _33 : int8;
  var _38 : int8;
  var _43 : int8;
  var _48 : int8;
  var _53 : int8;
  var res : (int8, bool);
  var _58 : bool;
  var res1 : (int8, bool);
  var _67 : bool;
  var res2 : (int8, bool);
  var _76 : bool;
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 290 12 290 30] CheckedDiv0.checked_div ([#"../checked_ops.rs" 290 12 290 15] (5 : int8)) ([#"../checked_ops.rs" 290 28 290 29] (0 : int8)));
    goto BB1
  }
  BB1 {
    _3 <- ([#"../checked_ops.rs" 290 12 290 40] IsNone0.is_none _5);
    goto BB2
  }
  BB2 {
    switch (not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 291 12 291 30] CheckedDiv0.checked_div ([#"../checked_ops.rs" 291 12 291 15] (5 : int8)) ([#"../checked_ops.rs" 291 28 291 29] (2 : int8)));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 291 12 291 39] Unwrap0.unwrap _11);
    _11 <- any Core_Option_Option_Type.t_option int8;
    goto BB6
  }
  BB6 {
    switch (not ([#"../checked_ops.rs" 291 12 291 44] _10 = ([#"../checked_ops.rs" 291 43 291 44] (2 : int8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 292 12 292 31] CheckedDiv0.checked_div ([#"../checked_ops.rs" 292 12 292 15] (5 : int8)) ([#"../checked_ops.rs" 292 28 292 30] (-2 : int8)));
    goto BB9
  }
  BB9 {
    _16 <- ([#"../checked_ops.rs" 292 12 292 40] Unwrap0.unwrap _17);
    _17 <- any Core_Option_Option_Type.t_option int8;
    goto BB10
  }
  BB10 {
    switch (not ([#"../checked_ops.rs" 292 12 292 46] _16 = ([#"../checked_ops.rs" 292 44 292 46] (-2 : int8))))
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _23 <- ([#"../checked_ops.rs" 293 12 293 36] CheckedDiv0.checked_div ([#"../checked_ops.rs" 293 12 293 20] (-128 : int8)) ([#"../checked_ops.rs" 293 33 293 35] (-1 : int8)));
    goto BB13
  }
  BB13 {
    _21 <- ([#"../checked_ops.rs" 293 12 293 46] IsNone0.is_none _23);
    goto BB14
  }
  BB14 {
    switch (not _21)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _28 <- ([#"../checked_ops.rs" 295 12 295 31] WrappingDiv0.wrapping_div ([#"../checked_ops.rs" 295 12 295 15] (5 : int8)) ([#"../checked_ops.rs" 295 29 295 30] (2 : int8)));
    goto BB17
  }
  BB17 {
    switch (not ([#"../checked_ops.rs" 295 12 295 36] _28 = ([#"../checked_ops.rs" 295 35 295 36] (2 : int8))))
      | False -> goto BB19
      | True -> goto BB18
      end
  }
  BB18 {
    absurd
  }
  BB19 {
    _33 <- ([#"../checked_ops.rs" 296 12 296 32] WrappingDiv0.wrapping_div ([#"../checked_ops.rs" 296 12 296 15] (5 : int8)) ([#"../checked_ops.rs" 296 29 296 31] (-2 : int8)));
    goto BB20
  }
  BB20 {
    switch (not ([#"../checked_ops.rs" 296 12 296 38] _33 = ([#"../checked_ops.rs" 296 36 296 38] (-2 : int8))))
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    absurd
  }
  BB22 {
    _38 <- ([#"../checked_ops.rs" 297 12 297 37] WrappingDiv0.wrapping_div ([#"../checked_ops.rs" 297 12 297 20] (-128 : int8)) ([#"../checked_ops.rs" 297 34 297 36] (-1 : int8)));
    goto BB23
  }
  BB23 {
    switch (not ([#"../checked_ops.rs" 297 12 297 45] _38 = ([#"../checked_ops.rs" 297 41 297 45] (-128 : int8))))
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB24 {
    absurd
  }
  BB25 {
    _43 <- ([#"../checked_ops.rs" 299 12 299 33] SaturatingDiv0.saturating_div ([#"../checked_ops.rs" 299 12 299 15] (5 : int8)) ([#"../checked_ops.rs" 299 31 299 32] (2 : int8)));
    goto BB26
  }
  BB26 {
    switch (not ([#"../checked_ops.rs" 299 12 299 38] _43 = ([#"../checked_ops.rs" 299 37 299 38] (2 : int8))))
      | False -> goto BB28
      | True -> goto BB27
      end
  }
  BB27 {
    absurd
  }
  BB28 {
    _48 <- ([#"../checked_ops.rs" 300 12 300 34] SaturatingDiv0.saturating_div ([#"../checked_ops.rs" 300 12 300 15] (5 : int8)) ([#"../checked_ops.rs" 300 31 300 33] (-2 : int8)));
    goto BB29
  }
  BB29 {
    switch (not ([#"../checked_ops.rs" 300 12 300 40] _48 = ([#"../checked_ops.rs" 300 38 300 40] (-2 : int8))))
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    absurd
  }
  BB31 {
    _53 <- ([#"../checked_ops.rs" 301 12 301 39] SaturatingDiv0.saturating_div ([#"../checked_ops.rs" 301 12 301 20] (-128 : int8)) ([#"../checked_ops.rs" 301 36 301 38] (-1 : int8)));
    goto BB32
  }
  BB32 {
    switch (not ([#"../checked_ops.rs" 301 12 301 47] _53 = ([#"../checked_ops.rs" 301 43 301 47] (-128 : int8))))
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    absurd
  }
  BB34 {
    res <- ([#"../checked_ops.rs" 303 14 303 36] OverflowingDiv0.overflowing_div ([#"../checked_ops.rs" 303 14 303 17] (5 : int8)) ([#"../checked_ops.rs" 303 34 303 35] (2 : int8)));
    goto BB35
  }
  BB35 {
    switch ([#"../checked_ops.rs" 304 12 304 22] (let (a, _) = res in a) = ([#"../checked_ops.rs" 304 21 304 22] (2 : int8)))
      | False -> goto BB36
      | True -> goto BB37
      end
  }
  BB36 {
    assume { Resolve0.resolve res };
    _58 <- ([#"../checked_ops.rs" 304 12 304 40] false);
    goto BB38
  }
  BB37 {
    assume { Resolve0.resolve res };
    _58 <- ([#"../checked_ops.rs" 304 26 304 40] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 304 35 304 40] false));
    goto BB38
  }
  BB38 {
    switch (not _58)
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    absurd
  }
  BB40 {
    res1 <- ([#"../checked_ops.rs" 305 14 305 37] OverflowingDiv0.overflowing_div ([#"../checked_ops.rs" 305 14 305 17] (5 : int8)) ([#"../checked_ops.rs" 305 34 305 36] (-2 : int8)));
    goto BB41
  }
  BB41 {
    switch ([#"../checked_ops.rs" 306 12 306 23] (let (a, _) = res1 in a) = ([#"../checked_ops.rs" 306 21 306 23] (-2 : int8)))
      | False -> goto BB42
      | True -> goto BB43
      end
  }
  BB42 {
    assume { Resolve0.resolve res1 };
    _67 <- ([#"../checked_ops.rs" 306 12 306 41] false);
    goto BB44
  }
  BB43 {
    assume { Resolve0.resolve res1 };
    _67 <- ([#"../checked_ops.rs" 306 27 306 41] Bool.eqb (let (_, a) = res1 in a) ([#"../checked_ops.rs" 306 36 306 41] false));
    goto BB44
  }
  BB44 {
    switch (not _67)
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    absurd
  }
  BB46 {
    res2 <- ([#"../checked_ops.rs" 307 14 307 42] OverflowingDiv0.overflowing_div ([#"../checked_ops.rs" 307 14 307 22] (-128 : int8)) ([#"../checked_ops.rs" 307 39 307 41] (-1 : int8)));
    goto BB47
  }
  BB47 {
    switch ([#"../checked_ops.rs" 308 12 308 25] (let (a, _) = res2 in a) = ([#"../checked_ops.rs" 308 21 308 25] (-128 : int8)))
      | False -> goto BB48
      | True -> goto BB49
      end
  }
  BB48 {
    assume { Resolve0.resolve res2 };
    _76 <- ([#"../checked_ops.rs" 308 12 308 42] false);
    goto BB50
  }
  BB49 {
    assume { Resolve0.resolve res2 };
    _76 <- ([#"../checked_ops.rs" 308 29 308 42] Bool.eqb (let (_, a) = res2 in a) ([#"../checked_ops.rs" 308 38 308 42] true));
    goto BB50
  }
  BB50 {
    switch (not _76)
      | False -> goto BB52
      | True -> goto BB51
      end
  }
  BB51 {
    absurd
  }
  BB52 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8DivNoOverflow_Interface
  use prelude.Int8
  use prelude.Int
  val test_i8_div_no_overflow [#"../checked_ops.rs" 313 0 313 44] (a : int8) (b : int8) : ()
    requires {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    
end
module CheckedOps_TestI8DivNoOverflow
  use prelude.Int
  use prelude.Int8
  use prelude.Bool
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = int8
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = int8,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Num_Impl0_Min as Min0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl0_OverflowingDiv_Interface as OverflowingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl0_SaturatingDiv_Interface as SaturatingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Num_Impl0_WrappingDiv_Interface as WrappingDiv0 with
    val Min0.mIN' = Min0.mIN'
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone Core_Num_Impl0_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_i8_div_no_overflow [#"../checked_ops.rs" 313 0 313 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    requires {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : int8;
  var _8 : Core_Option_Option_Type.t_option int8;
  var _12 : int8;
  var _13 : int8;
  var _14 : bool;
  var _17 : bool;
  var _22 : int8;
  var _26 : int8;
  var _27 : int8;
  var _28 : bool;
  var _31 : bool;
  var _36 : int8;
  var _40 : int8;
  var _41 : int8;
  var _42 : bool;
  var _45 : bool;
  var res : (int8, bool);
  var _52 : bool;
  var _56 : int8;
  var _57 : int8;
  var _58 : bool;
  var _61 : bool;
  {
    goto BB0
  }
  BB0 {
    _8 <- ([#"../checked_ops.rs" 314 12 314 28] CheckedDiv0.checked_div a b);
    goto BB1
  }
  BB1 {
    _7 <- ([#"../checked_ops.rs" 314 12 314 37] Unwrap0.unwrap _8);
    _8 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    _12 <- a;
    _13 <- b;
    _14 <- ([#"../checked_ops.rs" 314 41 314 46] _13 = ([#"../checked_ops.rs" 314 41 314 46] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 314 41 314 46] not _14 };
    goto BB3
  }
  BB3 {
    _17 <- ([#"../checked_ops.rs" 314 41 314 46] ([#"../checked_ops.rs" 314 41 314 46] _13 = ([#"../checked_ops.rs" 314 41 314 46] (-1 : int8))) && ([#"../checked_ops.rs" 314 41 314 46] _12 = ([#"../checked_ops.rs" 314 41 314 46] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 314 41 314 46] not _17 };
    goto BB4
  }
  BB4 {
    switch (not ([#"../checked_ops.rs" 314 12 314 46] _7 = ([#"../checked_ops.rs" 314 41 314 46] _12 / _13)))
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB5 {
    absurd
  }
  BB6 {
    _22 <- ([#"../checked_ops.rs" 315 12 315 29] WrappingDiv0.wrapping_div a b);
    goto BB7
  }
  BB7 {
    _26 <- a;
    _27 <- b;
    _28 <- ([#"../checked_ops.rs" 315 33 315 38] _27 = ([#"../checked_ops.rs" 315 33 315 38] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 315 33 315 38] not _28 };
    goto BB8
  }
  BB8 {
    _31 <- ([#"../checked_ops.rs" 315 33 315 38] ([#"../checked_ops.rs" 315 33 315 38] _27 = ([#"../checked_ops.rs" 315 33 315 38] (-1 : int8))) && ([#"../checked_ops.rs" 315 33 315 38] _26 = ([#"../checked_ops.rs" 315 33 315 38] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 315 33 315 38] not _31 };
    goto BB9
  }
  BB9 {
    switch (not ([#"../checked_ops.rs" 315 12 315 38] _22 = ([#"../checked_ops.rs" 315 33 315 38] _26 / _27)))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _36 <- ([#"../checked_ops.rs" 316 12 316 31] SaturatingDiv0.saturating_div a b);
    goto BB12
  }
  BB12 {
    _40 <- a;
    _41 <- b;
    _42 <- ([#"../checked_ops.rs" 316 35 316 40] _41 = ([#"../checked_ops.rs" 316 35 316 40] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 316 35 316 40] not _42 };
    goto BB13
  }
  BB13 {
    _45 <- ([#"../checked_ops.rs" 316 35 316 40] ([#"../checked_ops.rs" 316 35 316 40] _41 = ([#"../checked_ops.rs" 316 35 316 40] (-1 : int8))) && ([#"../checked_ops.rs" 316 35 316 40] _40 = ([#"../checked_ops.rs" 316 35 316 40] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 316 35 316 40] not _45 };
    goto BB14
  }
  BB14 {
    switch (not ([#"../checked_ops.rs" 316 12 316 40] _36 = ([#"../checked_ops.rs" 316 35 316 40] _40 / _41)))
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    res <- ([#"../checked_ops.rs" 317 14 317 34] OverflowingDiv0.overflowing_div a b);
    goto BB17
  }
  BB17 {
    _56 <- a;
    _57 <- b;
    _58 <- ([#"../checked_ops.rs" 318 21 318 26] _57 = ([#"../checked_ops.rs" 318 21 318 26] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 318 21 318 26] not _58 };
    goto BB21
  }
  BB18 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 318 12 318 44] false);
    goto BB20
  }
  BB19 {
    assume { Resolve0.resolve res };
    _52 <- ([#"../checked_ops.rs" 318 30 318 44] Bool.eqb (let (_, a) = res in a) ([#"../checked_ops.rs" 318 39 318 44] false));
    goto BB20
  }
  BB20 {
    switch (not _52)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB21 {
    _61 <- ([#"../checked_ops.rs" 318 21 318 26] ([#"../checked_ops.rs" 318 21 318 26] _57 = ([#"../checked_ops.rs" 318 21 318 26] (-1 : int8))) && ([#"../checked_ops.rs" 318 21 318 26] _56 = ([#"../checked_ops.rs" 318 21 318 26] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 318 21 318 26] not _61 };
    goto BB22
  }
  BB22 {
    switch ([#"../checked_ops.rs" 318 12 318 26] (let (a, _) = res in a) = ([#"../checked_ops.rs" 318 21 318 26] _56 / _57))
      | False -> goto BB18
      | True -> goto BB19
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8DivZero_Interface
  use prelude.Int
  use prelude.Int8
  val test_i8_div_zero [#"../checked_ops.rs" 322 0 322 30] (a : int8) : ()
end
module CheckedOps_TestI8DivZero
  use prelude.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Core_Option_Option_Type.t_option int8
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Core_Option_Option_Type.t_option int8,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl0_Min as Min0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8,
    predicate Inv0.inv = Inv0.inv
  clone Core_Num_Impl0_CheckedDiv_Interface as CheckedDiv0 with
    val Min0.mIN' = Min0.mIN'
  let rec cfg test_i8_div_zero [#"../checked_ops.rs" 322 0 322 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _4 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../checked_ops.rs" 323 12 323 28] CheckedDiv0.checked_div a ([#"../checked_ops.rs" 323 26 323 27] (0 : int8)));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 323 12 323 38] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    switch (not _4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _0 <- ();
    return _0
  }
  
end
