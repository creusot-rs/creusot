
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module Core_Num_Impl7_CheckedAdd_Interface
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
end
module Core_Num_Impl7_CheckedAdd
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
end
module Core_Option_Impl0_Unwrap_Interface
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  val unwrap [@cfg:stackify] (self : Core_Option_Option_Type.t_option t) : t
    requires {self <> Core_Option_Option_Type.C_None}
    ensures { Core_Option_Option_Type.C_Some result = self }
    
end
module Core_Option_Impl0_Unwrap
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  val unwrap [@cfg:stackify] (self : Core_Option_Option_Type.t_option t) : t
    requires {self <> Core_Option_Option_Type.C_None}
    ensures { Core_Option_Option_Type.C_Some result = self }
    
end
module Core_Option_Impl0_IsNone_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  val is_none [@cfg:stackify] (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = (self = Core_Option_Option_Type.C_None) }
    
end
module Core_Option_Impl0_IsNone
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  val is_none [@cfg:stackify] (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = (self = Core_Option_Option_Type.C_None) }
    
end
module Core_Num_Impl7_WrappingAdd_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_add [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_WrappingAdd
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_add [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_SaturatingAdd_Interface
  use prelude.UInt8
  use mach.int.Int
  val saturating_add [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_SaturatingAdd
  use prelude.UInt8
  use mach.int.Int
  val saturating_add [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_OverflowingAdd_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_add [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module Core_Num_Impl7_OverflowingAdd
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_add [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CheckedOps_TestU8AddExample_Interface
  val test_u8_add_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestU8AddExample
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingAdd_Interface as OverflowingAdd0
  clone Core_Num_Impl7_SaturatingAdd_Interface as SaturatingAdd0
  clone Core_Num_Impl7_WrappingAdd_Interface as WrappingAdd0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedAdd_Interface as CheckedAdd0
  let rec cfg test_u8_add_example [@cfg:stackify] [#"../checked_ops.rs" 5 0 5 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : Core_Option_Option_Type.t_option uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : uint8;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : bool;
  var _21 : uint8;
  var _22 : ();
  var _23 : ();
  var _24 : bool;
  var _25 : bool;
  var _26 : uint8;
  var _27 : ();
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : uint8;
  var _32 : ();
  var res_33 : (uint8, bool);
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : bool;
  var _38 : uint8;
  var _39 : bool;
  var _40 : bool;
  var _41 : ();
  var res_42 : (uint8, bool);
  var _43 : ();
  var _44 : bool;
  var _45 : bool;
  var _46 : bool;
  var _47 : uint8;
  var _48 : bool;
  var _49 : bool;
  var _50 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 6 12 6 31] CheckedAdd0.checked_add (5 : uint8) (10 : uint8));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 6 12 6 40] Unwrap0.unwrap _5);
    goto BB2
  }
  BB2 {
    _3 <- ([#"../checked_ops.rs" 6 12 6 46] _4 = (15 : uint8));
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 7 12 7 33] CheckedAdd0.checked_add (250 : uint8) (10 : uint8));
    goto BB5
  }
  BB5 {
    _10 <- _11;
    _9 <- ([#"../checked_ops.rs" 7 12 7 43] IsNone0.is_none _10);
    goto BB6
  }
  BB6 {
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _16 <- ([#"../checked_ops.rs" 9 12 9 32] WrappingAdd0.wrapping_add (5 : uint8) (10 : uint8));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 9 12 9 38] _16 = (15 : uint8));
    _14 <- not _15;
    switch (_14)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _13 <- ();
    _21 <- ([#"../checked_ops.rs" 10 12 10 34] WrappingAdd0.wrapping_add (250 : uint8) (10 : uint8));
    goto BB12
  }
  BB12 {
    _20 <- ([#"../checked_ops.rs" 10 12 10 39] _21 = (4 : uint8));
    _19 <- not _20;
    switch (_19)
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _18 <- ();
    _26 <- ([#"../checked_ops.rs" 12 12 12 34] SaturatingAdd0.saturating_add (5 : uint8) (10 : uint8));
    goto BB15
  }
  BB15 {
    _25 <- ([#"../checked_ops.rs" 12 12 12 40] _26 = (15 : uint8));
    _24 <- not _25;
    switch (_24)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _23 <- ();
    _31 <- ([#"../checked_ops.rs" 13 12 13 36] SaturatingAdd0.saturating_add (250 : uint8) (10 : uint8));
    goto BB18
  }
  BB18 {
    _30 <- ([#"../checked_ops.rs" 13 12 13 43] _31 = (255 : uint8));
    _29 <- not _30;
    switch (_29)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _28 <- ();
    res_33 <- ([#"../checked_ops.rs" 15 14 15 37] OverflowingAdd0.overflowing_add (5 : uint8) (10 : uint8));
    goto BB21
  }
  BB21 {
    _38 <- (let (a, _) = res_33 in a);
    _37 <- ([#"../checked_ops.rs" 16 12 16 23] _38 = (15 : uint8));
    switch (_37)
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res_33 };
    _36 <- false;
    goto BB24
  }
  BB23 {
    _40 <- (let (_, a) = res_33 in a);
    assume { Resolve0.resolve res_33 };
    _39 <- ([#"../checked_ops.rs" 16 27 16 41] Bool.eqb _40 false);
    _36 <- _39;
    _39 <- any bool;
    goto BB24
  }
  BB24 {
    _35 <- not _36;
    switch (_35)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    _34 <- ();
    res_42 <- ([#"../checked_ops.rs" 17 14 17 39] OverflowingAdd0.overflowing_add (250 : uint8) (10 : uint8));
    goto BB27
  }
  BB27 {
    _47 <- (let (a, _) = res_42 in a);
    _46 <- ([#"../checked_ops.rs" 18 12 18 22] _47 = (4 : uint8));
    switch (_46)
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res_42 };
    _45 <- false;
    goto BB30
  }
  BB29 {
    _49 <- (let (_, a) = res_42 in a);
    assume { Resolve0.resolve res_42 };
    _48 <- ([#"../checked_ops.rs" 18 26 18 39] Bool.eqb _49 true);
    _45 <- _48;
    _48 <- any bool;
    goto BB30
  }
  BB30 {
    _44 <- not _45;
    switch (_44)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _43 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8AddOverflow_Interface
  use prelude.UInt8
  use mach.int.Int
  val test_u8_add_overflow [@cfg:stackify] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    
end
module CheckedOps_TestU8AddOverflow
  use prelude.UInt8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingAdd_Interface as OverflowingAdd0
  clone Core_Num_Impl7_SaturatingAdd_Interface as SaturatingAdd0
  clone Core_Num_Impl7_WrappingAdd_Interface as WrappingAdd0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedAdd_Interface as CheckedAdd0
  let rec cfg test_u8_add_overflow [@cfg:stackify] [#"../checked_ops.rs" 23 0 23 34] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _8 : uint8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : uint8;
  var _14 : uint8;
  var _15 : uint8;
  var _16 : uint8;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : bool;
  var _21 : uint8;
  var _22 : uint8;
  var _23 : ();
  var res_24 : (uint8, bool);
  var _25 : uint8;
  var _26 : ();
  var _27 : bool;
  var _28 : bool;
  var _29 : bool;
  var _30 : uint8;
  var _31 : uint8;
  var _32 : uint8;
  var _33 : bool;
  var _34 : bool;
  var _35 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 24 12 24 32] CheckedAdd0.checked_add (255 : uint8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 24 12 24 42] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 25 12 25 33] WrappingAdd0.wrapping_add (255 : uint8) _14);
    goto BB5
  }
  BB5 {
    _16 <- a_1;
    _15 <- ([#"../checked_ops.rs" 25 37 25 42] _16 - (1 : uint8));
    _12 <- ([#"../checked_ops.rs" 25 12 25 42] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _22 <- a_1;
    _21 <- ([#"../checked_ops.rs" 26 12 26 35] SaturatingAdd0.saturating_add (255 : uint8) _22);
    goto BB8
  }
  BB8 {
    _20 <- ([#"../checked_ops.rs" 26 12 26 42] _21 = (255 : uint8));
    _19 <- not _20;
    switch (_19)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _18 <- ();
    _25 <- a_1;
    res_24 <- ([#"../checked_ops.rs" 27 14 27 38] OverflowingAdd0.overflowing_add (255 : uint8) _25);
    goto BB11
  }
  BB11 {
    _30 <- (let (a, _) = res_24 in a);
    _32 <- a_1;
    _31 <- ([#"../checked_ops.rs" 28 21 28 26] _32 - (1 : uint8));
    _29 <- ([#"../checked_ops.rs" 28 12 28 26] _30 = _31);
    switch (_29)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_24 };
    _28 <- false;
    goto BB14
  }
  BB13 {
    _34 <- (let (_, a) = res_24 in a);
    assume { Resolve0.resolve res_24 };
    _33 <- ([#"../checked_ops.rs" 28 30 28 43] Bool.eqb _34 true);
    _28 <- _33;
    _33 <- any bool;
    goto BB14
  }
  BB14 {
    _27 <- not _28;
    switch (_27)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _26 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8WrappingAdd_Interface
  use prelude.UInt8
  use mach.int.Int
  val test_u8_wrapping_add [@cfg:stackify] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result = UInt8.to_int a + UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256 }
    
end
module CheckedOps_TestU8WrappingAdd
  use prelude.UInt8
  use mach.int.Int
  clone Core_Num_Impl7_WrappingAdd_Interface as WrappingAdd0
  let rec cfg test_u8_wrapping_add [@cfg:stackify] [#"../checked_ops.rs" 34 0 34 47] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result = UInt8.to_int a + UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a_1 : uint8;
  var b_2 : uint8;
  var _4 : uint8;
  var _5 : uint8;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _4 <- a_1;
    _5 <- b_2;
    _0 <- ([#"../checked_ops.rs" 35 4 35 21] WrappingAdd0.wrapping_add _4 _5);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingAdd_Interface
  use mach.int.Int
  use prelude.UInt8
  val test_u8_overflowing_add [@cfg:stackify] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingAdd
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedAdd_Interface as CheckedAdd0
  clone Core_Num_Impl7_WrappingAdd_Interface as WrappingAdd0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingAdd_Interface as OverflowingAdd0
  let rec cfg test_u8_overflowing_add [@cfg:stackify] [#"../checked_ops.rs" 39 0 39 44] (a : uint8) (b : uint8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var b_2 : uint8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : uint8;
  var _7 : (uint8, bool);
  var _8 : uint8;
  var _9 : uint8;
  var _10 : uint8;
  var _11 : uint8;
  var _12 : uint8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (uint8, bool);
  var _19 : uint8;
  var _20 : uint8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option uint8;
  var _23 : Core_Option_Option_Type.t_option uint8;
  var _24 : uint8;
  var _25 : uint8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 40 12 40 32] OverflowingAdd0.overflowing_add _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 40 38 40 55] WrappingAdd0.wrapping_add _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 40 12 40 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 41 12 41 32] OverflowingAdd0.overflowing_add _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 41 38 41 54] CheckedAdd0.checked_add _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 41 38 41 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 41 12 41 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl7_CheckedSub_Interface
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
end
module Core_Num_Impl7_CheckedSub
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
end
module Core_Num_Impl7_WrappingSub_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_WrappingSub
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_SaturatingSub_Interface
  use prelude.UInt8
  use mach.int.Int
  val saturating_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_SaturatingSub
  use prelude.UInt8
  use mach.int.Int
  val saturating_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_OverflowingSub_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module Core_Num_Impl7_OverflowingSub
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_sub [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module CheckedOps_TestU8SubExample_Interface
  val test_u8_sub_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestU8SubExample
  use prelude.Borrow
  use mach.int.Int
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingSub_Interface as OverflowingSub0
  clone Core_Num_Impl7_SaturatingSub_Interface as SaturatingSub0
  clone Core_Num_Impl7_WrappingSub_Interface as WrappingSub0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedSub_Interface as CheckedSub0
  let rec cfg test_u8_sub_example [@cfg:stackify] [#"../checked_ops.rs" 45 0 45 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : Core_Option_Option_Type.t_option uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : uint8;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : bool;
  var _21 : uint8;
  var _22 : ();
  var _23 : ();
  var _24 : bool;
  var _25 : bool;
  var _26 : uint8;
  var _27 : ();
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : uint8;
  var _32 : ();
  var res_33 : (uint8, bool);
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : bool;
  var _38 : uint8;
  var _39 : bool;
  var _40 : bool;
  var _41 : ();
  var res_42 : (uint8, bool);
  var _43 : ();
  var _44 : bool;
  var _45 : bool;
  var _46 : bool;
  var _47 : uint8;
  var _48 : bool;
  var _49 : bool;
  var _50 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 46 12 46 31] CheckedSub0.checked_sub (5 : uint8) (10 : uint8));
    goto BB1
  }
  BB1 {
    _4 <- _5;
    _3 <- ([#"../checked_ops.rs" 46 12 46 41] IsNone0.is_none _4);
    goto BB2
  }
  BB2 {
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 47 12 47 33] CheckedSub0.checked_sub (250 : uint8) (10 : uint8));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 47 12 47 42] Unwrap0.unwrap _11);
    goto BB6
  }
  BB6 {
    _9 <- ([#"../checked_ops.rs" 47 12 47 49] _10 = (240 : uint8));
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _16 <- ([#"../checked_ops.rs" 49 12 49 32] WrappingSub0.wrapping_sub (5 : uint8) (10 : uint8));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 49 12 49 39] _16 = (251 : uint8));
    _14 <- not _15;
    switch (_14)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _13 <- ();
    _21 <- ([#"../checked_ops.rs" 50 12 50 34] WrappingSub0.wrapping_sub (250 : uint8) (10 : uint8));
    goto BB12
  }
  BB12 {
    _20 <- ([#"../checked_ops.rs" 50 12 50 41] _21 = (240 : uint8));
    _19 <- not _20;
    switch (_19)
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _18 <- ();
    _26 <- ([#"../checked_ops.rs" 52 12 52 34] SaturatingSub0.saturating_sub (5 : uint8) (10 : uint8));
    goto BB15
  }
  BB15 {
    _25 <- ([#"../checked_ops.rs" 52 12 52 39] _26 = (0 : uint8));
    _24 <- not _25;
    switch (_24)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _23 <- ();
    _31 <- ([#"../checked_ops.rs" 53 12 53 36] SaturatingSub0.saturating_sub (250 : uint8) (10 : uint8));
    goto BB18
  }
  BB18 {
    _30 <- ([#"../checked_ops.rs" 53 12 53 43] _31 = (240 : uint8));
    _29 <- not _30;
    switch (_29)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _28 <- ();
    res_33 <- ([#"../checked_ops.rs" 55 14 55 37] OverflowingSub0.overflowing_sub (5 : uint8) (10 : uint8));
    goto BB21
  }
  BB21 {
    _38 <- (let (a, _) = res_33 in a);
    _37 <- ([#"../checked_ops.rs" 56 12 56 24] _38 = (251 : uint8));
    switch (_37)
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res_33 };
    _36 <- false;
    goto BB24
  }
  BB23 {
    _40 <- (let (_, a) = res_33 in a);
    assume { Resolve0.resolve res_33 };
    _39 <- ([#"../checked_ops.rs" 56 28 56 41] Bool.eqb _40 true);
    _36 <- _39;
    _39 <- any bool;
    goto BB24
  }
  BB24 {
    _35 <- not _36;
    switch (_35)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    _34 <- ();
    res_42 <- ([#"../checked_ops.rs" 57 14 57 39] OverflowingSub0.overflowing_sub (250 : uint8) (10 : uint8));
    goto BB27
  }
  BB27 {
    _47 <- (let (a, _) = res_42 in a);
    _46 <- ([#"../checked_ops.rs" 58 12 58 24] _47 = (240 : uint8));
    switch (_46)
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res_42 };
    _45 <- false;
    goto BB30
  }
  BB29 {
    _49 <- (let (_, a) = res_42 in a);
    assume { Resolve0.resolve res_42 };
    _48 <- ([#"../checked_ops.rs" 58 28 58 42] Bool.eqb _49 false);
    _45 <- _48;
    _48 <- any bool;
    goto BB30
  }
  BB30 {
    _44 <- not _45;
    switch (_44)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _43 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8SubOverflow_Interface
  use prelude.UInt8
  use mach.int.Int
  val test_u8_sub_overflow [@cfg:stackify] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    
end
module CheckedOps_TestU8SubOverflow
  use prelude.UInt8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingSub_Interface as OverflowingSub0
  clone Core_Num_Impl7_SaturatingSub_Interface as SaturatingSub0
  clone Core_Num_Impl7_WrappingSub_Interface as WrappingSub0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedSub_Interface as CheckedSub0
  let rec cfg test_u8_sub_overflow [@cfg:stackify] [#"../checked_ops.rs" 63 0 63 34] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _8 : uint8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : uint8;
  var _14 : uint8;
  var _15 : uint8;
  var _16 : uint8;
  var _17 : uint8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : uint8;
  var _23 : uint8;
  var _24 : ();
  var res_25 : (uint8, bool);
  var _26 : uint8;
  var _27 : ();
  var _28 : bool;
  var _29 : bool;
  var _30 : bool;
  var _31 : uint8;
  var _32 : uint8;
  var _33 : uint8;
  var _34 : uint8;
  var _35 : bool;
  var _36 : bool;
  var _37 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 64 12 64 30] CheckedSub0.checked_sub (0 : uint8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 64 12 64 40] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 65 12 65 31] WrappingSub0.wrapping_sub (0 : uint8) _14);
    goto BB5
  }
  BB5 {
    _17 <- a_1;
    _16 <- ([#"../checked_ops.rs" 65 35 65 42] (255 : uint8) - _17);
    _15 <- ([#"../checked_ops.rs" 65 35 65 46] _16 + (1 : uint8));
    _12 <- ([#"../checked_ops.rs" 65 12 65 46] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _23 <- a_1;
    _22 <- ([#"../checked_ops.rs" 66 12 66 33] SaturatingSub0.saturating_sub (0 : uint8) _23);
    goto BB8
  }
  BB8 {
    _21 <- ([#"../checked_ops.rs" 66 12 66 38] _22 = (0 : uint8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _19 <- ();
    _26 <- a_1;
    res_25 <- ([#"../checked_ops.rs" 67 14 67 36] OverflowingSub0.overflowing_sub (0 : uint8) _26);
    goto BB11
  }
  BB11 {
    _31 <- (let (a, _) = res_25 in a);
    _34 <- a_1;
    _33 <- ([#"../checked_ops.rs" 68 21 68 28] (255 : uint8) - _34);
    _32 <- ([#"../checked_ops.rs" 68 21 68 32] _33 + (1 : uint8));
    _30 <- ([#"../checked_ops.rs" 68 12 68 32] _31 = _32);
    switch (_30)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_25 };
    _29 <- false;
    goto BB14
  }
  BB13 {
    _36 <- (let (_, a) = res_25 in a);
    assume { Resolve0.resolve res_25 };
    _35 <- ([#"../checked_ops.rs" 68 36 68 49] Bool.eqb _36 true);
    _29 <- _35;
    _35 <- any bool;
    goto BB14
  }
  BB14 {
    _28 <- not _29;
    switch (_28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _27 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8WrappingSub_Interface
  use prelude.UInt8
  use mach.int.Int
  val test_u8_wrapping_sub [@cfg:stackify] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result = UInt8.to_int a - UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256 }
    
end
module CheckedOps_TestU8WrappingSub
  use prelude.UInt8
  use mach.int.Int
  clone Core_Num_Impl7_WrappingSub_Interface as WrappingSub0
  let rec cfg test_u8_wrapping_sub [@cfg:stackify] [#"../checked_ops.rs" 74 0 74 47] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result = UInt8.to_int a - UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a_1 : uint8;
  var b_2 : uint8;
  var _4 : uint8;
  var _5 : uint8;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _4 <- a_1;
    _5 <- b_2;
    _0 <- ([#"../checked_ops.rs" 75 4 75 21] WrappingSub0.wrapping_sub _4 _5);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingSub_Interface
  use mach.int.Int
  use prelude.UInt8
  val test_u8_overflowing_sub [@cfg:stackify] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingSub
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedSub_Interface as CheckedSub0
  clone Core_Num_Impl7_WrappingSub_Interface as WrappingSub0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingSub_Interface as OverflowingSub0
  let rec cfg test_u8_overflowing_sub [@cfg:stackify] [#"../checked_ops.rs" 79 0 79 44] (a : uint8) (b : uint8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var b_2 : uint8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : uint8;
  var _7 : (uint8, bool);
  var _8 : uint8;
  var _9 : uint8;
  var _10 : uint8;
  var _11 : uint8;
  var _12 : uint8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (uint8, bool);
  var _19 : uint8;
  var _20 : uint8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option uint8;
  var _23 : Core_Option_Option_Type.t_option uint8;
  var _24 : uint8;
  var _25 : uint8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 80 12 80 32] OverflowingSub0.overflowing_sub _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 80 38 80 55] WrappingSub0.wrapping_sub _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 80 12 80 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 81 12 81 32] OverflowingSub0.overflowing_sub _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 81 38 81 54] CheckedSub0.checked_sub _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 81 38 81 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 81 12 81 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl7_CheckedMul_Interface
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
end
module Core_Num_Impl7_CheckedMul
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
end
module Core_Num_Impl7_WrappingMul_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_WrappingMul
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    
end
module Core_Num_Impl7_SaturatingMul_Interface
  use prelude.UInt8
  use mach.int.Int
  val saturating_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_SaturatingMul
  use prelude.UInt8
  use mach.int.Int
  val saturating_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> UInt8.to_int result = UInt8.to_int (255 : uint8) }
    
end
module Core_Num_Impl7_OverflowingMul_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module Core_Num_Impl7_OverflowingMul
  use prelude.UInt8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_mul [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (0 : uint8) /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (255 : uint8) -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8) -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (255 : uint8) - UInt8.to_int (0 : uint8) + 1)) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (0 : uint8) \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (255 : uint8)) }
    
end
module CheckedOps_TestU8MulExample_Interface
  val test_u8_mul_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestU8MulExample
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingMul_Interface as OverflowingMul0
  clone Core_Num_Impl7_SaturatingMul_Interface as SaturatingMul0
  clone Core_Num_Impl7_WrappingMul_Interface as WrappingMul0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedMul_Interface as CheckedMul0
  let rec cfg test_u8_mul_example [@cfg:stackify] [#"../checked_ops.rs" 85 0 85 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : Core_Option_Option_Type.t_option uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : uint8;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : bool;
  var _21 : uint8;
  var _22 : ();
  var _23 : ();
  var _24 : bool;
  var _25 : bool;
  var _26 : uint8;
  var _27 : ();
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : uint8;
  var _32 : ();
  var res_33 : (uint8, bool);
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : bool;
  var _38 : uint8;
  var _39 : bool;
  var _40 : bool;
  var _41 : ();
  var res_42 : (uint8, bool);
  var _43 : ();
  var _44 : bool;
  var _45 : bool;
  var _46 : bool;
  var _47 : uint8;
  var _48 : bool;
  var _49 : bool;
  var _50 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 86 12 86 31] CheckedMul0.checked_mul (5 : uint8) (10 : uint8));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 86 12 86 40] Unwrap0.unwrap _5);
    goto BB2
  }
  BB2 {
    _3 <- ([#"../checked_ops.rs" 86 12 86 46] _4 = (50 : uint8));
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 87 12 87 32] CheckedMul0.checked_mul (50 : uint8) (10 : uint8));
    goto BB5
  }
  BB5 {
    _10 <- _11;
    _9 <- ([#"../checked_ops.rs" 87 12 87 42] IsNone0.is_none _10);
    goto BB6
  }
  BB6 {
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _16 <- ([#"../checked_ops.rs" 89 12 89 32] WrappingMul0.wrapping_mul (5 : uint8) (10 : uint8));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 89 12 89 38] _16 = (50 : uint8));
    _14 <- not _15;
    switch (_14)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _13 <- ();
    _21 <- ([#"../checked_ops.rs" 90 12 90 33] WrappingMul0.wrapping_mul (50 : uint8) (10 : uint8));
    goto BB12
  }
  BB12 {
    _20 <- ([#"../checked_ops.rs" 90 12 90 40] _21 = (244 : uint8));
    _19 <- not _20;
    switch (_19)
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _18 <- ();
    _26 <- ([#"../checked_ops.rs" 92 12 92 34] SaturatingMul0.saturating_mul (5 : uint8) (10 : uint8));
    goto BB15
  }
  BB15 {
    _25 <- ([#"../checked_ops.rs" 92 12 92 40] _26 = (50 : uint8));
    _24 <- not _25;
    switch (_24)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _23 <- ();
    _31 <- ([#"../checked_ops.rs" 93 12 93 35] SaturatingMul0.saturating_mul (50 : uint8) (10 : uint8));
    goto BB18
  }
  BB18 {
    _30 <- ([#"../checked_ops.rs" 93 12 93 42] _31 = (255 : uint8));
    _29 <- not _30;
    switch (_29)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _28 <- ();
    res_33 <- ([#"../checked_ops.rs" 95 14 95 37] OverflowingMul0.overflowing_mul (5 : uint8) (10 : uint8));
    goto BB21
  }
  BB21 {
    _38 <- (let (a, _) = res_33 in a);
    _37 <- ([#"../checked_ops.rs" 96 12 96 23] _38 = (50 : uint8));
    switch (_37)
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { Resolve0.resolve res_33 };
    _36 <- false;
    goto BB24
  }
  BB23 {
    _40 <- (let (_, a) = res_33 in a);
    assume { Resolve0.resolve res_33 };
    _39 <- ([#"../checked_ops.rs" 96 27 96 41] Bool.eqb _40 false);
    _36 <- _39;
    _39 <- any bool;
    goto BB24
  }
  BB24 {
    _35 <- not _36;
    switch (_35)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    absurd
  }
  BB26 {
    _34 <- ();
    res_42 <- ([#"../checked_ops.rs" 97 14 97 38] OverflowingMul0.overflowing_mul (50 : uint8) (10 : uint8));
    goto BB27
  }
  BB27 {
    _47 <- (let (a, _) = res_42 in a);
    _46 <- ([#"../checked_ops.rs" 98 12 98 24] _47 = (244 : uint8));
    switch (_46)
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { Resolve0.resolve res_42 };
    _45 <- false;
    goto BB30
  }
  BB29 {
    _49 <- (let (_, a) = res_42 in a);
    assume { Resolve0.resolve res_42 };
    _48 <- ([#"../checked_ops.rs" 98 28 98 41] Bool.eqb _49 true);
    _45 <- _48;
    _48 <- any bool;
    goto BB30
  }
  BB30 {
    _44 <- not _45;
    switch (_44)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    absurd
  }
  BB32 {
    _43 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8MulZero_Interface
  use mach.int.Int
  use prelude.UInt8
  val test_u8_mul_zero [@cfg:stackify] (a : uint8) : ()
end
module CheckedOps_TestU8MulZero
  use mach.int.Int
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingMul_Interface as OverflowingMul0
  clone Core_Num_Impl7_SaturatingMul_Interface as SaturatingMul0
  clone Core_Num_Impl7_WrappingMul_Interface as WrappingMul0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedMul_Interface as CheckedMul0
  let rec cfg test_u8_mul_zero [@cfg:stackify] [#"../checked_ops.rs" 102 0 102 30] (a : uint8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var _2 : ();
  var _3 : bool;
  var _4 : bool;
  var _5 : uint8;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _7 : uint8;
  var _8 : ();
  var _9 : ();
  var _10 : bool;
  var _11 : bool;
  var _12 : uint8;
  var _13 : uint8;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : bool;
  var _18 : uint8;
  var _19 : uint8;
  var _20 : ();
  var res_21 : (uint8, bool);
  var _22 : uint8;
  var _23 : ();
  var _24 : bool;
  var _25 : bool;
  var _26 : bool;
  var _27 : uint8;
  var _28 : bool;
  var _29 : bool;
  var _30 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _7 <- a_1;
    _6 <- ([#"../checked_ops.rs" 103 12 103 30] CheckedMul0.checked_mul (0 : uint8) _7);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 103 12 103 39] Unwrap0.unwrap _6);
    goto BB2
  }
  BB2 {
    _4 <- ([#"../checked_ops.rs" 103 12 103 44] _5 = (0 : uint8));
    _3 <- not _4;
    switch (_3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _2 <- ();
    _13 <- a_1;
    _12 <- ([#"../checked_ops.rs" 104 12 104 31] WrappingMul0.wrapping_mul (0 : uint8) _13);
    goto BB5
  }
  BB5 {
    _11 <- ([#"../checked_ops.rs" 104 12 104 36] _12 = (0 : uint8));
    _10 <- not _11;
    switch (_10)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _9 <- ();
    _19 <- a_1;
    _18 <- ([#"../checked_ops.rs" 105 12 105 33] SaturatingMul0.saturating_mul (0 : uint8) _19);
    goto BB8
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 105 12 105 38] _18 = (0 : uint8));
    _16 <- not _17;
    switch (_16)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _15 <- ();
    _22 <- a_1;
    res_21 <- ([#"../checked_ops.rs" 106 14 106 36] OverflowingMul0.overflowing_mul (0 : uint8) _22);
    goto BB11
  }
  BB11 {
    _27 <- (let (a, _) = res_21 in a);
    _26 <- ([#"../checked_ops.rs" 107 12 107 22] _27 = (0 : uint8));
    switch (_26)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_21 };
    _25 <- false;
    goto BB14
  }
  BB13 {
    _29 <- (let (_, a) = res_21 in a);
    assume { Resolve0.resolve res_21 };
    _28 <- ([#"../checked_ops.rs" 107 26 107 40] Bool.eqb _29 false);
    _25 <- _28;
    _28 <- any bool;
    goto BB14
  }
  BB14 {
    _24 <- not _25;
    switch (_24)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _23 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingMul_Interface
  use mach.int.Int
  use prelude.UInt8
  val test_u8_overflowing_mul [@cfg:stackify] (a : uint8) (b : uint8) : ()
end
module CheckedOps_TestU8OverflowingMul
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedMul_Interface as CheckedMul0
  clone Core_Num_Impl7_WrappingMul_Interface as WrappingMul0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingMul_Interface as OverflowingMul0
  let rec cfg test_u8_overflowing_mul [@cfg:stackify] [#"../checked_ops.rs" 111 0 111 44] (a : uint8) (b : uint8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var b_2 : uint8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : uint8;
  var _7 : (uint8, bool);
  var _8 : uint8;
  var _9 : uint8;
  var _10 : uint8;
  var _11 : uint8;
  var _12 : uint8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (uint8, bool);
  var _19 : uint8;
  var _20 : uint8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option uint8;
  var _23 : Core_Option_Option_Type.t_option uint8;
  var _24 : uint8;
  var _25 : uint8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 112 12 112 32] OverflowingMul0.overflowing_mul _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 112 38 112 55] WrappingMul0.wrapping_mul _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 112 12 112 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 113 12 113 32] OverflowingMul0.overflowing_mul _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 113 38 113 54] CheckedMul0.checked_mul _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 113 38 113 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 113 12 113 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl7_CheckedDiv_Interface
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_CheckedDiv
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div [@cfg:stackify] (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1) }
    ensures { forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_WrappingDiv_Interface
  use prelude.UInt8
  use mach.int.Int
  val wrapping_div [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int self }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_WrappingDiv
  use prelude.UInt8
  use mach.int.Int
  val wrapping_div [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int self }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_SaturatingDiv_Interface
  use prelude.UInt8
  use mach.int.Int
  val saturating_div [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_SaturatingDiv
  use prelude.UInt8
  use mach.int.Int
  val saturating_div [@cfg:stackify] (self : uint8) (rhs : uint8) : uint8
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int (0 : uint8) }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
end
module Core_Num_Impl7_OverflowingDiv_Interface
  use prelude.UInt8
  use mach.int.Int
  val overflowing_div [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1) }
    
end
module Core_Num_Impl7_OverflowingDiv
  use prelude.UInt8
  use mach.int.Int
  val overflowing_div [@cfg:stackify] (self : uint8) (rhs : uint8) : (uint8, bool)
    requires {UInt8.to_int rhs <> 0}
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self }
    ensures { UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs) }
    ensures { (let (_, a) = result in a) = (UInt8.to_int self = UInt8.to_int (0 : uint8) /\ UInt8.to_int rhs = - 1) }
    
end
module CheckedOps_TestU8DivExample_Interface
  val test_u8_div_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestU8DivExample
  use prelude.Borrow
  use mach.int.Int
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingDiv_Interface as OverflowingDiv0
  clone Core_Num_Impl7_SaturatingDiv_Interface as SaturatingDiv0
  clone Core_Num_Impl7_WrappingDiv_Interface as WrappingDiv0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_u8_div_example [@cfg:stackify] [#"../checked_ops.rs" 117 0 117 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : Core_Option_Option_Type.t_option uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : uint8;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : bool;
  var _21 : uint8;
  var _22 : ();
  var res_23 : (uint8, bool);
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : bool;
  var _28 : uint8;
  var _29 : bool;
  var _30 : bool;
  var _31 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 118 12 118 30] CheckedDiv0.checked_div (5 : uint8) (0 : uint8));
    goto BB1
  }
  BB1 {
    _4 <- _5;
    _3 <- ([#"../checked_ops.rs" 118 12 118 40] IsNone0.is_none _4);
    goto BB2
  }
  BB2 {
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 119 12 119 30] CheckedDiv0.checked_div (5 : uint8) (2 : uint8));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 119 12 119 39] Unwrap0.unwrap _11);
    goto BB6
  }
  BB6 {
    _9 <- ([#"../checked_ops.rs" 119 12 119 44] _10 = (2 : uint8));
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _16 <- ([#"../checked_ops.rs" 120 12 120 31] WrappingDiv0.wrapping_div (5 : uint8) (2 : uint8));
    goto BB9
  }
  BB9 {
    _15 <- ([#"../checked_ops.rs" 120 12 120 36] _16 = (2 : uint8));
    _14 <- not _15;
    switch (_14)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _13 <- ();
    _21 <- ([#"../checked_ops.rs" 121 12 121 33] SaturatingDiv0.saturating_div (5 : uint8) (2 : uint8));
    goto BB12
  }
  BB12 {
    _20 <- ([#"../checked_ops.rs" 121 12 121 38] _21 = (2 : uint8));
    _19 <- not _20;
    switch (_19)
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    absurd
  }
  BB14 {
    _18 <- ();
    res_23 <- ([#"../checked_ops.rs" 122 14 122 36] OverflowingDiv0.overflowing_div (5 : uint8) (2 : uint8));
    goto BB15
  }
  BB15 {
    _28 <- (let (a, _) = res_23 in a);
    _27 <- ([#"../checked_ops.rs" 123 12 123 22] _28 = (2 : uint8));
    switch (_27)
      | False -> goto BB16
      | True -> goto BB17
      end
  }
  BB16 {
    assume { Resolve0.resolve res_23 };
    _26 <- false;
    goto BB18
  }
  BB17 {
    _30 <- (let (_, a) = res_23 in a);
    assume { Resolve0.resolve res_23 };
    _29 <- ([#"../checked_ops.rs" 123 26 123 40] Bool.eqb _30 false);
    _26 <- _29;
    _29 <- any bool;
    goto BB18
  }
  BB18 {
    _25 <- not _26;
    switch (_25)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _24 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8DivNoOverflow_Interface
  use prelude.UInt8
  use mach.int.Int
  val test_u8_div_no_overflow [@cfg:stackify] (a : uint8) (b : uint8) : ()
    requires {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b <> 0}
    
end
module CheckedOps_TestU8DivNoOverflow
  use prelude.UInt8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = uint8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl7_OverflowingDiv_Interface as OverflowingDiv0
  clone Core_Num_Impl7_SaturatingDiv_Interface as SaturatingDiv0
  clone Core_Num_Impl7_WrappingDiv_Interface as WrappingDiv0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_u8_div_no_overflow [@cfg:stackify] [#"../checked_ops.rs" 128 0 128 44] (a : uint8) (b : uint8) : ()
    requires {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var b_2 : uint8;
  var _4 : ();
  var _5 : bool;
  var _6 : bool;
  var _7 : uint8;
  var _8 : Core_Option_Option_Type.t_option uint8;
  var _9 : uint8;
  var _10 : uint8;
  var _11 : uint8;
  var _12 : uint8;
  var _13 : uint8;
  var _14 : bool;
  var _15 : ();
  var _16 : ();
  var _17 : bool;
  var _18 : bool;
  var _19 : uint8;
  var _20 : uint8;
  var _21 : uint8;
  var _22 : uint8;
  var _23 : uint8;
  var _24 : uint8;
  var _25 : bool;
  var _26 : ();
  var _27 : ();
  var _28 : bool;
  var _29 : bool;
  var _30 : uint8;
  var _31 : uint8;
  var _32 : uint8;
  var _33 : uint8;
  var _34 : uint8;
  var _35 : uint8;
  var _36 : bool;
  var _37 : ();
  var res_38 : (uint8, bool);
  var _39 : uint8;
  var _40 : uint8;
  var _41 : ();
  var _42 : bool;
  var _43 : bool;
  var _44 : bool;
  var _45 : uint8;
  var _46 : uint8;
  var _47 : uint8;
  var _48 : uint8;
  var _49 : bool;
  var _50 : bool;
  var _51 : bool;
  var _52 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _9 <- a_1;
    _10 <- b_2;
    _8 <- ([#"../checked_ops.rs" 129 12 129 28] CheckedDiv0.checked_div _9 _10);
    goto BB1
  }
  BB1 {
    _7 <- ([#"../checked_ops.rs" 129 12 129 37] Unwrap0.unwrap _8);
    goto BB2
  }
  BB2 {
    _12 <- a_1;
    _13 <- b_2;
    _14 <- ([#"../checked_ops.rs" 129 41 129 46] _13 = (0 : uint8));
    assert { [#"../checked_ops.rs" 129 41 129 46] not _14 };
    goto BB3
  }
  BB3 {
    _11 <- ([#"../checked_ops.rs" 129 41 129 46] _12 / _13);
    _6 <- ([#"../checked_ops.rs" 129 12 129 46] _7 = _11);
    _5 <- not _6;
    switch (_5)
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    absurd
  }
  BB5 {
    _4 <- ();
    _20 <- a_1;
    _21 <- b_2;
    _19 <- ([#"../checked_ops.rs" 130 12 130 29] WrappingDiv0.wrapping_div _20 _21);
    goto BB6
  }
  BB6 {
    _23 <- a_1;
    _24 <- b_2;
    _25 <- ([#"../checked_ops.rs" 130 33 130 38] _24 = (0 : uint8));
    assert { [#"../checked_ops.rs" 130 33 130 38] not _25 };
    goto BB7
  }
  BB7 {
    _22 <- ([#"../checked_ops.rs" 130 33 130 38] _23 / _24);
    _18 <- ([#"../checked_ops.rs" 130 12 130 38] _19 = _22);
    _17 <- not _18;
    switch (_17)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _16 <- ();
    _31 <- a_1;
    _32 <- b_2;
    _30 <- ([#"../checked_ops.rs" 131 12 131 31] SaturatingDiv0.saturating_div _31 _32);
    goto BB10
  }
  BB10 {
    _34 <- a_1;
    _35 <- b_2;
    _36 <- ([#"../checked_ops.rs" 131 35 131 40] _35 = (0 : uint8));
    assert { [#"../checked_ops.rs" 131 35 131 40] not _36 };
    goto BB11
  }
  BB11 {
    _33 <- ([#"../checked_ops.rs" 131 35 131 40] _34 / _35);
    _29 <- ([#"../checked_ops.rs" 131 12 131 40] _30 = _33);
    _28 <- not _29;
    switch (_28)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB12 {
    absurd
  }
  BB13 {
    _27 <- ();
    _39 <- a_1;
    _40 <- b_2;
    res_38 <- ([#"../checked_ops.rs" 132 14 132 34] OverflowingDiv0.overflowing_div _39 _40);
    goto BB14
  }
  BB14 {
    _45 <- (let (a, _) = res_38 in a);
    _47 <- a_1;
    _48 <- b_2;
    _49 <- ([#"../checked_ops.rs" 133 21 133 26] _48 = (0 : uint8));
    assert { [#"../checked_ops.rs" 133 21 133 26] not _49 };
    goto BB18
  }
  BB15 {
    assume { Resolve0.resolve res_38 };
    _43 <- false;
    goto BB17
  }
  BB16 {
    _51 <- (let (_, a) = res_38 in a);
    assume { Resolve0.resolve res_38 };
    _50 <- ([#"../checked_ops.rs" 133 30 133 44] Bool.eqb _51 false);
    _43 <- _50;
    _50 <- any bool;
    goto BB17
  }
  BB17 {
    _42 <- not _43;
    switch (_42)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB18 {
    _46 <- ([#"../checked_ops.rs" 133 21 133 26] _47 / _48);
    _44 <- ([#"../checked_ops.rs" 133 12 133 26] _45 = _46);
    switch (_44)
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB19 {
    absurd
  }
  BB20 {
    _41 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestU8DivZero_Interface
  use mach.int.Int
  use prelude.UInt8
  val test_u8_div_zero [@cfg:stackify] (a : uint8) : ()
end
module CheckedOps_TestU8DivZero
  use mach.int.Int
  use prelude.UInt8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = uint8
  clone Core_Num_Impl7_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_u8_div_zero [@cfg:stackify] [#"../checked_ops.rs" 137 0 137 30] (a : uint8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : uint8;
  var _2 : ();
  var _3 : bool;
  var _4 : bool;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _7 : uint8;
  var _8 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _7 <- a_1;
    _6 <- ([#"../checked_ops.rs" 138 12 138 28] CheckedDiv0.checked_div _7 (0 : uint8));
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _4 <- ([#"../checked_ops.rs" 138 12 138 38] IsNone0.is_none _5);
    goto BB2
  }
  BB2 {
    _3 <- not _4;
    switch (_3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _2 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl1_CheckedAdd_Interface
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
end
module Core_Num_Impl1_CheckedAdd
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_add [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
end
module Core_Num_Impl1_WrappingAdd_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_add [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_WrappingAdd
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_add [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_SaturatingAdd_Interface
  use prelude.Int8
  use mach.int.Int
  val saturating_add [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_SaturatingAdd
  use prelude.Int8
  use mach.int.Int
  val saturating_add [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_OverflowingAdd_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_add [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module Core_Num_Impl1_OverflowingAdd
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_add [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self + Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module CheckedOps_TestI8AddExample_Interface
  val test_i8_add_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestI8AddExample
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingAdd_Interface as OverflowingAdd0
  clone Core_Num_Impl1_SaturatingAdd_Interface as SaturatingAdd0
  clone Core_Num_Impl1_WrappingAdd_Interface as WrappingAdd0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Num_Impl1_CheckedAdd_Interface as CheckedAdd0
  let rec cfg test_i8_add_example [@cfg:stackify] [#"../checked_ops.rs" 142 0 142 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : Core_Option_Option_Type.t_option int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : Core_Option_Option_Type.t_option int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : int8;
  var _28 : ();
  var _29 : ();
  var _30 : bool;
  var _31 : bool;
  var _32 : int8;
  var _33 : ();
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : int8;
  var _38 : ();
  var _39 : ();
  var _40 : bool;
  var _41 : bool;
  var _42 : int8;
  var _43 : ();
  var _44 : ();
  var _45 : bool;
  var _46 : bool;
  var _47 : int8;
  var _48 : ();
  var res_49 : (int8, bool);
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : bool;
  var _54 : int8;
  var _55 : bool;
  var _56 : bool;
  var _57 : ();
  var res_58 : (int8, bool);
  var _59 : ();
  var _60 : bool;
  var _61 : bool;
  var _62 : bool;
  var _63 : int8;
  var _64 : bool;
  var _65 : bool;
  var _66 : ();
  var res_67 : (int8, bool);
  var _68 : ();
  var _69 : bool;
  var _70 : bool;
  var _71 : bool;
  var _72 : int8;
  var _73 : bool;
  var _74 : bool;
  var _75 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 143 12 143 31] CheckedAdd0.checked_add (5 : int8) (10 : int8));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 143 12 143 40] Unwrap0.unwrap _5);
    goto BB2
  }
  BB2 {
    _3 <- ([#"../checked_ops.rs" 143 12 143 46] _4 = (15 : int8));
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 144 12 144 33] CheckedAdd0.checked_add (120 : int8) (10 : int8));
    goto BB5
  }
  BB5 {
    _10 <- _11;
    _9 <- ([#"../checked_ops.rs" 144 12 144 43] IsNone0.is_none _10);
    goto BB6
  }
  BB6 {
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _17 <- ([#"../checked_ops.rs" 145 12 145 37] CheckedAdd0.checked_add (-120 : int8) (-10 : int8));
    goto BB9
  }
  BB9 {
    _16 <- _17;
    _15 <- ([#"../checked_ops.rs" 145 12 145 47] IsNone0.is_none _16);
    goto BB10
  }
  BB10 {
    _14 <- not _15;
    switch (_14)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _13 <- ();
    _22 <- ([#"../checked_ops.rs" 147 12 147 32] WrappingAdd0.wrapping_add (5 : int8) (10 : int8));
    goto BB13
  }
  BB13 {
    _21 <- ([#"../checked_ops.rs" 147 12 147 38] _22 = (15 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _19 <- ();
    _27 <- ([#"../checked_ops.rs" 148 12 148 34] WrappingAdd0.wrapping_add (120 : int8) (10 : int8));
    goto BB16
  }
  BB16 {
    _26 <- ([#"../checked_ops.rs" 148 12 148 42] _27 = (-126 : int8));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _24 <- ();
    _32 <- ([#"../checked_ops.rs" 149 12 149 38] WrappingAdd0.wrapping_add (-120 : int8) (-10 : int8));
    goto BB19
  }
  BB19 {
    _31 <- ([#"../checked_ops.rs" 149 12 149 45] _32 = (126 : int8));
    _30 <- not _31;
    switch (_30)
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _29 <- ();
    _37 <- ([#"../checked_ops.rs" 151 12 151 34] SaturatingAdd0.saturating_add (5 : int8) (10 : int8));
    goto BB22
  }
  BB22 {
    _36 <- ([#"../checked_ops.rs" 151 12 151 40] _37 = (15 : int8));
    _35 <- not _36;
    switch (_35)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _34 <- ();
    _42 <- ([#"../checked_ops.rs" 152 12 152 36] SaturatingAdd0.saturating_add (120 : int8) (10 : int8));
    goto BB25
  }
  BB25 {
    _41 <- ([#"../checked_ops.rs" 152 12 152 43] _42 = (127 : int8));
    _40 <- not _41;
    switch (_40)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _39 <- ();
    _47 <- ([#"../checked_ops.rs" 153 12 153 40] SaturatingAdd0.saturating_add (-120 : int8) (-10 : int8));
    goto BB28
  }
  BB28 {
    _46 <- ([#"../checked_ops.rs" 153 12 153 48] _47 = (-128 : int8));
    _45 <- not _46;
    switch (_45)
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    _44 <- ();
    res_49 <- ([#"../checked_ops.rs" 155 14 155 37] OverflowingAdd0.overflowing_add (5 : int8) (10 : int8));
    goto BB31
  }
  BB31 {
    _54 <- (let (a, _) = res_49 in a);
    _53 <- ([#"../checked_ops.rs" 156 12 156 23] _54 = (15 : int8));
    switch (_53)
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res_49 };
    _52 <- false;
    goto BB34
  }
  BB33 {
    _56 <- (let (_, a) = res_49 in a);
    assume { Resolve0.resolve res_49 };
    _55 <- ([#"../checked_ops.rs" 156 27 156 41] Bool.eqb _56 false);
    _52 <- _55;
    _55 <- any bool;
    goto BB34
  }
  BB34 {
    _51 <- not _52;
    switch (_51)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    _50 <- ();
    res_58 <- ([#"../checked_ops.rs" 157 14 157 39] OverflowingAdd0.overflowing_add (120 : int8) (10 : int8));
    goto BB37
  }
  BB37 {
    _63 <- (let (a, _) = res_58 in a);
    _62 <- ([#"../checked_ops.rs" 158 12 158 25] _63 = (-126 : int8));
    switch (_62)
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res_58 };
    _61 <- false;
    goto BB40
  }
  BB39 {
    _65 <- (let (_, a) = res_58 in a);
    assume { Resolve0.resolve res_58 };
    _64 <- ([#"../checked_ops.rs" 158 29 158 42] Bool.eqb _65 true);
    _61 <- _64;
    _64 <- any bool;
    goto BB40
  }
  BB40 {
    _60 <- not _61;
    switch (_60)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    _59 <- ();
    res_67 <- ([#"../checked_ops.rs" 159 14 159 43] OverflowingAdd0.overflowing_add (-120 : int8) (-10 : int8));
    goto BB43
  }
  BB43 {
    _72 <- (let (a, _) = res_67 in a);
    _71 <- ([#"../checked_ops.rs" 160 12 160 24] _72 = (126 : int8));
    switch (_71)
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res_67 };
    _70 <- false;
    goto BB46
  }
  BB45 {
    _74 <- (let (_, a) = res_67 in a);
    assume { Resolve0.resolve res_67 };
    _73 <- ([#"../checked_ops.rs" 160 28 160 41] Bool.eqb _74 true);
    _70 <- _73;
    _73 <- any bool;
    goto BB46
  }
  BB46 {
    _69 <- not _70;
    switch (_69)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _68 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowPos_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_add_overflow_pos [@cfg:stackify] (a : int8) : ()
    requires {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a > 0}
    
end
module CheckedOps_TestI8AddOverflowPos
  use prelude.Int8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingAdd_Interface as OverflowingAdd0
  clone Core_Num_Impl1_SaturatingAdd_Interface as SaturatingAdd0
  clone Core_Num_Impl1_WrappingAdd_Interface as WrappingAdd0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedAdd_Interface as CheckedAdd0
  let rec cfg test_i8_add_overflow_pos [@cfg:stackify] [#"../checked_ops.rs" 165 0 165 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _8 : int8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : int8;
  var _14 : int8;
  var _15 : int8;
  var _16 : int8;
  var _17 : int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : int8;
  var _24 : ();
  var res_25 : (int8, bool);
  var _26 : int8;
  var _27 : ();
  var _28 : bool;
  var _29 : bool;
  var _30 : bool;
  var _31 : int8;
  var _32 : int8;
  var _33 : int8;
  var _34 : int8;
  var _35 : bool;
  var _36 : bool;
  var _37 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 166 12 166 32] CheckedAdd0.checked_add (127 : int8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 166 12 166 42] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 167 12 167 33] WrappingAdd0.wrapping_add (127 : int8) _14);
    goto BB5
  }
  BB5 {
    _17 <- a_1;
    _16 <- ([#"../checked_ops.rs" 167 37 167 44] _17 - (127 : int8));
    _15 <- ([#"../checked_ops.rs" 167 37 167 48] _16 - (2 : int8));
    _12 <- ([#"../checked_ops.rs" 167 12 167 48] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _23 <- a_1;
    _22 <- ([#"../checked_ops.rs" 168 12 168 35] SaturatingAdd0.saturating_add (127 : int8) _23);
    goto BB8
  }
  BB8 {
    _21 <- ([#"../checked_ops.rs" 168 12 168 42] _22 = (127 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _19 <- ();
    _26 <- a_1;
    res_25 <- ([#"../checked_ops.rs" 169 14 169 38] OverflowingAdd0.overflowing_add (127 : int8) _26);
    goto BB11
  }
  BB11 {
    _31 <- (let (a, _) = res_25 in a);
    _34 <- a_1;
    _33 <- ([#"../checked_ops.rs" 170 21 170 28] _34 - (127 : int8));
    _32 <- ([#"../checked_ops.rs" 170 21 170 32] _33 - (2 : int8));
    _30 <- ([#"../checked_ops.rs" 170 12 170 32] _31 = _32);
    switch (_30)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_25 };
    _29 <- false;
    goto BB14
  }
  BB13 {
    _36 <- (let (_, a) = res_25 in a);
    assume { Resolve0.resolve res_25 };
    _35 <- ([#"../checked_ops.rs" 170 36 170 49] Bool.eqb _36 true);
    _29 <- _35;
    _35 <- any bool;
    goto BB14
  }
  BB14 {
    _28 <- not _29;
    switch (_28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _27 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowNeg_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_add_overflow_neg [@cfg:stackify] (a : int8) : ()
    requires {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a < 0}
    
end
module CheckedOps_TestI8AddOverflowNeg
  use prelude.Int8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingAdd_Interface as OverflowingAdd0
  clone Core_Num_Impl1_SaturatingAdd_Interface as SaturatingAdd0
  clone Core_Num_Impl1_WrappingAdd_Interface as WrappingAdd0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedAdd_Interface as CheckedAdd0
  let rec cfg test_i8_add_overflow_neg [@cfg:stackify] [#"../checked_ops.rs" 175 0 175 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _8 : int8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : int8;
  var _14 : int8;
  var _15 : int8;
  var _16 : int8;
  var _17 : int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : int8;
  var _24 : ();
  var res_25 : (int8, bool);
  var _26 : int8;
  var _27 : ();
  var _28 : bool;
  var _29 : bool;
  var _30 : bool;
  var _31 : int8;
  var _32 : int8;
  var _33 : int8;
  var _34 : int8;
  var _35 : bool;
  var _36 : bool;
  var _37 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 176 12 176 35] CheckedAdd0.checked_add (-128 : int8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 176 12 176 45] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 177 12 177 36] WrappingAdd0.wrapping_add (-128 : int8) _14);
    goto BB5
  }
  BB5 {
    _17 <- a_1;
    _16 <- ([#"../checked_ops.rs" 177 40 177 47] _17 + (127 : int8));
    _15 <- ([#"../checked_ops.rs" 177 40 177 51] _16 + (1 : int8));
    _12 <- ([#"../checked_ops.rs" 177 12 177 51] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _23 <- a_1;
    _22 <- ([#"../checked_ops.rs" 178 12 178 38] SaturatingAdd0.saturating_add (-128 : int8) _23);
    goto BB8
  }
  BB8 {
    _21 <- ([#"../checked_ops.rs" 178 12 178 46] _22 = (-128 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _19 <- ();
    _26 <- a_1;
    res_25 <- ([#"../checked_ops.rs" 179 14 179 41] OverflowingAdd0.overflowing_add (-128 : int8) _26);
    goto BB11
  }
  BB11 {
    _31 <- (let (a, _) = res_25 in a);
    _34 <- a_1;
    _33 <- ([#"../checked_ops.rs" 180 21 180 28] _34 + (127 : int8));
    _32 <- ([#"../checked_ops.rs" 180 21 180 32] _33 + (1 : int8));
    _30 <- ([#"../checked_ops.rs" 180 12 180 32] _31 = _32);
    switch (_30)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_25 };
    _29 <- false;
    goto BB14
  }
  BB13 {
    _36 <- (let (_, a) = res_25 in a);
    assume { Resolve0.resolve res_25 };
    _35 <- ([#"../checked_ops.rs" 180 36 180 49] Bool.eqb _36 true);
    _29 <- _35;
    _35 <- any bool;
    goto BB14
  }
  BB14 {
    _28 <- not _29;
    switch (_28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _27 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8WrappingAdd_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_wrapping_add [@cfg:stackify] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result = Int8.to_int a + Int8.to_int b \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256 \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256 }
    
end
module CheckedOps_TestI8WrappingAdd
  use prelude.Int8
  use mach.int.Int
  clone Core_Num_Impl1_WrappingAdd_Interface as WrappingAdd0
  let rec cfg test_i8_wrapping_add [@cfg:stackify] [#"../checked_ops.rs" 186 0 186 47] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result = Int8.to_int a + Int8.to_int b \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256 \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a_1 : int8;
  var b_2 : int8;
  var _4 : int8;
  var _5 : int8;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _4 <- a_1;
    _5 <- b_2;
    _0 <- ([#"../checked_ops.rs" 187 4 187 21] WrappingAdd0.wrapping_add _4 _5);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingAdd_Interface
  use mach.int.Int
  use prelude.Int8
  val test_i8_overflowing_add [@cfg:stackify] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingAdd
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedAdd_Interface as CheckedAdd0
  clone Core_Num_Impl1_WrappingAdd_Interface as WrappingAdd0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingAdd_Interface as OverflowingAdd0
  let rec cfg test_i8_overflowing_add [@cfg:stackify] [#"../checked_ops.rs" 191 0 191 44] (a : int8) (b : int8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var b_2 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : int8;
  var _7 : (int8, bool);
  var _8 : int8;
  var _9 : int8;
  var _10 : int8;
  var _11 : int8;
  var _12 : int8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (int8, bool);
  var _19 : int8;
  var _20 : int8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option int8;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _24 : int8;
  var _25 : int8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 192 12 192 32] OverflowingAdd0.overflowing_add _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 192 38 192 55] WrappingAdd0.wrapping_add _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 192 12 192 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 193 12 193 32] OverflowingAdd0.overflowing_add _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 193 38 193 54] CheckedAdd0.checked_add _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 193 38 193 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 193 12 193 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl1_CheckedSub_Interface
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
end
module Core_Num_Impl1_CheckedSub
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_sub [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
end
module Core_Num_Impl1_WrappingSub_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_sub [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_WrappingSub
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_sub [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_SaturatingSub_Interface
  use prelude.Int8
  use mach.int.Int
  val saturating_sub [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_SaturatingSub
  use prelude.Int8
  use mach.int.Int
  val saturating_sub [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_OverflowingSub_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_sub [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module Core_Num_Impl1_OverflowingSub
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_sub [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self - Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module CheckedOps_TestI8SubExample_Interface
  val test_i8_sub_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestI8SubExample
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingSub_Interface as OverflowingSub0
  clone Core_Num_Impl1_SaturatingSub_Interface as SaturatingSub0
  clone Core_Num_Impl1_WrappingSub_Interface as WrappingSub0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Num_Impl1_CheckedSub_Interface as CheckedSub0
  let rec cfg test_i8_sub_example [@cfg:stackify] [#"../checked_ops.rs" 197 0 197 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : Core_Option_Option_Type.t_option int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : int8;
  var _28 : ();
  var _29 : ();
  var _30 : bool;
  var _31 : bool;
  var _32 : int8;
  var _33 : ();
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : int8;
  var _38 : ();
  var _39 : ();
  var _40 : bool;
  var _41 : bool;
  var _42 : int8;
  var _43 : ();
  var _44 : ();
  var _45 : bool;
  var _46 : bool;
  var _47 : int8;
  var _48 : ();
  var res_49 : (int8, bool);
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : bool;
  var _54 : int8;
  var _55 : bool;
  var _56 : bool;
  var _57 : ();
  var res_58 : (int8, bool);
  var _59 : ();
  var _60 : bool;
  var _61 : bool;
  var _62 : bool;
  var _63 : int8;
  var _64 : bool;
  var _65 : bool;
  var _66 : ();
  var res_67 : (int8, bool);
  var _68 : ();
  var _69 : bool;
  var _70 : bool;
  var _71 : bool;
  var _72 : int8;
  var _73 : bool;
  var _74 : bool;
  var _75 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 198 12 198 31] CheckedSub0.checked_sub (5 : int8) (10 : int8));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 198 12 198 40] Unwrap0.unwrap _5);
    goto BB2
  }
  BB2 {
    _3 <- ([#"../checked_ops.rs" 198 12 198 46] _4 = (-5 : int8));
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 199 12 199 33] CheckedSub0.checked_sub (120 : int8) (10 : int8));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 199 12 199 42] Unwrap0.unwrap _11);
    goto BB6
  }
  BB6 {
    _9 <- ([#"../checked_ops.rs" 199 12 199 49] _10 = (110 : int8));
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _17 <- ([#"../checked_ops.rs" 200 12 200 36] CheckedSub0.checked_sub (-120 : int8) (10 : int8));
    goto BB9
  }
  BB9 {
    _16 <- _17;
    _15 <- ([#"../checked_ops.rs" 200 12 200 46] IsNone0.is_none _16);
    goto BB10
  }
  BB10 {
    _14 <- not _15;
    switch (_14)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _13 <- ();
    _22 <- ([#"../checked_ops.rs" 202 12 202 32] WrappingSub0.wrapping_sub (5 : int8) (10 : int8));
    goto BB13
  }
  BB13 {
    _21 <- ([#"../checked_ops.rs" 202 12 202 38] _22 = (-5 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _19 <- ();
    _27 <- ([#"../checked_ops.rs" 203 12 203 34] WrappingSub0.wrapping_sub (120 : int8) (10 : int8));
    goto BB16
  }
  BB16 {
    _26 <- ([#"../checked_ops.rs" 203 12 203 41] _27 = (110 : int8));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _24 <- ();
    _32 <- ([#"../checked_ops.rs" 204 12 204 37] WrappingSub0.wrapping_sub (-120 : int8) (10 : int8));
    goto BB19
  }
  BB19 {
    _31 <- ([#"../checked_ops.rs" 204 12 204 44] _32 = (126 : int8));
    _30 <- not _31;
    switch (_30)
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _29 <- ();
    _37 <- ([#"../checked_ops.rs" 206 12 206 34] SaturatingSub0.saturating_sub (5 : int8) (10 : int8));
    goto BB22
  }
  BB22 {
    _36 <- ([#"../checked_ops.rs" 206 12 206 40] _37 = (-5 : int8));
    _35 <- not _36;
    switch (_35)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _34 <- ();
    _42 <- ([#"../checked_ops.rs" 207 12 207 36] SaturatingSub0.saturating_sub (120 : int8) (10 : int8));
    goto BB25
  }
  BB25 {
    _41 <- ([#"../checked_ops.rs" 207 12 207 43] _42 = (110 : int8));
    _40 <- not _41;
    switch (_40)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _39 <- ();
    _47 <- ([#"../checked_ops.rs" 208 12 208 39] SaturatingSub0.saturating_sub (-120 : int8) (10 : int8));
    goto BB28
  }
  BB28 {
    _46 <- ([#"../checked_ops.rs" 208 12 208 47] _47 = (-128 : int8));
    _45 <- not _46;
    switch (_45)
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    _44 <- ();
    res_49 <- ([#"../checked_ops.rs" 210 14 210 37] OverflowingSub0.overflowing_sub (5 : int8) (10 : int8));
    goto BB31
  }
  BB31 {
    _54 <- (let (a, _) = res_49 in a);
    _53 <- ([#"../checked_ops.rs" 211 12 211 23] _54 = (-5 : int8));
    switch (_53)
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res_49 };
    _52 <- false;
    goto BB34
  }
  BB33 {
    _56 <- (let (_, a) = res_49 in a);
    assume { Resolve0.resolve res_49 };
    _55 <- ([#"../checked_ops.rs" 211 27 211 41] Bool.eqb _56 false);
    _52 <- _55;
    _55 <- any bool;
    goto BB34
  }
  BB34 {
    _51 <- not _52;
    switch (_51)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    _50 <- ();
    res_58 <- ([#"../checked_ops.rs" 212 14 212 39] OverflowingSub0.overflowing_sub (120 : int8) (10 : int8));
    goto BB37
  }
  BB37 {
    _63 <- (let (a, _) = res_58 in a);
    _62 <- ([#"../checked_ops.rs" 213 12 213 24] _63 = (110 : int8));
    switch (_62)
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res_58 };
    _61 <- false;
    goto BB40
  }
  BB39 {
    _65 <- (let (_, a) = res_58 in a);
    assume { Resolve0.resolve res_58 };
    _64 <- ([#"../checked_ops.rs" 213 28 213 42] Bool.eqb _65 false);
    _61 <- _64;
    _64 <- any bool;
    goto BB40
  }
  BB40 {
    _60 <- not _61;
    switch (_60)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    _59 <- ();
    res_67 <- ([#"../checked_ops.rs" 214 14 214 42] OverflowingSub0.overflowing_sub (-120 : int8) (10 : int8));
    goto BB43
  }
  BB43 {
    _72 <- (let (a, _) = res_67 in a);
    _71 <- ([#"../checked_ops.rs" 215 12 215 24] _72 = (126 : int8));
    switch (_71)
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res_67 };
    _70 <- false;
    goto BB46
  }
  BB45 {
    _74 <- (let (_, a) = res_67 in a);
    assume { Resolve0.resolve res_67 };
    _73 <- ([#"../checked_ops.rs" 215 28 215 41] Bool.eqb _74 true);
    _70 <- _73;
    _73 <- any bool;
    goto BB46
  }
  BB46 {
    _69 <- not _70;
    switch (_69)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _68 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowPos_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_sub_overflow_pos [@cfg:stackify] (a : int8) : ()
    requires {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a > 0}
    
end
module CheckedOps_TestI8SubOverflowPos
  use prelude.Int8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingSub_Interface as OverflowingSub0
  clone Core_Num_Impl1_SaturatingSub_Interface as SaturatingSub0
  clone Core_Num_Impl1_WrappingSub_Interface as WrappingSub0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedSub_Interface as CheckedSub0
  let rec cfg test_i8_sub_overflow_pos [@cfg:stackify] [#"../checked_ops.rs" 220 0 220 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _8 : int8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : int8;
  var _14 : int8;
  var _15 : int8;
  var _16 : int8;
  var _17 : int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : int8;
  var _24 : ();
  var res_25 : (int8, bool);
  var _26 : int8;
  var _27 : ();
  var _28 : bool;
  var _29 : bool;
  var _30 : bool;
  var _31 : int8;
  var _32 : int8;
  var _33 : int8;
  var _34 : int8;
  var _35 : bool;
  var _36 : bool;
  var _37 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 221 12 221 35] CheckedSub0.checked_sub (-128 : int8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 221 12 221 45] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 222 12 222 36] WrappingSub0.wrapping_sub (-128 : int8) _14);
    goto BB5
  }
  BB5 {
    _17 <- a_1;
    _16 <- ([#"../checked_ops.rs" 222 40 222 47] (127 : int8) - _17);
    _15 <- ([#"../checked_ops.rs" 222 40 222 51] _16 + (1 : int8));
    _12 <- ([#"../checked_ops.rs" 222 12 222 51] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _23 <- a_1;
    _22 <- ([#"../checked_ops.rs" 223 12 223 38] SaturatingSub0.saturating_sub (-128 : int8) _23);
    goto BB8
  }
  BB8 {
    _21 <- ([#"../checked_ops.rs" 223 12 223 46] _22 = (-128 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _19 <- ();
    _26 <- a_1;
    res_25 <- ([#"../checked_ops.rs" 224 14 224 41] OverflowingSub0.overflowing_sub (-128 : int8) _26);
    goto BB11
  }
  BB11 {
    _31 <- (let (a, _) = res_25 in a);
    _34 <- a_1;
    _33 <- ([#"../checked_ops.rs" 225 21 225 28] (127 : int8) - _34);
    _32 <- ([#"../checked_ops.rs" 225 21 225 32] _33 + (1 : int8));
    _30 <- ([#"../checked_ops.rs" 225 12 225 32] _31 = _32);
    switch (_30)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_25 };
    _29 <- false;
    goto BB14
  }
  BB13 {
    _36 <- (let (_, a) = res_25 in a);
    assume { Resolve0.resolve res_25 };
    _35 <- ([#"../checked_ops.rs" 225 36 225 49] Bool.eqb _36 true);
    _29 <- _35;
    _35 <- any bool;
    goto BB14
  }
  BB14 {
    _28 <- not _29;
    switch (_28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _27 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowNeg_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_sub_overflow_neg [@cfg:stackify] (a : int8) : ()
    requires {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a < 0}
    
end
module CheckedOps_TestI8SubOverflowNeg
  use prelude.Int8
  use mach.int.Int
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingSub_Interface as OverflowingSub0
  clone Core_Num_Impl1_SaturatingSub_Interface as SaturatingSub0
  clone Core_Num_Impl1_WrappingSub_Interface as WrappingSub0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedSub_Interface as CheckedSub0
  let rec cfg test_i8_sub_overflow_neg [@cfg:stackify] [#"../checked_ops.rs" 230 0 230 38] (a : int8) : ()
    requires {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _8 : int8;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : bool;
  var _13 : int8;
  var _14 : int8;
  var _15 : int8;
  var _16 : int8;
  var _17 : int8;
  var _18 : int8;
  var _19 : ();
  var _20 : ();
  var _21 : bool;
  var _22 : bool;
  var _23 : int8;
  var _24 : int8;
  var _25 : ();
  var res_26 : (int8, bool);
  var _27 : int8;
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : bool;
  var _32 : int8;
  var _33 : int8;
  var _34 : int8;
  var _35 : int8;
  var _36 : int8;
  var _37 : bool;
  var _38 : bool;
  var _39 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _7 <- ([#"../checked_ops.rs" 231 12 231 32] CheckedSub0.checked_sub (127 : int8) _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _5 <- ([#"../checked_ops.rs" 231 12 231 42] IsNone0.is_none _6);
    goto BB2
  }
  BB2 {
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _14 <- a_1;
    _13 <- ([#"../checked_ops.rs" 232 12 232 33] WrappingSub0.wrapping_sub (127 : int8) _14);
    goto BB5
  }
  BB5 {
    _18 <- a_1;
    _17 <- ([#"../checked_ops.rs" 232 38 232 45] (2 : int8) + _18);
    _16 <- - _17;
    _15 <- ([#"../checked_ops.rs" 232 37 232 51] _16 - (127 : int8));
    _12 <- ([#"../checked_ops.rs" 232 12 232 51] _13 = _15);
    _11 <- not _12;
    switch (_11)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _10 <- ();
    _24 <- a_1;
    _23 <- ([#"../checked_ops.rs" 233 12 233 35] SaturatingSub0.saturating_sub (127 : int8) _24);
    goto BB8
  }
  BB8 {
    _22 <- ([#"../checked_ops.rs" 233 12 233 42] _23 = (127 : int8));
    _21 <- not _22;
    switch (_21)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _20 <- ();
    _27 <- a_1;
    res_26 <- ([#"../checked_ops.rs" 234 14 234 38] OverflowingSub0.overflowing_sub (127 : int8) _27);
    goto BB11
  }
  BB11 {
    _32 <- (let (a, _) = res_26 in a);
    _36 <- a_1;
    _35 <- ([#"../checked_ops.rs" 235 22 235 29] (2 : int8) + _36);
    _34 <- - _35;
    _33 <- ([#"../checked_ops.rs" 235 21 235 35] _34 - (127 : int8));
    _31 <- ([#"../checked_ops.rs" 235 12 235 35] _32 = _33);
    switch (_31)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_26 };
    _30 <- false;
    goto BB14
  }
  BB13 {
    _38 <- (let (_, a) = res_26 in a);
    assume { Resolve0.resolve res_26 };
    _37 <- ([#"../checked_ops.rs" 235 39 235 52] Bool.eqb _38 true);
    _30 <- _37;
    _37 <- any bool;
    goto BB14
  }
  BB14 {
    _29 <- not _30;
    switch (_29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _28 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8WrappingSub_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_wrapping_sub [@cfg:stackify] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result = Int8.to_int a - Int8.to_int b \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256 \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256 }
    
end
module CheckedOps_TestI8WrappingSub
  use prelude.Int8
  use mach.int.Int
  clone Core_Num_Impl1_WrappingSub_Interface as WrappingSub0
  let rec cfg test_i8_wrapping_sub [@cfg:stackify] [#"../checked_ops.rs" 241 0 241 47] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result = Int8.to_int a - Int8.to_int b \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256 \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a_1 : int8;
  var b_2 : int8;
  var _4 : int8;
  var _5 : int8;
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _4 <- a_1;
    _5 <- b_2;
    _0 <- ([#"../checked_ops.rs" 242 4 242 21] WrappingSub0.wrapping_sub _4 _5);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingSub_Interface
  use mach.int.Int
  use prelude.Int8
  val test_i8_overflowing_sub [@cfg:stackify] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingSub
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedSub_Interface as CheckedSub0
  clone Core_Num_Impl1_WrappingSub_Interface as WrappingSub0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingSub_Interface as OverflowingSub0
  let rec cfg test_i8_overflowing_sub [@cfg:stackify] [#"../checked_ops.rs" 246 0 246 44] (a : int8) (b : int8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var b_2 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : int8;
  var _7 : (int8, bool);
  var _8 : int8;
  var _9 : int8;
  var _10 : int8;
  var _11 : int8;
  var _12 : int8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (int8, bool);
  var _19 : int8;
  var _20 : int8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option int8;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _24 : int8;
  var _25 : int8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 247 12 247 32] OverflowingSub0.overflowing_sub _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 247 38 247 55] WrappingSub0.wrapping_sub _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 247 12 247 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 248 12 248 32] OverflowingSub0.overflowing_sub _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 248 38 248 54] CheckedSub0.checked_sub _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 248 38 248 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 248 12 248 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl1_CheckedMul_Interface
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
end
module Core_Num_Impl1_CheckedMul
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_mul [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8)) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
end
module Core_Num_Impl1_WrappingMul_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_mul [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_WrappingMul
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val wrapping_mul [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    
end
module Core_Num_Impl1_SaturatingMul_Interface
  use prelude.Int8
  use mach.int.Int
  val saturating_mul [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_SaturatingMul
  use prelude.Int8
  use mach.int.Int
  val saturating_mul [@cfg:stackify] (self : int8) (rhs : int8) : int8
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> Int8.to_int result = Int8.to_int (127 : int8) }
    
end
module Core_Num_Impl1_OverflowingMul_Interface
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_mul [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module Core_Num_Impl1_OverflowingMul
  use prelude.Int8
  use mach.int.Int
  use mach.int.UInt32
  use int.Power
  use int.EuclideanDivision
  val overflowing_mul [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    ensures { Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (8 : uint32))) + Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self * Int8.to_int rhs >= Int8.to_int (-128 : int8) /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (127 : int8) -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8) -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (127 : int8) - Int8.to_int (-128 : int8) + 1)) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (-128 : int8) \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (127 : int8)) }
    
end
module CheckedOps_TestI8MulExample_Interface
  val test_i8_mul_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestI8MulExample
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingMul_Interface as OverflowingMul0
  clone Core_Num_Impl1_SaturatingMul_Interface as SaturatingMul0
  clone Core_Num_Impl1_WrappingMul_Interface as WrappingMul0
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Num_Impl1_CheckedMul_Interface as CheckedMul0
  let rec cfg test_i8_mul_example [@cfg:stackify] [#"../checked_ops.rs" 252 0 252 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : Core_Option_Option_Type.t_option int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : Core_Option_Option_Type.t_option int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : int8;
  var _28 : ();
  var _29 : ();
  var _30 : bool;
  var _31 : bool;
  var _32 : int8;
  var _33 : ();
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : int8;
  var _38 : ();
  var _39 : ();
  var _40 : bool;
  var _41 : bool;
  var _42 : int8;
  var _43 : ();
  var _44 : ();
  var _45 : bool;
  var _46 : bool;
  var _47 : int8;
  var _48 : ();
  var res_49 : (int8, bool);
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : bool;
  var _54 : int8;
  var _55 : bool;
  var _56 : bool;
  var _57 : ();
  var res_58 : (int8, bool);
  var _59 : ();
  var _60 : bool;
  var _61 : bool;
  var _62 : bool;
  var _63 : int8;
  var _64 : bool;
  var _65 : bool;
  var _66 : ();
  var res_67 : (int8, bool);
  var _68 : ();
  var _69 : bool;
  var _70 : bool;
  var _71 : bool;
  var _72 : int8;
  var _73 : bool;
  var _74 : bool;
  var _75 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 253 12 253 31] CheckedMul0.checked_mul (5 : int8) (10 : int8));
    goto BB1
  }
  BB1 {
    _4 <- ([#"../checked_ops.rs" 253 12 253 40] Unwrap0.unwrap _5);
    goto BB2
  }
  BB2 {
    _3 <- ([#"../checked_ops.rs" 253 12 253 46] _4 = (50 : int8));
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 254 12 254 32] CheckedMul0.checked_mul (50 : int8) (10 : int8));
    goto BB5
  }
  BB5 {
    _10 <- _11;
    _9 <- ([#"../checked_ops.rs" 254 12 254 42] IsNone0.is_none _10);
    goto BB6
  }
  BB6 {
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _17 <- ([#"../checked_ops.rs" 255 12 255 33] CheckedMul0.checked_mul (50 : int8) (-10 : int8));
    goto BB9
  }
  BB9 {
    _16 <- _17;
    _15 <- ([#"../checked_ops.rs" 255 12 255 43] IsNone0.is_none _16);
    goto BB10
  }
  BB10 {
    _14 <- not _15;
    switch (_14)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _13 <- ();
    _22 <- ([#"../checked_ops.rs" 257 12 257 32] WrappingMul0.wrapping_mul (5 : int8) (10 : int8));
    goto BB13
  }
  BB13 {
    _21 <- ([#"../checked_ops.rs" 257 12 257 38] _22 = (50 : int8));
    _20 <- not _21;
    switch (_20)
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    absurd
  }
  BB15 {
    _19 <- ();
    _27 <- ([#"../checked_ops.rs" 258 12 258 33] WrappingMul0.wrapping_mul (50 : int8) (10 : int8));
    goto BB16
  }
  BB16 {
    _26 <- ([#"../checked_ops.rs" 258 12 258 40] _27 = (-12 : int8));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _24 <- ();
    _32 <- ([#"../checked_ops.rs" 259 12 259 34] WrappingMul0.wrapping_mul (50 : int8) (-10 : int8));
    goto BB19
  }
  BB19 {
    _31 <- ([#"../checked_ops.rs" 259 12 259 40] _32 = (12 : int8));
    _30 <- not _31;
    switch (_30)
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    absurd
  }
  BB21 {
    _29 <- ();
    _37 <- ([#"../checked_ops.rs" 261 12 261 34] SaturatingMul0.saturating_mul (5 : int8) (10 : int8));
    goto BB22
  }
  BB22 {
    _36 <- ([#"../checked_ops.rs" 261 12 261 40] _37 = (50 : int8));
    _35 <- not _36;
    switch (_35)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _34 <- ();
    _42 <- ([#"../checked_ops.rs" 262 12 262 35] SaturatingMul0.saturating_mul (50 : int8) (10 : int8));
    goto BB25
  }
  BB25 {
    _41 <- ([#"../checked_ops.rs" 262 12 262 42] _42 = (127 : int8));
    _40 <- not _41;
    switch (_40)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _39 <- ();
    _47 <- ([#"../checked_ops.rs" 263 12 263 36] SaturatingMul0.saturating_mul (50 : int8) (-10 : int8));
    goto BB28
  }
  BB28 {
    _46 <- ([#"../checked_ops.rs" 263 12 263 44] _47 = (-128 : int8));
    _45 <- not _46;
    switch (_45)
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    _44 <- ();
    res_49 <- ([#"../checked_ops.rs" 265 14 265 37] OverflowingMul0.overflowing_mul (5 : int8) (10 : int8));
    goto BB31
  }
  BB31 {
    _54 <- (let (a, _) = res_49 in a);
    _53 <- ([#"../checked_ops.rs" 266 12 266 23] _54 = (50 : int8));
    switch (_53)
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { Resolve0.resolve res_49 };
    _52 <- false;
    goto BB34
  }
  BB33 {
    _56 <- (let (_, a) = res_49 in a);
    assume { Resolve0.resolve res_49 };
    _55 <- ([#"../checked_ops.rs" 266 27 266 41] Bool.eqb _56 false);
    _52 <- _55;
    _55 <- any bool;
    goto BB34
  }
  BB34 {
    _51 <- not _52;
    switch (_51)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    _50 <- ();
    res_58 <- ([#"../checked_ops.rs" 267 14 267 38] OverflowingMul0.overflowing_mul (50 : int8) (10 : int8));
    goto BB37
  }
  BB37 {
    _63 <- (let (a, _) = res_58 in a);
    _62 <- ([#"../checked_ops.rs" 268 12 268 24] _63 = (-12 : int8));
    switch (_62)
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { Resolve0.resolve res_58 };
    _61 <- false;
    goto BB40
  }
  BB39 {
    _65 <- (let (_, a) = res_58 in a);
    assume { Resolve0.resolve res_58 };
    _64 <- ([#"../checked_ops.rs" 268 28 268 41] Bool.eqb _65 true);
    _61 <- _64;
    _64 <- any bool;
    goto BB40
  }
  BB40 {
    _60 <- not _61;
    switch (_60)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    _59 <- ();
    res_67 <- ([#"../checked_ops.rs" 269 14 269 39] OverflowingMul0.overflowing_mul (50 : int8) (-10 : int8));
    goto BB43
  }
  BB43 {
    _72 <- (let (a, _) = res_67 in a);
    _71 <- ([#"../checked_ops.rs" 270 12 270 23] _72 = (12 : int8));
    switch (_71)
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { Resolve0.resolve res_67 };
    _70 <- false;
    goto BB46
  }
  BB45 {
    _74 <- (let (_, a) = res_67 in a);
    assume { Resolve0.resolve res_67 };
    _73 <- ([#"../checked_ops.rs" 270 27 270 40] Bool.eqb _74 true);
    _70 <- _73;
    _73 <- any bool;
    goto BB46
  }
  BB46 {
    _69 <- not _70;
    switch (_69)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _68 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8MulZero_Interface
  use mach.int.Int
  use prelude.Int8
  val test_i8_mul_zero [@cfg:stackify] (a : int8) : ()
end
module CheckedOps_TestI8MulZero
  use mach.int.Int
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingMul_Interface as OverflowingMul0
  clone Core_Num_Impl1_SaturatingMul_Interface as SaturatingMul0
  clone Core_Num_Impl1_WrappingMul_Interface as WrappingMul0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Num_Impl1_CheckedMul_Interface as CheckedMul0
  let rec cfg test_i8_mul_zero [@cfg:stackify] [#"../checked_ops.rs" 274 0 274 30] (a : int8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _2 : ();
  var _3 : bool;
  var _4 : bool;
  var _5 : int8;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : int8;
  var _8 : ();
  var _9 : ();
  var _10 : bool;
  var _11 : bool;
  var _12 : int8;
  var _13 : int8;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : bool;
  var _18 : int8;
  var _19 : int8;
  var _20 : ();
  var res_21 : (int8, bool);
  var _22 : int8;
  var _23 : ();
  var _24 : bool;
  var _25 : bool;
  var _26 : bool;
  var _27 : int8;
  var _28 : bool;
  var _29 : bool;
  var _30 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _7 <- a_1;
    _6 <- ([#"../checked_ops.rs" 275 12 275 30] CheckedMul0.checked_mul (0 : int8) _7);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../checked_ops.rs" 275 12 275 39] Unwrap0.unwrap _6);
    goto BB2
  }
  BB2 {
    _4 <- ([#"../checked_ops.rs" 275 12 275 44] _5 = (0 : int8));
    _3 <- not _4;
    switch (_3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _2 <- ();
    _13 <- a_1;
    _12 <- ([#"../checked_ops.rs" 276 12 276 31] WrappingMul0.wrapping_mul (0 : int8) _13);
    goto BB5
  }
  BB5 {
    _11 <- ([#"../checked_ops.rs" 276 12 276 36] _12 = (0 : int8));
    _10 <- not _11;
    switch (_10)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    absurd
  }
  BB7 {
    _9 <- ();
    _19 <- a_1;
    _18 <- ([#"../checked_ops.rs" 277 12 277 33] SaturatingMul0.saturating_mul (0 : int8) _19);
    goto BB8
  }
  BB8 {
    _17 <- ([#"../checked_ops.rs" 277 12 277 38] _18 = (0 : int8));
    _16 <- not _17;
    switch (_16)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    absurd
  }
  BB10 {
    _15 <- ();
    _22 <- a_1;
    res_21 <- ([#"../checked_ops.rs" 278 14 278 36] OverflowingMul0.overflowing_mul (0 : int8) _22);
    goto BB11
  }
  BB11 {
    _27 <- (let (a, _) = res_21 in a);
    _26 <- ([#"../checked_ops.rs" 279 12 279 22] _27 = (0 : int8));
    switch (_26)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { Resolve0.resolve res_21 };
    _25 <- false;
    goto BB14
  }
  BB13 {
    _29 <- (let (_, a) = res_21 in a);
    assume { Resolve0.resolve res_21 };
    _28 <- ([#"../checked_ops.rs" 279 26 279 40] Bool.eqb _29 false);
    _25 <- _28;
    _28 <- any bool;
    goto BB14
  }
  BB14 {
    _24 <- not _25;
    switch (_24)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _23 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingMul_Interface
  use mach.int.Int
  use prelude.Int8
  val test_i8_overflowing_mul [@cfg:stackify] (a : int8) (b : int8) : ()
end
module CheckedOps_TestI8OverflowingMul
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedMul_Interface as CheckedMul0
  clone Core_Num_Impl1_WrappingMul_Interface as WrappingMul0
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingMul_Interface as OverflowingMul0
  let rec cfg test_i8_overflowing_mul [@cfg:stackify] [#"../checked_ops.rs" 283 0 283 44] (a : int8) (b : int8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var b_2 : int8;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : int8;
  var _7 : (int8, bool);
  var _8 : int8;
  var _9 : int8;
  var _10 : int8;
  var _11 : int8;
  var _12 : int8;
  var _13 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : (int8, bool);
  var _19 : int8;
  var _20 : int8;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option int8;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _24 : int8;
  var _25 : int8;
  var _26 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _8 <- a_1;
    _9 <- b_2;
    _7 <- ([#"../checked_ops.rs" 284 12 284 32] OverflowingMul0.overflowing_mul _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- (let (a, _) = _7 in a);
    assume { Resolve0.resolve _7 };
    _11 <- a_1;
    _12 <- b_2;
    _10 <- ([#"../checked_ops.rs" 284 38 284 55] WrappingMul0.wrapping_mul _11 _12);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../checked_ops.rs" 284 12 284 55] _6 = _10);
    _4 <- not _5;
    switch (_4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _3 <- ();
    _19 <- a_1;
    _20 <- b_2;
    _18 <- ([#"../checked_ops.rs" 285 12 285 32] OverflowingMul0.overflowing_mul _19 _20);
    goto BB5
  }
  BB5 {
    _17 <- (let (_, a) = _18 in a);
    assume { Resolve0.resolve _18 };
    _24 <- a_1;
    _25 <- b_2;
    _23 <- ([#"../checked_ops.rs" 285 38 285 54] CheckedMul0.checked_mul _24 _25);
    goto BB6
  }
  BB6 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 285 38 285 64] IsNone0.is_none _22);
    goto BB7
  }
  BB7 {
    _16 <- ([#"../checked_ops.rs" 285 12 285 64] Bool.eqb _17 _21);
    _15 <- not _16;
    switch (_15)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    absurd
  }
  BB9 {
    _14 <- ();
    _0 <- ();
    return _0
  }
  
end
module Core_Num_Impl1_CheckedDiv_Interface
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_CheckedDiv
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  val checked_div [@cfg:stackify] (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1) }
    ensures { forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_WrappingDiv_Interface
  use prelude.Int8
  use mach.int.Int
  val wrapping_div [@cfg:stackify] (self : int8) (rhs : int8) : int8
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int self }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_WrappingDiv
  use prelude.Int8
  use mach.int.Int
  val wrapping_div [@cfg:stackify] (self : int8) (rhs : int8) : int8
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int self }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_SaturatingDiv_Interface
  use prelude.Int8
  use mach.int.Int
  val saturating_div [@cfg:stackify] (self : int8) (rhs : int8) : int8
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_SaturatingDiv
  use prelude.Int8
  use mach.int.Int
  val saturating_div [@cfg:stackify] (self : int8) (rhs : int8) : int8
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int (-128 : int8) }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
end
module Core_Num_Impl1_OverflowingDiv_Interface
  use prelude.Int8
  use mach.int.Int
  val overflowing_div [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1) }
    
end
module Core_Num_Impl1_OverflowingDiv
  use prelude.Int8
  use mach.int.Int
  val overflowing_div [@cfg:stackify] (self : int8) (rhs : int8) : (int8, bool)
    requires {Int8.to_int rhs <> 0}
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self }
    ensures { Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1 \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs) }
    ensures { (let (_, a) = result in a) = (Int8.to_int self = Int8.to_int (-128 : int8) /\ Int8.to_int rhs = - 1) }
    
end
module CheckedOps_TestI8DivExample_Interface
  val test_i8_div_example [@cfg:stackify] (_ : ()) : ()
end
module CheckedOps_TestI8DivExample
  use prelude.Borrow
  use mach.int.Int
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingDiv_Interface as OverflowingDiv0
  clone Core_Num_Impl1_SaturatingDiv_Interface as SaturatingDiv0
  clone Core_Num_Impl1_WrappingDiv_Interface as WrappingDiv0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_i8_div_example [@cfg:stackify] [#"../checked_ops.rs" 289 0 289 28] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : ();
  var _2 : bool;
  var _3 : bool;
  var _4 : Core_Option_Option_Type.t_option int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _6 : ();
  var _7 : ();
  var _8 : bool;
  var _9 : bool;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : bool;
  var _16 : int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : Core_Option_Option_Type.t_option int8;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _24 : ();
  var _25 : ();
  var _26 : bool;
  var _27 : bool;
  var _28 : int8;
  var _29 : ();
  var _30 : ();
  var _31 : bool;
  var _32 : bool;
  var _33 : int8;
  var _34 : ();
  var _35 : ();
  var _36 : bool;
  var _37 : bool;
  var _38 : int8;
  var _39 : ();
  var _40 : ();
  var _41 : bool;
  var _42 : bool;
  var _43 : int8;
  var _44 : ();
  var _45 : ();
  var _46 : bool;
  var _47 : bool;
  var _48 : int8;
  var _49 : ();
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : int8;
  var _54 : ();
  var res_55 : (int8, bool);
  var _56 : ();
  var _57 : bool;
  var _58 : bool;
  var _59 : bool;
  var _60 : int8;
  var _61 : bool;
  var _62 : bool;
  var _63 : ();
  var res_64 : (int8, bool);
  var _65 : ();
  var _66 : bool;
  var _67 : bool;
  var _68 : bool;
  var _69 : int8;
  var _70 : bool;
  var _71 : bool;
  var _72 : ();
  var res_73 : (int8, bool);
  var _74 : ();
  var _75 : bool;
  var _76 : bool;
  var _77 : bool;
  var _78 : int8;
  var _79 : bool;
  var _80 : bool;
  var _81 : ();
  {
    goto BB0
  }
  BB0 {
    _5 <- ([#"../checked_ops.rs" 290 12 290 30] CheckedDiv0.checked_div (5 : int8) (0 : int8));
    goto BB1
  }
  BB1 {
    _4 <- _5;
    _3 <- ([#"../checked_ops.rs" 290 12 290 40] IsNone0.is_none _4);
    goto BB2
  }
  BB2 {
    _2 <- not _3;
    switch (_2)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _1 <- ();
    _11 <- ([#"../checked_ops.rs" 291 12 291 30] CheckedDiv0.checked_div (5 : int8) (2 : int8));
    goto BB5
  }
  BB5 {
    _10 <- ([#"../checked_ops.rs" 291 12 291 39] Unwrap0.unwrap _11);
    goto BB6
  }
  BB6 {
    _9 <- ([#"../checked_ops.rs" 291 12 291 44] _10 = (2 : int8));
    _8 <- not _9;
    switch (_8)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    absurd
  }
  BB8 {
    _7 <- ();
    _17 <- ([#"../checked_ops.rs" 292 12 292 31] CheckedDiv0.checked_div (5 : int8) (-2 : int8));
    goto BB9
  }
  BB9 {
    _16 <- ([#"../checked_ops.rs" 292 12 292 40] Unwrap0.unwrap _17);
    goto BB10
  }
  BB10 {
    _15 <- ([#"../checked_ops.rs" 292 12 292 46] _16 = (-2 : int8));
    _14 <- not _15;
    switch (_14)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    absurd
  }
  BB12 {
    _13 <- ();
    _23 <- ([#"../checked_ops.rs" 293 12 293 36] CheckedDiv0.checked_div (-128 : int8) (-1 : int8));
    goto BB13
  }
  BB13 {
    _22 <- _23;
    _21 <- ([#"../checked_ops.rs" 293 12 293 46] IsNone0.is_none _22);
    goto BB14
  }
  BB14 {
    _20 <- not _21;
    switch (_20)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _19 <- ();
    _28 <- ([#"../checked_ops.rs" 295 12 295 31] WrappingDiv0.wrapping_div (5 : int8) (2 : int8));
    goto BB17
  }
  BB17 {
    _27 <- ([#"../checked_ops.rs" 295 12 295 36] _28 = (2 : int8));
    _26 <- not _27;
    switch (_26)
      | False -> goto BB19
      | True -> goto BB18
      end
  }
  BB18 {
    absurd
  }
  BB19 {
    _25 <- ();
    _33 <- ([#"../checked_ops.rs" 296 12 296 32] WrappingDiv0.wrapping_div (5 : int8) (-2 : int8));
    goto BB20
  }
  BB20 {
    _32 <- ([#"../checked_ops.rs" 296 12 296 38] _33 = (-2 : int8));
    _31 <- not _32;
    switch (_31)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    absurd
  }
  BB22 {
    _30 <- ();
    _38 <- ([#"../checked_ops.rs" 297 12 297 37] WrappingDiv0.wrapping_div (-128 : int8) (-1 : int8));
    goto BB23
  }
  BB23 {
    _37 <- ([#"../checked_ops.rs" 297 12 297 45] _38 = (-128 : int8));
    _36 <- not _37;
    switch (_36)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB24 {
    absurd
  }
  BB25 {
    _35 <- ();
    _43 <- ([#"../checked_ops.rs" 299 12 299 33] SaturatingDiv0.saturating_div (5 : int8) (2 : int8));
    goto BB26
  }
  BB26 {
    _42 <- ([#"../checked_ops.rs" 299 12 299 38] _43 = (2 : int8));
    _41 <- not _42;
    switch (_41)
      | False -> goto BB28
      | True -> goto BB27
      end
  }
  BB27 {
    absurd
  }
  BB28 {
    _40 <- ();
    _48 <- ([#"../checked_ops.rs" 300 12 300 34] SaturatingDiv0.saturating_div (5 : int8) (-2 : int8));
    goto BB29
  }
  BB29 {
    _47 <- ([#"../checked_ops.rs" 300 12 300 40] _48 = (-2 : int8));
    _46 <- not _47;
    switch (_46)
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    absurd
  }
  BB31 {
    _45 <- ();
    _53 <- ([#"../checked_ops.rs" 301 12 301 39] SaturatingDiv0.saturating_div (-128 : int8) (-1 : int8));
    goto BB32
  }
  BB32 {
    _52 <- ([#"../checked_ops.rs" 301 12 301 47] _53 = (-128 : int8));
    _51 <- not _52;
    switch (_51)
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    absurd
  }
  BB34 {
    _50 <- ();
    res_55 <- ([#"../checked_ops.rs" 303 14 303 36] OverflowingDiv0.overflowing_div (5 : int8) (2 : int8));
    goto BB35
  }
  BB35 {
    _60 <- (let (a, _) = res_55 in a);
    _59 <- ([#"../checked_ops.rs" 304 12 304 22] _60 = (2 : int8));
    switch (_59)
      | False -> goto BB36
      | True -> goto BB37
      end
  }
  BB36 {
    assume { Resolve0.resolve res_55 };
    _58 <- false;
    goto BB38
  }
  BB37 {
    _62 <- (let (_, a) = res_55 in a);
    assume { Resolve0.resolve res_55 };
    _61 <- ([#"../checked_ops.rs" 304 26 304 40] Bool.eqb _62 false);
    _58 <- _61;
    _61 <- any bool;
    goto BB38
  }
  BB38 {
    _57 <- not _58;
    switch (_57)
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    absurd
  }
  BB40 {
    _56 <- ();
    res_64 <- ([#"../checked_ops.rs" 305 14 305 37] OverflowingDiv0.overflowing_div (5 : int8) (-2 : int8));
    goto BB41
  }
  BB41 {
    _69 <- (let (a, _) = res_64 in a);
    _68 <- ([#"../checked_ops.rs" 306 12 306 23] _69 = (-2 : int8));
    switch (_68)
      | False -> goto BB42
      | True -> goto BB43
      end
  }
  BB42 {
    assume { Resolve0.resolve res_64 };
    _67 <- false;
    goto BB44
  }
  BB43 {
    _71 <- (let (_, a) = res_64 in a);
    assume { Resolve0.resolve res_64 };
    _70 <- ([#"../checked_ops.rs" 306 27 306 41] Bool.eqb _71 false);
    _67 <- _70;
    _70 <- any bool;
    goto BB44
  }
  BB44 {
    _66 <- not _67;
    switch (_66)
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    absurd
  }
  BB46 {
    _65 <- ();
    res_73 <- ([#"../checked_ops.rs" 307 14 307 42] OverflowingDiv0.overflowing_div (-128 : int8) (-1 : int8));
    goto BB47
  }
  BB47 {
    _78 <- (let (a, _) = res_73 in a);
    _77 <- ([#"../checked_ops.rs" 308 12 308 25] _78 = (-128 : int8));
    switch (_77)
      | False -> goto BB48
      | True -> goto BB49
      end
  }
  BB48 {
    assume { Resolve0.resolve res_73 };
    _76 <- false;
    goto BB50
  }
  BB49 {
    _80 <- (let (_, a) = res_73 in a);
    assume { Resolve0.resolve res_73 };
    _79 <- ([#"../checked_ops.rs" 308 29 308 42] Bool.eqb _80 true);
    _76 <- _79;
    _79 <- any bool;
    goto BB50
  }
  BB50 {
    _75 <- not _76;
    switch (_75)
      | False -> goto BB52
      | True -> goto BB51
      end
  }
  BB51 {
    absurd
  }
  BB52 {
    _74 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8DivNoOverflow_Interface
  use prelude.Int8
  use mach.int.Int
  val test_i8_div_no_overflow [@cfg:stackify] (a : int8) (b : int8) : ()
    requires {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    
end
module CheckedOps_TestI8DivNoOverflow
  use prelude.Int8
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with
    type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with
    type t = int8
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = int8,
    type t2 = bool,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Core_Num_Impl1_OverflowingDiv_Interface as OverflowingDiv0
  clone Core_Num_Impl1_SaturatingDiv_Interface as SaturatingDiv0
  clone Core_Num_Impl1_WrappingDiv_Interface as WrappingDiv0
  clone Core_Option_Impl0_Unwrap_Interface as Unwrap0 with
    type t = int8
  clone Core_Num_Impl1_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_i8_div_no_overflow [@cfg:stackify] [#"../checked_ops.rs" 313 0 313 44] (a : int8) (b : int8) : ()
    requires {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var b_2 : int8;
  var _4 : ();
  var _5 : bool;
  var _6 : bool;
  var _7 : int8;
  var _8 : Core_Option_Option_Type.t_option int8;
  var _9 : int8;
  var _10 : int8;
  var _11 : int8;
  var _12 : int8;
  var _13 : int8;
  var _14 : bool;
  var _15 : bool;
  var _16 : bool;
  var _17 : bool;
  var _18 : ();
  var _19 : ();
  var _20 : bool;
  var _21 : bool;
  var _22 : int8;
  var _23 : int8;
  var _24 : int8;
  var _25 : int8;
  var _26 : int8;
  var _27 : int8;
  var _28 : bool;
  var _29 : bool;
  var _30 : bool;
  var _31 : bool;
  var _32 : ();
  var _33 : ();
  var _34 : bool;
  var _35 : bool;
  var _36 : int8;
  var _37 : int8;
  var _38 : int8;
  var _39 : int8;
  var _40 : int8;
  var _41 : int8;
  var _42 : bool;
  var _43 : bool;
  var _44 : bool;
  var _45 : bool;
  var _46 : ();
  var res_47 : (int8, bool);
  var _48 : int8;
  var _49 : int8;
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : bool;
  var _54 : int8;
  var _55 : int8;
  var _56 : int8;
  var _57 : int8;
  var _58 : bool;
  var _59 : bool;
  var _60 : bool;
  var _61 : bool;
  var _62 : bool;
  var _63 : bool;
  var _64 : ();
  {
    a_1 <- a;
    b_2 <- b;
    goto BB0
  }
  BB0 {
    _9 <- a_1;
    _10 <- b_2;
    _8 <- ([#"../checked_ops.rs" 314 12 314 28] CheckedDiv0.checked_div _9 _10);
    goto BB1
  }
  BB1 {
    _7 <- ([#"../checked_ops.rs" 314 12 314 37] Unwrap0.unwrap _8);
    goto BB2
  }
  BB2 {
    _12 <- a_1;
    _13 <- b_2;
    _14 <- ([#"../checked_ops.rs" 314 41 314 46] _13 = (0 : int8));
    assert { [#"../checked_ops.rs" 314 41 314 46] not _14 };
    goto BB3
  }
  BB3 {
    _15 <- ([#"../checked_ops.rs" 314 41 314 46] _13 = (-1 : int8));
    _16 <- ([#"../checked_ops.rs" 314 41 314 46] _12 = (-128 : int8));
    _17 <- ([#"../checked_ops.rs" 314 41 314 46] _15 && _16);
    assert { [#"../checked_ops.rs" 314 41 314 46] not _17 };
    goto BB4
  }
  BB4 {
    _11 <- ([#"../checked_ops.rs" 314 41 314 46] _12 / _13);
    _6 <- ([#"../checked_ops.rs" 314 12 314 46] _7 = _11);
    _5 <- not _6;
    switch (_5)
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB5 {
    absurd
  }
  BB6 {
    _4 <- ();
    _23 <- a_1;
    _24 <- b_2;
    _22 <- ([#"../checked_ops.rs" 315 12 315 29] WrappingDiv0.wrapping_div _23 _24);
    goto BB7
  }
  BB7 {
    _26 <- a_1;
    _27 <- b_2;
    _28 <- ([#"../checked_ops.rs" 315 33 315 38] _27 = (0 : int8));
    assert { [#"../checked_ops.rs" 315 33 315 38] not _28 };
    goto BB8
  }
  BB8 {
    _29 <- ([#"../checked_ops.rs" 315 33 315 38] _27 = (-1 : int8));
    _30 <- ([#"../checked_ops.rs" 315 33 315 38] _26 = (-128 : int8));
    _31 <- ([#"../checked_ops.rs" 315 33 315 38] _29 && _30);
    assert { [#"../checked_ops.rs" 315 33 315 38] not _31 };
    goto BB9
  }
  BB9 {
    _25 <- ([#"../checked_ops.rs" 315 33 315 38] _26 / _27);
    _21 <- ([#"../checked_ops.rs" 315 12 315 38] _22 = _25);
    _20 <- not _21;
    switch (_20)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    absurd
  }
  BB11 {
    _19 <- ();
    _37 <- a_1;
    _38 <- b_2;
    _36 <- ([#"../checked_ops.rs" 316 12 316 31] SaturatingDiv0.saturating_div _37 _38);
    goto BB12
  }
  BB12 {
    _40 <- a_1;
    _41 <- b_2;
    _42 <- ([#"../checked_ops.rs" 316 35 316 40] _41 = (0 : int8));
    assert { [#"../checked_ops.rs" 316 35 316 40] not _42 };
    goto BB13
  }
  BB13 {
    _43 <- ([#"../checked_ops.rs" 316 35 316 40] _41 = (-1 : int8));
    _44 <- ([#"../checked_ops.rs" 316 35 316 40] _40 = (-128 : int8));
    _45 <- ([#"../checked_ops.rs" 316 35 316 40] _43 && _44);
    assert { [#"../checked_ops.rs" 316 35 316 40] not _45 };
    goto BB14
  }
  BB14 {
    _39 <- ([#"../checked_ops.rs" 316 35 316 40] _40 / _41);
    _35 <- ([#"../checked_ops.rs" 316 12 316 40] _36 = _39);
    _34 <- not _35;
    switch (_34)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    absurd
  }
  BB16 {
    _33 <- ();
    _48 <- a_1;
    _49 <- b_2;
    res_47 <- ([#"../checked_ops.rs" 317 14 317 34] OverflowingDiv0.overflowing_div _48 _49);
    goto BB17
  }
  BB17 {
    _54 <- (let (a, _) = res_47 in a);
    _56 <- a_1;
    _57 <- b_2;
    _58 <- ([#"../checked_ops.rs" 318 21 318 26] _57 = (0 : int8));
    assert { [#"../checked_ops.rs" 318 21 318 26] not _58 };
    goto BB21
  }
  BB18 {
    assume { Resolve0.resolve res_47 };
    _52 <- false;
    goto BB20
  }
  BB19 {
    _63 <- (let (_, a) = res_47 in a);
    assume { Resolve0.resolve res_47 };
    _62 <- ([#"../checked_ops.rs" 318 30 318 44] Bool.eqb _63 false);
    _52 <- _62;
    _62 <- any bool;
    goto BB20
  }
  BB20 {
    _51 <- not _52;
    switch (_51)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB21 {
    _59 <- ([#"../checked_ops.rs" 318 21 318 26] _57 = (-1 : int8));
    _60 <- ([#"../checked_ops.rs" 318 21 318 26] _56 = (-128 : int8));
    _61 <- ([#"../checked_ops.rs" 318 21 318 26] _59 && _60);
    assert { [#"../checked_ops.rs" 318 21 318 26] not _61 };
    goto BB22
  }
  BB22 {
    _55 <- ([#"../checked_ops.rs" 318 21 318 26] _56 / _57);
    _53 <- ([#"../checked_ops.rs" 318 12 318 26] _54 = _55);
    switch (_53)
      | False -> goto BB18
      | True -> goto BB19
      end
  }
  BB23 {
    absurd
  }
  BB24 {
    _50 <- ();
    _0 <- ();
    return _0
  }
  
end
module CheckedOps_TestI8DivZero_Interface
  use mach.int.Int
  use prelude.Int8
  val test_i8_div_zero [@cfg:stackify] (a : int8) : ()
end
module CheckedOps_TestI8DivZero
  use mach.int.Int
  use prelude.Int8
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = int8
  clone Core_Num_Impl1_CheckedDiv_Interface as CheckedDiv0
  let rec cfg test_i8_div_zero [@cfg:stackify] [#"../checked_ops.rs" 322 0 322 30] (a : int8) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a_1 : int8;
  var _2 : ();
  var _3 : bool;
  var _4 : bool;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _7 : int8;
  var _8 : ();
  {
    a_1 <- a;
    goto BB0
  }
  BB0 {
    _7 <- a_1;
    _6 <- ([#"../checked_ops.rs" 323 12 323 28] CheckedDiv0.checked_div _7 (0 : int8));
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _4 <- ([#"../checked_ops.rs" 323 12 323 38] IsNone0.is_none _5);
    goto BB2
  }
  BB2 {
    _3 <- not _4;
    switch (_3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    absurd
  }
  BB4 {
    _2 <- ();
    _0 <- ();
    return _0
  }
  
end
