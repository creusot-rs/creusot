
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CheckedOps_TestU8AddExample
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant2 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option uint8)
  val inv2 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option uint8 . inv2 x = true
  predicate invariant1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : uint8)
  val inv1 (_x : uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : uint8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.UInt8
  val overflowing_add0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_add0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
  let rec cfg test_u8_add_example [#"../checked_ops.rs" 5 0 5 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 6 12 6 31] _5 <- ([#"../checked_ops.rs" 6 12 6 31] checked_add0 ([#"../checked_ops.rs" 6 12 6 15] [#"../checked_ops.rs" 6 12 6 15] (5 : uint8)) ([#"../checked_ops.rs" 6 28 6 30] [#"../checked_ops.rs" 6 28 6 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 6 12 6 40] _4 <- ([#"../checked_ops.rs" 6 12 6 40] unwrap0 _5);
    _5 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 6 4 6 47] not ([#"../checked_ops.rs" 6 12 6 46] _4 = ([#"../checked_ops.rs" 6 44 6 46] [#"../checked_ops.rs" 6 44 6 46] (15 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 6 4 6 47] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 7 12 7 33] _11 <- ([#"../checked_ops.rs" 7 12 7 33] checked_add0 ([#"../checked_ops.rs" 7 12 7 17] [#"../checked_ops.rs" 7 12 7 17] (250 : uint8)) ([#"../checked_ops.rs" 7 30 7 32] [#"../checked_ops.rs" 7 30 7 32] (10 : uint8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 7 12 7 43] _9 <- ([#"../checked_ops.rs" 7 12 7 43] is_none0 ([#"../checked_ops.rs" 7 12 7 43] _11));
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 7 4 7 44] not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 7 4 7 44] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 9 12 9 32] _16 <- ([#"../checked_ops.rs" 9 12 9 32] wrapping_add0 ([#"../checked_ops.rs" 9 12 9 15] [#"../checked_ops.rs" 9 12 9 15] (5 : uint8)) ([#"../checked_ops.rs" 9 29 9 31] [#"../checked_ops.rs" 9 29 9 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch ([#"../checked_ops.rs" 9 4 9 39] not ([#"../checked_ops.rs" 9 12 9 38] _16 = ([#"../checked_ops.rs" 9 36 9 38] [#"../checked_ops.rs" 9 36 9 38] (15 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    assert { [#"../checked_ops.rs" 9 4 9 39] false };
    absurd
  }
  BB11 {
    [#"../checked_ops.rs" 10 12 10 34] _21 <- ([#"../checked_ops.rs" 10 12 10 34] wrapping_add0 ([#"../checked_ops.rs" 10 12 10 17] [#"../checked_ops.rs" 10 12 10 17] (250 : uint8)) ([#"../checked_ops.rs" 10 31 10 33] [#"../checked_ops.rs" 10 31 10 33] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch ([#"../checked_ops.rs" 10 4 10 40] not ([#"../checked_ops.rs" 10 12 10 39] _21 = ([#"../checked_ops.rs" 10 38 10 39] [#"../checked_ops.rs" 10 38 10 39] (4 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    assert { [#"../checked_ops.rs" 10 4 10 40] false };
    absurd
  }
  BB14 {
    [#"../checked_ops.rs" 12 12 12 34] _26 <- ([#"../checked_ops.rs" 12 12 12 34] saturating_add0 ([#"../checked_ops.rs" 12 12 12 15] [#"../checked_ops.rs" 12 12 12 15] (5 : uint8)) ([#"../checked_ops.rs" 12 31 12 33] [#"../checked_ops.rs" 12 31 12 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch ([#"../checked_ops.rs" 12 4 12 41] not ([#"../checked_ops.rs" 12 12 12 40] _26 = ([#"../checked_ops.rs" 12 38 12 40] [#"../checked_ops.rs" 12 38 12 40] (15 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assert { [#"../checked_ops.rs" 12 4 12 41] false };
    absurd
  }
  BB17 {
    [#"../checked_ops.rs" 13 12 13 36] _31 <- ([#"../checked_ops.rs" 13 12 13 36] saturating_add0 ([#"../checked_ops.rs" 13 12 13 17] [#"../checked_ops.rs" 13 12 13 17] (250 : uint8)) ([#"../checked_ops.rs" 13 33 13 35] [#"../checked_ops.rs" 13 33 13 35] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch ([#"../checked_ops.rs" 13 4 13 44] not ([#"../checked_ops.rs" 13 12 13 43] _31 = ([#"../checked_ops.rs" 13 40 13 43] [#"../checked_ops.rs" 13 40 13 43] (255 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [#"../checked_ops.rs" 13 4 13 44] false };
    absurd
  }
  BB20 {
    [#"../checked_ops.rs" 15 14 15 37] res <- ([#"../checked_ops.rs" 15 14 15 37] overflowing_add0 ([#"../checked_ops.rs" 15 14 15 17] [#"../checked_ops.rs" 15 14 15 17] (5 : uint8)) ([#"../checked_ops.rs" 15 34 15 36] [#"../checked_ops.rs" 15 34 15 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 16 12 16 23] ([#"../checked_ops.rs" 16 12 16 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 16 21 16 23] [#"../checked_ops.rs" 16 21 16 23] (15 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 16 12 16 41] _36 <- ([#"../checked_ops.rs" 16 12 16 41] [#"../checked_ops.rs" 16 12 16 41] false);
    goto BB24
  }
  BB23 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 16 12 16 41] _36 <- ([#"../checked_ops.rs" 16 27 16 41] Bool.eqb ([#"../checked_ops.rs" 16 27 16 32] let (_, a) = res in a) ([#"../checked_ops.rs" 16 36 16 41] [#"../checked_ops.rs" 16 36 16 41] false));
    goto BB24
  }
  BB24 {
    switch ([#"../checked_ops.rs" 16 4 16 42] not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    assert { [#"../checked_ops.rs" 16 4 16 42] false };
    absurd
  }
  BB26 {
    [#"../checked_ops.rs" 17 14 17 39] res1 <- ([#"../checked_ops.rs" 17 14 17 39] overflowing_add0 ([#"../checked_ops.rs" 17 14 17 19] [#"../checked_ops.rs" 17 14 17 19] (250 : uint8)) ([#"../checked_ops.rs" 17 36 17 38] [#"../checked_ops.rs" 17 36 17 38] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 18 12 18 22] ([#"../checked_ops.rs" 18 12 18 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 18 21 18 22] [#"../checked_ops.rs" 18 21 18 22] (4 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 18 12 18 39] _45 <- ([#"../checked_ops.rs" 18 12 18 39] [#"../checked_ops.rs" 18 12 18 39] false);
    goto BB30
  }
  BB29 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 18 12 18 39] _45 <- ([#"../checked_ops.rs" 18 26 18 39] Bool.eqb ([#"../checked_ops.rs" 18 26 18 31] let (_, a) = res1 in a) ([#"../checked_ops.rs" 18 35 18 39] [#"../checked_ops.rs" 18 35 18 39] true));
    goto BB30
  }
  BB30 {
    switch ([#"../checked_ops.rs" 18 4 18 40] not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    assert { [#"../checked_ops.rs" 18 4 18 40] false };
    absurd
  }
  BB32 {
    [#"../checked_ops.rs" 5 29 19 1] _0 <- ([#"../checked_ops.rs" 5 29 19 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8AddOverflow
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.UInt8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_add0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_add0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
  let rec cfg test_u8_add_overflow [#"../checked_ops.rs" 23 0 23 34] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _21 : uint8;
  var res : (uint8, bool);
  var _28 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 24 12 24 32] _7 <- ([#"../checked_ops.rs" 24 12 24 32] checked_add0 ([#"../checked_ops.rs" 24 12 24 17] [#"../checked_ops.rs" 24 12 24 17] (255 : uint8)) ([#"../checked_ops.rs" 24 30 24 31] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 24 12 24 42] _5 <- ([#"../checked_ops.rs" 24 12 24 42] is_none0 ([#"../checked_ops.rs" 24 12 24 42] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 24 4 24 43] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 24 4 24 43] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 25 12 25 33] _13 <- ([#"../checked_ops.rs" 25 12 25 33] wrapping_add0 ([#"../checked_ops.rs" 25 12 25 17] [#"../checked_ops.rs" 25 12 25 17] (255 : uint8)) ([#"../checked_ops.rs" 25 31 25 32] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 25 4 25 43] not ([#"../checked_ops.rs" 25 12 25 42] _13 = ([#"../checked_ops.rs" 25 37 25 42] ([#"../checked_ops.rs" 25 37 25 38] a) - ([#"../checked_ops.rs" 25 41 25 42] [#"../checked_ops.rs" 25 41 25 42] (1 : uint8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 25 4 25 43] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 26 12 26 35] _21 <- ([#"../checked_ops.rs" 26 12 26 35] saturating_add0 ([#"../checked_ops.rs" 26 12 26 17] [#"../checked_ops.rs" 26 12 26 17] (255 : uint8)) ([#"../checked_ops.rs" 26 33 26 34] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 26 4 26 43] not ([#"../checked_ops.rs" 26 12 26 42] _21 = ([#"../checked_ops.rs" 26 39 26 42] [#"../checked_ops.rs" 26 39 26 42] (255 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 26 4 26 43] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 27 14 27 38] res <- ([#"../checked_ops.rs" 27 14 27 38] overflowing_add0 ([#"../checked_ops.rs" 27 14 27 19] [#"../checked_ops.rs" 27 14 27 19] (255 : uint8)) ([#"../checked_ops.rs" 27 36 27 37] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 28 12 28 26] ([#"../checked_ops.rs" 28 12 28 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 28 21 28 26] ([#"../checked_ops.rs" 28 21 28 22] a) - ([#"../checked_ops.rs" 28 25 28 26] [#"../checked_ops.rs" 28 25 28 26] (1 : uint8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 28 12 28 43] _28 <- ([#"../checked_ops.rs" 28 12 28 43] [#"../checked_ops.rs" 28 12 28 43] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 28 12 28 43] _28 <- ([#"../checked_ops.rs" 28 30 28 43] Bool.eqb ([#"../checked_ops.rs" 28 30 28 35] let (_, a) = res in a) ([#"../checked_ops.rs" 28 39 28 43] [#"../checked_ops.rs" 28 39 28 43] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 28 4 28 44] not _28)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 28 4 28 44] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 23 35 29 1] _0 <- ([#"../checked_ops.rs" 23 35 29 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8WrappingAdd
  use prelude.UInt8
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  let rec cfg test_u8_wrapping_add [#"../checked_ops.rs" 34 0 34 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result = UInt8.to_int a + UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a : uint8 = a;
  var b : uint8 = b;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 35 4 35 21] _0 <- ([#"../checked_ops.rs" 35 4 35 21] wrapping_add0 ([#"../checked_ops.rs" 35 4 35 5] a) ([#"../checked_ops.rs" 35 19 35 20] b));
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingAdd
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use prelude.UInt8
  val checked_add0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_add0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_add0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int max0) }
    
  let rec cfg test_u8_overflowing_add [#"../checked_ops.rs" 39 0 39 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 40 12 40 32] _7 <- ([#"../checked_ops.rs" 40 12 40 32] overflowing_add0 ([#"../checked_ops.rs" 40 12 40 13] a) ([#"../checked_ops.rs" 40 30 40 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 40 38 40 55] _10 <- ([#"../checked_ops.rs" 40 38 40 55] wrapping_add0 ([#"../checked_ops.rs" 40 38 40 39] a) ([#"../checked_ops.rs" 40 53 40 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 40 4 40 56] not ([#"../checked_ops.rs" 40 12 40 55] ([#"../checked_ops.rs" 40 12 40 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 40 4 40 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 41 12 41 32] _18 <- ([#"../checked_ops.rs" 41 12 41 32] overflowing_add0 ([#"../checked_ops.rs" 41 12 41 13] a) ([#"../checked_ops.rs" 41 30 41 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 41 38 41 54] _23 <- ([#"../checked_ops.rs" 41 38 41 54] checked_add0 ([#"../checked_ops.rs" 41 38 41 39] a) ([#"../checked_ops.rs" 41 52 41 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 41 38 41 64] _21 <- ([#"../checked_ops.rs" 41 38 41 64] is_none0 ([#"../checked_ops.rs" 41 38 41 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 41 4 41 65] not ([#"../checked_ops.rs" 41 12 41 64] Bool.eqb ([#"../checked_ops.rs" 41 12 41 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 41 4 41 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 39 45 42 1] _0 <- ([#"../checked_ops.rs" 39 45 42 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8SubExample
  use prelude.UInt8
  predicate invariant2 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : uint8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : uint8)
  val inv2 (_x : uint8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : uint8 . inv2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant1 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Core_Option_Option_Type.t_option uint8)
  val inv1 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Core_Option_Option_Type.t_option uint8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.UInt8
  val overflowing_sub0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv2 result }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_sub0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
  let rec cfg test_u8_sub_example [#"../checked_ops.rs" 45 0 45 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 46 12 46 31] _5 <- ([#"../checked_ops.rs" 46 12 46 31] checked_sub0 ([#"../checked_ops.rs" 46 12 46 15] [#"../checked_ops.rs" 46 12 46 15] (5 : uint8)) ([#"../checked_ops.rs" 46 28 46 30] [#"../checked_ops.rs" 46 28 46 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 46 12 46 41] _3 <- ([#"../checked_ops.rs" 46 12 46 41] is_none0 ([#"../checked_ops.rs" 46 12 46 41] _5));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 46 4 46 42] not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 46 4 46 42] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 47 12 47 33] _11 <- ([#"../checked_ops.rs" 47 12 47 33] checked_sub0 ([#"../checked_ops.rs" 47 12 47 17] [#"../checked_ops.rs" 47 12 47 17] (250 : uint8)) ([#"../checked_ops.rs" 47 30 47 32] [#"../checked_ops.rs" 47 30 47 32] (10 : uint8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 47 12 47 42] _10 <- ([#"../checked_ops.rs" 47 12 47 42] unwrap0 _11);
    _11 <- any Core_Option_Option_Type.t_option uint8;
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 47 4 47 50] not ([#"../checked_ops.rs" 47 12 47 49] _10 = ([#"../checked_ops.rs" 47 46 47 49] [#"../checked_ops.rs" 47 46 47 49] (240 : uint8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 47 4 47 50] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 49 12 49 32] _16 <- ([#"../checked_ops.rs" 49 12 49 32] wrapping_sub0 ([#"../checked_ops.rs" 49 12 49 15] [#"../checked_ops.rs" 49 12 49 15] (5 : uint8)) ([#"../checked_ops.rs" 49 29 49 31] [#"../checked_ops.rs" 49 29 49 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch ([#"../checked_ops.rs" 49 4 49 40] not ([#"../checked_ops.rs" 49 12 49 39] _16 = ([#"../checked_ops.rs" 49 36 49 39] [#"../checked_ops.rs" 49 36 49 39] (251 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    assert { [#"../checked_ops.rs" 49 4 49 40] false };
    absurd
  }
  BB11 {
    [#"../checked_ops.rs" 50 12 50 34] _21 <- ([#"../checked_ops.rs" 50 12 50 34] wrapping_sub0 ([#"../checked_ops.rs" 50 12 50 17] [#"../checked_ops.rs" 50 12 50 17] (250 : uint8)) ([#"../checked_ops.rs" 50 31 50 33] [#"../checked_ops.rs" 50 31 50 33] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch ([#"../checked_ops.rs" 50 4 50 42] not ([#"../checked_ops.rs" 50 12 50 41] _21 = ([#"../checked_ops.rs" 50 38 50 41] [#"../checked_ops.rs" 50 38 50 41] (240 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    assert { [#"../checked_ops.rs" 50 4 50 42] false };
    absurd
  }
  BB14 {
    [#"../checked_ops.rs" 52 12 52 34] _26 <- ([#"../checked_ops.rs" 52 12 52 34] saturating_sub0 ([#"../checked_ops.rs" 52 12 52 15] [#"../checked_ops.rs" 52 12 52 15] (5 : uint8)) ([#"../checked_ops.rs" 52 31 52 33] [#"../checked_ops.rs" 52 31 52 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch ([#"../checked_ops.rs" 52 4 52 40] not ([#"../checked_ops.rs" 52 12 52 39] _26 = ([#"../checked_ops.rs" 52 38 52 39] [#"../checked_ops.rs" 52 38 52 39] (0 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assert { [#"../checked_ops.rs" 52 4 52 40] false };
    absurd
  }
  BB17 {
    [#"../checked_ops.rs" 53 12 53 36] _31 <- ([#"../checked_ops.rs" 53 12 53 36] saturating_sub0 ([#"../checked_ops.rs" 53 12 53 17] [#"../checked_ops.rs" 53 12 53 17] (250 : uint8)) ([#"../checked_ops.rs" 53 33 53 35] [#"../checked_ops.rs" 53 33 53 35] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch ([#"../checked_ops.rs" 53 4 53 44] not ([#"../checked_ops.rs" 53 12 53 43] _31 = ([#"../checked_ops.rs" 53 40 53 43] [#"../checked_ops.rs" 53 40 53 43] (240 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [#"../checked_ops.rs" 53 4 53 44] false };
    absurd
  }
  BB20 {
    [#"../checked_ops.rs" 55 14 55 37] res <- ([#"../checked_ops.rs" 55 14 55 37] overflowing_sub0 ([#"../checked_ops.rs" 55 14 55 17] [#"../checked_ops.rs" 55 14 55 17] (5 : uint8)) ([#"../checked_ops.rs" 55 34 55 36] [#"../checked_ops.rs" 55 34 55 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 56 12 56 24] ([#"../checked_ops.rs" 56 12 56 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 56 21 56 24] [#"../checked_ops.rs" 56 21 56 24] (251 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 56 12 56 41] _36 <- ([#"../checked_ops.rs" 56 12 56 41] [#"../checked_ops.rs" 56 12 56 41] false);
    goto BB24
  }
  BB23 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 56 12 56 41] _36 <- ([#"../checked_ops.rs" 56 28 56 41] Bool.eqb ([#"../checked_ops.rs" 56 28 56 33] let (_, a) = res in a) ([#"../checked_ops.rs" 56 37 56 41] [#"../checked_ops.rs" 56 37 56 41] true));
    goto BB24
  }
  BB24 {
    switch ([#"../checked_ops.rs" 56 4 56 42] not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    assert { [#"../checked_ops.rs" 56 4 56 42] false };
    absurd
  }
  BB26 {
    [#"../checked_ops.rs" 57 14 57 39] res1 <- ([#"../checked_ops.rs" 57 14 57 39] overflowing_sub0 ([#"../checked_ops.rs" 57 14 57 19] [#"../checked_ops.rs" 57 14 57 19] (250 : uint8)) ([#"../checked_ops.rs" 57 36 57 38] [#"../checked_ops.rs" 57 36 57 38] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 58 12 58 24] ([#"../checked_ops.rs" 58 12 58 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 58 21 58 24] [#"../checked_ops.rs" 58 21 58 24] (240 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 58 12 58 42] _45 <- ([#"../checked_ops.rs" 58 12 58 42] [#"../checked_ops.rs" 58 12 58 42] false);
    goto BB30
  }
  BB29 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 58 12 58 42] _45 <- ([#"../checked_ops.rs" 58 28 58 42] Bool.eqb ([#"../checked_ops.rs" 58 28 58 33] let (_, a) = res1 in a) ([#"../checked_ops.rs" 58 37 58 42] [#"../checked_ops.rs" 58 37 58 42] false));
    goto BB30
  }
  BB30 {
    switch ([#"../checked_ops.rs" 58 4 58 43] not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    assert { [#"../checked_ops.rs" 58 4 58 43] false };
    absurd
  }
  BB32 {
    [#"../checked_ops.rs" 45 29 59 1] _0 <- ([#"../checked_ops.rs" 45 29 59 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8SubOverflow
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.UInt8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_sub0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_sub0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
  let rec cfg test_u8_sub_overflow [#"../checked_ops.rs" 63 0 63 34] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    requires {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _22 : uint8;
  var res : (uint8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 64 12 64 30] _7 <- ([#"../checked_ops.rs" 64 12 64 30] checked_sub0 ([#"../checked_ops.rs" 64 12 64 15] [#"../checked_ops.rs" 64 12 64 15] (0 : uint8)) ([#"../checked_ops.rs" 64 28 64 29] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 64 12 64 40] _5 <- ([#"../checked_ops.rs" 64 12 64 40] is_none0 ([#"../checked_ops.rs" 64 12 64 40] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 64 4 64 41] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 64 4 64 41] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 65 12 65 31] _13 <- ([#"../checked_ops.rs" 65 12 65 31] wrapping_sub0 ([#"../checked_ops.rs" 65 12 65 15] [#"../checked_ops.rs" 65 12 65 15] (0 : uint8)) ([#"../checked_ops.rs" 65 29 65 30] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 65 4 65 47] not ([#"../checked_ops.rs" 65 12 65 46] _13 = ([#"../checked_ops.rs" 65 35 65 46] ([#"../checked_ops.rs" 65 35 65 42] ([#"../checked_ops.rs" 65 35 65 38] [#"../checked_ops.rs" 65 35 65 38] (255 : uint8)) - ([#"../checked_ops.rs" 65 41 65 42] a)) + ([#"../checked_ops.rs" 65 45 65 46] [#"../checked_ops.rs" 65 45 65 46] (1 : uint8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 65 4 65 47] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 66 12 66 33] _22 <- ([#"../checked_ops.rs" 66 12 66 33] saturating_sub0 ([#"../checked_ops.rs" 66 12 66 15] [#"../checked_ops.rs" 66 12 66 15] (0 : uint8)) ([#"../checked_ops.rs" 66 31 66 32] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 66 4 66 39] not ([#"../checked_ops.rs" 66 12 66 38] _22 = ([#"../checked_ops.rs" 66 37 66 38] [#"../checked_ops.rs" 66 37 66 38] (0 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 66 4 66 39] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 67 14 67 36] res <- ([#"../checked_ops.rs" 67 14 67 36] overflowing_sub0 ([#"../checked_ops.rs" 67 14 67 17] [#"../checked_ops.rs" 67 14 67 17] (0 : uint8)) ([#"../checked_ops.rs" 67 34 67 35] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 68 12 68 32] ([#"../checked_ops.rs" 68 12 68 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 68 21 68 32] ([#"../checked_ops.rs" 68 21 68 28] ([#"../checked_ops.rs" 68 21 68 24] [#"../checked_ops.rs" 68 21 68 24] (255 : uint8)) - ([#"../checked_ops.rs" 68 27 68 28] a)) + ([#"../checked_ops.rs" 68 31 68 32] [#"../checked_ops.rs" 68 31 68 32] (1 : uint8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 68 12 68 49] _29 <- ([#"../checked_ops.rs" 68 12 68 49] [#"../checked_ops.rs" 68 12 68 49] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 68 12 68 49] _29 <- ([#"../checked_ops.rs" 68 36 68 49] Bool.eqb ([#"../checked_ops.rs" 68 36 68 41] let (_, a) = res in a) ([#"../checked_ops.rs" 68 45 68 49] [#"../checked_ops.rs" 68 45 68 49] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 68 4 68 50] not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 68 4 68 50] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 63 35 69 1] _0 <- ([#"../checked_ops.rs" 63 35 69 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8WrappingSub
  use prelude.UInt8
  use prelude.UInt8
  use prelude.Int
  use prelude.UInt32
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  let rec cfg test_u8_wrapping_sub [#"../checked_ops.rs" 74 0 74 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : uint8
    ensures { [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result = UInt8.to_int a - UInt8.to_int b \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint8;
  var a : uint8 = a;
  var b : uint8 = b;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 75 4 75 21] _0 <- ([#"../checked_ops.rs" 75 4 75 21] wrapping_sub0 ([#"../checked_ops.rs" 75 4 75 5] a) ([#"../checked_ops.rs" 75 19 75 20] b));
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingSub
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use prelude.UInt8
  val checked_sub0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_sub0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_sub0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int max0) }
    
  let rec cfg test_u8_overflowing_sub [#"../checked_ops.rs" 79 0 79 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 80 12 80 32] _7 <- ([#"../checked_ops.rs" 80 12 80 32] overflowing_sub0 ([#"../checked_ops.rs" 80 12 80 13] a) ([#"../checked_ops.rs" 80 30 80 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 80 38 80 55] _10 <- ([#"../checked_ops.rs" 80 38 80 55] wrapping_sub0 ([#"../checked_ops.rs" 80 38 80 39] a) ([#"../checked_ops.rs" 80 53 80 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 80 4 80 56] not ([#"../checked_ops.rs" 80 12 80 55] ([#"../checked_ops.rs" 80 12 80 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 80 4 80 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 81 12 81 32] _18 <- ([#"../checked_ops.rs" 81 12 81 32] overflowing_sub0 ([#"../checked_ops.rs" 81 12 81 13] a) ([#"../checked_ops.rs" 81 30 81 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 81 38 81 54] _23 <- ([#"../checked_ops.rs" 81 38 81 54] checked_sub0 ([#"../checked_ops.rs" 81 38 81 39] a) ([#"../checked_ops.rs" 81 52 81 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 81 38 81 64] _21 <- ([#"../checked_ops.rs" 81 38 81 64] is_none0 ([#"../checked_ops.rs" 81 38 81 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 81 4 81 65] not ([#"../checked_ops.rs" 81 12 81 64] Bool.eqb ([#"../checked_ops.rs" 81 12 81 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 81 4 81 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 79 45 82 1] _0 <- ([#"../checked_ops.rs" 79 45 82 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8MulExample
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant2 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option uint8)
  val inv2 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option uint8 . inv2 x = true
  predicate invariant1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : uint8)
  val inv1 (_x : uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : uint8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.UInt8
  val overflowing_mul0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_mul0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_mul0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_mul0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
  let rec cfg test_u8_mul_example [#"../checked_ops.rs" 85 0 85 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : uint8;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var _26 : uint8;
  var _31 : uint8;
  var res : (uint8, bool);
  var _36 : bool;
  var res1 : (uint8, bool);
  var _45 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 86 12 86 31] _5 <- ([#"../checked_ops.rs" 86 12 86 31] checked_mul0 ([#"../checked_ops.rs" 86 12 86 15] [#"../checked_ops.rs" 86 12 86 15] (5 : uint8)) ([#"../checked_ops.rs" 86 28 86 30] [#"../checked_ops.rs" 86 28 86 30] (10 : uint8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 86 12 86 40] _4 <- ([#"../checked_ops.rs" 86 12 86 40] unwrap0 _5);
    _5 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 86 4 86 47] not ([#"../checked_ops.rs" 86 12 86 46] _4 = ([#"../checked_ops.rs" 86 44 86 46] [#"../checked_ops.rs" 86 44 86 46] (50 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 86 4 86 47] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 87 12 87 32] _11 <- ([#"../checked_ops.rs" 87 12 87 32] checked_mul0 ([#"../checked_ops.rs" 87 12 87 16] [#"../checked_ops.rs" 87 12 87 16] (50 : uint8)) ([#"../checked_ops.rs" 87 29 87 31] [#"../checked_ops.rs" 87 29 87 31] (10 : uint8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 87 12 87 42] _9 <- ([#"../checked_ops.rs" 87 12 87 42] is_none0 ([#"../checked_ops.rs" 87 12 87 42] _11));
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 87 4 87 43] not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 87 4 87 43] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 89 12 89 32] _16 <- ([#"../checked_ops.rs" 89 12 89 32] wrapping_mul0 ([#"../checked_ops.rs" 89 12 89 15] [#"../checked_ops.rs" 89 12 89 15] (5 : uint8)) ([#"../checked_ops.rs" 89 29 89 31] [#"../checked_ops.rs" 89 29 89 31] (10 : uint8)));
    goto BB9
  }
  BB9 {
    switch ([#"../checked_ops.rs" 89 4 89 39] not ([#"../checked_ops.rs" 89 12 89 38] _16 = ([#"../checked_ops.rs" 89 36 89 38] [#"../checked_ops.rs" 89 36 89 38] (50 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    assert { [#"../checked_ops.rs" 89 4 89 39] false };
    absurd
  }
  BB11 {
    [#"../checked_ops.rs" 90 12 90 33] _21 <- ([#"../checked_ops.rs" 90 12 90 33] wrapping_mul0 ([#"../checked_ops.rs" 90 12 90 16] [#"../checked_ops.rs" 90 12 90 16] (50 : uint8)) ([#"../checked_ops.rs" 90 30 90 32] [#"../checked_ops.rs" 90 30 90 32] (10 : uint8)));
    goto BB12
  }
  BB12 {
    switch ([#"../checked_ops.rs" 90 4 90 41] not ([#"../checked_ops.rs" 90 12 90 40] _21 = ([#"../checked_ops.rs" 90 37 90 40] [#"../checked_ops.rs" 90 37 90 40] (244 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    assert { [#"../checked_ops.rs" 90 4 90 41] false };
    absurd
  }
  BB14 {
    [#"../checked_ops.rs" 92 12 92 34] _26 <- ([#"../checked_ops.rs" 92 12 92 34] saturating_mul0 ([#"../checked_ops.rs" 92 12 92 15] [#"../checked_ops.rs" 92 12 92 15] (5 : uint8)) ([#"../checked_ops.rs" 92 31 92 33] [#"../checked_ops.rs" 92 31 92 33] (10 : uint8)));
    goto BB15
  }
  BB15 {
    switch ([#"../checked_ops.rs" 92 4 92 41] not ([#"../checked_ops.rs" 92 12 92 40] _26 = ([#"../checked_ops.rs" 92 38 92 40] [#"../checked_ops.rs" 92 38 92 40] (50 : uint8))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assert { [#"../checked_ops.rs" 92 4 92 41] false };
    absurd
  }
  BB17 {
    [#"../checked_ops.rs" 93 12 93 35] _31 <- ([#"../checked_ops.rs" 93 12 93 35] saturating_mul0 ([#"../checked_ops.rs" 93 12 93 16] [#"../checked_ops.rs" 93 12 93 16] (50 : uint8)) ([#"../checked_ops.rs" 93 32 93 34] [#"../checked_ops.rs" 93 32 93 34] (10 : uint8)));
    goto BB18
  }
  BB18 {
    switch ([#"../checked_ops.rs" 93 4 93 43] not ([#"../checked_ops.rs" 93 12 93 42] _31 = ([#"../checked_ops.rs" 93 39 93 42] [#"../checked_ops.rs" 93 39 93 42] (255 : uint8))))
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [#"../checked_ops.rs" 93 4 93 43] false };
    absurd
  }
  BB20 {
    [#"../checked_ops.rs" 95 14 95 37] res <- ([#"../checked_ops.rs" 95 14 95 37] overflowing_mul0 ([#"../checked_ops.rs" 95 14 95 17] [#"../checked_ops.rs" 95 14 95 17] (5 : uint8)) ([#"../checked_ops.rs" 95 34 95 36] [#"../checked_ops.rs" 95 34 95 36] (10 : uint8)));
    goto BB21
  }
  BB21 {
    switch ([#"../checked_ops.rs" 96 12 96 23] ([#"../checked_ops.rs" 96 12 96 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 96 21 96 23] [#"../checked_ops.rs" 96 21 96 23] (50 : uint8)))
      | False -> goto BB22
      | True -> goto BB23
      end
  }
  BB22 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 96 12 96 41] _36 <- ([#"../checked_ops.rs" 96 12 96 41] [#"../checked_ops.rs" 96 12 96 41] false);
    goto BB24
  }
  BB23 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 96 12 96 41] _36 <- ([#"../checked_ops.rs" 96 27 96 41] Bool.eqb ([#"../checked_ops.rs" 96 27 96 32] let (_, a) = res in a) ([#"../checked_ops.rs" 96 36 96 41] [#"../checked_ops.rs" 96 36 96 41] false));
    goto BB24
  }
  BB24 {
    switch ([#"../checked_ops.rs" 96 4 96 42] not _36)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    assert { [#"../checked_ops.rs" 96 4 96 42] false };
    absurd
  }
  BB26 {
    [#"../checked_ops.rs" 97 14 97 38] res1 <- ([#"../checked_ops.rs" 97 14 97 38] overflowing_mul0 ([#"../checked_ops.rs" 97 14 97 18] [#"../checked_ops.rs" 97 14 97 18] (50 : uint8)) ([#"../checked_ops.rs" 97 35 97 37] [#"../checked_ops.rs" 97 35 97 37] (10 : uint8)));
    goto BB27
  }
  BB27 {
    switch ([#"../checked_ops.rs" 98 12 98 24] ([#"../checked_ops.rs" 98 12 98 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 98 21 98 24] [#"../checked_ops.rs" 98 21 98 24] (244 : uint8)))
      | False -> goto BB28
      | True -> goto BB29
      end
  }
  BB28 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 98 12 98 41] _45 <- ([#"../checked_ops.rs" 98 12 98 41] [#"../checked_ops.rs" 98 12 98 41] false);
    goto BB30
  }
  BB29 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 98 12 98 41] _45 <- ([#"../checked_ops.rs" 98 28 98 41] Bool.eqb ([#"../checked_ops.rs" 98 28 98 33] let (_, a) = res1 in a) ([#"../checked_ops.rs" 98 37 98 41] [#"../checked_ops.rs" 98 37 98 41] true));
    goto BB30
  }
  BB30 {
    switch ([#"../checked_ops.rs" 98 4 98 42] not _45)
      | False -> goto BB32
      | True -> goto BB31
      end
  }
  BB31 {
    assert { [#"../checked_ops.rs" 98 4 98 42] false };
    absurd
  }
  BB32 {
    [#"../checked_ops.rs" 85 29 99 1] _0 <- ([#"../checked_ops.rs" 85 29 99 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8MulZero
  use prelude.UInt8
  predicate invariant1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : uint8)
  val inv1 (_x : uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : uint8 . inv1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.UInt8
  val overflowing_mul0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    
  val saturating_mul0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int max0 }
    
  val wrapping_mul0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_mul0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
  let rec cfg test_u8_mul_zero [#"../checked_ops.rs" 102 0 102 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _5 : uint8;
  var _6 : Core_Option_Option_Type.t_option uint8;
  var _12 : uint8;
  var _18 : uint8;
  var res : (uint8, bool);
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 103 12 103 30] _6 <- ([#"../checked_ops.rs" 103 12 103 30] checked_mul0 ([#"../checked_ops.rs" 103 12 103 15] [#"../checked_ops.rs" 103 12 103 15] (0 : uint8)) ([#"../checked_ops.rs" 103 28 103 29] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 103 12 103 39] _5 <- ([#"../checked_ops.rs" 103 12 103 39] unwrap0 _6);
    _6 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 103 4 103 45] not ([#"../checked_ops.rs" 103 12 103 44] _5 = ([#"../checked_ops.rs" 103 43 103 44] [#"../checked_ops.rs" 103 43 103 44] (0 : uint8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 103 4 103 45] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 104 12 104 31] _12 <- ([#"../checked_ops.rs" 104 12 104 31] wrapping_mul0 ([#"../checked_ops.rs" 104 12 104 15] [#"../checked_ops.rs" 104 12 104 15] (0 : uint8)) ([#"../checked_ops.rs" 104 29 104 30] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 104 4 104 37] not ([#"../checked_ops.rs" 104 12 104 36] _12 = ([#"../checked_ops.rs" 104 35 104 36] [#"../checked_ops.rs" 104 35 104 36] (0 : uint8))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 104 4 104 37] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 105 12 105 33] _18 <- ([#"../checked_ops.rs" 105 12 105 33] saturating_mul0 ([#"../checked_ops.rs" 105 12 105 15] [#"../checked_ops.rs" 105 12 105 15] (0 : uint8)) ([#"../checked_ops.rs" 105 31 105 32] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 105 4 105 39] not ([#"../checked_ops.rs" 105 12 105 38] _18 = ([#"../checked_ops.rs" 105 37 105 38] [#"../checked_ops.rs" 105 37 105 38] (0 : uint8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 105 4 105 39] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 106 14 106 36] res <- ([#"../checked_ops.rs" 106 14 106 36] overflowing_mul0 ([#"../checked_ops.rs" 106 14 106 17] [#"../checked_ops.rs" 106 14 106 17] (0 : uint8)) ([#"../checked_ops.rs" 106 34 106 35] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 107 12 107 22] ([#"../checked_ops.rs" 107 12 107 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 107 21 107 22] [#"../checked_ops.rs" 107 21 107 22] (0 : uint8)))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 107 12 107 40] _25 <- ([#"../checked_ops.rs" 107 12 107 40] [#"../checked_ops.rs" 107 12 107 40] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 107 12 107 40] _25 <- ([#"../checked_ops.rs" 107 26 107 40] Bool.eqb ([#"../checked_ops.rs" 107 26 107 31] let (_, a) = res in a) ([#"../checked_ops.rs" 107 35 107 40] [#"../checked_ops.rs" 107 35 107 40] false));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 107 4 107 41] not _25)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 107 4 107 41] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 102 31 108 1] _0 <- ([#"../checked_ops.rs" 102 31 108 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8OverflowingMul
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (255 : uint8)
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use prelude.UInt8
  val checked_mul0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_mul0 (self : uint8) (rhs : uint8) : uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt8.to_int result = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_mul0 (self : uint8) (rhs : uint8) : (uint8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] UInt8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int min0 /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int max0 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0 -> (exists k : int . k > 0 /\ UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int max0 - UInt8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int min0 \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int max0) }
    
  let rec cfg test_u8_overflowing_mul [#"../checked_ops.rs" 111 0 111 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : (uint8, bool);
  var _10 : uint8;
  var _18 : (uint8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 112 12 112 32] _7 <- ([#"../checked_ops.rs" 112 12 112 32] overflowing_mul0 ([#"../checked_ops.rs" 112 12 112 13] a) ([#"../checked_ops.rs" 112 30 112 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 112 38 112 55] _10 <- ([#"../checked_ops.rs" 112 38 112 55] wrapping_mul0 ([#"../checked_ops.rs" 112 38 112 39] a) ([#"../checked_ops.rs" 112 53 112 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 112 4 112 56] not ([#"../checked_ops.rs" 112 12 112 55] ([#"../checked_ops.rs" 112 12 112 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 112 4 112 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 113 12 113 32] _18 <- ([#"../checked_ops.rs" 113 12 113 32] overflowing_mul0 ([#"../checked_ops.rs" 113 12 113 13] a) ([#"../checked_ops.rs" 113 30 113 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 113 38 113 54] _23 <- ([#"../checked_ops.rs" 113 38 113 54] checked_mul0 ([#"../checked_ops.rs" 113 38 113 39] a) ([#"../checked_ops.rs" 113 52 113 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 113 38 113 64] _21 <- ([#"../checked_ops.rs" 113 38 113 64] is_none0 ([#"../checked_ops.rs" 113 38 113 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 113 4 113 65] not ([#"../checked_ops.rs" 113 12 113 64] Bool.eqb ([#"../checked_ops.rs" 113 12 113 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 113 4 113 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 111 45 114 1] _0 <- ([#"../checked_ops.rs" 111 45 114 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8DivExample
  use prelude.UInt8
  predicate invariant2 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : uint8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : uint8)
  val inv2 (_x : uint8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : uint8 . inv2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant1 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Core_Option_Option_Type.t_option uint8)
  val inv1 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Core_Option_Option_Type.t_option uint8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use prelude.UInt8
  val overflowing_div0 (self : uint8) (rhs : uint8) : (uint8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1) }
    
  val saturating_div0 (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  val wrapping_div0 (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv2 result }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_div0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  let rec cfg test_u8_div_example [#"../checked_ops.rs" 117 0 117 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option uint8;
  var _10 : uint8;
  var _11 : Core_Option_Option_Type.t_option uint8;
  var _16 : uint8;
  var _21 : uint8;
  var res : (uint8, bool);
  var _26 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 118 12 118 30] _5 <- ([#"../checked_ops.rs" 118 12 118 30] checked_div0 ([#"../checked_ops.rs" 118 12 118 15] [#"../checked_ops.rs" 118 12 118 15] (5 : uint8)) ([#"../checked_ops.rs" 118 28 118 29] [#"../checked_ops.rs" 118 28 118 29] (0 : uint8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 118 12 118 40] _3 <- ([#"../checked_ops.rs" 118 12 118 40] is_none0 ([#"../checked_ops.rs" 118 12 118 40] _5));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 118 4 118 41] not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 118 4 118 41] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 119 12 119 30] _11 <- ([#"../checked_ops.rs" 119 12 119 30] checked_div0 ([#"../checked_ops.rs" 119 12 119 15] [#"../checked_ops.rs" 119 12 119 15] (5 : uint8)) ([#"../checked_ops.rs" 119 28 119 29] [#"../checked_ops.rs" 119 28 119 29] (2 : uint8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 119 12 119 39] _10 <- ([#"../checked_ops.rs" 119 12 119 39] unwrap0 _11);
    _11 <- any Core_Option_Option_Type.t_option uint8;
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 119 4 119 45] not ([#"../checked_ops.rs" 119 12 119 44] _10 = ([#"../checked_ops.rs" 119 43 119 44] [#"../checked_ops.rs" 119 43 119 44] (2 : uint8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 119 4 119 45] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 120 12 120 31] _16 <- ([#"../checked_ops.rs" 120 12 120 31] wrapping_div0 ([#"../checked_ops.rs" 120 12 120 15] [#"../checked_ops.rs" 120 12 120 15] (5 : uint8)) ([#"../checked_ops.rs" 120 29 120 30] [#"../checked_ops.rs" 120 29 120 30] (2 : uint8)));
    goto BB9
  }
  BB9 {
    switch ([#"../checked_ops.rs" 120 4 120 37] not ([#"../checked_ops.rs" 120 12 120 36] _16 = ([#"../checked_ops.rs" 120 35 120 36] [#"../checked_ops.rs" 120 35 120 36] (2 : uint8))))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    assert { [#"../checked_ops.rs" 120 4 120 37] false };
    absurd
  }
  BB11 {
    [#"../checked_ops.rs" 121 12 121 33] _21 <- ([#"../checked_ops.rs" 121 12 121 33] saturating_div0 ([#"../checked_ops.rs" 121 12 121 15] [#"../checked_ops.rs" 121 12 121 15] (5 : uint8)) ([#"../checked_ops.rs" 121 31 121 32] [#"../checked_ops.rs" 121 31 121 32] (2 : uint8)));
    goto BB12
  }
  BB12 {
    switch ([#"../checked_ops.rs" 121 4 121 39] not ([#"../checked_ops.rs" 121 12 121 38] _21 = ([#"../checked_ops.rs" 121 37 121 38] [#"../checked_ops.rs" 121 37 121 38] (2 : uint8))))
      | False -> goto BB14
      | True -> goto BB13
      end
  }
  BB13 {
    assert { [#"../checked_ops.rs" 121 4 121 39] false };
    absurd
  }
  BB14 {
    [#"../checked_ops.rs" 122 14 122 36] res <- ([#"../checked_ops.rs" 122 14 122 36] overflowing_div0 ([#"../checked_ops.rs" 122 14 122 17] [#"../checked_ops.rs" 122 14 122 17] (5 : uint8)) ([#"../checked_ops.rs" 122 34 122 35] [#"../checked_ops.rs" 122 34 122 35] (2 : uint8)));
    goto BB15
  }
  BB15 {
    switch ([#"../checked_ops.rs" 123 12 123 22] ([#"../checked_ops.rs" 123 12 123 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 123 21 123 22] [#"../checked_ops.rs" 123 21 123 22] (2 : uint8)))
      | False -> goto BB16
      | True -> goto BB17
      end
  }
  BB16 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 123 12 123 40] _26 <- ([#"../checked_ops.rs" 123 12 123 40] [#"../checked_ops.rs" 123 12 123 40] false);
    goto BB18
  }
  BB17 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 123 12 123 40] _26 <- ([#"../checked_ops.rs" 123 26 123 40] Bool.eqb ([#"../checked_ops.rs" 123 26 123 31] let (_, a) = res in a) ([#"../checked_ops.rs" 123 35 123 40] [#"../checked_ops.rs" 123 35 123 40] false));
    goto BB18
  }
  BB18 {
    switch ([#"../checked_ops.rs" 123 4 123 41] not _26)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB19 {
    assert { [#"../checked_ops.rs" 123 4 123 41] false };
    absurd
  }
  BB20 {
    [#"../checked_ops.rs" 117 29 124 1] _0 <- ([#"../checked_ops.rs" 117 29 124 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8DivNoOverflow
  use prelude.UInt8
  predicate invariant1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : uint8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : uint8)
  val inv1 (_x : uint8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : uint8 . inv1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.UInt8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (uint8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  val overflowing_div0 (self : uint8) (rhs : uint8) : (uint8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1) }
    
  val saturating_div0 (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  val wrapping_div0 (self : uint8) (rhs : uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] UInt8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 -> UInt8.to_int result = UInt8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1 \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option uint8) : uint8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_div0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  let rec cfg test_u8_div_no_overflow [#"../checked_ops.rs" 128 0 128 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) (b : uint8) : ()
    requires {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b <> 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var b : uint8 = b;
  var _7 : uint8;
  var _8 : Core_Option_Option_Type.t_option uint8;
  var _13 : uint8;
  var _14 : bool;
  var _19 : uint8;
  var _24 : uint8;
  var _25 : bool;
  var _30 : uint8;
  var _35 : uint8;
  var _36 : bool;
  var res : (uint8, bool);
  var _43 : bool;
  var _48 : uint8;
  var _49 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 129 12 129 28] _8 <- ([#"../checked_ops.rs" 129 12 129 28] checked_div0 ([#"../checked_ops.rs" 129 12 129 13] a) ([#"../checked_ops.rs" 129 26 129 27] b));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 129 12 129 37] _7 <- ([#"../checked_ops.rs" 129 12 129 37] unwrap0 _8);
    _8 <- any Core_Option_Option_Type.t_option uint8;
    goto BB2
  }
  BB2 {
    [#"../checked_ops.rs" 129 45 129 46] _13 <- ([#"../checked_ops.rs" 129 45 129 46] b);
    [#"../checked_ops.rs" 129 41 129 46] _14 <- ([#"../checked_ops.rs" 129 41 129 46] _13 = ([#"../checked_ops.rs" 129 41 129 46] [#"../checked_ops.rs" 129 41 129 46] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 129 41 129 46] not _14 };
    goto BB3
  }
  BB3 {
    switch ([#"../checked_ops.rs" 129 4 129 47] not ([#"../checked_ops.rs" 129 12 129 46] _7 = ([#"../checked_ops.rs" 129 41 129 46] ([#"../checked_ops.rs" 129 41 129 42] a) / _13)))
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    assert { [#"../checked_ops.rs" 129 4 129 47] false };
    absurd
  }
  BB5 {
    [#"../checked_ops.rs" 130 12 130 29] _19 <- ([#"../checked_ops.rs" 130 12 130 29] wrapping_div0 ([#"../checked_ops.rs" 130 12 130 13] a) ([#"../checked_ops.rs" 130 27 130 28] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 130 37 130 38] _24 <- ([#"../checked_ops.rs" 130 37 130 38] b);
    [#"../checked_ops.rs" 130 33 130 38] _25 <- ([#"../checked_ops.rs" 130 33 130 38] _24 = ([#"../checked_ops.rs" 130 33 130 38] [#"../checked_ops.rs" 130 33 130 38] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 130 33 130 38] not _25 };
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 130 4 130 39] not ([#"../checked_ops.rs" 130 12 130 38] _19 = ([#"../checked_ops.rs" 130 33 130 38] ([#"../checked_ops.rs" 130 33 130 34] a) / _24)))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 130 4 130 39] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 131 12 131 31] _30 <- ([#"../checked_ops.rs" 131 12 131 31] saturating_div0 ([#"../checked_ops.rs" 131 12 131 13] a) ([#"../checked_ops.rs" 131 29 131 30] b));
    goto BB10
  }
  BB10 {
    [#"../checked_ops.rs" 131 39 131 40] _35 <- ([#"../checked_ops.rs" 131 39 131 40] b);
    [#"../checked_ops.rs" 131 35 131 40] _36 <- ([#"../checked_ops.rs" 131 35 131 40] _35 = ([#"../checked_ops.rs" 131 35 131 40] [#"../checked_ops.rs" 131 35 131 40] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 131 35 131 40] not _36 };
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 131 4 131 41] not ([#"../checked_ops.rs" 131 12 131 40] _30 = ([#"../checked_ops.rs" 131 35 131 40] ([#"../checked_ops.rs" 131 35 131 36] a) / _35)))
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB12 {
    assert { [#"../checked_ops.rs" 131 4 131 41] false };
    absurd
  }
  BB13 {
    [#"../checked_ops.rs" 132 14 132 34] res <- ([#"../checked_ops.rs" 132 14 132 34] overflowing_div0 ([#"../checked_ops.rs" 132 14 132 15] a) ([#"../checked_ops.rs" 132 32 132 33] b));
    goto BB14
  }
  BB14 {
    [#"../checked_ops.rs" 133 25 133 26] _48 <- ([#"../checked_ops.rs" 133 25 133 26] b);
    [#"../checked_ops.rs" 133 21 133 26] _49 <- ([#"../checked_ops.rs" 133 21 133 26] _48 = ([#"../checked_ops.rs" 133 21 133 26] [#"../checked_ops.rs" 133 21 133 26] (0 : uint8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 133 21 133 26] not _49 };
    goto BB18
  }
  BB15 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 133 12 133 44] _43 <- ([#"../checked_ops.rs" 133 12 133 44] [#"../checked_ops.rs" 133 12 133 44] false);
    goto BB17
  }
  BB16 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 133 12 133 44] _43 <- ([#"../checked_ops.rs" 133 30 133 44] Bool.eqb ([#"../checked_ops.rs" 133 30 133 35] let (_, a) = res in a) ([#"../checked_ops.rs" 133 39 133 44] [#"../checked_ops.rs" 133 39 133 44] false));
    goto BB17
  }
  BB17 {
    switch ([#"../checked_ops.rs" 133 4 133 45] not _43)
      | False -> goto BB20
      | True -> goto BB19
      end
  }
  BB18 {
    switch ([#"../checked_ops.rs" 133 12 133 26] ([#"../checked_ops.rs" 133 12 133 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 133 21 133 26] ([#"../checked_ops.rs" 133 21 133 22] a) / _48))
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB19 {
    assert { [#"../checked_ops.rs" 133 4 133 45] false };
    absurd
  }
  BB20 {
    [#"../checked_ops.rs" 128 45 134 1] _0 <- ([#"../checked_ops.rs" 128 45 134 1] ());
    return _0
  }
  
end
module CheckedOps_TestU8DivZero
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option uint8)
  val inv0 (_x : Core_Option_Option_Type.t_option uint8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option uint8 . inv0 x = true
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option uint8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant min0  : uint8 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint8)
  use prelude.UInt8
  val checked_div0 (self : uint8) (rhs : uint8) : Core_Option_Option_Type.t_option uint8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int min0 /\ UInt8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : uint8 . result = Core_Option_Option_Type.C_Some r -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs) }
    
  let rec cfg test_u8_div_zero [#"../checked_ops.rs" 137 0 137 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : uint8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : uint8 = a;
  var _4 : bool;
  var _6 : Core_Option_Option_Type.t_option uint8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 138 12 138 28] _6 <- ([#"../checked_ops.rs" 138 12 138 28] checked_div0 ([#"../checked_ops.rs" 138 12 138 13] a) ([#"../checked_ops.rs" 138 26 138 27] [#"../checked_ops.rs" 138 26 138 27] (0 : uint8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 138 12 138 38] _4 <- ([#"../checked_ops.rs" 138 12 138 38] is_none0 ([#"../checked_ops.rs" 138 12 138 38] _6));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 138 4 138 39] not _4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 138 4 138 39] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 137 31 139 1] _0 <- ([#"../checked_ops.rs" 137 31 139 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8AddExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option int8)
  val inv2 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option int8 . inv2 x = true
  predicate invariant1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int8)
  val inv1 (_x : int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.Int8
  val overflowing_add0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_add0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
  let rec cfg test_i8_add_example [#"../checked_ops.rs" 142 0 142 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 143 12 143 31] _5 <- ([#"../checked_ops.rs" 143 12 143 31] checked_add0 ([#"../checked_ops.rs" 143 12 143 15] [#"../checked_ops.rs" 143 12 143 15] (5 : int8)) ([#"../checked_ops.rs" 143 28 143 30] [#"../checked_ops.rs" 143 28 143 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 143 12 143 40] _4 <- ([#"../checked_ops.rs" 143 12 143 40] unwrap0 _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 143 4 143 47] not ([#"../checked_ops.rs" 143 12 143 46] _4 = ([#"../checked_ops.rs" 143 44 143 46] [#"../checked_ops.rs" 143 44 143 46] (15 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 143 4 143 47] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 144 12 144 33] _11 <- ([#"../checked_ops.rs" 144 12 144 33] checked_add0 ([#"../checked_ops.rs" 144 12 144 17] [#"../checked_ops.rs" 144 12 144 17] (120 : int8)) ([#"../checked_ops.rs" 144 30 144 32] [#"../checked_ops.rs" 144 30 144 32] (10 : int8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 144 12 144 43] _9 <- ([#"../checked_ops.rs" 144 12 144 43] is_none0 ([#"../checked_ops.rs" 144 12 144 43] _11));
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 144 4 144 44] not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 144 4 144 44] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 145 12 145 37] _17 <- ([#"../checked_ops.rs" 145 12 145 37] checked_add0 ([#"../checked_ops.rs" 145 12 145 20] [#"../checked_ops.rs" 145 12 145 20] (-120 : int8)) ([#"../checked_ops.rs" 145 33 145 36] [#"../checked_ops.rs" 145 33 145 36] (-10 : int8)));
    goto BB9
  }
  BB9 {
    [#"../checked_ops.rs" 145 12 145 47] _15 <- ([#"../checked_ops.rs" 145 12 145 47] is_none0 ([#"../checked_ops.rs" 145 12 145 47] _17));
    goto BB10
  }
  BB10 {
    switch ([#"../checked_ops.rs" 145 4 145 48] not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    assert { [#"../checked_ops.rs" 145 4 145 48] false };
    absurd
  }
  BB12 {
    [#"../checked_ops.rs" 147 12 147 32] _22 <- ([#"../checked_ops.rs" 147 12 147 32] wrapping_add0 ([#"../checked_ops.rs" 147 12 147 15] [#"../checked_ops.rs" 147 12 147 15] (5 : int8)) ([#"../checked_ops.rs" 147 29 147 31] [#"../checked_ops.rs" 147 29 147 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch ([#"../checked_ops.rs" 147 4 147 39] not ([#"../checked_ops.rs" 147 12 147 38] _22 = ([#"../checked_ops.rs" 147 36 147 38] [#"../checked_ops.rs" 147 36 147 38] (15 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    assert { [#"../checked_ops.rs" 147 4 147 39] false };
    absurd
  }
  BB15 {
    [#"../checked_ops.rs" 148 12 148 34] _27 <- ([#"../checked_ops.rs" 148 12 148 34] wrapping_add0 ([#"../checked_ops.rs" 148 12 148 17] [#"../checked_ops.rs" 148 12 148 17] (120 : int8)) ([#"../checked_ops.rs" 148 31 148 33] [#"../checked_ops.rs" 148 31 148 33] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch ([#"../checked_ops.rs" 148 4 148 43] not ([#"../checked_ops.rs" 148 12 148 42] _27 = ([#"../checked_ops.rs" 148 38 148 42] [#"../checked_ops.rs" 148 38 148 42] (-126 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    assert { [#"../checked_ops.rs" 148 4 148 43] false };
    absurd
  }
  BB18 {
    [#"../checked_ops.rs" 149 12 149 38] _32 <- ([#"../checked_ops.rs" 149 12 149 38] wrapping_add0 ([#"../checked_ops.rs" 149 12 149 20] [#"../checked_ops.rs" 149 12 149 20] (-120 : int8)) ([#"../checked_ops.rs" 149 34 149 37] [#"../checked_ops.rs" 149 34 149 37] (-10 : int8)));
    goto BB19
  }
  BB19 {
    switch ([#"../checked_ops.rs" 149 4 149 46] not ([#"../checked_ops.rs" 149 12 149 45] _32 = ([#"../checked_ops.rs" 149 42 149 45] [#"../checked_ops.rs" 149 42 149 45] (126 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    assert { [#"../checked_ops.rs" 149 4 149 46] false };
    absurd
  }
  BB21 {
    [#"../checked_ops.rs" 151 12 151 34] _37 <- ([#"../checked_ops.rs" 151 12 151 34] saturating_add0 ([#"../checked_ops.rs" 151 12 151 15] [#"../checked_ops.rs" 151 12 151 15] (5 : int8)) ([#"../checked_ops.rs" 151 31 151 33] [#"../checked_ops.rs" 151 31 151 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch ([#"../checked_ops.rs" 151 4 151 41] not ([#"../checked_ops.rs" 151 12 151 40] _37 = ([#"../checked_ops.rs" 151 38 151 40] [#"../checked_ops.rs" 151 38 151 40] (15 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    assert { [#"../checked_ops.rs" 151 4 151 41] false };
    absurd
  }
  BB24 {
    [#"../checked_ops.rs" 152 12 152 36] _42 <- ([#"../checked_ops.rs" 152 12 152 36] saturating_add0 ([#"../checked_ops.rs" 152 12 152 17] [#"../checked_ops.rs" 152 12 152 17] (120 : int8)) ([#"../checked_ops.rs" 152 33 152 35] [#"../checked_ops.rs" 152 33 152 35] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch ([#"../checked_ops.rs" 152 4 152 44] not ([#"../checked_ops.rs" 152 12 152 43] _42 = ([#"../checked_ops.rs" 152 40 152 43] [#"../checked_ops.rs" 152 40 152 43] (127 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assert { [#"../checked_ops.rs" 152 4 152 44] false };
    absurd
  }
  BB27 {
    [#"../checked_ops.rs" 153 12 153 40] _47 <- ([#"../checked_ops.rs" 153 12 153 40] saturating_add0 ([#"../checked_ops.rs" 153 12 153 20] [#"../checked_ops.rs" 153 12 153 20] (-120 : int8)) ([#"../checked_ops.rs" 153 36 153 39] [#"../checked_ops.rs" 153 36 153 39] (-10 : int8)));
    goto BB28
  }
  BB28 {
    switch ([#"../checked_ops.rs" 153 4 153 49] not ([#"../checked_ops.rs" 153 12 153 48] _47 = ([#"../checked_ops.rs" 153 44 153 48] [#"../checked_ops.rs" 153 44 153 48] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    assert { [#"../checked_ops.rs" 153 4 153 49] false };
    absurd
  }
  BB30 {
    [#"../checked_ops.rs" 155 14 155 37] res <- ([#"../checked_ops.rs" 155 14 155 37] overflowing_add0 ([#"../checked_ops.rs" 155 14 155 17] [#"../checked_ops.rs" 155 14 155 17] (5 : int8)) ([#"../checked_ops.rs" 155 34 155 36] [#"../checked_ops.rs" 155 34 155 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 156 12 156 23] ([#"../checked_ops.rs" 156 12 156 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 156 21 156 23] [#"../checked_ops.rs" 156 21 156 23] (15 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 156 12 156 41] _52 <- ([#"../checked_ops.rs" 156 12 156 41] [#"../checked_ops.rs" 156 12 156 41] false);
    goto BB34
  }
  BB33 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 156 12 156 41] _52 <- ([#"../checked_ops.rs" 156 27 156 41] Bool.eqb ([#"../checked_ops.rs" 156 27 156 32] let (_, a) = res in a) ([#"../checked_ops.rs" 156 36 156 41] [#"../checked_ops.rs" 156 36 156 41] false));
    goto BB34
  }
  BB34 {
    switch ([#"../checked_ops.rs" 156 4 156 42] not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assert { [#"../checked_ops.rs" 156 4 156 42] false };
    absurd
  }
  BB36 {
    [#"../checked_ops.rs" 157 14 157 39] res1 <- ([#"../checked_ops.rs" 157 14 157 39] overflowing_add0 ([#"../checked_ops.rs" 157 14 157 19] [#"../checked_ops.rs" 157 14 157 19] (120 : int8)) ([#"../checked_ops.rs" 157 36 157 38] [#"../checked_ops.rs" 157 36 157 38] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 158 12 158 25] ([#"../checked_ops.rs" 158 12 158 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 158 21 158 25] [#"../checked_ops.rs" 158 21 158 25] (-126 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 158 12 158 42] _61 <- ([#"../checked_ops.rs" 158 12 158 42] [#"../checked_ops.rs" 158 12 158 42] false);
    goto BB40
  }
  BB39 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 158 12 158 42] _61 <- ([#"../checked_ops.rs" 158 29 158 42] Bool.eqb ([#"../checked_ops.rs" 158 29 158 34] let (_, a) = res1 in a) ([#"../checked_ops.rs" 158 38 158 42] [#"../checked_ops.rs" 158 38 158 42] true));
    goto BB40
  }
  BB40 {
    switch ([#"../checked_ops.rs" 158 4 158 43] not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assert { [#"../checked_ops.rs" 158 4 158 43] false };
    absurd
  }
  BB42 {
    [#"../checked_ops.rs" 159 14 159 43] res2 <- ([#"../checked_ops.rs" 159 14 159 43] overflowing_add0 ([#"../checked_ops.rs" 159 14 159 22] [#"../checked_ops.rs" 159 14 159 22] (-120 : int8)) ([#"../checked_ops.rs" 159 39 159 42] [#"../checked_ops.rs" 159 39 159 42] (-10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 160 12 160 24] ([#"../checked_ops.rs" 160 12 160 17] let (a, _) = res2 in a) = ([#"../checked_ops.rs" 160 21 160 24] [#"../checked_ops.rs" 160 21 160 24] (126 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 160 12 160 41] _70 <- ([#"../checked_ops.rs" 160 12 160 41] [#"../checked_ops.rs" 160 12 160 41] false);
    goto BB46
  }
  BB45 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 160 12 160 41] _70 <- ([#"../checked_ops.rs" 160 28 160 41] Bool.eqb ([#"../checked_ops.rs" 160 28 160 33] let (_, a) = res2 in a) ([#"../checked_ops.rs" 160 37 160 41] [#"../checked_ops.rs" 160 37 160 41] true));
    goto BB46
  }
  BB46 {
    switch ([#"../checked_ops.rs" 160 4 160 42] not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assert { [#"../checked_ops.rs" 160 4 160 42] false };
    absurd
  }
  BB48 {
    [#"../checked_ops.rs" 142 29 161 1] _0 <- ([#"../checked_ops.rs" 142 29 161 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowPos
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Int8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_add0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_add0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
  let rec cfg test_i8_add_overflow_pos [#"../checked_ops.rs" 165 0 165 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 166 12 166 32] _7 <- ([#"../checked_ops.rs" 166 12 166 32] checked_add0 ([#"../checked_ops.rs" 166 12 166 17] [#"../checked_ops.rs" 166 12 166 17] (127 : int8)) ([#"../checked_ops.rs" 166 30 166 31] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 166 12 166 42] _5 <- ([#"../checked_ops.rs" 166 12 166 42] is_none0 ([#"../checked_ops.rs" 166 12 166 42] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 166 4 166 43] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 166 4 166 43] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 167 12 167 33] _13 <- ([#"../checked_ops.rs" 167 12 167 33] wrapping_add0 ([#"../checked_ops.rs" 167 12 167 17] [#"../checked_ops.rs" 167 12 167 17] (127 : int8)) ([#"../checked_ops.rs" 167 31 167 32] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 167 4 167 49] not ([#"../checked_ops.rs" 167 12 167 48] _13 = ([#"../checked_ops.rs" 167 37 167 48] ([#"../checked_ops.rs" 167 37 167 44] ([#"../checked_ops.rs" 167 37 167 38] a) - ([#"../checked_ops.rs" 167 41 167 44] [#"../checked_ops.rs" 167 41 167 44] (127 : int8))) - ([#"../checked_ops.rs" 167 47 167 48] [#"../checked_ops.rs" 167 47 167 48] (2 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 167 4 167 49] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 168 12 168 35] _22 <- ([#"../checked_ops.rs" 168 12 168 35] saturating_add0 ([#"../checked_ops.rs" 168 12 168 17] [#"../checked_ops.rs" 168 12 168 17] (127 : int8)) ([#"../checked_ops.rs" 168 33 168 34] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 168 4 168 43] not ([#"../checked_ops.rs" 168 12 168 42] _22 = ([#"../checked_ops.rs" 168 39 168 42] [#"../checked_ops.rs" 168 39 168 42] (127 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 168 4 168 43] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 169 14 169 38] res <- ([#"../checked_ops.rs" 169 14 169 38] overflowing_add0 ([#"../checked_ops.rs" 169 14 169 19] [#"../checked_ops.rs" 169 14 169 19] (127 : int8)) ([#"../checked_ops.rs" 169 36 169 37] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 170 12 170 32] ([#"../checked_ops.rs" 170 12 170 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 170 21 170 32] ([#"../checked_ops.rs" 170 21 170 28] ([#"../checked_ops.rs" 170 21 170 22] a) - ([#"../checked_ops.rs" 170 25 170 28] [#"../checked_ops.rs" 170 25 170 28] (127 : int8))) - ([#"../checked_ops.rs" 170 31 170 32] [#"../checked_ops.rs" 170 31 170 32] (2 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 170 12 170 49] _29 <- ([#"../checked_ops.rs" 170 12 170 49] [#"../checked_ops.rs" 170 12 170 49] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 170 12 170 49] _29 <- ([#"../checked_ops.rs" 170 36 170 49] Bool.eqb ([#"../checked_ops.rs" 170 36 170 41] let (_, a) = res in a) ([#"../checked_ops.rs" 170 45 170 49] [#"../checked_ops.rs" 170 45 170 49] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 170 4 170 50] not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 170 4 170 50] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 165 39 171 1] _0 <- ([#"../checked_ops.rs" 165 39 171 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8AddOverflowNeg
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Int8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_add0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_add0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
  let rec cfg test_i8_add_overflow_neg [#"../checked_ops.rs" 175 0 175 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 176 12 176 35] _7 <- ([#"../checked_ops.rs" 176 12 176 35] checked_add0 ([#"../checked_ops.rs" 176 12 176 20] [#"../checked_ops.rs" 176 12 176 20] (-128 : int8)) ([#"../checked_ops.rs" 176 33 176 34] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 176 12 176 45] _5 <- ([#"../checked_ops.rs" 176 12 176 45] is_none0 ([#"../checked_ops.rs" 176 12 176 45] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 176 4 176 46] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 176 4 176 46] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 177 12 177 36] _13 <- ([#"../checked_ops.rs" 177 12 177 36] wrapping_add0 ([#"../checked_ops.rs" 177 12 177 20] [#"../checked_ops.rs" 177 12 177 20] (-128 : int8)) ([#"../checked_ops.rs" 177 34 177 35] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 177 4 177 52] not ([#"../checked_ops.rs" 177 12 177 51] _13 = ([#"../checked_ops.rs" 177 40 177 51] ([#"../checked_ops.rs" 177 40 177 47] ([#"../checked_ops.rs" 177 40 177 41] a) + ([#"../checked_ops.rs" 177 44 177 47] [#"../checked_ops.rs" 177 44 177 47] (127 : int8))) + ([#"../checked_ops.rs" 177 50 177 51] [#"../checked_ops.rs" 177 50 177 51] (1 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 177 4 177 52] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 178 12 178 38] _22 <- ([#"../checked_ops.rs" 178 12 178 38] saturating_add0 ([#"../checked_ops.rs" 178 12 178 20] [#"../checked_ops.rs" 178 12 178 20] (-128 : int8)) ([#"../checked_ops.rs" 178 36 178 37] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 178 4 178 47] not ([#"../checked_ops.rs" 178 12 178 46] _22 = ([#"../checked_ops.rs" 178 42 178 46] [#"../checked_ops.rs" 178 42 178 46] (-128 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 178 4 178 47] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 179 14 179 41] res <- ([#"../checked_ops.rs" 179 14 179 41] overflowing_add0 ([#"../checked_ops.rs" 179 14 179 22] [#"../checked_ops.rs" 179 14 179 22] (-128 : int8)) ([#"../checked_ops.rs" 179 39 179 40] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 180 12 180 32] ([#"../checked_ops.rs" 180 12 180 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 180 21 180 32] ([#"../checked_ops.rs" 180 21 180 28] ([#"../checked_ops.rs" 180 21 180 22] a) + ([#"../checked_ops.rs" 180 25 180 28] [#"../checked_ops.rs" 180 25 180 28] (127 : int8))) + ([#"../checked_ops.rs" 180 31 180 32] [#"../checked_ops.rs" 180 31 180 32] (1 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 180 12 180 49] _29 <- ([#"../checked_ops.rs" 180 12 180 49] [#"../checked_ops.rs" 180 12 180 49] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 180 12 180 49] _29 <- ([#"../checked_ops.rs" 180 36 180 49] Bool.eqb ([#"../checked_ops.rs" 180 36 180 41] let (_, a) = res in a) ([#"../checked_ops.rs" 180 45 180 49] [#"../checked_ops.rs" 180 45 180 49] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 180 4 180 50] not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 180 4 180 50] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 175 39 181 1] _0 <- ([#"../checked_ops.rs" 175 39 181 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8WrappingAdd
  use prelude.Int8
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  let rec cfg test_i8_wrapping_add [#"../checked_ops.rs" 186 0 186 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result = Int8.to_int a + Int8.to_int b \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256 \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a : int8 = a;
  var b : int8 = b;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 187 4 187 21] _0 <- ([#"../checked_ops.rs" 187 4 187 21] wrapping_add0 ([#"../checked_ops.rs" 187 4 187 5] a) ([#"../checked_ops.rs" 187 19 187 20] b));
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingAdd
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use prelude.Int8
  val checked_add0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_add0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_add0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self + Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self + Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self + Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int max0) }
    
  let rec cfg test_i8_overflowing_add [#"../checked_ops.rs" 191 0 191 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 192 12 192 32] _7 <- ([#"../checked_ops.rs" 192 12 192 32] overflowing_add0 ([#"../checked_ops.rs" 192 12 192 13] a) ([#"../checked_ops.rs" 192 30 192 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 192 38 192 55] _10 <- ([#"../checked_ops.rs" 192 38 192 55] wrapping_add0 ([#"../checked_ops.rs" 192 38 192 39] a) ([#"../checked_ops.rs" 192 53 192 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 192 4 192 56] not ([#"../checked_ops.rs" 192 12 192 55] ([#"../checked_ops.rs" 192 12 192 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 192 4 192 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 193 12 193 32] _18 <- ([#"../checked_ops.rs" 193 12 193 32] overflowing_add0 ([#"../checked_ops.rs" 193 12 193 13] a) ([#"../checked_ops.rs" 193 30 193 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 193 38 193 54] _23 <- ([#"../checked_ops.rs" 193 38 193 54] checked_add0 ([#"../checked_ops.rs" 193 38 193 39] a) ([#"../checked_ops.rs" 193 52 193 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 193 38 193 64] _21 <- ([#"../checked_ops.rs" 193 38 193 64] is_none0 ([#"../checked_ops.rs" 193 38 193 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 193 4 193 65] not ([#"../checked_ops.rs" 193 12 193 64] Bool.eqb ([#"../checked_ops.rs" 193 12 193 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 193 4 193 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 191 45 194 1] _0 <- ([#"../checked_ops.rs" 191 45 194 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8SubExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option int8)
  val inv2 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option int8 . inv2 x = true
  predicate invariant1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int8)
  val inv1 (_x : int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.Int8
  val overflowing_sub0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_sub0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
  let rec cfg test_i8_sub_example [#"../checked_ops.rs" 197 0 197 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 198 12 198 31] _5 <- ([#"../checked_ops.rs" 198 12 198 31] checked_sub0 ([#"../checked_ops.rs" 198 12 198 15] [#"../checked_ops.rs" 198 12 198 15] (5 : int8)) ([#"../checked_ops.rs" 198 28 198 30] [#"../checked_ops.rs" 198 28 198 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 198 12 198 40] _4 <- ([#"../checked_ops.rs" 198 12 198 40] unwrap0 _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 198 4 198 47] not ([#"../checked_ops.rs" 198 12 198 46] _4 = ([#"../checked_ops.rs" 198 44 198 46] [#"../checked_ops.rs" 198 44 198 46] (-5 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 198 4 198 47] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 199 12 199 33] _11 <- ([#"../checked_ops.rs" 199 12 199 33] checked_sub0 ([#"../checked_ops.rs" 199 12 199 17] [#"../checked_ops.rs" 199 12 199 17] (120 : int8)) ([#"../checked_ops.rs" 199 30 199 32] [#"../checked_ops.rs" 199 30 199 32] (10 : int8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 199 12 199 42] _10 <- ([#"../checked_ops.rs" 199 12 199 42] unwrap0 _11);
    _11 <- any Core_Option_Option_Type.t_option int8;
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 199 4 199 50] not ([#"../checked_ops.rs" 199 12 199 49] _10 = ([#"../checked_ops.rs" 199 46 199 49] [#"../checked_ops.rs" 199 46 199 49] (110 : int8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 199 4 199 50] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 200 12 200 36] _17 <- ([#"../checked_ops.rs" 200 12 200 36] checked_sub0 ([#"../checked_ops.rs" 200 12 200 20] [#"../checked_ops.rs" 200 12 200 20] (-120 : int8)) ([#"../checked_ops.rs" 200 33 200 35] [#"../checked_ops.rs" 200 33 200 35] (10 : int8)));
    goto BB9
  }
  BB9 {
    [#"../checked_ops.rs" 200 12 200 46] _15 <- ([#"../checked_ops.rs" 200 12 200 46] is_none0 ([#"../checked_ops.rs" 200 12 200 46] _17));
    goto BB10
  }
  BB10 {
    switch ([#"../checked_ops.rs" 200 4 200 47] not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    assert { [#"../checked_ops.rs" 200 4 200 47] false };
    absurd
  }
  BB12 {
    [#"../checked_ops.rs" 202 12 202 32] _22 <- ([#"../checked_ops.rs" 202 12 202 32] wrapping_sub0 ([#"../checked_ops.rs" 202 12 202 15] [#"../checked_ops.rs" 202 12 202 15] (5 : int8)) ([#"../checked_ops.rs" 202 29 202 31] [#"../checked_ops.rs" 202 29 202 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch ([#"../checked_ops.rs" 202 4 202 39] not ([#"../checked_ops.rs" 202 12 202 38] _22 = ([#"../checked_ops.rs" 202 36 202 38] [#"../checked_ops.rs" 202 36 202 38] (-5 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    assert { [#"../checked_ops.rs" 202 4 202 39] false };
    absurd
  }
  BB15 {
    [#"../checked_ops.rs" 203 12 203 34] _27 <- ([#"../checked_ops.rs" 203 12 203 34] wrapping_sub0 ([#"../checked_ops.rs" 203 12 203 17] [#"../checked_ops.rs" 203 12 203 17] (120 : int8)) ([#"../checked_ops.rs" 203 31 203 33] [#"../checked_ops.rs" 203 31 203 33] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch ([#"../checked_ops.rs" 203 4 203 42] not ([#"../checked_ops.rs" 203 12 203 41] _27 = ([#"../checked_ops.rs" 203 38 203 41] [#"../checked_ops.rs" 203 38 203 41] (110 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    assert { [#"../checked_ops.rs" 203 4 203 42] false };
    absurd
  }
  BB18 {
    [#"../checked_ops.rs" 204 12 204 37] _32 <- ([#"../checked_ops.rs" 204 12 204 37] wrapping_sub0 ([#"../checked_ops.rs" 204 12 204 20] [#"../checked_ops.rs" 204 12 204 20] (-120 : int8)) ([#"../checked_ops.rs" 204 34 204 36] [#"../checked_ops.rs" 204 34 204 36] (10 : int8)));
    goto BB19
  }
  BB19 {
    switch ([#"../checked_ops.rs" 204 4 204 45] not ([#"../checked_ops.rs" 204 12 204 44] _32 = ([#"../checked_ops.rs" 204 41 204 44] [#"../checked_ops.rs" 204 41 204 44] (126 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    assert { [#"../checked_ops.rs" 204 4 204 45] false };
    absurd
  }
  BB21 {
    [#"../checked_ops.rs" 206 12 206 34] _37 <- ([#"../checked_ops.rs" 206 12 206 34] saturating_sub0 ([#"../checked_ops.rs" 206 12 206 15] [#"../checked_ops.rs" 206 12 206 15] (5 : int8)) ([#"../checked_ops.rs" 206 31 206 33] [#"../checked_ops.rs" 206 31 206 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch ([#"../checked_ops.rs" 206 4 206 41] not ([#"../checked_ops.rs" 206 12 206 40] _37 = ([#"../checked_ops.rs" 206 38 206 40] [#"../checked_ops.rs" 206 38 206 40] (-5 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    assert { [#"../checked_ops.rs" 206 4 206 41] false };
    absurd
  }
  BB24 {
    [#"../checked_ops.rs" 207 12 207 36] _42 <- ([#"../checked_ops.rs" 207 12 207 36] saturating_sub0 ([#"../checked_ops.rs" 207 12 207 17] [#"../checked_ops.rs" 207 12 207 17] (120 : int8)) ([#"../checked_ops.rs" 207 33 207 35] [#"../checked_ops.rs" 207 33 207 35] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch ([#"../checked_ops.rs" 207 4 207 44] not ([#"../checked_ops.rs" 207 12 207 43] _42 = ([#"../checked_ops.rs" 207 40 207 43] [#"../checked_ops.rs" 207 40 207 43] (110 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assert { [#"../checked_ops.rs" 207 4 207 44] false };
    absurd
  }
  BB27 {
    [#"../checked_ops.rs" 208 12 208 39] _47 <- ([#"../checked_ops.rs" 208 12 208 39] saturating_sub0 ([#"../checked_ops.rs" 208 12 208 20] [#"../checked_ops.rs" 208 12 208 20] (-120 : int8)) ([#"../checked_ops.rs" 208 36 208 38] [#"../checked_ops.rs" 208 36 208 38] (10 : int8)));
    goto BB28
  }
  BB28 {
    switch ([#"../checked_ops.rs" 208 4 208 48] not ([#"../checked_ops.rs" 208 12 208 47] _47 = ([#"../checked_ops.rs" 208 43 208 47] [#"../checked_ops.rs" 208 43 208 47] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    assert { [#"../checked_ops.rs" 208 4 208 48] false };
    absurd
  }
  BB30 {
    [#"../checked_ops.rs" 210 14 210 37] res <- ([#"../checked_ops.rs" 210 14 210 37] overflowing_sub0 ([#"../checked_ops.rs" 210 14 210 17] [#"../checked_ops.rs" 210 14 210 17] (5 : int8)) ([#"../checked_ops.rs" 210 34 210 36] [#"../checked_ops.rs" 210 34 210 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 211 12 211 23] ([#"../checked_ops.rs" 211 12 211 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 211 21 211 23] [#"../checked_ops.rs" 211 21 211 23] (-5 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 211 12 211 41] _52 <- ([#"../checked_ops.rs" 211 12 211 41] [#"../checked_ops.rs" 211 12 211 41] false);
    goto BB34
  }
  BB33 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 211 12 211 41] _52 <- ([#"../checked_ops.rs" 211 27 211 41] Bool.eqb ([#"../checked_ops.rs" 211 27 211 32] let (_, a) = res in a) ([#"../checked_ops.rs" 211 36 211 41] [#"../checked_ops.rs" 211 36 211 41] false));
    goto BB34
  }
  BB34 {
    switch ([#"../checked_ops.rs" 211 4 211 42] not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assert { [#"../checked_ops.rs" 211 4 211 42] false };
    absurd
  }
  BB36 {
    [#"../checked_ops.rs" 212 14 212 39] res1 <- ([#"../checked_ops.rs" 212 14 212 39] overflowing_sub0 ([#"../checked_ops.rs" 212 14 212 19] [#"../checked_ops.rs" 212 14 212 19] (120 : int8)) ([#"../checked_ops.rs" 212 36 212 38] [#"../checked_ops.rs" 212 36 212 38] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 213 12 213 24] ([#"../checked_ops.rs" 213 12 213 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 213 21 213 24] [#"../checked_ops.rs" 213 21 213 24] (110 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 213 12 213 42] _61 <- ([#"../checked_ops.rs" 213 12 213 42] [#"../checked_ops.rs" 213 12 213 42] false);
    goto BB40
  }
  BB39 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 213 12 213 42] _61 <- ([#"../checked_ops.rs" 213 28 213 42] Bool.eqb ([#"../checked_ops.rs" 213 28 213 33] let (_, a) = res1 in a) ([#"../checked_ops.rs" 213 37 213 42] [#"../checked_ops.rs" 213 37 213 42] false));
    goto BB40
  }
  BB40 {
    switch ([#"../checked_ops.rs" 213 4 213 43] not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assert { [#"../checked_ops.rs" 213 4 213 43] false };
    absurd
  }
  BB42 {
    [#"../checked_ops.rs" 214 14 214 42] res2 <- ([#"../checked_ops.rs" 214 14 214 42] overflowing_sub0 ([#"../checked_ops.rs" 214 14 214 22] [#"../checked_ops.rs" 214 14 214 22] (-120 : int8)) ([#"../checked_ops.rs" 214 39 214 41] [#"../checked_ops.rs" 214 39 214 41] (10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 215 12 215 24] ([#"../checked_ops.rs" 215 12 215 17] let (a, _) = res2 in a) = ([#"../checked_ops.rs" 215 21 215 24] [#"../checked_ops.rs" 215 21 215 24] (126 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 215 12 215 41] _70 <- ([#"../checked_ops.rs" 215 12 215 41] [#"../checked_ops.rs" 215 12 215 41] false);
    goto BB46
  }
  BB45 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 215 12 215 41] _70 <- ([#"../checked_ops.rs" 215 28 215 41] Bool.eqb ([#"../checked_ops.rs" 215 28 215 33] let (_, a) = res2 in a) ([#"../checked_ops.rs" 215 37 215 41] [#"../checked_ops.rs" 215 37 215 41] true));
    goto BB46
  }
  BB46 {
    switch ([#"../checked_ops.rs" 215 4 215 42] not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assert { [#"../checked_ops.rs" 215 4 215 42] false };
    absurd
  }
  BB48 {
    [#"../checked_ops.rs" 197 29 216 1] _0 <- ([#"../checked_ops.rs" 197 29 216 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowPos
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Int8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_sub0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_sub0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
  let rec cfg test_i8_sub_overflow_pos [#"../checked_ops.rs" 220 0 220 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a > 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _22 : int8;
  var res : (int8, bool);
  var _29 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 221 12 221 35] _7 <- ([#"../checked_ops.rs" 221 12 221 35] checked_sub0 ([#"../checked_ops.rs" 221 12 221 20] [#"../checked_ops.rs" 221 12 221 20] (-128 : int8)) ([#"../checked_ops.rs" 221 33 221 34] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 221 12 221 45] _5 <- ([#"../checked_ops.rs" 221 12 221 45] is_none0 ([#"../checked_ops.rs" 221 12 221 45] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 221 4 221 46] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 221 4 221 46] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 222 12 222 36] _13 <- ([#"../checked_ops.rs" 222 12 222 36] wrapping_sub0 ([#"../checked_ops.rs" 222 12 222 20] [#"../checked_ops.rs" 222 12 222 20] (-128 : int8)) ([#"../checked_ops.rs" 222 34 222 35] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 222 4 222 52] not ([#"../checked_ops.rs" 222 12 222 51] _13 = ([#"../checked_ops.rs" 222 40 222 51] ([#"../checked_ops.rs" 222 40 222 47] ([#"../checked_ops.rs" 222 40 222 43] [#"../checked_ops.rs" 222 40 222 43] (127 : int8)) - ([#"../checked_ops.rs" 222 46 222 47] a)) + ([#"../checked_ops.rs" 222 50 222 51] [#"../checked_ops.rs" 222 50 222 51] (1 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 222 4 222 52] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 223 12 223 38] _22 <- ([#"../checked_ops.rs" 223 12 223 38] saturating_sub0 ([#"../checked_ops.rs" 223 12 223 20] [#"../checked_ops.rs" 223 12 223 20] (-128 : int8)) ([#"../checked_ops.rs" 223 36 223 37] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 223 4 223 47] not ([#"../checked_ops.rs" 223 12 223 46] _22 = ([#"../checked_ops.rs" 223 42 223 46] [#"../checked_ops.rs" 223 42 223 46] (-128 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 223 4 223 47] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 224 14 224 41] res <- ([#"../checked_ops.rs" 224 14 224 41] overflowing_sub0 ([#"../checked_ops.rs" 224 14 224 22] [#"../checked_ops.rs" 224 14 224 22] (-128 : int8)) ([#"../checked_ops.rs" 224 39 224 40] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 225 12 225 32] ([#"../checked_ops.rs" 225 12 225 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 225 21 225 32] ([#"../checked_ops.rs" 225 21 225 28] ([#"../checked_ops.rs" 225 21 225 24] [#"../checked_ops.rs" 225 21 225 24] (127 : int8)) - ([#"../checked_ops.rs" 225 27 225 28] a)) + ([#"../checked_ops.rs" 225 31 225 32] [#"../checked_ops.rs" 225 31 225 32] (1 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 225 12 225 49] _29 <- ([#"../checked_ops.rs" 225 12 225 49] [#"../checked_ops.rs" 225 12 225 49] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 225 12 225 49] _29 <- ([#"../checked_ops.rs" 225 36 225 49] Bool.eqb ([#"../checked_ops.rs" 225 36 225 41] let (_, a) = res in a) ([#"../checked_ops.rs" 225 45 225 49] [#"../checked_ops.rs" 225 45 225 49] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 225 4 225 50] not _29)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 225 4 225 50] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 220 39 226 1] _0 <- ([#"../checked_ops.rs" 220 39 226 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8SubOverflowNeg
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Int8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val overflowing_sub0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_sub0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
  let rec cfg test_i8_sub_overflow_neg [#"../checked_ops.rs" 230 0 230 38] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    requires {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a < 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : bool;
  var _7 : Core_Option_Option_Type.t_option int8;
  var _13 : int8;
  var _23 : int8;
  var res : (int8, bool);
  var _30 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 231 12 231 32] _7 <- ([#"../checked_ops.rs" 231 12 231 32] checked_sub0 ([#"../checked_ops.rs" 231 12 231 17] [#"../checked_ops.rs" 231 12 231 17] (127 : int8)) ([#"../checked_ops.rs" 231 30 231 31] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 231 12 231 42] _5 <- ([#"../checked_ops.rs" 231 12 231 42] is_none0 ([#"../checked_ops.rs" 231 12 231 42] _7));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 231 4 231 43] not _5)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 231 4 231 43] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 232 12 232 33] _13 <- ([#"../checked_ops.rs" 232 12 232 33] wrapping_sub0 ([#"../checked_ops.rs" 232 12 232 17] [#"../checked_ops.rs" 232 12 232 17] (127 : int8)) ([#"../checked_ops.rs" 232 31 232 32] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 232 4 232 52] not ([#"../checked_ops.rs" 232 12 232 51] _13 = ([#"../checked_ops.rs" 232 37 232 51] ([#"../checked_ops.rs" 232 37 232 45] - ([#"../checked_ops.rs" 232 38 232 45] ([#"../checked_ops.rs" 232 39 232 40] [#"../checked_ops.rs" 232 39 232 40] (2 : int8)) + ([#"../checked_ops.rs" 232 43 232 44] a))) - ([#"../checked_ops.rs" 232 48 232 51] [#"../checked_ops.rs" 232 48 232 51] (127 : int8)))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 232 4 232 52] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 233 12 233 35] _23 <- ([#"../checked_ops.rs" 233 12 233 35] saturating_sub0 ([#"../checked_ops.rs" 233 12 233 17] [#"../checked_ops.rs" 233 12 233 17] (127 : int8)) ([#"../checked_ops.rs" 233 33 233 34] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 233 4 233 43] not ([#"../checked_ops.rs" 233 12 233 42] _23 = ([#"../checked_ops.rs" 233 39 233 42] [#"../checked_ops.rs" 233 39 233 42] (127 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 233 4 233 43] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 234 14 234 38] res <- ([#"../checked_ops.rs" 234 14 234 38] overflowing_sub0 ([#"../checked_ops.rs" 234 14 234 19] [#"../checked_ops.rs" 234 14 234 19] (127 : int8)) ([#"../checked_ops.rs" 234 36 234 37] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 235 12 235 35] ([#"../checked_ops.rs" 235 12 235 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 235 21 235 35] ([#"../checked_ops.rs" 235 21 235 29] - ([#"../checked_ops.rs" 235 22 235 29] ([#"../checked_ops.rs" 235 23 235 24] [#"../checked_ops.rs" 235 23 235 24] (2 : int8)) + ([#"../checked_ops.rs" 235 27 235 28] a))) - ([#"../checked_ops.rs" 235 32 235 35] [#"../checked_ops.rs" 235 32 235 35] (127 : int8))))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 235 12 235 52] _30 <- ([#"../checked_ops.rs" 235 12 235 52] [#"../checked_ops.rs" 235 12 235 52] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 235 12 235 52] _30 <- ([#"../checked_ops.rs" 235 39 235 52] Bool.eqb ([#"../checked_ops.rs" 235 39 235 44] let (_, a) = res in a) ([#"../checked_ops.rs" 235 48 235 52] [#"../checked_ops.rs" 235 48 235 52] true));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 235 4 235 53] not _30)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 235 4 235 53] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 230 39 236 1] _0 <- ([#"../checked_ops.rs" 230 39 236 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8WrappingSub
  use prelude.Int8
  use prelude.Int8
  use prelude.Int
  use prelude.UInt32
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  let rec cfg test_i8_wrapping_sub [#"../checked_ops.rs" 241 0 241 47] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : int8
    ensures { [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result = Int8.to_int a - Int8.to_int b \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256 \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int8;
  var a : int8 = a;
  var b : int8 = b;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 242 4 242 21] _0 <- ([#"../checked_ops.rs" 242 4 242 21] wrapping_sub0 ([#"../checked_ops.rs" 242 4 242 5] a) ([#"../checked_ops.rs" 242 19 242 20] b));
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingSub
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use prelude.Int8
  val checked_sub0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_sub0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_sub0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self - Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self - Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self - Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int max0) }
    
  let rec cfg test_i8_overflowing_sub [#"../checked_ops.rs" 246 0 246 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 247 12 247 32] _7 <- ([#"../checked_ops.rs" 247 12 247 32] overflowing_sub0 ([#"../checked_ops.rs" 247 12 247 13] a) ([#"../checked_ops.rs" 247 30 247 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 247 38 247 55] _10 <- ([#"../checked_ops.rs" 247 38 247 55] wrapping_sub0 ([#"../checked_ops.rs" 247 38 247 39] a) ([#"../checked_ops.rs" 247 53 247 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 247 4 247 56] not ([#"../checked_ops.rs" 247 12 247 55] ([#"../checked_ops.rs" 247 12 247 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 247 4 247 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 248 12 248 32] _18 <- ([#"../checked_ops.rs" 248 12 248 32] overflowing_sub0 ([#"../checked_ops.rs" 248 12 248 13] a) ([#"../checked_ops.rs" 248 30 248 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 248 38 248 54] _23 <- ([#"../checked_ops.rs" 248 38 248 54] checked_sub0 ([#"../checked_ops.rs" 248 38 248 39] a) ([#"../checked_ops.rs" 248 52 248 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 248 38 248 64] _21 <- ([#"../checked_ops.rs" 248 38 248 64] is_none0 ([#"../checked_ops.rs" 248 38 248 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 248 4 248 65] not ([#"../checked_ops.rs" 248 12 248 64] Bool.eqb ([#"../checked_ops.rs" 248 12 248 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 248 4 248 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 246 45 249 1] _0 <- ([#"../checked_ops.rs" 246 45 249 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8MulExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option int8)
  val inv2 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option int8 . inv2 x = true
  predicate invariant1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int8)
  val inv1 (_x : int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.Int8
  val overflowing_mul0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_mul0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_mul0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_mul0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
  let rec cfg test_i8_mul_example [#"../checked_ops.rs" 252 0 252 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _4 : int8;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _9 : bool;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _15 : bool;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _22 : int8;
  var _27 : int8;
  var _32 : int8;
  var _37 : int8;
  var _42 : int8;
  var _47 : int8;
  var res : (int8, bool);
  var _52 : bool;
  var res1 : (int8, bool);
  var _61 : bool;
  var res2 : (int8, bool);
  var _70 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 253 12 253 31] _5 <- ([#"../checked_ops.rs" 253 12 253 31] checked_mul0 ([#"../checked_ops.rs" 253 12 253 15] [#"../checked_ops.rs" 253 12 253 15] (5 : int8)) ([#"../checked_ops.rs" 253 28 253 30] [#"../checked_ops.rs" 253 28 253 30] (10 : int8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 253 12 253 40] _4 <- ([#"../checked_ops.rs" 253 12 253 40] unwrap0 _5);
    _5 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 253 4 253 47] not ([#"../checked_ops.rs" 253 12 253 46] _4 = ([#"../checked_ops.rs" 253 44 253 46] [#"../checked_ops.rs" 253 44 253 46] (50 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 253 4 253 47] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 254 12 254 32] _11 <- ([#"../checked_ops.rs" 254 12 254 32] checked_mul0 ([#"../checked_ops.rs" 254 12 254 16] [#"../checked_ops.rs" 254 12 254 16] (50 : int8)) ([#"../checked_ops.rs" 254 29 254 31] [#"../checked_ops.rs" 254 29 254 31] (10 : int8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 254 12 254 42] _9 <- ([#"../checked_ops.rs" 254 12 254 42] is_none0 ([#"../checked_ops.rs" 254 12 254 42] _11));
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 254 4 254 43] not _9)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 254 4 254 43] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 255 12 255 33] _17 <- ([#"../checked_ops.rs" 255 12 255 33] checked_mul0 ([#"../checked_ops.rs" 255 12 255 16] [#"../checked_ops.rs" 255 12 255 16] (50 : int8)) ([#"../checked_ops.rs" 255 29 255 32] [#"../checked_ops.rs" 255 29 255 32] (-10 : int8)));
    goto BB9
  }
  BB9 {
    [#"../checked_ops.rs" 255 12 255 43] _15 <- ([#"../checked_ops.rs" 255 12 255 43] is_none0 ([#"../checked_ops.rs" 255 12 255 43] _17));
    goto BB10
  }
  BB10 {
    switch ([#"../checked_ops.rs" 255 4 255 44] not _15)
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    assert { [#"../checked_ops.rs" 255 4 255 44] false };
    absurd
  }
  BB12 {
    [#"../checked_ops.rs" 257 12 257 32] _22 <- ([#"../checked_ops.rs" 257 12 257 32] wrapping_mul0 ([#"../checked_ops.rs" 257 12 257 15] [#"../checked_ops.rs" 257 12 257 15] (5 : int8)) ([#"../checked_ops.rs" 257 29 257 31] [#"../checked_ops.rs" 257 29 257 31] (10 : int8)));
    goto BB13
  }
  BB13 {
    switch ([#"../checked_ops.rs" 257 4 257 39] not ([#"../checked_ops.rs" 257 12 257 38] _22 = ([#"../checked_ops.rs" 257 36 257 38] [#"../checked_ops.rs" 257 36 257 38] (50 : int8))))
      | False -> goto BB15
      | True -> goto BB14
      end
  }
  BB14 {
    assert { [#"../checked_ops.rs" 257 4 257 39] false };
    absurd
  }
  BB15 {
    [#"../checked_ops.rs" 258 12 258 33] _27 <- ([#"../checked_ops.rs" 258 12 258 33] wrapping_mul0 ([#"../checked_ops.rs" 258 12 258 16] [#"../checked_ops.rs" 258 12 258 16] (50 : int8)) ([#"../checked_ops.rs" 258 30 258 32] [#"../checked_ops.rs" 258 30 258 32] (10 : int8)));
    goto BB16
  }
  BB16 {
    switch ([#"../checked_ops.rs" 258 4 258 41] not ([#"../checked_ops.rs" 258 12 258 40] _27 = ([#"../checked_ops.rs" 258 37 258 40] [#"../checked_ops.rs" 258 37 258 40] (-12 : int8))))
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    assert { [#"../checked_ops.rs" 258 4 258 41] false };
    absurd
  }
  BB18 {
    [#"../checked_ops.rs" 259 12 259 34] _32 <- ([#"../checked_ops.rs" 259 12 259 34] wrapping_mul0 ([#"../checked_ops.rs" 259 12 259 16] [#"../checked_ops.rs" 259 12 259 16] (50 : int8)) ([#"../checked_ops.rs" 259 30 259 33] [#"../checked_ops.rs" 259 30 259 33] (-10 : int8)));
    goto BB19
  }
  BB19 {
    switch ([#"../checked_ops.rs" 259 4 259 41] not ([#"../checked_ops.rs" 259 12 259 40] _32 = ([#"../checked_ops.rs" 259 38 259 40] [#"../checked_ops.rs" 259 38 259 40] (12 : int8))))
      | False -> goto BB21
      | True -> goto BB20
      end
  }
  BB20 {
    assert { [#"../checked_ops.rs" 259 4 259 41] false };
    absurd
  }
  BB21 {
    [#"../checked_ops.rs" 261 12 261 34] _37 <- ([#"../checked_ops.rs" 261 12 261 34] saturating_mul0 ([#"../checked_ops.rs" 261 12 261 15] [#"../checked_ops.rs" 261 12 261 15] (5 : int8)) ([#"../checked_ops.rs" 261 31 261 33] [#"../checked_ops.rs" 261 31 261 33] (10 : int8)));
    goto BB22
  }
  BB22 {
    switch ([#"../checked_ops.rs" 261 4 261 41] not ([#"../checked_ops.rs" 261 12 261 40] _37 = ([#"../checked_ops.rs" 261 38 261 40] [#"../checked_ops.rs" 261 38 261 40] (50 : int8))))
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB23 {
    assert { [#"../checked_ops.rs" 261 4 261 41] false };
    absurd
  }
  BB24 {
    [#"../checked_ops.rs" 262 12 262 35] _42 <- ([#"../checked_ops.rs" 262 12 262 35] saturating_mul0 ([#"../checked_ops.rs" 262 12 262 16] [#"../checked_ops.rs" 262 12 262 16] (50 : int8)) ([#"../checked_ops.rs" 262 32 262 34] [#"../checked_ops.rs" 262 32 262 34] (10 : int8)));
    goto BB25
  }
  BB25 {
    switch ([#"../checked_ops.rs" 262 4 262 43] not ([#"../checked_ops.rs" 262 12 262 42] _42 = ([#"../checked_ops.rs" 262 39 262 42] [#"../checked_ops.rs" 262 39 262 42] (127 : int8))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assert { [#"../checked_ops.rs" 262 4 262 43] false };
    absurd
  }
  BB27 {
    [#"../checked_ops.rs" 263 12 263 36] _47 <- ([#"../checked_ops.rs" 263 12 263 36] saturating_mul0 ([#"../checked_ops.rs" 263 12 263 16] [#"../checked_ops.rs" 263 12 263 16] (50 : int8)) ([#"../checked_ops.rs" 263 32 263 35] [#"../checked_ops.rs" 263 32 263 35] (-10 : int8)));
    goto BB28
  }
  BB28 {
    switch ([#"../checked_ops.rs" 263 4 263 45] not ([#"../checked_ops.rs" 263 12 263 44] _47 = ([#"../checked_ops.rs" 263 40 263 44] [#"../checked_ops.rs" 263 40 263 44] (-128 : int8))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    assert { [#"../checked_ops.rs" 263 4 263 45] false };
    absurd
  }
  BB30 {
    [#"../checked_ops.rs" 265 14 265 37] res <- ([#"../checked_ops.rs" 265 14 265 37] overflowing_mul0 ([#"../checked_ops.rs" 265 14 265 17] [#"../checked_ops.rs" 265 14 265 17] (5 : int8)) ([#"../checked_ops.rs" 265 34 265 36] [#"../checked_ops.rs" 265 34 265 36] (10 : int8)));
    goto BB31
  }
  BB31 {
    switch ([#"../checked_ops.rs" 266 12 266 23] ([#"../checked_ops.rs" 266 12 266 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 266 21 266 23] [#"../checked_ops.rs" 266 21 266 23] (50 : int8)))
      | False -> goto BB32
      | True -> goto BB33
      end
  }
  BB32 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 266 12 266 41] _52 <- ([#"../checked_ops.rs" 266 12 266 41] [#"../checked_ops.rs" 266 12 266 41] false);
    goto BB34
  }
  BB33 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 266 12 266 41] _52 <- ([#"../checked_ops.rs" 266 27 266 41] Bool.eqb ([#"../checked_ops.rs" 266 27 266 32] let (_, a) = res in a) ([#"../checked_ops.rs" 266 36 266 41] [#"../checked_ops.rs" 266 36 266 41] false));
    goto BB34
  }
  BB34 {
    switch ([#"../checked_ops.rs" 266 4 266 42] not _52)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assert { [#"../checked_ops.rs" 266 4 266 42] false };
    absurd
  }
  BB36 {
    [#"../checked_ops.rs" 267 14 267 38] res1 <- ([#"../checked_ops.rs" 267 14 267 38] overflowing_mul0 ([#"../checked_ops.rs" 267 14 267 18] [#"../checked_ops.rs" 267 14 267 18] (50 : int8)) ([#"../checked_ops.rs" 267 35 267 37] [#"../checked_ops.rs" 267 35 267 37] (10 : int8)));
    goto BB37
  }
  BB37 {
    switch ([#"../checked_ops.rs" 268 12 268 24] ([#"../checked_ops.rs" 268 12 268 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 268 21 268 24] [#"../checked_ops.rs" 268 21 268 24] (-12 : int8)))
      | False -> goto BB38
      | True -> goto BB39
      end
  }
  BB38 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 268 12 268 41] _61 <- ([#"../checked_ops.rs" 268 12 268 41] [#"../checked_ops.rs" 268 12 268 41] false);
    goto BB40
  }
  BB39 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 268 12 268 41] _61 <- ([#"../checked_ops.rs" 268 28 268 41] Bool.eqb ([#"../checked_ops.rs" 268 28 268 33] let (_, a) = res1 in a) ([#"../checked_ops.rs" 268 37 268 41] [#"../checked_ops.rs" 268 37 268 41] true));
    goto BB40
  }
  BB40 {
    switch ([#"../checked_ops.rs" 268 4 268 42] not _61)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assert { [#"../checked_ops.rs" 268 4 268 42] false };
    absurd
  }
  BB42 {
    [#"../checked_ops.rs" 269 14 269 39] res2 <- ([#"../checked_ops.rs" 269 14 269 39] overflowing_mul0 ([#"../checked_ops.rs" 269 14 269 18] [#"../checked_ops.rs" 269 14 269 18] (50 : int8)) ([#"../checked_ops.rs" 269 35 269 38] [#"../checked_ops.rs" 269 35 269 38] (-10 : int8)));
    goto BB43
  }
  BB43 {
    switch ([#"../checked_ops.rs" 270 12 270 23] ([#"../checked_ops.rs" 270 12 270 17] let (a, _) = res2 in a) = ([#"../checked_ops.rs" 270 21 270 23] [#"../checked_ops.rs" 270 21 270 23] (12 : int8)))
      | False -> goto BB44
      | True -> goto BB45
      end
  }
  BB44 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 270 12 270 40] _70 <- ([#"../checked_ops.rs" 270 12 270 40] [#"../checked_ops.rs" 270 12 270 40] false);
    goto BB46
  }
  BB45 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 270 12 270 40] _70 <- ([#"../checked_ops.rs" 270 27 270 40] Bool.eqb ([#"../checked_ops.rs" 270 27 270 32] let (_, a) = res2 in a) ([#"../checked_ops.rs" 270 36 270 40] [#"../checked_ops.rs" 270 36 270 40] true));
    goto BB46
  }
  BB46 {
    switch ([#"../checked_ops.rs" 270 4 270 41] not _70)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assert { [#"../checked_ops.rs" 270 4 270 41] false };
    absurd
  }
  BB48 {
    [#"../checked_ops.rs" 252 29 271 1] _0 <- ([#"../checked_ops.rs" 252 29 271 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8MulZero
  use prelude.Int8
  predicate invariant1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int8)
  val inv1 (_x : int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int8 . inv1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.UInt32
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  use prelude.Int8
  val overflowing_mul0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    
  val saturating_mul0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 161 16 164 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 166 16 166 85] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 167 16 167 85] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> Int8.to_int result = Int8.to_int max0 }
    
  val wrapping_mul0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_mul0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
  let rec cfg test_i8_mul_zero [#"../checked_ops.rs" 274 0 274 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _5 : int8;
  var _6 : Core_Option_Option_Type.t_option int8;
  var _12 : int8;
  var _18 : int8;
  var res : (int8, bool);
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 275 12 275 30] _6 <- ([#"../checked_ops.rs" 275 12 275 30] checked_mul0 ([#"../checked_ops.rs" 275 12 275 15] [#"../checked_ops.rs" 275 12 275 15] (0 : int8)) ([#"../checked_ops.rs" 275 28 275 29] a));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 275 12 275 39] _5 <- ([#"../checked_ops.rs" 275 12 275 39] unwrap0 _6);
    _6 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 275 4 275 45] not ([#"../checked_ops.rs" 275 12 275 44] _5 = ([#"../checked_ops.rs" 275 43 275 44] [#"../checked_ops.rs" 275 43 275 44] (0 : int8))))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 275 4 275 45] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 276 12 276 31] _12 <- ([#"../checked_ops.rs" 276 12 276 31] wrapping_mul0 ([#"../checked_ops.rs" 276 12 276 15] [#"../checked_ops.rs" 276 12 276 15] (0 : int8)) ([#"../checked_ops.rs" 276 29 276 30] a));
    goto BB5
  }
  BB5 {
    switch ([#"../checked_ops.rs" 276 4 276 37] not ([#"../checked_ops.rs" 276 12 276 36] _12 = ([#"../checked_ops.rs" 276 35 276 36] [#"../checked_ops.rs" 276 35 276 36] (0 : int8))))
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assert { [#"../checked_ops.rs" 276 4 276 37] false };
    absurd
  }
  BB7 {
    [#"../checked_ops.rs" 277 12 277 33] _18 <- ([#"../checked_ops.rs" 277 12 277 33] saturating_mul0 ([#"../checked_ops.rs" 277 12 277 15] [#"../checked_ops.rs" 277 12 277 15] (0 : int8)) ([#"../checked_ops.rs" 277 31 277 32] a));
    goto BB8
  }
  BB8 {
    switch ([#"../checked_ops.rs" 277 4 277 39] not ([#"../checked_ops.rs" 277 12 277 38] _18 = ([#"../checked_ops.rs" 277 37 277 38] [#"../checked_ops.rs" 277 37 277 38] (0 : int8))))
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    assert { [#"../checked_ops.rs" 277 4 277 39] false };
    absurd
  }
  BB10 {
    [#"../checked_ops.rs" 278 14 278 36] res <- ([#"../checked_ops.rs" 278 14 278 36] overflowing_mul0 ([#"../checked_ops.rs" 278 14 278 17] [#"../checked_ops.rs" 278 14 278 17] (0 : int8)) ([#"../checked_ops.rs" 278 34 278 35] a));
    goto BB11
  }
  BB11 {
    switch ([#"../checked_ops.rs" 279 12 279 22] ([#"../checked_ops.rs" 279 12 279 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 279 21 279 22] [#"../checked_ops.rs" 279 21 279 22] (0 : int8)))
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB12 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 279 12 279 40] _25 <- ([#"../checked_ops.rs" 279 12 279 40] [#"../checked_ops.rs" 279 12 279 40] false);
    goto BB14
  }
  BB13 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 279 12 279 40] _25 <- ([#"../checked_ops.rs" 279 26 279 40] Bool.eqb ([#"../checked_ops.rs" 279 26 279 31] let (_, a) = res in a) ([#"../checked_ops.rs" 279 35 279 40] [#"../checked_ops.rs" 279 35 279 40] false));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 279 4 279 41] not _25)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 279 4 279 41] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 274 31 280 1] _0 <- ([#"../checked_ops.rs" 274 31 280 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8OverflowingMul
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant max0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (127 : int8)
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use prelude.Int8
  val checked_mul0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 124 20 125 89] (result = Core_Option_Option_Type.C_None) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 128 16 128 89] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs }
    
  use prelude.UInt32
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (8 : uint32)
  val wrapping_mul0 (self : int8) (rhs : int8) : int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] Int8.to_int result = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int result = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  val overflowing_mul0 (self : int8) (rhs : int8) : (int8, bool)
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 175 20 175 95] Int8.to_int (let (a, _) = result in a) = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 178 16 181 18] Int8.to_int self * Int8.to_int rhs >= Int8.to_int min0 /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int max0 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 185 16 189 18] Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 190 16 194 18] Int8.to_int self * Int8.to_int rhs > Int8.to_int max0 -> (exists k : int . k > 0 /\ Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int max0 - Int8.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 197 20 197 98] (let (_, a) = result in a) = (Int8.to_int self * Int8.to_int rhs < Int8.to_int min0 \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int max0) }
    
  let rec cfg test_i8_overflowing_mul [#"../checked_ops.rs" 283 0 283 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : (int8, bool);
  var _10 : int8;
  var _18 : (int8, bool);
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 284 12 284 32] _7 <- ([#"../checked_ops.rs" 284 12 284 32] overflowing_mul0 ([#"../checked_ops.rs" 284 12 284 13] a) ([#"../checked_ops.rs" 284 30 284 31] b));
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    [#"../checked_ops.rs" 284 38 284 55] _10 <- ([#"../checked_ops.rs" 284 38 284 55] wrapping_mul0 ([#"../checked_ops.rs" 284 38 284 39] a) ([#"../checked_ops.rs" 284 53 284 54] b));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 284 4 284 56] not ([#"../checked_ops.rs" 284 12 284 55] ([#"../checked_ops.rs" 284 12 284 34] let (a, _) = _7 in a) = _10))
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 284 4 284 56] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 285 12 285 32] _18 <- ([#"../checked_ops.rs" 285 12 285 32] overflowing_mul0 ([#"../checked_ops.rs" 285 12 285 13] a) ([#"../checked_ops.rs" 285 30 285 31] b));
    goto BB5
  }
  BB5 {
    assume { resolve0 _18 };
    [#"../checked_ops.rs" 285 38 285 54] _23 <- ([#"../checked_ops.rs" 285 38 285 54] checked_mul0 ([#"../checked_ops.rs" 285 38 285 39] a) ([#"../checked_ops.rs" 285 52 285 53] b));
    goto BB6
  }
  BB6 {
    [#"../checked_ops.rs" 285 38 285 64] _21 <- ([#"../checked_ops.rs" 285 38 285 64] is_none0 ([#"../checked_ops.rs" 285 38 285 64] _23));
    goto BB7
  }
  BB7 {
    switch ([#"../checked_ops.rs" 285 4 285 65] not ([#"../checked_ops.rs" 285 12 285 64] Bool.eqb ([#"../checked_ops.rs" 285 12 285 34] let (_, a) = _18 in a) _21))
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    assert { [#"../checked_ops.rs" 285 4 285 65] false };
    absurd
  }
  BB9 {
    [#"../checked_ops.rs" 283 45 286 1] _0 <- ([#"../checked_ops.rs" 283 45 286 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8DivExample
  use prelude.Int8
  predicate invariant2 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : int8) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : int8)
  val inv2 (_x : int8) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : int8 . inv2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant1 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Core_Option_Option_Type.t_option int8)
  val inv1 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Core_Option_Option_Type.t_option int8 . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use prelude.Int8
  val overflowing_div0 (self : int8) (rhs : int8) : (int8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1) }
    
  val saturating_div0 (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
  val wrapping_div0 (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv2 result }
    
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  val checked_div0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
  let rec cfg test_i8_div_example [#"../checked_ops.rs" 289 0 289 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _3 : bool;
  var _5 : Core_Option_Option_Type.t_option int8;
  var _10 : int8;
  var _11 : Core_Option_Option_Type.t_option int8;
  var _16 : int8;
  var _17 : Core_Option_Option_Type.t_option int8;
  var _21 : bool;
  var _23 : Core_Option_Option_Type.t_option int8;
  var _28 : int8;
  var _33 : int8;
  var _38 : int8;
  var _43 : int8;
  var _48 : int8;
  var _53 : int8;
  var res : (int8, bool);
  var _58 : bool;
  var res1 : (int8, bool);
  var _67 : bool;
  var res2 : (int8, bool);
  var _76 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 290 12 290 30] _5 <- ([#"../checked_ops.rs" 290 12 290 30] checked_div0 ([#"../checked_ops.rs" 290 12 290 15] [#"../checked_ops.rs" 290 12 290 15] (5 : int8)) ([#"../checked_ops.rs" 290 28 290 29] [#"../checked_ops.rs" 290 28 290 29] (0 : int8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 290 12 290 40] _3 <- ([#"../checked_ops.rs" 290 12 290 40] is_none0 ([#"../checked_ops.rs" 290 12 290 40] _5));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 290 4 290 41] not _3)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 290 4 290 41] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 291 12 291 30] _11 <- ([#"../checked_ops.rs" 291 12 291 30] checked_div0 ([#"../checked_ops.rs" 291 12 291 15] [#"../checked_ops.rs" 291 12 291 15] (5 : int8)) ([#"../checked_ops.rs" 291 28 291 29] [#"../checked_ops.rs" 291 28 291 29] (2 : int8)));
    goto BB5
  }
  BB5 {
    [#"../checked_ops.rs" 291 12 291 39] _10 <- ([#"../checked_ops.rs" 291 12 291 39] unwrap0 _11);
    _11 <- any Core_Option_Option_Type.t_option int8;
    goto BB6
  }
  BB6 {
    switch ([#"../checked_ops.rs" 291 4 291 45] not ([#"../checked_ops.rs" 291 12 291 44] _10 = ([#"../checked_ops.rs" 291 43 291 44] [#"../checked_ops.rs" 291 43 291 44] (2 : int8))))
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assert { [#"../checked_ops.rs" 291 4 291 45] false };
    absurd
  }
  BB8 {
    [#"../checked_ops.rs" 292 12 292 31] _17 <- ([#"../checked_ops.rs" 292 12 292 31] checked_div0 ([#"../checked_ops.rs" 292 12 292 15] [#"../checked_ops.rs" 292 12 292 15] (5 : int8)) ([#"../checked_ops.rs" 292 28 292 30] [#"../checked_ops.rs" 292 28 292 30] (-2 : int8)));
    goto BB9
  }
  BB9 {
    [#"../checked_ops.rs" 292 12 292 40] _16 <- ([#"../checked_ops.rs" 292 12 292 40] unwrap0 _17);
    _17 <- any Core_Option_Option_Type.t_option int8;
    goto BB10
  }
  BB10 {
    switch ([#"../checked_ops.rs" 292 4 292 47] not ([#"../checked_ops.rs" 292 12 292 46] _16 = ([#"../checked_ops.rs" 292 44 292 46] [#"../checked_ops.rs" 292 44 292 46] (-2 : int8))))
      | False -> goto BB12
      | True -> goto BB11
      end
  }
  BB11 {
    assert { [#"../checked_ops.rs" 292 4 292 47] false };
    absurd
  }
  BB12 {
    [#"../checked_ops.rs" 293 12 293 36] _23 <- ([#"../checked_ops.rs" 293 12 293 36] checked_div0 ([#"../checked_ops.rs" 293 12 293 20] [#"../checked_ops.rs" 293 12 293 20] (-128 : int8)) ([#"../checked_ops.rs" 293 33 293 35] [#"../checked_ops.rs" 293 33 293 35] (-1 : int8)));
    goto BB13
  }
  BB13 {
    [#"../checked_ops.rs" 293 12 293 46] _21 <- ([#"../checked_ops.rs" 293 12 293 46] is_none0 ([#"../checked_ops.rs" 293 12 293 46] _23));
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 293 4 293 47] not _21)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 293 4 293 47] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 295 12 295 31] _28 <- ([#"../checked_ops.rs" 295 12 295 31] wrapping_div0 ([#"../checked_ops.rs" 295 12 295 15] [#"../checked_ops.rs" 295 12 295 15] (5 : int8)) ([#"../checked_ops.rs" 295 29 295 30] [#"../checked_ops.rs" 295 29 295 30] (2 : int8)));
    goto BB17
  }
  BB17 {
    switch ([#"../checked_ops.rs" 295 4 295 37] not ([#"../checked_ops.rs" 295 12 295 36] _28 = ([#"../checked_ops.rs" 295 35 295 36] [#"../checked_ops.rs" 295 35 295 36] (2 : int8))))
      | False -> goto BB19
      | True -> goto BB18
      end
  }
  BB18 {
    assert { [#"../checked_ops.rs" 295 4 295 37] false };
    absurd
  }
  BB19 {
    [#"../checked_ops.rs" 296 12 296 32] _33 <- ([#"../checked_ops.rs" 296 12 296 32] wrapping_div0 ([#"../checked_ops.rs" 296 12 296 15] [#"../checked_ops.rs" 296 12 296 15] (5 : int8)) ([#"../checked_ops.rs" 296 29 296 31] [#"../checked_ops.rs" 296 29 296 31] (-2 : int8)));
    goto BB20
  }
  BB20 {
    switch ([#"../checked_ops.rs" 296 4 296 39] not ([#"../checked_ops.rs" 296 12 296 38] _33 = ([#"../checked_ops.rs" 296 36 296 38] [#"../checked_ops.rs" 296 36 296 38] (-2 : int8))))
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assert { [#"../checked_ops.rs" 296 4 296 39] false };
    absurd
  }
  BB22 {
    [#"../checked_ops.rs" 297 12 297 37] _38 <- ([#"../checked_ops.rs" 297 12 297 37] wrapping_div0 ([#"../checked_ops.rs" 297 12 297 20] [#"../checked_ops.rs" 297 12 297 20] (-128 : int8)) ([#"../checked_ops.rs" 297 34 297 36] [#"../checked_ops.rs" 297 34 297 36] (-1 : int8)));
    goto BB23
  }
  BB23 {
    switch ([#"../checked_ops.rs" 297 4 297 46] not ([#"../checked_ops.rs" 297 12 297 45] _38 = ([#"../checked_ops.rs" 297 41 297 45] [#"../checked_ops.rs" 297 41 297 45] (-128 : int8))))
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB24 {
    assert { [#"../checked_ops.rs" 297 4 297 46] false };
    absurd
  }
  BB25 {
    [#"../checked_ops.rs" 299 12 299 33] _43 <- ([#"../checked_ops.rs" 299 12 299 33] saturating_div0 ([#"../checked_ops.rs" 299 12 299 15] [#"../checked_ops.rs" 299 12 299 15] (5 : int8)) ([#"../checked_ops.rs" 299 31 299 32] [#"../checked_ops.rs" 299 31 299 32] (2 : int8)));
    goto BB26
  }
  BB26 {
    switch ([#"../checked_ops.rs" 299 4 299 39] not ([#"../checked_ops.rs" 299 12 299 38] _43 = ([#"../checked_ops.rs" 299 37 299 38] [#"../checked_ops.rs" 299 37 299 38] (2 : int8))))
      | False -> goto BB28
      | True -> goto BB27
      end
  }
  BB27 {
    assert { [#"../checked_ops.rs" 299 4 299 39] false };
    absurd
  }
  BB28 {
    [#"../checked_ops.rs" 300 12 300 34] _48 <- ([#"../checked_ops.rs" 300 12 300 34] saturating_div0 ([#"../checked_ops.rs" 300 12 300 15] [#"../checked_ops.rs" 300 12 300 15] (5 : int8)) ([#"../checked_ops.rs" 300 31 300 33] [#"../checked_ops.rs" 300 31 300 33] (-2 : int8)));
    goto BB29
  }
  BB29 {
    switch ([#"../checked_ops.rs" 300 4 300 41] not ([#"../checked_ops.rs" 300 12 300 40] _48 = ([#"../checked_ops.rs" 300 38 300 40] [#"../checked_ops.rs" 300 38 300 40] (-2 : int8))))
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    assert { [#"../checked_ops.rs" 300 4 300 41] false };
    absurd
  }
  BB31 {
    [#"../checked_ops.rs" 301 12 301 39] _53 <- ([#"../checked_ops.rs" 301 12 301 39] saturating_div0 ([#"../checked_ops.rs" 301 12 301 20] [#"../checked_ops.rs" 301 12 301 20] (-128 : int8)) ([#"../checked_ops.rs" 301 36 301 38] [#"../checked_ops.rs" 301 36 301 38] (-1 : int8)));
    goto BB32
  }
  BB32 {
    switch ([#"../checked_ops.rs" 301 4 301 48] not ([#"../checked_ops.rs" 301 12 301 47] _53 = ([#"../checked_ops.rs" 301 43 301 47] [#"../checked_ops.rs" 301 43 301 47] (-128 : int8))))
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    assert { [#"../checked_ops.rs" 301 4 301 48] false };
    absurd
  }
  BB34 {
    [#"../checked_ops.rs" 303 14 303 36] res <- ([#"../checked_ops.rs" 303 14 303 36] overflowing_div0 ([#"../checked_ops.rs" 303 14 303 17] [#"../checked_ops.rs" 303 14 303 17] (5 : int8)) ([#"../checked_ops.rs" 303 34 303 35] [#"../checked_ops.rs" 303 34 303 35] (2 : int8)));
    goto BB35
  }
  BB35 {
    switch ([#"../checked_ops.rs" 304 12 304 22] ([#"../checked_ops.rs" 304 12 304 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 304 21 304 22] [#"../checked_ops.rs" 304 21 304 22] (2 : int8)))
      | False -> goto BB36
      | True -> goto BB37
      end
  }
  BB36 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 304 12 304 40] _58 <- ([#"../checked_ops.rs" 304 12 304 40] [#"../checked_ops.rs" 304 12 304 40] false);
    goto BB38
  }
  BB37 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 304 12 304 40] _58 <- ([#"../checked_ops.rs" 304 26 304 40] Bool.eqb ([#"../checked_ops.rs" 304 26 304 31] let (_, a) = res in a) ([#"../checked_ops.rs" 304 35 304 40] [#"../checked_ops.rs" 304 35 304 40] false));
    goto BB38
  }
  BB38 {
    switch ([#"../checked_ops.rs" 304 4 304 41] not _58)
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    assert { [#"../checked_ops.rs" 304 4 304 41] false };
    absurd
  }
  BB40 {
    [#"../checked_ops.rs" 305 14 305 37] res1 <- ([#"../checked_ops.rs" 305 14 305 37] overflowing_div0 ([#"../checked_ops.rs" 305 14 305 17] [#"../checked_ops.rs" 305 14 305 17] (5 : int8)) ([#"../checked_ops.rs" 305 34 305 36] [#"../checked_ops.rs" 305 34 305 36] (-2 : int8)));
    goto BB41
  }
  BB41 {
    switch ([#"../checked_ops.rs" 306 12 306 23] ([#"../checked_ops.rs" 306 12 306 17] let (a, _) = res1 in a) = ([#"../checked_ops.rs" 306 21 306 23] [#"../checked_ops.rs" 306 21 306 23] (-2 : int8)))
      | False -> goto BB42
      | True -> goto BB43
      end
  }
  BB42 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 306 12 306 41] _67 <- ([#"../checked_ops.rs" 306 12 306 41] [#"../checked_ops.rs" 306 12 306 41] false);
    goto BB44
  }
  BB43 {
    assume { resolve0 res1 };
    [#"../checked_ops.rs" 306 12 306 41] _67 <- ([#"../checked_ops.rs" 306 27 306 41] Bool.eqb ([#"../checked_ops.rs" 306 27 306 32] let (_, a) = res1 in a) ([#"../checked_ops.rs" 306 36 306 41] [#"../checked_ops.rs" 306 36 306 41] false));
    goto BB44
  }
  BB44 {
    switch ([#"../checked_ops.rs" 306 4 306 42] not _67)
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    assert { [#"../checked_ops.rs" 306 4 306 42] false };
    absurd
  }
  BB46 {
    [#"../checked_ops.rs" 307 14 307 42] res2 <- ([#"../checked_ops.rs" 307 14 307 42] overflowing_div0 ([#"../checked_ops.rs" 307 14 307 22] [#"../checked_ops.rs" 307 14 307 22] (-128 : int8)) ([#"../checked_ops.rs" 307 39 307 41] [#"../checked_ops.rs" 307 39 307 41] (-1 : int8)));
    goto BB47
  }
  BB47 {
    switch ([#"../checked_ops.rs" 308 12 308 25] ([#"../checked_ops.rs" 308 12 308 17] let (a, _) = res2 in a) = ([#"../checked_ops.rs" 308 21 308 25] [#"../checked_ops.rs" 308 21 308 25] (-128 : int8)))
      | False -> goto BB48
      | True -> goto BB49
      end
  }
  BB48 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 308 12 308 42] _76 <- ([#"../checked_ops.rs" 308 12 308 42] [#"../checked_ops.rs" 308 12 308 42] false);
    goto BB50
  }
  BB49 {
    assume { resolve0 res2 };
    [#"../checked_ops.rs" 308 12 308 42] _76 <- ([#"../checked_ops.rs" 308 29 308 42] Bool.eqb ([#"../checked_ops.rs" 308 29 308 34] let (_, a) = res2 in a) ([#"../checked_ops.rs" 308 38 308 42] [#"../checked_ops.rs" 308 38 308 42] true));
    goto BB50
  }
  BB50 {
    switch ([#"../checked_ops.rs" 308 4 308 43] not _76)
      | False -> goto BB52
      | True -> goto BB51
      end
  }
  BB51 {
    assert { [#"../checked_ops.rs" 308 4 308 43] false };
    absurd
  }
  BB52 {
    [#"../checked_ops.rs" 289 29 309 1] _0 <- ([#"../checked_ops.rs" 289 29 309 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8DivNoOverflow
  use prelude.Int8
  predicate invariant1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int8) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int8)
  val inv1 (_x : int8) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int8 . inv1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Int8
  use prelude.Bool
  predicate resolve2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : bool) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : int8) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (int8, bool)) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  val overflowing_div0 (self : int8) (rhs : int8) : (int8, bool)
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 91 27 91 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 93 16 93 87] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 95 26 95 91] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 97 26 97 74] (let (_, a) = result in a) = (Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1) }
    
  val saturating_div0 (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 82 27 82 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 84 16 84 91] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 86 26 86 89] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
  val wrapping_div0 (self : int8) (rhs : int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/num.rs" 73 27 73 36] Int8.to_int rhs <> 0}
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 75 16 75 85] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 -> Int8.to_int result = Int8.to_int self }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 77 26 77 89] Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1 \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs) }
    
  val unwrap0 (self : Core_Option_Option_Type.t_option int8) : int8
    requires {[#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] self <> Core_Option_Option_Type.C_None}
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 17 0 114 1] Core_Option_Option_Type.C_Some result = self }
    ensures { inv1 result }
    
  val checked_div0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
  let rec cfg test_i8_div_no_overflow [#"../checked_ops.rs" 313 0 313 44] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) (b : int8) : ()
    requires {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var b : int8 = b;
  var _7 : int8;
  var _8 : Core_Option_Option_Type.t_option int8;
  var _12 : int8;
  var _13 : int8;
  var _14 : bool;
  var _17 : bool;
  var _22 : int8;
  var _26 : int8;
  var _27 : int8;
  var _28 : bool;
  var _31 : bool;
  var _36 : int8;
  var _40 : int8;
  var _41 : int8;
  var _42 : bool;
  var _45 : bool;
  var res : (int8, bool);
  var _52 : bool;
  var _56 : int8;
  var _57 : int8;
  var _58 : bool;
  var _61 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 314 12 314 28] _8 <- ([#"../checked_ops.rs" 314 12 314 28] checked_div0 ([#"../checked_ops.rs" 314 12 314 13] a) ([#"../checked_ops.rs" 314 26 314 27] b));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 314 12 314 37] _7 <- ([#"../checked_ops.rs" 314 12 314 37] unwrap0 _8);
    _8 <- any Core_Option_Option_Type.t_option int8;
    goto BB2
  }
  BB2 {
    [#"../checked_ops.rs" 314 41 314 42] _12 <- ([#"../checked_ops.rs" 314 41 314 42] a);
    [#"../checked_ops.rs" 314 45 314 46] _13 <- ([#"../checked_ops.rs" 314 45 314 46] b);
    [#"../checked_ops.rs" 314 41 314 46] _14 <- ([#"../checked_ops.rs" 314 41 314 46] _13 = ([#"../checked_ops.rs" 314 41 314 46] [#"../checked_ops.rs" 314 41 314 46] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 314 41 314 46] not _14 };
    goto BB3
  }
  BB3 {
    [#"../checked_ops.rs" 314 41 314 46] _17 <- ([#"../checked_ops.rs" 314 41 314 46] ([#"../checked_ops.rs" 314 41 314 46] _13 = ([#"../checked_ops.rs" 314 41 314 46] [#"../checked_ops.rs" 314 41 314 46] (-1 : int8))) && ([#"../checked_ops.rs" 314 41 314 46] _12 = ([#"../checked_ops.rs" 314 41 314 46] [#"../checked_ops.rs" 314 41 314 46] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 314 41 314 46] not _17 };
    goto BB4
  }
  BB4 {
    switch ([#"../checked_ops.rs" 314 4 314 47] not ([#"../checked_ops.rs" 314 12 314 46] _7 = ([#"../checked_ops.rs" 314 41 314 46] _12 / _13)))
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB5 {
    assert { [#"../checked_ops.rs" 314 4 314 47] false };
    absurd
  }
  BB6 {
    [#"../checked_ops.rs" 315 12 315 29] _22 <- ([#"../checked_ops.rs" 315 12 315 29] wrapping_div0 ([#"../checked_ops.rs" 315 12 315 13] a) ([#"../checked_ops.rs" 315 27 315 28] b));
    goto BB7
  }
  BB7 {
    [#"../checked_ops.rs" 315 33 315 34] _26 <- ([#"../checked_ops.rs" 315 33 315 34] a);
    [#"../checked_ops.rs" 315 37 315 38] _27 <- ([#"../checked_ops.rs" 315 37 315 38] b);
    [#"../checked_ops.rs" 315 33 315 38] _28 <- ([#"../checked_ops.rs" 315 33 315 38] _27 = ([#"../checked_ops.rs" 315 33 315 38] [#"../checked_ops.rs" 315 33 315 38] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 315 33 315 38] not _28 };
    goto BB8
  }
  BB8 {
    [#"../checked_ops.rs" 315 33 315 38] _31 <- ([#"../checked_ops.rs" 315 33 315 38] ([#"../checked_ops.rs" 315 33 315 38] _27 = ([#"../checked_ops.rs" 315 33 315 38] [#"../checked_ops.rs" 315 33 315 38] (-1 : int8))) && ([#"../checked_ops.rs" 315 33 315 38] _26 = ([#"../checked_ops.rs" 315 33 315 38] [#"../checked_ops.rs" 315 33 315 38] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 315 33 315 38] not _31 };
    goto BB9
  }
  BB9 {
    switch ([#"../checked_ops.rs" 315 4 315 39] not ([#"../checked_ops.rs" 315 12 315 38] _22 = ([#"../checked_ops.rs" 315 33 315 38] _26 / _27)))
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    assert { [#"../checked_ops.rs" 315 4 315 39] false };
    absurd
  }
  BB11 {
    [#"../checked_ops.rs" 316 12 316 31] _36 <- ([#"../checked_ops.rs" 316 12 316 31] saturating_div0 ([#"../checked_ops.rs" 316 12 316 13] a) ([#"../checked_ops.rs" 316 29 316 30] b));
    goto BB12
  }
  BB12 {
    [#"../checked_ops.rs" 316 35 316 36] _40 <- ([#"../checked_ops.rs" 316 35 316 36] a);
    [#"../checked_ops.rs" 316 39 316 40] _41 <- ([#"../checked_ops.rs" 316 39 316 40] b);
    [#"../checked_ops.rs" 316 35 316 40] _42 <- ([#"../checked_ops.rs" 316 35 316 40] _41 = ([#"../checked_ops.rs" 316 35 316 40] [#"../checked_ops.rs" 316 35 316 40] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 316 35 316 40] not _42 };
    goto BB13
  }
  BB13 {
    [#"../checked_ops.rs" 316 35 316 40] _45 <- ([#"../checked_ops.rs" 316 35 316 40] ([#"../checked_ops.rs" 316 35 316 40] _41 = ([#"../checked_ops.rs" 316 35 316 40] [#"../checked_ops.rs" 316 35 316 40] (-1 : int8))) && ([#"../checked_ops.rs" 316 35 316 40] _40 = ([#"../checked_ops.rs" 316 35 316 40] [#"../checked_ops.rs" 316 35 316 40] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 316 35 316 40] not _45 };
    goto BB14
  }
  BB14 {
    switch ([#"../checked_ops.rs" 316 4 316 41] not ([#"../checked_ops.rs" 316 12 316 40] _36 = ([#"../checked_ops.rs" 316 35 316 40] _40 / _41)))
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assert { [#"../checked_ops.rs" 316 4 316 41] false };
    absurd
  }
  BB16 {
    [#"../checked_ops.rs" 317 14 317 34] res <- ([#"../checked_ops.rs" 317 14 317 34] overflowing_div0 ([#"../checked_ops.rs" 317 14 317 15] a) ([#"../checked_ops.rs" 317 32 317 33] b));
    goto BB17
  }
  BB17 {
    [#"../checked_ops.rs" 318 21 318 22] _56 <- ([#"../checked_ops.rs" 318 21 318 22] a);
    [#"../checked_ops.rs" 318 25 318 26] _57 <- ([#"../checked_ops.rs" 318 25 318 26] b);
    [#"../checked_ops.rs" 318 21 318 26] _58 <- ([#"../checked_ops.rs" 318 21 318 26] _57 = ([#"../checked_ops.rs" 318 21 318 26] [#"../checked_ops.rs" 318 21 318 26] (0 : int8)));
    assert { [@expl:division by zero] [#"../checked_ops.rs" 318 21 318 26] not _58 };
    goto BB21
  }
  BB18 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 318 12 318 44] _52 <- ([#"../checked_ops.rs" 318 12 318 44] [#"../checked_ops.rs" 318 12 318 44] false);
    goto BB20
  }
  BB19 {
    assume { resolve0 res };
    [#"../checked_ops.rs" 318 12 318 44] _52 <- ([#"../checked_ops.rs" 318 30 318 44] Bool.eqb ([#"../checked_ops.rs" 318 30 318 35] let (_, a) = res in a) ([#"../checked_ops.rs" 318 39 318 44] [#"../checked_ops.rs" 318 39 318 44] false));
    goto BB20
  }
  BB20 {
    switch ([#"../checked_ops.rs" 318 4 318 45] not _52)
      | False -> goto BB24
      | True -> goto BB23
      end
  }
  BB21 {
    [#"../checked_ops.rs" 318 21 318 26] _61 <- ([#"../checked_ops.rs" 318 21 318 26] ([#"../checked_ops.rs" 318 21 318 26] _57 = ([#"../checked_ops.rs" 318 21 318 26] [#"../checked_ops.rs" 318 21 318 26] (-1 : int8))) && ([#"../checked_ops.rs" 318 21 318 26] _56 = ([#"../checked_ops.rs" 318 21 318 26] [#"../checked_ops.rs" 318 21 318 26] (-128 : int8))));
    assert { [@expl:Div overflow] [#"../checked_ops.rs" 318 21 318 26] not _61 };
    goto BB22
  }
  BB22 {
    switch ([#"../checked_ops.rs" 318 12 318 26] ([#"../checked_ops.rs" 318 12 318 17] let (a, _) = res in a) = ([#"../checked_ops.rs" 318 21 318 26] _56 / _57))
      | False -> goto BB18
      | True -> goto BB19
      end
  }
  BB23 {
    assert { [#"../checked_ops.rs" 318 4 318 45] false };
    absurd
  }
  BB24 {
    [#"../checked_ops.rs" 313 45 319 1] _0 <- ([#"../checked_ops.rs" 313 45 319 1] ());
    return _0
  }
  
end
module CheckedOps_TestI8DivZero
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option int8)
  val inv0 (_x : Core_Option_Option_Type.t_option int8) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option int8 . inv0 x = true
  use prelude.Borrow
  val is_none0 (self : Core_Option_Option_Type.t_option int8) : bool
    requires {inv0 self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
  use prelude.Int
  let constant min0  : int8 = [@vc:do_not_keep_trace] [@vc:sp]
    (-128 : int8)
  use prelude.Int8
  val checked_div0 (self : int8) (rhs : int8) : Core_Option_Option_Type.t_option int8
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 66 26 66 97] (result = Core_Option_Option_Type.C_None) = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int min0 /\ Int8.to_int rhs = - 1) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 68 16 68 85] forall r : int8 . result = Core_Option_Option_Type.C_Some r -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs) }
    
  let rec cfg test_i8_div_zero [#"../checked_ops.rs" 322 0 322 30] [@cfg:stackify] [@cfg:subregion_analysis] (a : int8) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : int8 = a;
  var _4 : bool;
  var _6 : Core_Option_Option_Type.t_option int8;
  {
    goto BB0
  }
  BB0 {
    [#"../checked_ops.rs" 323 12 323 28] _6 <- ([#"../checked_ops.rs" 323 12 323 28] checked_div0 ([#"../checked_ops.rs" 323 12 323 13] a) ([#"../checked_ops.rs" 323 26 323 27] [#"../checked_ops.rs" 323 26 323 27] (0 : int8)));
    goto BB1
  }
  BB1 {
    [#"../checked_ops.rs" 323 12 323 38] _4 <- ([#"../checked_ops.rs" 323 12 323 38] is_none0 ([#"../checked_ops.rs" 323 12 323 38] _6));
    goto BB2
  }
  BB2 {
    switch ([#"../checked_ops.rs" 323 4 323 39] not _4)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [#"../checked_ops.rs" 323 4 323 39] false };
    absurd
  }
  BB4 {
    [#"../checked_ops.rs" 322 31 324 1] _0 <- ([#"../checked_ops.rs" 322 31 324 1] ());
    return _0
  }
  
end
