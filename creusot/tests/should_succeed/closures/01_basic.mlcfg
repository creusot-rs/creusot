
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Ops_Impl1_Unnest_Stub
  type args
  type f
  predicate unnest (self : f) (_2 : f)
end
module CreusotContracts_Std1_Ops_Impl1_Unnest_Interface
  type args
  type f
  predicate unnest (self : f) (_2 : f)
  val unnest (self : f) (_2 : f) : bool
    ensures { result = unnest self _2 }
    
end
module CreusotContracts_Std1_Ops_Impl1_Unnest
  type args
  type f
  predicate unnest (self : f) (_2 : f)
  val unnest (self : f) (_2 : f) : bool
    ensures { result = unnest self _2 }
    
end
module C01Basic_UsesClosure_Closure0_Type
  use prelude.Borrow
  type c01basic_usesclosure_closure0  =
    | C01Basic_UsesClosure_Closure0 bool
    
end
module C01Basic_UsesClosure_Closure0_Interface
  use export C01Basic_UsesClosure_Closure0_Type
  use prelude.Borrow
  let function field_0 [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) : bool
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_UsesClosure_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 6 14 6 16] (_1 : c01basic_usesclosure_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate unnest [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_2 : c01basic_usesclosure_closure0)
    
   =
    [#"../01_basic.rs" 1 0 1 0] field_0 _2 = field_0 self
  predicate precondition [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) (result : bool)
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 6 14 6 16] (self : borrowed c01basic_usesclosure_closure0) (_ : ()) (result : bool)
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  predicate postcondition [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) (result : bool)
   =
    [#"../01_basic.rs" 1 0 1 0] true
  val c01Basic_UsesClosure_Closure0 [#"../01_basic.rs" 6 14 6 16] (_1 : c01basic_usesclosure_closure0) : bool
end
module C01Basic_UsesClosure_Closure0
  use export C01Basic_UsesClosure_Closure0_Type
  use prelude.Borrow
  let function field_0 [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) : bool
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_UsesClosure_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 6 14 6 16] (_1 : c01basic_usesclosure_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate unnest [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_2 : c01basic_usesclosure_closure0)
    
   =
    [#"../01_basic.rs" 1 0 1 0] field_0 _2 = field_0 self
  predicate precondition [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) (result : bool)
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 6 14 6 16] (self : borrowed c01basic_usesclosure_closure0) (_ : ()) (result : bool)
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  predicate postcondition [#"../01_basic.rs" 6 14 6 16] (self : c01basic_usesclosure_closure0) (_ : ()) (result : bool)
   =
    [#"../01_basic.rs" 1 0 1 0] true
  let rec cfg c01Basic_UsesClosure_Closure0 [#"../01_basic.rs" 6 14 6 16] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : c01basic_usesclosure_closure0) : bool
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var _1 : c01basic_usesclosure_closure0 = _1;
  {
    goto BB0
  }
  BB0 {
    _0 <- field_0 _1;
    return _0
  }
  
end
module C01Basic_UsesClosure_Interface
  val uses_closure [#"../01_basic.rs" 4 0 4 21] (_1 : ()) : ()
end
module C01Basic_UsesClosure
  clone C01Basic_UsesClosure_Closure0_Interface as Closure00
  let rec cfg uses_closure [#"../01_basic.rs" 4 0 4 21] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var y : bool;
  var _x : bool;
  var _4 : Closure00.c01basic_usesclosure_closure0;
  {
    goto BB0
  }
  BB0 {
    y <- ([#"../01_basic.rs" 5 12 5 16] true);
    _4 <- Closure00.C01Basic_UsesClosure_Closure0 y;
    _x <- ([#"../01_basic.rs" 6 13 6 21] let () = () in Closure00.c01Basic_UsesClosure_Closure0 _4);
    goto BB1
  }
  BB1 {
    assume { Closure00.resolve _4 };
    _0 <- ();
    return _0
  }
  
end
module C01Basic_MultiArg_Closure0_Type
  type c01basic_multiarg_closure0  =
    | C01Basic_MultiArg_Closure0
    
end
module C01Basic_MultiArg_Closure0_Interface
  use export C01Basic_MultiArg_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  predicate resolve [#"../01_basic.rs" 10 12 10 18] (_1 : c01basic_multiarg_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate unnest [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (_2 : c01basic_multiarg_closure0)
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  predicate postcondition_once [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  predicate postcondition_mut [#"../01_basic.rs" 10 12 10 18] (self : borrowed c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] (let (a, b) = args in true) /\ unnest ( * self) ( ^ self)
  predicate postcondition [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  val c01Basic_MultiArg_Closure0 [#"../01_basic.rs" 10 12 10 18] (_1 : c01basic_multiarg_closure0) (a : int32) (b : int32) : int32
    
end
module C01Basic_MultiArg_Closure0
  use export C01Basic_MultiArg_Closure0_Type
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  predicate resolve [#"../01_basic.rs" 10 12 10 18] (_1 : c01basic_multiarg_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate unnest [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (_2 : c01basic_multiarg_closure0)
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  predicate postcondition_once [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  predicate postcondition_mut [#"../01_basic.rs" 10 12 10 18] (self : borrowed c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] (let (a, b) = args in true) /\ unnest ( * self) ( ^ self)
  predicate postcondition [#"../01_basic.rs" 10 12 10 18] (self : c01basic_multiarg_closure0) (args : (int32, int32)) (result : int32)
    
   =
    [#"../01_basic.rs" 1 0 1 0] let (a, b) = args in true
  let rec cfg c01Basic_MultiArg_Closure0 [#"../01_basic.rs" 10 12 10 18] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : c01basic_multiarg_closure0) (a : int32) (b : int32) : int32
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var a : int32 = a;
  var b : int32 = b;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../01_basic.rs" 10 19 10 24] a + b);
    return _0
  }
  
end
module C01Basic_MultiArg_Interface
  val multi_arg [#"../01_basic.rs" 9 0 9 18] (_1 : ()) : ()
end
module C01Basic_MultiArg
  use prelude.Int
  use prelude.Int32
  clone C01Basic_MultiArg_Closure0_Interface as Closure00
  let rec cfg multi_arg [#"../01_basic.rs" 9 0 9 18] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : Closure00.c01basic_multiarg_closure0;
  var _a : int32;
  {
    goto BB0
  }
  BB0 {
    x <- Closure00.C01Basic_MultiArg_Closure0;
    _a <- ([#"../01_basic.rs" 11 13 11 22] let (a, b) = ([#"../01_basic.rs" 11 17 11 18] (0 : int32), [#"../01_basic.rs" 11 20 11 21] (3 : int32)) in Closure00.c01Basic_MultiArg_Closure0 x a b);
    goto BB1
  }
  BB1 {
    assume { Closure00.resolve x };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module C01Basic_MoveClosure_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  type c01basic_moveclosure_closure0  =
    | C01Basic_MoveClosure_Closure0 (borrowed int32)
    
end
module C01Basic_MoveClosure_Closure0_Interface
  use export C01Basic_MoveClosure_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = int32
  let function field_0 [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) : borrowed int32
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_MoveClosure_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 19 16 19 23] (_1 : c01basic_moveclosure_closure0) =
    [#"../01_basic.rs" 1 0 1 0] Resolve0.resolve (field_0 _1)
  predicate unnest [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_2 : c01basic_moveclosure_closure0)
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 19 16 19 23] (self : borrowed c01basic_moveclosure_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  val c01Basic_MoveClosure_Closure0 [#"../01_basic.rs" 19 16 19 23] (_1 : borrowed c01basic_moveclosure_closure0) : ()
    ensures { unnest ( * _1) ( ^ _1) }
    
end
module C01Basic_MoveClosure_Closure0
  use export C01Basic_MoveClosure_Closure0_Type
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = c01basic_moveclosure_closure0
  let function field_0 [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) : borrowed int32
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_MoveClosure_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 19 16 19 23] (_1 : c01basic_moveclosure_closure0) =
    [#"../01_basic.rs" 1 0 1 0] Resolve1.resolve (field_0 _1)
  predicate unnest [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_2 : c01basic_moveclosure_closure0)
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 19 16 19 23] (self : c01basic_moveclosure_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 19 16 19 23] (self : borrowed c01basic_moveclosure_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  let rec cfg c01Basic_MoveClosure_Closure0 [#"../01_basic.rs" 19 16 19 23] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : borrowed c01basic_moveclosure_closure0) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : borrowed c01basic_moveclosure_closure0 = _1;
  {
    goto BB0
  }
  BB0 {
    _1 <- { _1 with current = (let C01Basic_MoveClosure_Closure0 a =  * _1 in C01Basic_MoveClosure_Closure0 ({ (field_0 ( * _1)) with current = ([#"../01_basic.rs" 20 8 20 15]  * field_0 ( * _1) + ([#"../01_basic.rs" 20 14 20 15] (1 : int32))) })) };
    assume { Resolve0.resolve _1 };
    _0 <- ();
    return _0
  }
  
end
module C01Basic_MoveClosure_Interface
  val move_closure [#"../01_basic.rs" 16 0 16 21] (_1 : ()) : ()
end
module C01Basic_MoveClosure
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone C01Basic_MoveClosure_Closure0_Interface as Closure00 with
    predicate Resolve0.resolve = Resolve0.resolve
  let rec cfg move_closure [#"../01_basic.rs" 16 0 16 21] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var a : borrowed int32;
  var _2 : int32;
  var x : Closure00.c01basic_moveclosure_closure0;
  var _4 : ();
  var _5 : borrowed Closure00.c01basic_moveclosure_closure0;
  var _7 : ();
  var _8 : borrowed Closure00.c01basic_moveclosure_closure0;
  {
    goto BB0
  }
  BB0 {
    _2 <- ([#"../01_basic.rs" 17 17 17 21] (0 : int32));
    a <- Borrow.borrow_mut _2;
    _2 <-  ^ a;
    x <- Closure00.C01Basic_MoveClosure_Closure0 a;
    a <- any borrowed int32;
    _5 <- Borrow.borrow_mut x;
    x <-  ^ _5;
    _4 <- ([#"../01_basic.rs" 23 4 23 9] let () = () in Closure00.c01Basic_MoveClosure_Closure0 _5);
    _5 <- any borrowed Closure00.c01basic_moveclosure_closure0;
    goto BB1
  }
  BB1 {
    _8 <- Borrow.borrow_mut x;
    x <-  ^ _8;
    _7 <- ([#"../01_basic.rs" 24 4 24 9] let () = () in Closure00.c01Basic_MoveClosure_Closure0 _8);
    _8 <- any borrowed Closure00.c01basic_moveclosure_closure0;
    goto BB2
  }
  BB2 {
    assume { Closure00.resolve x };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 27 4 27 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module C01Basic_NewRef_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val new_ref [#"../01_basic.rs" 28 0 28 36] (_1 : ()) : borrowed t
    ensures { [#"../01_basic.rs" 28 27 28 36] Inv0.inv result }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module C01Basic_MoveMut_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  type c01basic_movemut_closure0  =
    | C01Basic_MoveMut_Closure0 (borrowed uint32)
    
end
module C01Basic_MoveMut_Closure0_Interface
  use export C01Basic_MoveMut_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = uint32
  let function field_0 [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) : borrowed uint32
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_MoveMut_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 35 16 35 23] (_1 : c01basic_movemut_closure0) =
    [#"../01_basic.rs" 1 0 1 0] Resolve0.resolve (field_0 _1)
  predicate unnest [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_2 : c01basic_movemut_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_ : ()) (result : ())
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 35 16 35 23] (self : borrowed c01basic_movemut_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  val c01Basic_MoveMut_Closure0 [#"../01_basic.rs" 35 16 35 23] (_1 : borrowed c01basic_movemut_closure0) : ()
    ensures { unnest ( * _1) ( ^ _1) }
    
end
module C01Basic_MoveMut_Closure0
  use export C01Basic_MoveMut_Closure0_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed uint32
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed uint32,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = c01basic_movemut_closure0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = uint32
  clone C01Basic_NewRef_Interface as NewRef0 with
    type t = uint32,
    predicate Inv0.inv = Inv0.inv
  let function field_0 [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) : borrowed uint32
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../01_basic.rs" 1 0 1 0] let C01Basic_MoveMut_Closure0 a = self in a
  predicate resolve [#"../01_basic.rs" 35 16 35 23] (_1 : c01basic_movemut_closure0) =
    [#"../01_basic.rs" 1 0 1 0] Resolve0.resolve (field_0 _1)
  predicate unnest [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_2 : c01basic_movemut_closure0) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate precondition [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_ : ()) =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_once [#"../01_basic.rs" 35 16 35 23] (self : c01basic_movemut_closure0) (_ : ()) (result : ())
   =
    [#"../01_basic.rs" 1 0 1 0] true
  predicate postcondition_mut [#"../01_basic.rs" 35 16 35 23] (self : borrowed c01basic_movemut_closure0) (_ : ()) (result : ())
    
   =
    [#"../01_basic.rs" 1 0 1 0] unnest ( * self) ( ^ self)
  let rec cfg c01Basic_MoveMut_Closure0 [#"../01_basic.rs" 35 16 35 23] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : borrowed c01basic_movemut_closure0) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var _1 : borrowed c01basic_movemut_closure0 = _1;
  var _2 : borrowed uint32;
  var _3 : borrowed uint32;
  {
    goto BB0
  }
  BB0 {
    _3 <- ([#"../01_basic.rs" 36 12 36 21] NewRef0.new_ref ());
    goto BB1
  }
  BB1 {
    _2 <- Borrow.borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _2) };
    _1 <- { _1 with current = (let C01Basic_MoveMut_Closure0 a =  * _1 in C01Basic_MoveMut_Closure0 _2) };
    _2 <- any borrowed uint32;
    assume { Resolve0.resolve (field_0 ( * _1)) };
    assume { Resolve1.resolve _1 };
    assume { Resolve0.resolve _3 };
    _0 <- ();
    return _0
  }
  
end
module C01Basic_MoveMut_Interface
  val move_mut [#"../01_basic.rs" 32 0 32 17] (_1 : ()) : ()
end
module C01Basic_MoveMut
  use prelude.Int
  use prelude.UInt32
  use prelude.Borrow
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = uint32
  clone C01Basic_MoveMut_Closure0_Interface as Closure00 with
    predicate Resolve0.resolve = Resolve0.resolve
  let rec cfg move_mut [#"../01_basic.rs" 32 0 32 17] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed uint32;
  var _2 : uint32;
  var a : Closure00.c01basic_movemut_closure0;
  var _4 : ();
  var _5 : borrowed Closure00.c01basic_movemut_closure0;
  var _7 : ();
  var _8 : borrowed Closure00.c01basic_movemut_closure0;
  {
    goto BB0
  }
  BB0 {
    _2 <- ([#"../01_basic.rs" 33 21 33 25] (0 : uint32));
    x <- Borrow.borrow_mut _2;
    _2 <-  ^ x;
    a <- Closure00.C01Basic_MoveMut_Closure0 x;
    x <- any borrowed uint32;
    _5 <- Borrow.borrow_mut a;
    a <-  ^ _5;
    _4 <- ([#"../01_basic.rs" 38 4 38 9] let () = () in Closure00.c01Basic_MoveMut_Closure0 _5);
    _5 <- any borrowed Closure00.c01basic_movemut_closure0;
    goto BB1
  }
  BB1 {
    _8 <- Borrow.borrow_mut a;
    a <-  ^ _8;
    _7 <- ([#"../01_basic.rs" 39 4 39 9] let () = () in Closure00.c01Basic_MoveMut_Closure0 _8);
    _8 <- any borrowed Closure00.c01basic_movemut_closure0;
    goto BB2
  }
  BB2 {
    assume { Closure00.resolve a };
    _0 <- ();
    return _0
  }
  
end
