module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_option__is_some_none [#"option.rs" 6 0 6 21]
  let%span soption0 = "option.rs" 8 33 8 34
  let%span soption1 = "option.rs" 11 4 11 46
  let%span soption2 = "option.rs" 10 4 10 46
  let%span soption3 = "../../../creusot-contracts/src/std/option.rs" 36 26 36 51
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any [ return' (result:bool)-> {[%#soption4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec is_some'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any [ return' (result:bool)-> {[%#soption3] result = (self <> Option'0.C_None)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec is_some_none (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = is_some'0 {some} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = any [ br0 -> {_4 = false} (! bb6) | br1 -> {_4} (! bb2) ] 
    | bb2 = s0 [ s0 = is_some'0 {none} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_6 = false} (! bb5) | br1 -> {_6} (! bb4) ] 
    | bb4 = bb7
    | bb5 = s0 [ s0 = is_none'0 {some} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb9) ] 
    | bb9 = bb14
    | bb10 = s0 [ s0 = is_none'0 {none} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = any [ br0 -> {_12 = false} (! bb13) | br1 -> {_12} (! bb12) ] 
    | bb12 = return' {_0}
    | bb13 = bb14
    | bb14 = {[%#soption1] false} any
    | bb6 = bb7
    | bb7 = {[%#soption2] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : bool = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__unwrap__qyClosure0 [#"option.rs" 30 12 30 30]
  type m_option__unwrap__qyClosure0  =
    | M_option__unwrap__qyClosure0
  
  let rec m_option__unwrap__qyClosure0 (input:m_option__unwrap__qyClosure0) (ret  )= any
    [ good -> {M_option__unwrap__qyClosure0  = input} (! ret) ]
    
end
module M_option__unwrap__qyClosure0 [#"option.rs" 30 12 30 30]
  let%span soption0 = "option.rs" 30 23 30 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__unwrap__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__unwrap__qyClosure0 (_1:Closure'0.m_option__unwrap__qyClosure0) (return'  (ret:int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:int32)-> (! return' {result}) ] 
end
module T_option__unwrap__qyClosure1 [#"option.rs" 36 12 36 38]
  type m_option__unwrap__qyClosure1  =
    | M_option__unwrap__qyClosure1
  
  let rec m_option__unwrap__qyClosure1 (input:m_option__unwrap__qyClosure1) (ret  )= any
    [ good -> {M_option__unwrap__qyClosure1  = input} (! ret) ]
    
end
module M_option__unwrap__qyClosure1 [#"option.rs" 36 12 36 38]
  let%span soption0 = "option.rs" 37 15 37 16
  let%span soption1 = "option.rs" 36 22 36 36
  
  use T_option__unwrap__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__unwrap__qyClosure1 (_1:Closure'0.m_option__unwrap__qyClosure1) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] (3 : int32) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () | & res : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption1] result = (3 : int32)} (! return' {result}) ]
    
end
module M_option__unwrap [#"option.rs" 15 0 15 15]
  let%span soption0 = "option.rs" 17 33 17 34
  let%span soption1 = "option.rs" 19 29 19 30
  let%span soption2 = "option.rs" 20 24 20 32
  let%span soption3 = "option.rs" 20 37 20 38
  let%span soption4 = "option.rs" 22 27 22 28
  let%span soption5 = "option.rs" 22 33 22 34
  let%span soption6 = "option.rs" 23 27 23 28
  let%span soption7 = "option.rs" 23 33 23 34
  let%span soption8 = "option.rs" 25 40 25 41
  let%span soption9 = "option.rs" 26 40 26 41
  let%span soption10 = "option.rs" 32 13 32 14
  let%span soption11 = "option.rs" 38 13 38 14
  let%span soption12 = "option.rs" 41 50 41 51
  let%span soption13 = "option.rs" 41 4 41 52
  let%span soption14 = "option.rs" 34 4 39 5
  let%span soption15 = "option.rs" 28 4 33 5
  let%span soption16 = "option.rs" 26 4 26 42
  let%span soption17 = "option.rs" 25 4 25 42
  let%span soption18 = "option.rs" 23 4 23 35
  let%span soption19 = "option.rs" 22 4 22 35
  let%span soption20 = "option.rs" 20 4 20 39
  let%span soption21 = "option.rs" 19 4 19 31
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption23 = "../../../creusot-contracts/src/std/option.rs" 94 16 94 62
  let%span soption24 = "../../../creusot-contracts/src/std/option.rs" 112 16 112 64
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 98 16 98 64
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 30 28 30 32
  let%span soption28 = "option.rs" 30 23 30 28
  let%span soption29 = "option.rs" 36 22 36 36
  
  use T_option__unwrap__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__unwrap__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__unwrap__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use T_option__unwrap__qyClosure0 as Closure'0
  
  predicate inv'2 (_1 : Closure'0.m_option__unwrap__qyClosure0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Closure'0.m_option__unwrap__qyClosure0 [inv'2 x] . inv'2 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate inv'1 (_1 : int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int32 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap_unchecked'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption22] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'1 result} {[%#soption22] Option'0.C_Some result = self} (! return' {result}) ] 
  
  predicate postcondition_once'1 [#"option.rs" 36 12 36 38] (self : Closure'1.m_option__unwrap__qyClosure1) (_ : ()) (result : int32)
    
   =
    [%#soption29] result = (3 : int32)
  
  predicate precondition'1 [#"option.rs" 36 12 36 38] (self : Closure'1.m_option__unwrap__qyClosure1) (_ : ()) =
    true
  
  let rec unwrap_or_else'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__unwrap__qyClosure1) (return'  (ret:int32))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption25] self = Option'0.C_None  -> precondition'1 f ()}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption26] match self with
        | Option'0.C_None -> postcondition_once'1 f () result
        | Option'0.C_Some t -> result = t
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 30 12 30 30] (self : Closure'0.m_option__unwrap__qyClosure0) (_ : ()) (result : int32)
    
   =
    true
  
  predicate precondition'0 [#"option.rs" 30 12 30 30] (self : Closure'0.m_option__unwrap__qyClosure0) (_ : ()) =
    [%#soption28] false
  
  let rec unwrap_or_else'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__unwrap__qyClosure0) (return'  (ret:int32))= {[@expl:precondition] inv'2 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption25] self = Option'0.C_None  -> precondition'0 f ()}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption26] match self with
        | Option'0.C_None -> postcondition_once'0 f () result
        | Option'0.C_Some t -> result = t
        end}
      (! return' {result}) ]
    
  
  predicate is_default'0 (self : int32) =
    [%#snum27] self = (0 : int32)
  
  let rec unwrap_or_default'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption22] self = Option'0.C_None \/ self = Option'0.C_Some result}
      {[%#soption24] self = Option'0.C_None  -> is_default'0 result}
      (! return' {result}) ]
    
  
  let rec unwrap_or'0 (self:Option'0.t_Option int32) (default:int32) (return'  (ret:int32))= {[@expl:precondition] inv'1 default}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption22] self = Option'0.C_None \/ self = Option'0.C_Some result}
      {[%#soption23] self = Option'0.C_None  -> result = default}
      (! return' {result}) ]
    
  
  let rec expect'0 (self:Option'0.t_Option int32) (msg:string) (return'  (ret:int32))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption22] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'1 result} {[%#soption22] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption22] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'1 result} {[%#soption22] Option'0.C_Some result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec unwrap (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = unwrap'0 {some} (fun (_ret':int32) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Int32.eq {_5} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]  ]
      
    | bb2 = s0
      [ s0 =  [ &_13 <- [%#soption2] "failed" ] s1
      | s1 = expect'0 {some} {_13} (fun (_ret':int32) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb4 ]
      
    | bb4 = s0
      [ s0 = Int32.eq {_10} {[%#soption3] (1 : int32)} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
      | s1 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 = unwrap_or'0 {some} {[%#soption4] (2 : int32)} (fun (_ret':int32) ->  [ &_17 <- _ret' ] s1) | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Int32.eq {_17} {[%#soption5] (1 : int32)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 = unwrap_or'0 {none} {[%#soption6] (2 : int32)} (fun (_ret':int32) ->  [ &_22 <- _ret' ] s1) | s1 = bb10 ]
      
    | bb10 = s0
      [ s0 = Int32.eq {_22} {[%#soption7] (2 : int32)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb12) | br1 -> {_21} (! bb11) ]  ]
      
    | bb11 = s0 [ s0 = unwrap_or_default'0 {some} (fun (_ret':int32) ->  [ &_27 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Int32.eq {_27} {[%#soption8] (1 : int32)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1)
      | s1 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb14) ]  ]
      
    | bb14 = s0 [ s0 = unwrap_or_default'0 {none} (fun (_ret':int32) ->  [ &_32 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = Int32.eq {_32} {[%#soption9] (0 : int32)} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s1)
      | s1 = any [ br0 -> {_31 = false} (! bb18) | br1 -> {_31} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 =  [ &_39 <- Closure'0.M_option__unwrap__qyClosure0 ] s1
      | s1 = unwrap_or_else'0 {some} {_39} (fun (_ret':int32) ->  [ &_37 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int32.eq {_37} {[%#soption10] (1 : int32)} (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb21) | br1 -> {_36} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &_45 <- Closure'1.M_option__unwrap__qyClosure1 ] s1
      | s1 = unwrap_or_else'1 {none} {_45} (fun (_ret':int32) ->  [ &_43 <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int32.eq {_43} {[%#soption11] (3 : int32)} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb24) | br1 -> {_42} (! bb23) ]  ]
      
    | bb23 = s0 [ s0 = unwrap_unchecked'0 {some} (fun (_ret':int32) ->  [ &_49 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 = Int32.eq {_49} {[%#soption12] (1 : int32)} (fun (_ret':bool) ->  [ &_48 <- _ret' ] s1)
      | s1 = any [ br0 -> {_48 = false} (! bb27) | br1 -> {_48} (! bb26) ]  ]
      
    | bb26 = return' {_0}
    | bb27 = {[%#soption13] false} any
    | bb24 = {[%#soption14] false} any
    | bb21 = {[%#soption15] false} any
    | bb18 = {[%#soption16] false} any
    | bb15 = {[%#soption17] false} any
    | bb12 = {[%#soption18] false} any
    | bb9 = {[%#soption19] false} any
    | bb6 = {[%#soption20] false} any
    | bb3 = {[%#soption21] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _5 : int32 = any_l ()
    | & _9 : bool = any_l ()
    | & _10 : int32 = any_l ()
    | & _13 : string = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : int32 = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int32 = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : int32 = any_l ()
    | & _31 : bool = any_l ()
    | & _32 : int32 = any_l ()
    | & _36 : bool = any_l ()
    | & _37 : int32 = any_l ()
    | & _39 : Closure'0.m_option__unwrap__qyClosure0 = any_l ()
    | & _42 : bool = any_l ()
    | & _43 : int32 = any_l ()
    | & _45 : Closure'1.m_option__unwrap__qyClosure1 = any_l ()
    | & _48 : bool = any_l ()
    | & _49 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__map__qyClosure0 [#"option.rs" 50 12 50 30]
  type m_option__map__qyClosure0  =
    | M_option__map__qyClosure0
  
  let rec m_option__map__qyClosure0 (input:m_option__map__qyClosure0) (ret  )= any
    [ good -> {M_option__map__qyClosure0  = input} (! ret) ]
    
end
module M_option__map__qyClosure0 [#"option.rs" 50 12 50 30]
  let%span soption0 = "option.rs" 50 23 50 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__map__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map__qyClosure0 (_1:Closure'0.m_option__map__qyClosure0) (_2:int32) (return'  (ret:()))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:())-> (! return' {result}) ] 
end
module T_option__map__qyClosure1 [#"option.rs" 56 12 56 38]
  type m_option__map__qyClosure1  =
    | M_option__map__qyClosure1
  
  let rec m_option__map__qyClosure1 (input:m_option__map__qyClosure1) (ret  )= any
    [ good -> {M_option__map__qyClosure1  = input} (! ret) ]
    
end
module M_option__map__qyClosure1 [#"option.rs" 56 12 56 38]
  let%span soption0 = "option.rs" 57 16 57 17
  let%span soption1 = "option.rs" 56 22 56 36
  
  use T_option__map__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map__qyClosure1 (_1:Closure'0.m_option__map__qyClosure1) (_2:int32) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] (3 : int32) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () | & res : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption1] result = (3 : int32)} (! return' {result}) ]
    
end
module T_option__map__qyClosure2 [#"option.rs" 63 12 63 41]
  type m_option__map__qyClosure2  =
    | M_option__map__qyClosure2
  
  let rec m_option__map__qyClosure2 (input:m_option__map__qyClosure2) (ret  )= any
    [ good -> {M_option__map__qyClosure2  = input} (! ret) ]
    
end
module M_option__map__qyClosure2 [#"option.rs" 63 12 63 41]
  let%span soption0 = "option.rs" 64 20 64 21
  let%span soption1 = "option.rs" 62 23 62 35
  let%span soption2 = "option.rs" 63 22 63 39
  
  use T_option__map__qyClosure2 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int32 = (2147483647 : int32)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map__qyClosure2 (_1:Closure'0.m_option__map__qyClosure2) (x:int32) (return'  (ret:int32))= {[%#soption1] x
    < (v_MAX'0 : int32)}
    (! bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption0] (1 : int32)} (fun (_ret':int32) ->  [ &res1 <- _ret' ] s1)
      | s1 =  [ &res <- res1 ] s2
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : int32 = any_l () | & x : int32 = x | & res : int32 = any_l () | & res1 : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption2] Int32.to_int result = Int32.to_int x + 1}
      (! return' {result}) ]
    
end
module M_option__map [#"option.rs" 44 0 44 12]
  let%span soption0 = "option.rs" 46 33 46 34
  let%span soption1 = "option.rs" 60 4 66 5
  let%span soption2 = "option.rs" 54 4 59 5
  let%span soption3 = "option.rs" 48 4 53 5
  let%span soption4 = "option.rs" 65 18 65 19
  let%span soption5 = "option.rs" 58 18 58 19
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 123 27 126 17
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 127 26 130 17
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption9 = "option.rs" 50 23 50 28
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption11 = "option.rs" 56 22 56 36
  let%span soption12 = "option.rs" 62 23 62 35
  let%span soption13 = "option.rs" 63 22 63 39
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span stuples15 = "../../../creusot-contracts/src/std/tuples.rs" 9 20 9 22
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__map__qyClosure2 as Closure'2
  
  predicate inv'6 (_1 : Closure'2.m_option__map__qyClosure2)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Closure'2.m_option__map__qyClosure2 [inv'6 x] . inv'6 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'5 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Option'0.t_Option int32 [inv'5 x] . inv'5 x = true
  
  use T_option__map__qyClosure1 as Closure'1
  
  predicate inv'4 (_1 : Closure'1.m_option__map__qyClosure1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'1.m_option__map__qyClosure1 [inv'4 x] . inv'4 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option ())
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option () [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option () [inv'2 x] . inv'2 x = true
  
  use T_option__map__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__map__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__map__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  predicate postcondition_once'2 [#"option.rs" 63 12 63 41] (self : Closure'2.m_option__map__qyClosure2) (args : int32) (result : int32)
    
   =
    [%#soption13] let (x) = args in Int32.to_int result = Int32.to_int x + 1
  
  constant v_MAX'0 : int32 = (2147483647 : int32)
  
  predicate precondition'2 [#"option.rs" 63 12 63 41] (self : Closure'2.m_option__map__qyClosure2) (args : int32) =
    [%#soption12] let (x) = args in x < (v_MAX'0 : int32)
  
  let rec map'2 (self:Option'0.t_Option int32) (f:Closure'2.m_option__map__qyClosure2) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'6 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'2 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> exists r : int32 . result = Option'0.C_Some r /\ postcondition_once'2 f (t) r
        end}
      (! return' {result}) ]
    
  
  function deep_model'5 (self : int32) : int =
    [%#snum16] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'3 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption14] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'5 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel10] deep_model'3 self
  
  let rec eq'1 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'5 other}
    {[@expl:precondition] inv'5 self}
    any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 56 12 56 38] (self : Closure'1.m_option__map__qyClosure1) (args : int32) (result : int32)
    
   =
    [%#soption11] let (_2) = args in result = (3 : int32)
  
  predicate precondition'1 [#"option.rs" 56 12 56 38] (self : Closure'1.m_option__map__qyClosure1) (args : int32) =
    let (_2) = args in true
  
  let rec map'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__map__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'4 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> exists r : int32 . result = Option'0.C_Some r /\ postcondition_once'1 f (t) r
        end}
      (! return' {result}) ]
    
  
  function deep_model'4 (self : ()) : () =
    [%#stuples15] ()
  
  function deep_model'2 (self : Option'0.t_Option ()) : Option'0.t_Option () =
    [%#soption14] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'4 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option ()) : Option'0.t_Option () =
    [%#smodel10] deep_model'2 self
  
  let rec eq'0 (self:Option'0.t_Option ()) (other:Option'0.t_Option ()) (return'  (ret:bool))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 50 12 50 30] (self : Closure'0.m_option__map__qyClosure0) (args : int32) (result : ())
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 50 12 50 30] (self : Closure'0.m_option__map__qyClosure0) (args : int32) =
    [%#soption9] let (_2) = args in false
  
  let rec map'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__map__qyClosure0) (return'  (ret:Option'0.t_Option ()))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option ())-> {inv'2 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> exists r : () . result = Option'0.C_Some r /\ postcondition_once'0 f (t) r
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption4] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption5] (3 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option ()))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option () = any_l () | & _1 : Option'0.t_Option () = any_l () ] 
    [ return' (result:Option'0.t_Option ())-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec map (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &_8 <- Closure'0.M_option__map__qyClosure0 ] s3
      | s3 = map'0 {none} {_8} (fun (_ret':Option'0.t_Option ()) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option ()) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- Closure'1.M_option__map__qyClosure1 ] s1
      | s1 = map'1 {some} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'1 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- Closure'2.M_option__map__qyClosure2 ] s1
      | s1 = map'2 {some} {_26} (fun (_ret':Option'0.t_Option int32) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'1 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option () = any_l ()
    | & _8 : Closure'0.m_option__map__qyClosure0 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _17 : Closure'1.m_option__map__qyClosure1 = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : Option'0.t_Option int32 = any_l ()
    | & _26 : Closure'2.m_option__map__qyClosure2 = any_l ()
    | & _30 : Option'0.t_Option int32 = any_l ()
    | & _31 : Option'0.t_Option int32 = any_l ()
    | & _32 : Option'0.t_Option () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__inspect__qyClosure0 [#"option.rs" 75 12 75 30]
  type m_option__inspect__qyClosure0  =
    | M_option__inspect__qyClosure0
  
  let rec m_option__inspect__qyClosure0 (input:m_option__inspect__qyClosure0) (ret  )= any
    [ good -> {M_option__inspect__qyClosure0  = input} (! ret) ]
    
end
module M_option__inspect__qyClosure0 [#"option.rs" 75 12 75 30]
  let%span soption0 = "option.rs" 75 23 75 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_option__inspect__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__inspect__qyClosure0 (_1:Closure'0.m_option__inspect__qyClosure0) (_2:int32) (return'  (ret:()))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:())-> (! return' {result}) ] 
end
module T_option__inspect__qyClosure1 [#"option.rs" 81 12 81 28]
  type m_option__inspect__qyClosure1  =
    | M_option__inspect__qyClosure1
  
  let rec m_option__inspect__qyClosure1 (input:m_option__inspect__qyClosure1) (ret  )= any
    [ good -> {M_option__inspect__qyClosure1  = input} (! ret) ]
    
end
module M_option__inspect__qyClosure1 [#"option.rs" 81 12 81 28]
  let%span soption0 = "option.rs" 81 22 81 26
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_option__inspect__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__inspect__qyClosure1 (_1:Closure'0.m_option__inspect__qyClosure1) (_2:int32) (return'  (ret:()))= (! bb0
    [ bb0 = return' {_0} ]
    ) [ & _0 : () = any_l () ] 
    [ return' (result:())-> {[@expl:postcondition] [%#soption0] true} (! return' {result}) ]
    
end
module M_option__inspect [#"option.rs" 69 0 69 16]
  let%span soption0 = "option.rs" 71 33 71 34
  let%span soption1 = "option.rs" 79 4 84 5
  let%span soption2 = "option.rs" 73 4 78 5
  let%span soption3 = "option.rs" 83 18 83 19
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 140 27 143 17
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 145 26 148 17
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption8 = "option.rs" 75 23 75 28
  let%span smodel9 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption10 = "option.rs" 81 22 81 26
  let%span soption11 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__inspect__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__inspect__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__inspect__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_option__inspect__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__inspect__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__inspect__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'1 [#"option.rs" 81 12 81 28] (self : Closure'1.m_option__inspect__qyClosure1) (args : int32) (result : ())
    
   =
    [%#soption10] let (_2) = args in true
  
  predicate precondition'1 [#"option.rs" 81 12 81 28] (self : Closure'1.m_option__inspect__qyClosure1) (args : int32) =
    let (_2) = args in true
  
  let rec inspect'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__inspect__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption4] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption6] match self with
        | Option'0.C_None -> true
        | Option'0.C_Some t -> postcondition_once'1 f (t) ()
        end}
      {[%#soption5] result = self}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum12] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption11] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel9] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[%#soption7] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 75 12 75 30] (self : Closure'0.m_option__inspect__qyClosure0) (args : int32) (result : ())
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 75 12 75 30] (self : Closure'0.m_option__inspect__qyClosure0) (args : int32) =
    [%#soption8] let (_2) = args in false
  
  let rec inspect'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__inspect__qyClosure0) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption4] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption6] match self with
        | Option'0.C_None -> true
        | Option'0.C_Some t -> postcondition_once'0 f (t) ()
        end}
      {[%#soption5] result = self}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption3] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec inspect (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &_8 <- Closure'0.M_option__inspect__qyClosure0 ] s3
      | s3 = inspect'0 {none} {_8} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_22 <- pr1 ] s1)
      | s1 = eq'0 {_6} {_22} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- Closure'1.M_option__inspect__qyClosure1 ] s1
      | s1 = inspect'1 {some} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_21 <- pr0 ] s1)
      | s1 = eq'0 {_15} {_21} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = return' {_0}
    | bb8 = {[%#soption1] false} any
    | bb4 = {[%#soption2] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _8 : Closure'0.m_option__inspect__qyClosure0 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _17 : Closure'1.m_option__inspect__qyClosure1 = any_l ()
    | & _21 : Option'0.t_Option int32 = any_l ()
    | & _22 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__map_or__qyClosure0 [#"option.rs" 95 12 95 30]
  type m_option__map_or__qyClosure0  =
    | M_option__map_or__qyClosure0
  
  let rec m_option__map_or__qyClosure0 (input:m_option__map_or__qyClosure0) (ret  )= any
    [ good -> {M_option__map_or__qyClosure0  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure0 [#"option.rs" 95 12 95 30]
  let%span soption0 = "option.rs" 95 23 95 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__map_or__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure0 (_1:Closure'0.m_option__map_or__qyClosure0) (_2:int32) (return'  (ret:int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:int32)-> (! return' {result}) ] 
end
module T_option__map_or__qyClosure1 [#"option.rs" 102 12 102 38]
  type m_option__map_or__qyClosure1  =
    | M_option__map_or__qyClosure1
  
  let rec m_option__map_or__qyClosure1 (input:m_option__map_or__qyClosure1) (ret  )= any
    [ good -> {M_option__map_or__qyClosure1  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure1 [#"option.rs" 102 12 102 38]
  let%span soption0 = "option.rs" 103 16 103 17
  let%span soption1 = "option.rs" 102 22 102 36
  
  use T_option__map_or__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure1 (_1:Closure'0.m_option__map_or__qyClosure1) (_2:int32) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] (3 : int32) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () | & res : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption1] result = (3 : int32)} (! return' {result}) ]
    
end
module T_option__map_or__qyClosure2 [#"option.rs" 110 12 110 41]
  type m_option__map_or__qyClosure2  =
    | M_option__map_or__qyClosure2
  
  let rec m_option__map_or__qyClosure2 (input:m_option__map_or__qyClosure2) (ret  )= any
    [ good -> {M_option__map_or__qyClosure2  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure2 [#"option.rs" 110 12 110 41]
  let%span soption0 = "option.rs" 111 20 111 21
  let%span soption1 = "option.rs" 109 23 109 35
  let%span soption2 = "option.rs" 110 22 110 39
  
  use T_option__map_or__qyClosure2 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int32 = (2147483647 : int32)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure2 (_1:Closure'0.m_option__map_or__qyClosure2) (x:int32) (return'  (ret:int32))= {[%#soption1] x
    < (v_MAX'0 : int32)}
    (! bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption0] (1 : int32)} (fun (_ret':int32) ->  [ &res1 <- _ret' ] s1)
      | s1 =  [ &res <- res1 ] s2
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : int32 = any_l () | & x : int32 = x | & res : int32 = any_l () | & res1 : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption2] Int32.to_int result = Int32.to_int x + 1}
      (! return' {result}) ]
    
end
module T_option__map_or__qyClosure3 [#"option.rs" 118 12 118 38]
  type m_option__map_or__qyClosure3  =
    | M_option__map_or__qyClosure3
  
  let rec m_option__map_or__qyClosure3 (input:m_option__map_or__qyClosure3) (ret  )= any
    [ good -> {M_option__map_or__qyClosure3  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure3 [#"option.rs" 118 12 118 38]
  let%span soption0 = "option.rs" 119 15 119 16
  let%span soption1 = "option.rs" 118 22 118 36
  
  use T_option__map_or__qyClosure3 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure3 (_1:Closure'0.m_option__map_or__qyClosure3) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] (2 : int32) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () | & res : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption1] result = (2 : int32)} (! return' {result}) ]
    
end
module T_option__map_or__qyClosure4 [#"option.rs" 120 12 120 30]
  type m_option__map_or__qyClosure4  =
    | M_option__map_or__qyClosure4
  
  let rec m_option__map_or__qyClosure4 (input:m_option__map_or__qyClosure4) (ret  )= any
    [ good -> {M_option__map_or__qyClosure4  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure4 [#"option.rs" 120 12 120 30]
  let%span soption0 = "option.rs" 120 23 120 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__map_or__qyClosure4 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure4 (_1:Closure'0.m_option__map_or__qyClosure4) (_2:int32) (return'  (ret:int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:int32)-> (! return' {result}) ] 
end
module T_option__map_or__qyClosure5 [#"option.rs" 126 12 126 30]
  type m_option__map_or__qyClosure5  =
    | M_option__map_or__qyClosure5
  
  let rec m_option__map_or__qyClosure5 (input:m_option__map_or__qyClosure5) (ret  )= any
    [ good -> {M_option__map_or__qyClosure5  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure5 [#"option.rs" 126 12 126 30]
  let%span soption0 = "option.rs" 126 23 126 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__map_or__qyClosure5 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure5 (_1:Closure'0.m_option__map_or__qyClosure5) (return'  (ret:int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:int32)-> (! return' {result}) ] 
end
module T_option__map_or__qyClosure6 [#"option.rs" 129 12 129 41]
  type m_option__map_or__qyClosure6  =
    | M_option__map_or__qyClosure6
  
  let rec m_option__map_or__qyClosure6 (input:m_option__map_or__qyClosure6) (ret  )= any
    [ good -> {M_option__map_or__qyClosure6  = input} (! ret) ]
    
end
module M_option__map_or__qyClosure6 [#"option.rs" 129 12 129 41]
  let%span soption0 = "option.rs" 130 20 130 21
  let%span soption1 = "option.rs" 128 23 128 35
  let%span soption2 = "option.rs" 129 22 129 39
  
  use T_option__map_or__qyClosure6 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int32 = (2147483647 : int32)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__map_or__qyClosure6 (_1:Closure'0.m_option__map_or__qyClosure6) (x:int32) (return'  (ret:int32))= {[%#soption1] x
    < (v_MAX'0 : int32)}
    (! bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption0] (1 : int32)} (fun (_ret':int32) ->  [ &res1 <- _ret' ] s1)
      | s1 =  [ &res <- res1 ] s2
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : int32 = any_l () | & x : int32 = x | & res : int32 = any_l () | & res1 : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption2] Int32.to_int result = Int32.to_int x + 1}
      (! return' {result}) ]
    
end
module M_option__map_or [#"option.rs" 87 0 87 15]
  let%span soption0 = "option.rs" 89 33 89 34
  let%span soption1 = "option.rs" 94 12 94 13
  let%span soption2 = "option.rs" 97 13 97 14
  let%span soption3 = "option.rs" 101 12 101 14
  let%span soption4 = "option.rs" 104 13 104 14
  let%span soption5 = "option.rs" 108 12 108 14
  let%span soption6 = "option.rs" 112 13 112 14
  let%span soption7 = "option.rs" 122 13 122 14
  let%span soption8 = "option.rs" 131 13 131 14
  let%span soption9 = "option.rs" 124 4 132 5
  let%span soption10 = "option.rs" 116 4 123 5
  let%span soption11 = "option.rs" 106 4 113 5
  let%span soption12 = "option.rs" 99 4 105 5
  let%span soption13 = "option.rs" 92 4 98 5
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 158 27 161 17
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 162 26 165 17
  let%span soption16 = "../../../creusot-contracts/src/std/option.rs" 175 27 178 17
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 179 26 182 17
  let%span soption18 = "option.rs" 95 23 95 28
  let%span soption19 = "option.rs" 102 22 102 36
  let%span soption20 = "option.rs" 109 23 109 35
  let%span soption21 = "option.rs" 110 22 110 39
  let%span soption22 = "option.rs" 120 23 120 28
  let%span soption23 = "option.rs" 118 22 118 36
  let%span soption24 = "option.rs" 126 23 126 28
  let%span soption25 = "option.rs" 128 23 128 35
  let%span soption26 = "option.rs" 129 22 129 39
  
  use T_option__map_or__qyClosure6 as Closure'6
  
  predicate inv'8 (_1 : Closure'6.m_option__map_or__qyClosure6)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Closure'6.m_option__map_or__qyClosure6 [inv'8 x] . inv'8 x = true
  
  use T_option__map_or__qyClosure5 as Closure'5
  
  predicate inv'7 (_1 : Closure'5.m_option__map_or__qyClosure5)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Closure'5.m_option__map_or__qyClosure5 [inv'7 x] . inv'7 x = true
  
  use T_option__map_or__qyClosure4 as Closure'4
  
  predicate inv'6 (_1 : Closure'4.m_option__map_or__qyClosure4)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Closure'4.m_option__map_or__qyClosure4 [inv'6 x] . inv'6 x = true
  
  use T_option__map_or__qyClosure3 as Closure'3
  
  predicate inv'5 (_1 : Closure'3.m_option__map_or__qyClosure3)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Closure'3.m_option__map_or__qyClosure3 [inv'5 x] . inv'5 x = true
  
  use T_option__map_or__qyClosure2 as Closure'2
  
  predicate inv'4 (_1 : Closure'2.m_option__map_or__qyClosure2)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'2.m_option__map_or__qyClosure2 [inv'4 x] . inv'4 x = true
  
  use T_option__map_or__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__map_or__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__map_or__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use T_option__map_or__qyClosure0 as Closure'0
  
  predicate inv'2 (_1 : Closure'0.m_option__map_or__qyClosure0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Closure'0.m_option__map_or__qyClosure0 [inv'2 x] . inv'2 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate inv'1 (_1 : int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int32 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  predicate postcondition_once'6 [#"option.rs" 129 12 129 41] (self : Closure'6.m_option__map_or__qyClosure6) (args : int32) (result : int32)
    
   =
    [%#soption26] let (x) = args in Int32.to_int result = Int32.to_int x + 1
  
  predicate postcondition_once'5 [#"option.rs" 126 12 126 30] (self : Closure'5.m_option__map_or__qyClosure5) (_ : ()) (result : int32)
    
   =
    true
  
  constant v_MAX'0 : int32 = (2147483647 : int32)
  
  predicate precondition'6 [#"option.rs" 129 12 129 41] (self : Closure'6.m_option__map_or__qyClosure6) (args : int32) =
    [%#soption25] let (x) = args in x < (v_MAX'0 : int32)
  
  predicate precondition'5 [#"option.rs" 126 12 126 30] (self : Closure'5.m_option__map_or__qyClosure5) (_ : ()) =
    [%#soption24] false
  
  let rec map_or_else'1 (self:Option'0.t_Option int32) (default:Closure'5.m_option__map_or__qyClosure5) (f:Closure'6.m_option__map_or__qyClosure6) (return'  (ret:int32))= {[@expl:precondition] inv'8 f}
    {[@expl:precondition] inv'7 default}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption16] match self with
      | Option'0.C_None -> precondition'5 default ()
      | Option'0.C_Some t -> precondition'6 f (t)
      end}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption17] match self with
        | Option'0.C_None -> postcondition_once'5 default () result
        | Option'0.C_Some t -> postcondition_once'6 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'4 [#"option.rs" 120 12 120 30] (self : Closure'4.m_option__map_or__qyClosure4) (args : int32) (result : int32)
    
   =
    let (_2) = args in true
  
  predicate postcondition_once'3 [#"option.rs" 118 12 118 38] (self : Closure'3.m_option__map_or__qyClosure3) (_ : ()) (result : int32)
    
   =
    [%#soption23] result = (2 : int32)
  
  predicate precondition'4 [#"option.rs" 120 12 120 30] (self : Closure'4.m_option__map_or__qyClosure4) (args : int32) =
    [%#soption22] let (_2) = args in false
  
  predicate precondition'3 [#"option.rs" 118 12 118 38] (self : Closure'3.m_option__map_or__qyClosure3) (_ : ()) =
    true
  
  let rec map_or_else'0 (self:Option'0.t_Option int32) (default:Closure'3.m_option__map_or__qyClosure3) (f:Closure'4.m_option__map_or__qyClosure4) (return'  (ret:int32))= {[@expl:precondition] inv'6 f}
    {[@expl:precondition] inv'5 default}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption16] match self with
      | Option'0.C_None -> precondition'3 default ()
      | Option'0.C_Some t -> precondition'4 f (t)
      end}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption17] match self with
        | Option'0.C_None -> postcondition_once'3 default () result
        | Option'0.C_Some t -> postcondition_once'4 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'2 [#"option.rs" 110 12 110 41] (self : Closure'2.m_option__map_or__qyClosure2) (args : int32) (result : int32)
    
   =
    [%#soption21] let (x) = args in Int32.to_int result = Int32.to_int x + 1
  
  predicate precondition'2 [#"option.rs" 110 12 110 41] (self : Closure'2.m_option__map_or__qyClosure2) (args : int32) =
    [%#soption20] let (x) = args in x < (v_MAX'0 : int32)
  
  let rec map_or'2 (self:Option'0.t_Option int32) (default:int32) (f:Closure'2.m_option__map_or__qyClosure2) (return'  (ret:int32))= {[@expl:precondition] inv'4 f}
    {[@expl:precondition] inv'1 default}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'2 f (t)
      end}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption15] match self with
        | Option'0.C_None -> result = default
        | Option'0.C_Some t -> postcondition_once'2 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 102 12 102 38] (self : Closure'1.m_option__map_or__qyClosure1) (args : int32) (result : int32)
    
   =
    [%#soption19] let (_2) = args in result = (3 : int32)
  
  predicate precondition'1 [#"option.rs" 102 12 102 38] (self : Closure'1.m_option__map_or__qyClosure1) (args : int32) =
    let (_2) = args in true
  
  let rec map_or'1 (self:Option'0.t_Option int32) (default:int32) (f:Closure'1.m_option__map_or__qyClosure1) (return'  (ret:int32))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'1 default}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption15] match self with
        | Option'0.C_None -> result = default
        | Option'0.C_Some t -> postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 95 12 95 30] (self : Closure'0.m_option__map_or__qyClosure0) (args : int32) (result : int32)
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 95 12 95 30] (self : Closure'0.m_option__map_or__qyClosure0) (args : int32) =
    [%#soption18] let (_2) = args in false
  
  let rec map_or'0 (self:Option'0.t_Option int32) (default:int32) (f:Closure'0.m_option__map_or__qyClosure0) (return'  (ret:int32))= {[@expl:precondition] inv'2 f}
    {[@expl:precondition] inv'1 default}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:int32)-> {inv'1 result}
      {[%#soption15] match self with
        | Option'0.C_None -> result = default
        | Option'0.C_Some t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec map_or (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &_7 <- Closure'0.M_option__map_or__qyClosure0 ] s3
      | s3 = map_or'0 {none} {[%#soption1] (2 : int32)} {_7} (fun (_ret':int32) ->  [ &_5 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = Int32.eq {_5} {[%#soption2] (2 : int32)} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]  ]
      
    | bb2 = s0
      [ s0 =  [ &_13 <- Closure'1.M_option__map_or__qyClosure1 ] s1
      | s1 = map_or'1 {some} {[%#soption3] (-1 : int32)} {_13} (fun (_ret':int32) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb4 ]
      
    | bb4 = s0
      [ s0 = Int32.eq {_11} {[%#soption4] (3 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1)
      | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 =  [ &_19 <- Closure'2.M_option__map_or__qyClosure2 ] s1
      | s1 = map_or'2 {some} {[%#soption5] (-1 : int32)} {_19} (fun (_ret':int32) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = Int32.eq {_17} {[%#soption6] (2 : int32)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &_25 <- Closure'3.M_option__map_or__qyClosure3 ] s1
      | s1 =  [ &_26 <- Closure'4.M_option__map_or__qyClosure4 ] s2
      | s2 = map_or_else'0 {none} {_25} {_26} (fun (_ret':int32) ->  [ &_23 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = s0
      [ s0 = Int32.eq {_23} {[%#soption7] (2 : int32)} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1)
      | s1 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]  ]
      
    | bb11 = s0
      [ s0 =  [ &_32 <- Closure'5.M_option__map_or__qyClosure5 ] s1
      | s1 =  [ &_33 <- Closure'6.M_option__map_or__qyClosure6 ] s2
      | s2 = map_or_else'1 {some} {_32} {_33} (fun (_ret':int32) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int32.eq {_30} {[%#soption8] (2 : int32)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb15) | br1 -> {_29} (! bb14) ]  ]
      
    | bb14 = return' {_0}
    | bb15 = {[%#soption9] false} any
    | bb12 = {[%#soption10] false} any
    | bb9 = {[%#soption11] false} any
    | bb6 = {[%#soption12] false} any
    | bb3 = {[%#soption13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _5 : int32 = any_l ()
    | & _7 : Closure'0.m_option__map_or__qyClosure0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int32 = any_l ()
    | & _13 : Closure'1.m_option__map_or__qyClosure1 = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : int32 = any_l ()
    | & _19 : Closure'2.m_option__map_or__qyClosure2 = any_l ()
    | & _22 : bool = any_l ()
    | & _23 : int32 = any_l ()
    | & _25 : Closure'3.m_option__map_or__qyClosure3 = any_l ()
    | & _26 : Closure'4.m_option__map_or__qyClosure4 = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : int32 = any_l ()
    | & _32 : Closure'5.m_option__map_or__qyClosure5 = any_l ()
    | & _33 : Closure'6.m_option__map_or__qyClosure6 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__result__Result
  type t_Result 't 'e =
    | C_Ok 't
    | C_Err 'e
  
  let rec v_Ok < 't > < 'e > (input:t_Result 't 'e) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Ok field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Ok field_0 : t_Result 't 'e] . C_Ok field_0 <> input} (! {false} any) ]
    
  
  let rec v_Err < 't > < 'e > (input:t_Result 't 'e) (ret  (field_0:'e))= any
    [ good (field_0:'e)-> {C_Err field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 'e [C_Err field_0 : t_Result 't 'e] . C_Err field_0 <> input} (! {false} any) ]
    
end
module T_option__ok_or__qyClosure2 [#"option.rs" 145 8 145 26]
  type m_option__ok_or__qyClosure2  =
    | M_option__ok_or__qyClosure2
  
  let rec m_option__ok_or__qyClosure2 (input:m_option__ok_or__qyClosure2) (ret  )= any
    [ good -> {M_option__ok_or__qyClosure2  = input} (! ret) ]
    
end
module M_option__ok_or__qyClosure2 [#"option.rs" 145 8 145 26]
  let%span soption0 = "option.rs" 146 11 146 15
  let%span soption1 = "option.rs" 145 18 145 24
  
  use T_option__ok_or__qyClosure2 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__ok_or__qyClosure2 (_1:Closure'0.m_option__ok_or__qyClosure2) (return'  (ret:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] true ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : bool = any_l () | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result} (! return' {result}) ]
    
end
module T_option__ok_or__qyClosure4 [#"option.rs" 150 8 150 26]
  type m_option__ok_or__qyClosure4  =
    | M_option__ok_or__qyClosure4
  
  let rec m_option__ok_or__qyClosure4 (input:m_option__ok_or__qyClosure4) (ret  )= any
    [ good -> {M_option__ok_or__qyClosure4  = input} (! ret) ]
    
end
module M_option__ok_or__qyClosure4 [#"option.rs" 150 8 150 26]
  let%span soption0 = "option.rs" 151 11 151 16
  let%span soption1 = "option.rs" 150 19 150 24
  
  use T_option__ok_or__qyClosure4 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__ok_or__qyClosure4 (_1:Closure'0.m_option__ok_or__qyClosure4) (return'  (ret:bool))= {[%#soption1] false}
    (! bb0 [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] false ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ] )
    [ & _0 : bool = any_l () | & res : bool = any_l () ]
     [ return' (result:bool)-> (! return' {result}) ] 
end
module M_option__ok_or [#"option.rs" 135 0 135 14]
  let%span soption0 = "option.rs" 137 33 137 34
  let%span soption1 = "option.rs" 139 25 139 29
  let%span soption2 = "option.rs" 140 18 140 34
  let%span soption3 = "option.rs" 141 24 141 29
  let%span soption4 = "option.rs" 142 18 142 32
  let%span soption5 = "option.rs" 148 18 148 34
  let%span soption6 = "option.rs" 153 18 153 32
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 193 26 196 17
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 199 16 199 66
  let%span soption9 = "../../../creusot-contracts/src/std/option.rs" 200 26 203 17
  let%span soption10 = "option.rs" 145 18 145 24
  let%span soption11 = "option.rs" 150 19 150 24
  
  use T_option__ok_or__qyClosure4 as Closure'1
  
  predicate inv'4 (_1 : Closure'1.m_option__ok_or__qyClosure4)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'1.m_option__ok_or__qyClosure4 [inv'4 x] . inv'4 x = true
  
  use T_option__ok_or__qyClosure2 as Closure'0
  
  predicate inv'3 (_1 : Closure'0.m_option__ok_or__qyClosure2)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'0.m_option__ok_or__qyClosure2 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__result__Result as Result'0
  
  predicate inv'2 (_1 : Result'0.t_Result int32 bool)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Result'0.t_Result int32 bool [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : bool)
  
  axiom inv_axiom'1 [@rewrite] : forall x : bool [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'1 [#"option.rs" 150 8 150 26] (self : Closure'1.m_option__ok_or__qyClosure4) (_ : ()) (result : bool)
    
   =
    true
  
  predicate precondition'1 [#"option.rs" 150 8 150 26] (self : Closure'1.m_option__ok_or__qyClosure4) (_ : ()) =
    [%#soption11] false
  
  let rec ok_or_else'1 (self:Option'0.t_Option int32) (err:Closure'1.m_option__ok_or__qyClosure4) (return'  (ret:Result'0.t_Result int32 bool))= {[@expl:precondition] inv'4 err}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption8] self = Option'0.C_None  -> precondition'1 err ()}
    any
    [ return' (result:Result'0.t_Result int32 bool)-> {inv'2 result}
      {[%#soption9] match self with
        | Option'0.C_None -> exists r : bool . result = Result'0.C_Err r /\ postcondition_once'1 err () r
        | Option'0.C_Some t -> result = Result'0.C_Ok t
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 145 8 145 26] (self : Closure'0.m_option__ok_or__qyClosure2) (_ : ()) (result : bool)
    
   =
    [%#soption10] result
  
  predicate precondition'0 [#"option.rs" 145 8 145 26] (self : Closure'0.m_option__ok_or__qyClosure2) (_ : ()) =
    true
  
  let rec ok_or_else'0 (self:Option'0.t_Option int32) (err:Closure'0.m_option__ok_or__qyClosure2) (return'  (ret:Result'0.t_Result int32 bool))= {[@expl:precondition] inv'3 err}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption8] self = Option'0.C_None  -> precondition'0 err ()}
    any
    [ return' (result:Result'0.t_Result int32 bool)-> {inv'2 result}
      {[%#soption9] match self with
        | Option'0.C_None -> exists r : bool . result = Result'0.C_Err r /\ postcondition_once'0 err () r
        | Option'0.C_Some t -> result = Result'0.C_Ok t
        end}
      (! return' {result}) ]
    
  
  let rec ok_or'0 (self:Option'0.t_Option int32) (err:bool) (return'  (ret:Result'0.t_Result int32 bool))= {[@expl:precondition] inv'1 err}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Result'0.t_Result int32 bool)-> {inv'2 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Result'0.C_Err err
        | Option'0.C_Some t -> result = Result'0.C_Ok t
        end}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec ok_or (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = ok_or'0 {none} {[%#soption1] true} (fun (_ret':Result'0.t_Result int32 bool) ->  [ &err <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#soption2] err = Result'0.C_Err true} s1
      | s1 = ok_or'0 {some} {[%#soption3] false} (fun (_ret':Result'0.t_Result int32 bool) ->  [ &ok <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:assertion] [%#soption4] ok = Result'0.C_Ok (1 : int32)} s1
      | s1 =  [ &_13 <- Closure'0.M_option__ok_or__qyClosure2 ] s2
      | s2 = ok_or_else'0 {none} {_13} (fun (_ret':Result'0.t_Result int32 bool) ->  [ &err1 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#soption5] err1 = Result'0.C_Err true} s1
      | s1 =  [ &_18 <- Closure'1.M_option__ok_or__qyClosure4 ] s2
      | s2 = ok_or_else'1 {some} {_18} (fun (_ret':Result'0.t_Result int32 bool) ->  [ &ok1 <- _ret' ] s3)
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#soption6] ok1 = Result'0.C_Ok (1 : int32)} s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & err : Result'0.t_Result int32 bool = any_l ()
    | & ok : Result'0.t_Result int32 bool = any_l ()
    | & err1 : Result'0.t_Result int32 bool = any_l ()
    | & _13 : Closure'0.m_option__ok_or__qyClosure2 = any_l ()
    | & ok1 : Result'0.t_Result int32 bool = any_l ()
    | & _18 : Closure'1.m_option__ok_or__qyClosure4 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__as_mut [#"option.rs" 156 0 156 15]
  let%span soption0 = "option.rs" 158 37 158 38
  let%span soption1 = "option.rs" 161 30 161 31
  let%span soption2 = "option.rs" 162 29 162 30
  let%span soption3 = "option.rs" 163 30 163 31
  let%span soption4 = "option.rs" 164 29 164 30
  let%span soption5 = "option.rs" 164 4 164 31
  let%span soption6 = "option.rs" 162 4 162 31
  let%span soption7 = "option.rs" 160 4 160 36
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 62 16 62 77
  let%span soption9 = "../../../creusot-contracts/src/std/option.rs" 63 16 66 18
  let%span soption10 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption11 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sresolve12 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sresolve13 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate inv'5 (_1 : int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int32 [inv'5 x] . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option int32 [inv'4 x] . inv'4 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : borrowed int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed int32 [inv'3 x] . inv'3 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'1 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'4 self}
    {[@expl:precondition] [%#soption11] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'5 result} {[%#soption11] Option'0.C_Some result = self} (! return' {result}) ] 
  
  predicate resolve'3 (self : borrowed int32) =
    [%#sresolve13] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed int32) =
    resolve'3 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:borrowed int32))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption11] self <> Option'0.C_None}
    any
    [ return' (result:borrowed int32)-> {inv'3 result}
      {[%#soption11] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : Option'0.t_Option (borrowed int32)) =
    [%#sresolve12] match self with
      | Option'0.C_Some x -> resolve'1 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'0 (_1 : Option'0.t_Option (borrowed int32)) =
    resolve'2 _1
  
  let rec is_none'0 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any [ return' (result:bool)-> {[%#soption10] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option int32)) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {inv'1 result}
      {[%#soption9] self.current = Option'0.C_None
      \/ (exists r : borrowed int32 . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption8] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec as_mut (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = as_mut'0 {_7} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = -{resolve'0 _6}- s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_11 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_11} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':borrowed int32) ->  [ &_9 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_9 <- { _9 with current = ([%#soption1] (2 : int32)) ; } ] s1
      | s1 = -{resolve'1 _9}- s2
      | s2 = unwrap'1 {some} (fun (_ret':int32) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = s0
      [ s0 = Int32.eq {_14} {[%#soption2] (2 : int32)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1)
      | s1 = any [ br0 -> {_13 = false} (! bb9) | br1 -> {_13} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_19 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_19} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_18 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0 [ s0 = unwrap'0 {_18} (fun (_ret':borrowed int32) ->  [ &_17 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_17 <- { _17 with current = ([%#soption3] (1 : int32)) ; } ] s1
      | s1 = -{resolve'1 _17}- s2
      | s2 = unwrap'1 {some} (fun (_ret':int32) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = Int32.eq {_22} {[%#soption4] (1 : int32)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = {[%#soption5] false} any
    | bb9 = {[%#soption6] false} any
    | bb4 = {[%#soption7] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _7 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _9 : borrowed int32 = any_l ()
    | & _10 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _11 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _13 : bool = any_l ()
    | & _14 : int32 = any_l ()
    | & _17 : borrowed int32 = any_l ()
    | & _18 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _19 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__as_ref [#"option.rs" 167 0 167 15]
  let%span soption0 = "option.rs" 169 33 169 34
  let%span soption1 = "option.rs" 172 39 172 40
  let%span soption2 = "option.rs" 172 4 172 41
  let%span soption3 = "option.rs" 171 4 171 36
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 55 16 55 60
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 56 16 58 18
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int32 [inv'3 x] . inv'3 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int32 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption7] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'3 result} {[%#soption7] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any [ return' (result:bool)-> {[%#soption6] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec as_ref'0 (self:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'1 result}
      {[%#soption5] self = Option'0.C_None
      \/ (exists r : int32 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption4] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec as_ref (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = as_ref'0 {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = as_ref'0 {some} (fun (_ret':Option'0.t_Option int32) ->  [ &_13 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = unwrap'0 {_13} (fun (_ret':int32) ->  [ &_12 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int32.eq {_12} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1)
      | s1 = any [ br0 -> {_10 = false} (! bb8) | br1 -> {_10} (! bb7) ]  ]
      
    | bb7 = return' {_0}
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : int32 = any_l ()
    | & _13 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__replace [#"option.rs" 175 0 175 16]
  let%span soption0 = "option.rs" 177 37 177 38
  let%span soption1 = "option.rs" 179 25 179 26
  let%span soption2 = "option.rs" 180 29 180 30
  let%span soption3 = "option.rs" 181 25 181 26
  let%span soption4 = "option.rs" 181 40 181 41
  let%span soption5 = "option.rs" 182 29 182 30
  let%span soption6 = "option.rs" 183 25 183 26
  let%span soption7 = "option.rs" 183 40 183 41
  let%span soption8 = "option.rs" 184 29 184 30
  let%span soption9 = "option.rs" 184 4 184 31
  let%span soption10 = "option.rs" 183 4 183 42
  let%span soption11 = "option.rs" 182 4 182 31
  let%span soption12 = "option.rs" 181 4 181 42
  let%span soption13 = "option.rs" 180 4 180 31
  let%span soption14 = "option.rs" 179 4 179 38
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption16 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'2 self}
    {[@expl:precondition] [%#soption15] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'1 result} {[%#soption15] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'3 self}
    any [ return' (result:bool)-> {[%#soption16] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec replace'0 (self:borrowed (Option'0.t_Option int32)) (value:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 value}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption15] result = self.current /\ self.final = Option'0.C_Some value}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec replace (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = replace'0 {_7} {[%#soption1] (2 : int32)} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = unwrap'0 {none} (fun (_ret':int32) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = Int32.eq {_11} {[%#soption2] (2 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1)
      | s1 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_18 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = replace'0 {_18} {[%#soption3] (2 : int32)} (fun (_ret':Option'0.t_Option int32) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0 [ s0 = unwrap'0 {_17} (fun (_ret':int32) ->  [ &_16 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = Int32.eq {_16} {[%#soption4] (1 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1)
      | s1 = any [ br0 -> {_15 = false} (! bb11) | br1 -> {_15} (! bb10) ]  ]
      
    | bb10 = s0 [ s0 = unwrap'0 {some} (fun (_ret':int32) ->  [ &_22 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = Int32.eq {_22} {[%#soption5] (2 : int32)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_29 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = replace'0 {_29} {[%#soption6] (1 : int32)} (fun (_ret':Option'0.t_Option int32) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = s0 [ s0 = unwrap'0 {_28} (fun (_ret':int32) ->  [ &_27 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = Int32.eq {_27} {[%#soption7] (2 : int32)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1)
      | s1 = any [ br0 -> {_26 = false} (! bb18) | br1 -> {_26} (! bb17) ]  ]
      
    | bb17 = s0 [ s0 = unwrap'0 {some} (fun (_ret':int32) ->  [ &_33 <- _ret' ] s1) | s1 = bb19 ] 
    | bb19 = s0
      [ s0 = Int32.eq {_33} {[%#soption8] (1 : int32)} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1)
      | s1 = any [ br0 -> {_32 = false} (! bb21) | br1 -> {_32} (! bb20) ]  ]
      
    | bb20 = return' {_0}
    | bb21 = {[%#soption9] false} any
    | bb18 = {[%#soption10] false} any
    | bb14 = {[%#soption11] false} any
    | bb11 = {[%#soption12] false} any
    | bb7 = {[%#soption13] false} any
    | bb4 = {[%#soption14] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _7 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int32 = any_l ()
    | & _15 : bool = any_l ()
    | & _16 : int32 = any_l ()
    | & _17 : Option'0.t_Option int32 = any_l ()
    | & _18 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int32 = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : int32 = any_l ()
    | & _28 : Option'0.t_Option int32 = any_l ()
    | & _29 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _32 : bool = any_l ()
    | & _33 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__and_or_xor [#"option.rs" 187 0 187 19]
  let%span soption0 = "option.rs" 189 33 189 34
  let%span soption1 = "option.rs" 193 26 193 27
  let%span soption2 = "option.rs" 195 26 195 27
  let%span soption3 = "option.rs" 198 25 198 26
  let%span soption4 = "option.rs" 200 25 200 26
  let%span soption5 = "option.rs" 203 26 203 27
  let%span soption6 = "option.rs" 205 26 205 27
  let%span soption7 = "option.rs" 205 4 205 38
  let%span soption8 = "option.rs" 204 4 204 38
  let%span soption9 = "option.rs" 203 4 203 41
  let%span soption10 = "option.rs" 202 4 202 35
  let%span soption11 = "option.rs" 200 4 200 40
  let%span soption12 = "option.rs" 199 4 199 37
  let%span soption13 = "option.rs" 198 4 198 40
  let%span soption14 = "option.rs" 197 4 197 34
  let%span soption15 = "option.rs" 195 4 195 41
  let%span soption16 = "option.rs" 194 4 194 35
  let%span soption17 = "option.rs" 193 4 193 38
  let%span soption18 = "option.rs" 192 4 192 35
  let%span soption19 = "option.rs" 204 35 204 36
  let%span soption20 = "option.rs" 203 38 203 39
  let%span soption21 = "option.rs" 200 37 200 38
  let%span soption22 = "option.rs" 199 34 199 35
  let%span soption23 = "option.rs" 198 37 198 38
  let%span soption24 = "option.rs" 195 38 195 39
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 222 16 222 59
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption27 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption28 = "../../../creusot-contracts/src/std/option.rs" 264 16 264 59
  let%span soption29 = "../../../creusot-contracts/src/std/option.rs" 283 26 288 17
  let%span sresolve30 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span smodel31 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption32 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'1 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (_1 : int32) =
    true
  
  let rec xor'0 (self:Option'0.t_Option int32) (optb:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption29] match (self, optb) with
        | (Option'0.C_None, Option'0.C_None) -> result = Option'0.C_None
        | (Option'0.C_Some t1, Option'0.C_Some t2) -> result = Option'0.C_None /\ resolve'1 t1 /\ resolve'1 t2
        | (Option'0.C_Some t, Option'0.C_None) -> result = Option'0.C_Some t
        | (Option'0.C_None, Option'0.C_Some t) -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : Option'0.t_Option int32) =
    [%#sresolve30] match self with
      | Option'0.C_Some x -> resolve'1 x
      | Option'0.C_None -> true
      end
  
  let rec or'0 (self:Option'0.t_Option int32) (optb:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption26] self = Option'0.C_None \/ result = self /\ resolve'0 optb}
      {[%#soption28] self = Option'0.C_None  -> result = optb}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum33] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption32] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel31] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'1 other}
    {[@expl:precondition] inv'1 self}
    any
    [ return' (result:bool)-> {[%#soption27] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  let rec and'0 (self:Option'0.t_Option int32) (optb:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption26] self = Option'0.C_None \/ result = optb /\ resolve'0 self}
      {[%#soption25] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption19] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption20] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted3 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted4 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption21] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted5 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption22] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted6 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption23] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted7 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted8 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption24] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted9 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted10 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted11 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec and_or_xor (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = and'0 {none} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted11 (fun (pr11:Option'0.t_Option int32) ->  [ &_122 <- pr11 ] s1)
      | s1 = eq'0 {_6} {_122} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- Option'0.C_Some ([%#soption1] (2 : int32)) ] s1
      | s1 = and'0 {none} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted10 (fun (pr10:Option'0.t_Option int32) ->  [ &_121 <- pr10 ] s1)
      | s1 = eq'0 {_15} {_121} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0 [ s0 = and'0 {some} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_24 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = promoted9 (fun (pr9:Option'0.t_Option int32) ->  [ &_120 <- pr9 ] s1)
      | s1 = eq'0 {_24} {_120} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_35 <- Option'0.C_Some ([%#soption2] (2 : int32)) ] s1
      | s1 = and'0 {some} {_35} (fun (_ret':Option'0.t_Option int32) ->  [ &_33 <- _ret' ] s2)
      | s2 = bb13 ]
      
    | bb13 = s0
      [ s0 = promoted8 (fun (pr8:Option'0.t_Option int32) ->  [ &_119 <- pr8 ] s1)
      | s1 = eq'0 {_33} {_119} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb15) ] 
    | bb15 = s0 [ s0 = or'0 {none} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_42 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 = promoted7 (fun (pr7:Option'0.t_Option int32) ->  [ &_118 <- pr7 ] s1)
      | s1 = eq'0 {_42} {_118} (fun (_ret':bool) ->  [ &_40 <- _ret' ] s2)
      | s2 = bb18 ]
      
    | bb18 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ] 
    | bb19 = s0
      [ s0 =  [ &_53 <- Option'0.C_Some ([%#soption3] (2 : int32)) ] s1
      | s1 = or'0 {none} {_53} (fun (_ret':Option'0.t_Option int32) ->  [ &_51 <- _ret' ] s2)
      | s2 = bb21 ]
      
    | bb21 = s0
      [ s0 = promoted6 (fun (pr6:Option'0.t_Option int32) ->  [ &_117 <- pr6 ] s1)
      | s1 = eq'0 {_51} {_117} (fun (_ret':bool) ->  [ &_49 <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = any [ br0 -> {_49 = false} (! bb24) | br1 -> {_49} (! bb23) ] 
    | bb23 = s0 [ s0 = or'0 {some} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_60 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 = promoted5 (fun (pr5:Option'0.t_Option int32) ->  [ &_116 <- pr5 ] s1)
      | s1 = eq'0 {_60} {_116} (fun (_ret':bool) ->  [ &_58 <- _ret' ] s2)
      | s2 = bb26 ]
      
    | bb26 = any [ br0 -> {_58 = false} (! bb28) | br1 -> {_58} (! bb27) ] 
    | bb27 = s0
      [ s0 =  [ &_71 <- Option'0.C_Some ([%#soption4] (2 : int32)) ] s1
      | s1 = or'0 {some} {_71} (fun (_ret':Option'0.t_Option int32) ->  [ &_69 <- _ret' ] s2)
      | s2 = bb29 ]
      
    | bb29 = s0
      [ s0 = promoted4 (fun (pr4:Option'0.t_Option int32) ->  [ &_115 <- pr4 ] s1)
      | s1 = eq'0 {_69} {_115} (fun (_ret':bool) ->  [ &_67 <- _ret' ] s2)
      | s2 = bb30 ]
      
    | bb30 = any [ br0 -> {_67 = false} (! bb32) | br1 -> {_67} (! bb31) ] 
    | bb31 = s0 [ s0 = xor'0 {none} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_78 <- _ret' ] s1) | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = promoted3 (fun (pr3:Option'0.t_Option int32) ->  [ &_114 <- pr3 ] s1)
      | s1 = eq'0 {_78} {_114} (fun (_ret':bool) ->  [ &_76 <- _ret' ] s2)
      | s2 = bb34 ]
      
    | bb34 = any [ br0 -> {_76 = false} (! bb36) | br1 -> {_76} (! bb35) ] 
    | bb35 = s0
      [ s0 =  [ &_89 <- Option'0.C_Some ([%#soption5] (2 : int32)) ] s1
      | s1 = xor'0 {none} {_89} (fun (_ret':Option'0.t_Option int32) ->  [ &_87 <- _ret' ] s2)
      | s2 = bb37 ]
      
    | bb37 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_113 <- pr2 ] s1)
      | s1 = eq'0 {_87} {_113} (fun (_ret':bool) ->  [ &_85 <- _ret' ] s2)
      | s2 = bb38 ]
      
    | bb38 = any [ br0 -> {_85 = false} (! bb40) | br1 -> {_85} (! bb39) ] 
    | bb39 = s0 [ s0 = xor'0 {some} {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_96 <- _ret' ] s1) | s1 = bb41 ] 
    | bb41 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_112 <- pr1 ] s1)
      | s1 = eq'0 {_96} {_112} (fun (_ret':bool) ->  [ &_94 <- _ret' ] s2)
      | s2 = bb42 ]
      
    | bb42 = any [ br0 -> {_94 = false} (! bb44) | br1 -> {_94} (! bb43) ] 
    | bb43 = s0
      [ s0 =  [ &_107 <- Option'0.C_Some ([%#soption6] (2 : int32)) ] s1
      | s1 = xor'0 {some} {_107} (fun (_ret':Option'0.t_Option int32) ->  [ &_105 <- _ret' ] s2)
      | s2 = bb45 ]
      
    | bb45 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_111 <- pr0 ] s1)
      | s1 = eq'0 {_105} {_111} (fun (_ret':bool) ->  [ &_103 <- _ret' ] s2)
      | s2 = bb46 ]
      
    | bb46 = any [ br0 -> {_103 = false} (! bb48) | br1 -> {_103} (! bb47) ] 
    | bb47 = return' {_0}
    | bb48 = {[%#soption7] false} any
    | bb44 = {[%#soption8] false} any
    | bb40 = {[%#soption9] false} any
    | bb36 = {[%#soption10] false} any
    | bb32 = {[%#soption11] false} any
    | bb28 = {[%#soption12] false} any
    | bb24 = {[%#soption13] false} any
    | bb20 = {[%#soption14] false} any
    | bb16 = {[%#soption15] false} any
    | bb12 = {[%#soption16] false} any
    | bb8 = {[%#soption17] false} any
    | bb4 = {[%#soption18] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _17 : Option'0.t_Option int32 = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : Option'0.t_Option int32 = any_l ()
    | & _31 : bool = any_l ()
    | & _33 : Option'0.t_Option int32 = any_l ()
    | & _35 : Option'0.t_Option int32 = any_l ()
    | & _40 : bool = any_l ()
    | & _42 : Option'0.t_Option int32 = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : Option'0.t_Option int32 = any_l ()
    | & _53 : Option'0.t_Option int32 = any_l ()
    | & _58 : bool = any_l ()
    | & _60 : Option'0.t_Option int32 = any_l ()
    | & _67 : bool = any_l ()
    | & _69 : Option'0.t_Option int32 = any_l ()
    | & _71 : Option'0.t_Option int32 = any_l ()
    | & _76 : bool = any_l ()
    | & _78 : Option'0.t_Option int32 = any_l ()
    | & _85 : bool = any_l ()
    | & _87 : Option'0.t_Option int32 = any_l ()
    | & _89 : Option'0.t_Option int32 = any_l ()
    | & _94 : bool = any_l ()
    | & _96 : Option'0.t_Option int32 = any_l ()
    | & _103 : bool = any_l ()
    | & _105 : Option'0.t_Option int32 = any_l ()
    | & _107 : Option'0.t_Option int32 = any_l ()
    | & _111 : Option'0.t_Option int32 = any_l ()
    | & _112 : Option'0.t_Option int32 = any_l ()
    | & _113 : Option'0.t_Option int32 = any_l ()
    | & _114 : Option'0.t_Option int32 = any_l ()
    | & _115 : Option'0.t_Option int32 = any_l ()
    | & _116 : Option'0.t_Option int32 = any_l ()
    | & _117 : Option'0.t_Option int32 = any_l ()
    | & _118 : Option'0.t_Option int32 = any_l ()
    | & _119 : Option'0.t_Option int32 = any_l ()
    | & _120 : Option'0.t_Option int32 = any_l ()
    | & _121 : Option'0.t_Option int32 = any_l ()
    | & _122 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__and_then__qyClosure0 [#"option.rs" 215 12 215 30]
  type m_option__and_then__qyClosure0  =
    | M_option__and_then__qyClosure0
  
  let rec m_option__and_then__qyClosure0 (input:m_option__and_then__qyClosure0) (ret  )= any
    [ good -> {M_option__and_then__qyClosure0  = input} (! ret) ]
    
end
module M_option__and_then__qyClosure0 [#"option.rs" 215 12 215 30]
  let%span soption0 = "option.rs" 215 23 215 28
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__and_then__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__and_then__qyClosure0 (_1:Closure'0.m_option__and_then__qyClosure0) (_2:int32) (return'  (ret:Option'0.t_Option int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:Option'0.t_Option int32)-> (! return' {result}) ] 
end
module T_option__and_then__qyClosure1 [#"option.rs" 219 15 223 7]
  type m_option__and_then__qyClosure1  =
    | M_option__and_then__qyClosure1
  
  let rec m_option__and_then__qyClosure1 (input:m_option__and_then__qyClosure1) (ret  )= any
    [ good -> {M_option__and_then__qyClosure1  = input} (! ret) ]
    
end
module M_option__and_then__qyClosure1 [#"option.rs" 219 15 223 7]
  let%span soption0 = "option.rs" 225 16 225 17
  let%span soption1 = "option.rs" 226 21 226 22
  let%span soption2 = "option.rs" 219 15 223 7
  
  use T_option__and_then__qyClosure1 as Closure'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Intrinsic
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__and_then__qyClosure1 (_1:Closure'0.m_option__and_then__qyClosure1) (x:int32) (return'  (ret:Option'0.t_Option int32))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x} {[%#soption0] (1 : int32)} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ]  ]
      
    | bb1 = s0
      [ s0 = Int32.add {x} {[%#soption1] (1 : int32)} (fun (_ret':int32) ->  [ &_6 <- _ret' ] s1)
      | s1 =  [ &res <- Option'0.C_Some _6 ] s2
      | s2 = bb3 ]
      
    | bb2 = s0 [ s0 =  [ &res <- Option'0.C_None ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &_0 <- res ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : Option'0.t_Option int32 = any_l ()
    | & x : int32 = x
    | & res : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : int32 = any_l () ]
    
    [ return' (result:Option'0.t_Option int32)-> {[@expl:postcondition] [%#soption2] if Int32.to_int x = 1 then
        exists r : int32 . result = Option'0.C_Some r /\ Int32.to_int r = Int32.to_int x + 1
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
end
module M_option__and_then [#"option.rs" 208 0 208 17]
  let%span soption0 = "option.rs" 210 34 210 35
  let%span soption1 = "option.rs" 211 34 211 35
  let%span soption2 = "option.rs" 232 4 232 41
  let%span soption3 = "option.rs" 231 4 231 47
  let%span soption4 = "option.rs" 213 4 218 5
  let%span soption5 = "option.rs" 231 41 231 45
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 226 27 229 17
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 230 26 233 17
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption9 = "option.rs" 215 23 215 28
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption11 = "option.rs" 219 15 223 7
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__and_then__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__and_then__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__and_then__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_option__and_then__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__and_then__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__and_then__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  predicate postcondition_once'1 [#"option.rs" 219 15 223 7] (self : Closure'1.m_option__and_then__qyClosure1) (args : int32) (result : Option'0.t_Option int32)
    
   =
    [%#soption11] let (x) = args in if Int32.to_int x = 1 then
      exists r : int32 . result = Option'0.C_Some r /\ Int32.to_int r = Int32.to_int x + 1
    else
      result = Option'0.C_None
    
  
  predicate precondition'1 [#"option.rs" 219 15 223 7] (self : Closure'1.m_option__and_then__qyClosure1) (args : int32)
   =
    let (x) = args in true
  
  let rec and_then'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__and_then__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]
    
  
  function deep_model'2 (self : int32) : int =
    [%#snum13] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption12] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel10] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 215 12 215 30] (self : Closure'0.m_option__and_then__qyClosure0) (args : int32) (result : Option'0.t_Option int32)
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 215 12 215 30] (self : Closure'0.m_option__and_then__qyClosure0) (args : int32)
   =
    [%#soption9] let (_2) = args in false
  
  let rec and_then'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__and_then__qyClosure0) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption5] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec and_then (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some1 <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &some2 <- Option'0.C_Some ([%#soption1] (3 : int32)) ] s3
      | s3 =  [ &_9 <- Closure'0.M_option__and_then__qyClosure0 ] s4
      | s4 = and_then'0 {none} {_9} (fun (_ret':Option'0.t_Option int32) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_34 <- pr2 ] s1)
      | s1 = eq'0 {_7} {_34} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &clos <- Closure'1.M_option__and_then__qyClosure1 ] s1
      | s1 = and_then'1 {some1} {clos} (fun (_ret':Option'0.t_Option int32) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_33 <- pr1 ] s1)
      | s1 = eq'0 {_17} {_33} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ] 
    | bb7 = s0
      [ s0 = and_then'1 {some2} {clos} (fun (_ret':Option'0.t_Option int32) ->  [ &_26 <- _ret' ] s1) | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_32 <- pr0 ] s1)
      | s1 = eq'0 {_26} {_32} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption2] false} any
    | bb8 = {[%#soption3] false} any
    | bb4 = {[%#soption4] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some1 : Option'0.t_Option int32 = any_l ()
    | & some2 : Option'0.t_Option int32 = any_l ()
    | & _5 : bool = any_l ()
    | & _7 : Option'0.t_Option int32 = any_l ()
    | & _9 : Closure'0.m_option__and_then__qyClosure0 = any_l ()
    | & clos : Closure'1.m_option__and_then__qyClosure1 = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : Option'0.t_Option int32 = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : Option'0.t_Option int32 = any_l ()
    | & _32 : Option'0.t_Option int32 = any_l ()
    | & _33 : Option'0.t_Option int32 = any_l ()
    | & _34 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__filter__qyClosure0 [#"option.rs" 241 12 241 30]
  type m_option__filter__qyClosure0  =
    | M_option__filter__qyClosure0
  
  let rec m_option__filter__qyClosure0 (input:m_option__filter__qyClosure0) (ret  )= any
    [ good -> {M_option__filter__qyClosure0  = input} (! ret) ]
    
end
module M_option__filter__qyClosure0 [#"option.rs" 241 12 241 30]
  let%span soption0 = "option.rs" 241 23 241 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_option__filter__qyClosure0 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__filter__qyClosure0 (_1:Closure'0.m_option__filter__qyClosure0) (_2:int32) (return'  (ret:bool))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:bool)-> (! return' {result}) ] 
end
module T_option__filter__qyClosure1 [#"option.rs" 247 12 247 43]
  type m_option__filter__qyClosure1  =
    | M_option__filter__qyClosure1
  
  let rec m_option__filter__qyClosure1 (input:m_option__filter__qyClosure1) (ret  )= any
    [ good -> {M_option__filter__qyClosure1  = input} (! ret) ]
    
end
module M_option__filter__qyClosure1 [#"option.rs" 247 12 247 43]
  let%span soption0 = "option.rs" 248 22 248 23
  let%span soption1 = "option.rs" 247 22 247 41
  let%span smodel2 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  
  use T_option__filter__qyClosure1 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function view'0 (self : int32) : int =
    [%#smodel2] Int32.to_int self
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__filter__qyClosure1 (_1:Closure'0.m_option__filter__qyClosure1) (x:int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x} {[%#soption0] (1 : int32)} (fun (_ret':bool) ->  [ &res <- _ret' ] s1)
      | s1 =  [ &_0 <- res ] s2
      | s2 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & x : int32 = x | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result = (view'0 x = 1)} (! return' {result}) ]
    
end
module T_option__filter__qyClosure2 [#"option.rs" 253 12 253 43]
  type m_option__filter__qyClosure2  =
    | M_option__filter__qyClosure2
  
  let rec m_option__filter__qyClosure2 (input:m_option__filter__qyClosure2) (ret  )= any
    [ good -> {M_option__filter__qyClosure2  = input} (! ret) ]
    
end
module M_option__filter__qyClosure2 [#"option.rs" 253 12 253 43]
  let%span soption0 = "option.rs" 254 22 254 23
  let%span soption1 = "option.rs" 253 22 253 41
  let%span smodel2 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  
  use T_option__filter__qyClosure2 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function view'0 (self : int32) : int =
    [%#smodel2] Int32.to_int self
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__filter__qyClosure2 (_1:Closure'0.m_option__filter__qyClosure2) (x:int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x} {[%#soption0] (2 : int32)} (fun (_ret':bool) ->  [ &res <- _ret' ] s1)
      | s1 =  [ &_0 <- res ] s2
      | s2 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & x : int32 = x | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result = (view'0 x = 2)} (! return' {result}) ]
    
end
module M_option__filter [#"option.rs" 235 0 235 15]
  let%span soption0 = "option.rs" 237 33 237 34
  let%span soption1 = "option.rs" 251 4 256 5
  let%span soption2 = "option.rs" 245 4 250 5
  let%span soption3 = "option.rs" 239 4 244 5
  let%span soption4 = "option.rs" 249 18 249 22
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 247 26 253 17
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption8 = "option.rs" 241 23 241 28
  let%span smodel9 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption10 = "option.rs" 247 22 247 41
  let%span soption11 = "option.rs" 253 22 253 41
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__filter__qyClosure2 as Closure'2
  
  predicate inv'4 (_1 : Closure'2.m_option__filter__qyClosure2)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'2.m_option__filter__qyClosure2 [inv'4 x] . inv'4 x = true
  
  use T_option__filter__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__filter__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__filter__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_option__filter__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__filter__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__filter__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (_1 : int32) =
    true
  
  use prelude.prelude.Int32
  
  function view'0 (self : int32) : int =
    [%#smodel13] Int32.to_int self
  
  predicate postcondition_once'2 [#"option.rs" 253 12 253 43] (self : Closure'2.m_option__filter__qyClosure2) (args : int32) (result : bool)
    
   =
    [%#soption11] let (x) = args in result = (view'0 x = 2)
  
  predicate precondition'2 [#"option.rs" 253 12 253 43] (self : Closure'2.m_option__filter__qyClosure2) (args : int32) =
    let (x) = args in true
  
  let rec filter'2 (self:Option'0.t_Option int32) (predicate':Closure'2.m_option__filter__qyClosure2) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'4 predicate'}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'2 predicate' (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption6] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> match result with
          | Option'0.C_None -> postcondition_once'2 predicate' (t) false /\ resolve'0 t
          | Option'0.C_Some r -> postcondition_once'2 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 247 12 247 43] (self : Closure'1.m_option__filter__qyClosure1) (args : int32) (result : bool)
    
   =
    [%#soption10] let (x) = args in result = (view'0 x = 1)
  
  predicate precondition'1 [#"option.rs" 247 12 247 43] (self : Closure'1.m_option__filter__qyClosure1) (args : int32) =
    let (x) = args in true
  
  let rec filter'1 (self:Option'0.t_Option int32) (predicate':Closure'1.m_option__filter__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'3 predicate'}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 predicate' (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption6] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> match result with
          | Option'0.C_None -> postcondition_once'1 predicate' (t) false /\ resolve'0 t
          | Option'0.C_Some r -> postcondition_once'1 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
  
  function deep_model'2 (self : int32) : int =
    [%#snum14] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption12] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel9] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[%#soption7] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 241 12 241 30] (self : Closure'0.m_option__filter__qyClosure0) (args : int32) (result : bool)
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 241 12 241 30] (self : Closure'0.m_option__filter__qyClosure0) (args : int32) =
    [%#soption8] let (_2) = args in false
  
  let rec filter'0 (self:Option'0.t_Option int32) (predicate':Closure'0.m_option__filter__qyClosure0) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 predicate'}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 predicate' (t)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption6] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> match result with
          | Option'0.C_None -> postcondition_once'0 predicate' (t) false /\ resolve'0 t
          | Option'0.C_Some r -> postcondition_once'0 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption4] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec filter (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &_8 <- Closure'0.M_option__filter__qyClosure0 ] s3
      | s3 = filter'0 {none} {_8} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- Closure'1.M_option__filter__qyClosure1 ] s1
      | s1 = filter'1 {some} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- Closure'2.M_option__filter__qyClosure2 ] s1
      | s1 = filter'2 {some} {_26} (fun (_ret':Option'0.t_Option int32) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _8 : Closure'0.m_option__filter__qyClosure0 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _17 : Closure'1.m_option__filter__qyClosure1 = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : Option'0.t_Option int32 = any_l ()
    | & _26 : Closure'2.m_option__filter__qyClosure2 = any_l ()
    | & _30 : Option'0.t_Option int32 = any_l ()
    | & _31 : Option'0.t_Option int32 = any_l ()
    | & _32 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__is_some_and__qyClosure0 [#"option.rs" 265 8 265 41]
  type m_option__is_some_and__qyClosure0  =
    | M_option__is_some_and__qyClosure0
  
  let rec m_option__is_some_and__qyClosure0 (input:m_option__is_some_and__qyClosure0) (ret  )= any
    [ good -> {M_option__is_some_and__qyClosure0  = input} (! ret) ]
    
end
module M_option__is_some_and__qyClosure0 [#"option.rs" 265 8 265 41]
  let%span soption0 = "option.rs" 266 17 266 18
  let%span soption1 = "option.rs" 265 18 265 39
  
  use T_option__is_some_and__qyClosure0 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__is_some_and__qyClosure0 (_1:Closure'0.m_option__is_some_and__qyClosure0) (x:int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x} {[%#soption0] (1 : int32)} (fun (_ret':bool) ->  [ &res <- _ret' ] s1)
      | s1 =  [ &_0 <- res ] s2
      | s2 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & x : int32 = x | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result = (x = (1 : int32))} (! return' {result}) ]
    
end
module T_option__is_some_and__qyClosure1 [#"option.rs" 269 8 269 41]
  type m_option__is_some_and__qyClosure1  =
    | M_option__is_some_and__qyClosure1
  
  let rec m_option__is_some_and__qyClosure1 (input:m_option__is_some_and__qyClosure1) (ret  )= any
    [ good -> {M_option__is_some_and__qyClosure1  = input} (! ret) ]
    
end
module M_option__is_some_and__qyClosure1 [#"option.rs" 269 8 269 41]
  let%span soption0 = "option.rs" 270 17 270 18
  let%span soption1 = "option.rs" 269 18 269 39
  
  use T_option__is_some_and__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__is_some_and__qyClosure1 (_1:Closure'0.m_option__is_some_and__qyClosure1) (x:int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x} {[%#soption0] (1 : int32)} (fun (_ret':bool) ->  [ &res <- _ret' ] s1)
      | s1 =  [ &_0 <- res ] s2
      | s2 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & x : int32 = x | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result = (x = (1 : int32))} (! return' {result}) ]
    
end
module T_option__is_some_and__qyClosure2 [#"option.rs" 273 8 273 26]
  type m_option__is_some_and__qyClosure2  =
    | M_option__is_some_and__qyClosure2
  
  let rec m_option__is_some_and__qyClosure2 (input:m_option__is_some_and__qyClosure2) (ret  )= any
    [ good -> {M_option__is_some_and__qyClosure2  = input} (! ret) ]
    
end
module M_option__is_some_and__qyClosure2 [#"option.rs" 273 8 273 26]
  let%span soption0 = "option.rs" 274 12 274 16
  let%span soption1 = "option.rs" 273 18 273 24
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__is_some_and__qyClosure2 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__is_some_and__qyClosure2 (_1:Closure'0.m_option__is_some_and__qyClosure2) (_2:int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] true ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : bool = any_l () | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result} (! return' {result}) ]
    
end
module M_option__is_some_and [#"option.rs" 259 0 259 20]
  let%span soption0 = "option.rs" 261 34 261 35
  let%span soption1 = "option.rs" 262 34 262 35
  let%span soption2 = "option.rs" 268 4 271 6
  let%span soption3 = "option.rs" 272 4 275 6
  let%span soption4 = "option.rs" 264 4 267 6
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 39 27 42 17
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 43 26 46 17
  let%span soption7 = "option.rs" 265 18 265 39
  let%span soption8 = "option.rs" 269 18 269 39
  let%span soption9 = "option.rs" 273 18 273 24
  
  use T_option__is_some_and__qyClosure2 as Closure'2
  
  predicate inv'3 (_1 : Closure'2.m_option__is_some_and__qyClosure2)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'2.m_option__is_some_and__qyClosure2 [inv'3 x] . inv'3 x = true
  
  use T_option__is_some_and__qyClosure1 as Closure'1
  
  predicate inv'2 (_1 : Closure'1.m_option__is_some_and__qyClosure1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Closure'1.m_option__is_some_and__qyClosure1 [inv'2 x] . inv'2 x = true
  
  use T_option__is_some_and__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__is_some_and__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__is_some_and__qyClosure0 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'2 [#"option.rs" 273 8 273 26] (self : Closure'2.m_option__is_some_and__qyClosure2) (args : int32) (result : bool)
    
   =
    [%#soption9] let (_2) = args in result
  
  use prelude.prelude.Borrow
  
  predicate resolve'0 (_1 : int32) =
    true
  
  predicate precondition'2 [#"option.rs" 273 8 273 26] (self : Closure'2.m_option__is_some_and__qyClosure2) (args : int32)
    
   =
    let (_2) = args in true
  
  let rec is_some_and'2 (self:Option'0.t_Option int32) (f:Closure'2.m_option__is_some_and__qyClosure2) (return'  (ret:bool))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'2 f (t)
      end}
    any
    [ return' (result:bool)-> {[%#soption6] match self with
        | Option'0.C_None -> result = false
        | Option'0.C_Some t -> resolve'0 t /\ postcondition_once'2 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 269 8 269 41] (self : Closure'1.m_option__is_some_and__qyClosure1) (args : int32) (result : bool)
    
   =
    [%#soption8] let (x) = args in result = (x = (1 : int32))
  
  predicate precondition'1 [#"option.rs" 269 8 269 41] (self : Closure'1.m_option__is_some_and__qyClosure1) (args : int32)
    
   =
    let (x) = args in true
  
  let rec is_some_and'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__is_some_and__qyClosure1) (return'  (ret:bool))= {[@expl:precondition] inv'2 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 f (t)
      end}
    any
    [ return' (result:bool)-> {[%#soption6] match self with
        | Option'0.C_None -> result = false
        | Option'0.C_Some t -> resolve'0 t /\ postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 265 8 265 41] (self : Closure'0.m_option__is_some_and__qyClosure0) (args : int32) (result : bool)
    
   =
    [%#soption7] let (x) = args in result = (x = (1 : int32))
  
  predicate precondition'0 [#"option.rs" 265 8 265 41] (self : Closure'0.m_option__is_some_and__qyClosure0) (args : int32)
    
   =
    let (x) = args in true
  
  let rec is_some_and'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__is_some_and__qyClosure0) (return'  (ret:bool))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption5] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:bool)-> {[%#soption6] match self with
        | Option'0.C_None -> result = false
        | Option'0.C_Some t -> resolve'0 t /\ postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec is_some_and (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some1 <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &some2 <- Option'0.C_Some ([%#soption1] (2 : int32)) ] s3
      | s3 =  [ &_7 <- Closure'0.M_option__is_some_and__qyClosure0 ] s4
      | s4 = is_some_and'0 {some1} {_7} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s5)
      | s5 = bb1 ]
      
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- Closure'1.M_option__is_some_and__qyClosure1 ] s1
      | s1 = is_some_and'1 {some2} {_12} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = {[%#soption2] false} any
    | bb6 = s0
      [ s0 =  [ &_17 <- Closure'2.M_option__is_some_and__qyClosure2 ] s1
      | s1 = is_some_and'2 {none} {_17} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ] 
    | bb8 = {[%#soption3] false} any
    | bb9 = return' {_0}
    | bb3 = {[%#soption4] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some1 : Option'0.t_Option int32 = any_l ()
    | & some2 : Option'0.t_Option int32 = any_l ()
    | & _5 : bool = any_l ()
    | & _7 : Closure'0.m_option__is_some_and__qyClosure0 = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : Closure'1.m_option__is_some_and__qyClosure1 = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : Closure'2.m_option__is_some_and__qyClosure2 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__or_else__qyClosure0 [#"option.rs" 284 12 284 44]
  type m_option__or_else__qyClosure0  =
    | M_option__or_else__qyClosure0
  
  let rec m_option__or_else__qyClosure0 (input:m_option__or_else__qyClosure0) (ret  )= any
    [ good -> {M_option__or_else__qyClosure0  = input} (! ret) ]
    
end
module M_option__or_else__qyClosure0 [#"option.rs" 284 12 284 44]
  let%span soption0 = "option.rs" 285 20 285 21
  let%span soption1 = "option.rs" 284 22 284 42
  
  use T_option__or_else__qyClosure0 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__or_else__qyClosure0 (_1:Closure'0.m_option__or_else__qyClosure0) (return'  (ret:Option'0.t_Option int32))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &res <- Option'0.C_Some ([%#soption0] (2 : int32)) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]
       ]
    ) [ & _0 : Option'0.t_Option int32 = any_l () | & res : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> {[@expl:postcondition] [%#soption1] result
      = Option'0.C_Some (2 : int32)}
      (! return' {result}) ]
    
end
module T_option__or_else__qyClosure1 [#"option.rs" 290 12 290 38]
  type m_option__or_else__qyClosure1  =
    | M_option__or_else__qyClosure1
  
  let rec m_option__or_else__qyClosure1 (input:m_option__or_else__qyClosure1) (ret  )= any
    [ good -> {M_option__or_else__qyClosure1  = input} (! ret) ]
    
end
module M_option__or_else__qyClosure1 [#"option.rs" 290 12 290 38]
  let%span soption0 = "option.rs" 290 22 290 36
  
  use T_option__or_else__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__or_else__qyClosure1 (_1:Closure'0.m_option__or_else__qyClosure1) (return'  (ret:Option'0.t_Option int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- Option'0.C_None ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : Option'0.t_Option int32 = any_l () | & res : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> {[@expl:postcondition] [%#soption0] result = Option'0.C_None}
      (! return' {result}) ]
    
end
module T_option__or_else__qyClosure2 [#"option.rs" 296 12 296 30]
  type m_option__or_else__qyClosure2  =
    | M_option__or_else__qyClosure2
  
  let rec m_option__or_else__qyClosure2 (input:m_option__or_else__qyClosure2) (ret  )= any
    [ good -> {M_option__or_else__qyClosure2  = input} (! ret) ]
    
end
module M_option__or_else__qyClosure2 [#"option.rs" 296 12 296 30]
  let%span soption0 = "option.rs" 296 23 296 28
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use T_option__or_else__qyClosure2 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__or_else__qyClosure2 (_1:Closure'0.m_option__or_else__qyClosure2) (return'  (ret:Option'0.t_Option int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:Option'0.t_Option int32)-> (! return' {result}) ] 
end
module M_option__or_else [#"option.rs" 278 0 278 16]
  let%span soption0 = "option.rs" 280 33 280 34
  let%span soption1 = "option.rs" 294 4 299 5
  let%span soption2 = "option.rs" 288 4 293 5
  let%span soption3 = "option.rs" 282 4 287 5
  let%span soption4 = "option.rs" 298 18 298 19
  let%span soption5 = "option.rs" 286 18 286 19
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 268 16 268 64
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 269 26 272 17
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption9 = "option.rs" 284 22 284 42
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption11 = "option.rs" 290 22 290 36
  let%span soption12 = "option.rs" 296 23 296 28
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__or_else__qyClosure2 as Closure'2
  
  predicate inv'4 (_1 : Closure'2.m_option__or_else__qyClosure2)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'2.m_option__or_else__qyClosure2 [inv'4 x] . inv'4 x = true
  
  use T_option__or_else__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__or_else__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__or_else__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_option__or_else__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__or_else__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__or_else__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'2 [#"option.rs" 296 12 296 30] (self : Closure'2.m_option__or_else__qyClosure2) (_ : ()) (result : Option'0.t_Option int32)
    
   =
    true
  
  predicate precondition'2 [#"option.rs" 296 12 296 30] (self : Closure'2.m_option__or_else__qyClosure2) (_ : ()) =
    [%#soption12] false
  
  let rec or_else'2 (self:Option'0.t_Option int32) (f:Closure'2.m_option__or_else__qyClosure2) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'4 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] self = Option'0.C_None  -> precondition'2 f ()}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> postcondition_once'2 f () result
        | Option'0.C_Some t -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 290 12 290 38] (self : Closure'1.m_option__or_else__qyClosure1) (_ : ()) (result : Option'0.t_Option int32)
    
   =
    [%#soption11] result = Option'0.C_None
  
  predicate precondition'1 [#"option.rs" 290 12 290 38] (self : Closure'1.m_option__or_else__qyClosure1) (_ : ()) =
    true
  
  let rec or_else'1 (self:Option'0.t_Option int32) (f:Closure'1.m_option__or_else__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'3 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] self = Option'0.C_None  -> precondition'1 f ()}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> postcondition_once'1 f () result
        | Option'0.C_Some t -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum14] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption13] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel10] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 284 12 284 44] (self : Closure'0.m_option__or_else__qyClosure0) (_ : ()) (result : Option'0.t_Option int32)
    
   =
    [%#soption9] result = Option'0.C_Some (2 : int32)
  
  predicate precondition'0 [#"option.rs" 284 12 284 44] (self : Closure'0.m_option__or_else__qyClosure0) (_ : ()) =
    true
  
  let rec or_else'0 (self:Option'0.t_Option int32) (f:Closure'0.m_option__or_else__qyClosure0) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption6] self = Option'0.C_None  -> precondition'0 f ()}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'0 result}
      {[%#soption7] match self with
        | Option'0.C_None -> postcondition_once'0 f () result
        | Option'0.C_Some t -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption4] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption5] (2 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec or_else (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &_8 <- Closure'0.M_option__or_else__qyClosure0 ] s3
      | s3 = or_else'0 {none} {_8} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- Closure'1.M_option__or_else__qyClosure1 ] s1
      | s1 = or_else'1 {none} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- Closure'2.M_option__or_else__qyClosure2 ] s1
      | s1 = or_else'2 {some} {_26} (fun (_ret':Option'0.t_Option int32) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _8 : Closure'0.m_option__or_else__qyClosure0 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _17 : Closure'1.m_option__or_else__qyClosure1 = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : Option'0.t_Option int32 = any_l ()
    | & _26 : Closure'2.m_option__or_else__qyClosure2 = any_l ()
    | & _30 : Option'0.t_Option int32 = any_l ()
    | & _31 : Option'0.t_Option int32 = any_l ()
    | & _32 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__insert [#"option.rs" 302 0 302 15]
  let%span soption0 = "option.rs" 304 37 304 38
  let%span soption1 = "option.rs" 306 25 306 26
  let%span soption2 = "option.rs" 307 19 307 20
  let%span soption3 = "option.rs" 308 10 308 11
  let%span soption4 = "option.rs" 310 25 310 26
  let%span soption5 = "option.rs" 311 19 311 20
  let%span soption6 = "option.rs" 312 10 312 11
  let%span soption7 = "option.rs" 313 4 313 28
  let%span soption8 = "option.rs" 311 4 311 21
  let%span soption9 = "option.rs" 309 4 309 28
  let%span soption10 = "option.rs" 307 4 307 21
  let%span soption11 = "option.rs" 313 25 313 26
  let%span soption12 = "option.rs" 309 25 309 26
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 292 26 295 17
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 296 26 296 68
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span sresolve16 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span smodel17 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption18 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : borrowed int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum19] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption18] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel17] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:bool)-> {[%#soption15] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed int32) =
    [%#sresolve16] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'2 _1
  
  predicate resolve'1 (_1 : int32) =
    true
  
  let rec insert'0 (self:borrowed (Option'0.t_Option int32)) (value:int32) (return'  (ret:borrowed int32))= {[@expl:precondition] inv'1 value}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:borrowed int32)-> {inv'2 result}
      {[%#soption14] result.current = value /\ self.final = Option'0.C_Some (result.final)}
      {[%#soption13] match self.current with
        | Option'0.C_Some t -> resolve'1 t
        | Option'0.C_None -> true
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption11] (5 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption12] (3 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec insert (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_4 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = insert'0 {_4} {[%#soption1] (2 : int32)} (fun (_ret':borrowed int32) ->  [ &i1 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = Int32.eq {i1.current} {[%#soption2] (2 : int32)} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s1)
      | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ]  ]
      
    | bb2 = s0
      [ s0 =  [ &i1 <- { i1 with current = ([%#soption3] (3 : int32)) ; } ] s1
      | s1 = -{resolve'0 i1}- s2
      | s2 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_28 <- pr1 ] s3)
      | s3 = eq'0 {none} {_28} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = insert'0 {_16} {[%#soption4] (4 : int32)} (fun (_ret':borrowed int32) ->  [ &i2 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = Int32.eq {i2.current} {[%#soption5] (4 : int32)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &i2 <- { i2 with current = ([%#soption6] (5 : int32)) ; } ] s1
      | s1 = -{resolve'0 i2}- s2
      | s2 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_27 <- pr0 ] s3)
      | s3 = eq'0 {some} {_27} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s4)
      | s4 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption7] false} any
    | bb9 = s0 [ s0 = -{resolve'0 i2}- s1 | s1 = {[%#soption8] false} any ] 
    | bb6 = {[%#soption9] false} any
    | bb3 = s0 [ s0 = -{resolve'0 i1}- s1 | s1 = {[%#soption10] false} any ]  ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & i1 : borrowed int32 = any_l ()
    | & _4 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _6 : bool = any_l ()
    | & _10 : bool = any_l ()
    | & i2 : borrowed int32 = any_l ()
    | & _16 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _18 : bool = any_l ()
    | & _22 : bool = any_l ()
    | & _27 : Option'0.t_Option int32 = any_l ()
    | & _28 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__get_or_insert__qyClosure0 [#"option.rs" 335 8 335 34]
  type m_option__get_or_insert__qyClosure0  =
    | M_option__get_or_insert__qyClosure0
  
  let rec m_option__get_or_insert__qyClosure0 (input:m_option__get_or_insert__qyClosure0) (ret  )= any
    [ good -> {M_option__get_or_insert__qyClosure0  = input} (! ret) ]
    
end
module M_option__get_or_insert__qyClosure0 [#"option.rs" 335 8 335 34]
  let%span soption0 = "option.rs" 336 11 336 12
  let%span soption1 = "option.rs" 335 18 335 32
  
  use T_option__get_or_insert__qyClosure0 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__get_or_insert__qyClosure0 (_1:Closure'0.m_option__get_or_insert__qyClosure0) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] (2 : int32) ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () | & res : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:postcondition] [%#soption1] result = (2 : int32)} (! return' {result}) ]
    
end
module T_option__get_or_insert__qyClosure1 [#"option.rs" 342 8 342 26]
  type m_option__get_or_insert__qyClosure1  =
    | M_option__get_or_insert__qyClosure1
  
  let rec m_option__get_or_insert__qyClosure1 (input:m_option__get_or_insert__qyClosure1) (ret  )= any
    [ good -> {M_option__get_or_insert__qyClosure1  = input} (! ret) ]
    
end
module M_option__get_or_insert__qyClosure1 [#"option.rs" 342 8 342 26]
  let%span soption0 = "option.rs" 342 19 342 24
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_option__get_or_insert__qyClosure1 as Closure'0
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__get_or_insert__qyClosure1 (_1:Closure'0.m_option__get_or_insert__qyClosure1) (return'  (ret:int32))= {[%#soption0] false}
    (! bb0 [ bb0 = {false} any ] ) [ return' (result:int32)-> (! return' {result}) ] 
end
module M_option__get_or_insert [#"option.rs" 316 0 316 22]
  let%span soption0 = "option.rs" 318 37 318 38
  let%span soption1 = "option.rs" 321 32 321 33
  let%span soption2 = "option.rs" 322 19 322 20
  let%span soption3 = "option.rs" 323 10 323 11
  let%span soption4 = "option.rs" 325 32 325 33
  let%span soption5 = "option.rs" 326 19 326 20
  let%span soption6 = "option.rs" 327 10 327 11
  let%span soption7 = "option.rs" 331 16 331 17
  let%span soption8 = "option.rs" 338 19 338 20
  let%span soption9 = "option.rs" 339 10 339 11
  let%span soption10 = "option.rs" 345 19 345 20
  let%span soption11 = "option.rs" 346 10 346 11
  let%span soption12 = "option.rs" 347 4 347 28
  let%span soption13 = "option.rs" 345 4 345 21
  let%span soption14 = "option.rs" 340 4 340 28
  let%span soption15 = "option.rs" 338 4 338 21
  let%span soption16 = "option.rs" 328 4 328 28
  let%span soption17 = "option.rs" 326 4 326 21
  let%span soption18 = "option.rs" 324 4 324 28
  let%span soption19 = "option.rs" 322 4 322 21
  let%span soption20 = "option.rs" 347 25 347 26
  let%span soption21 = "option.rs" 340 25 340 26
  let%span soption22 = "option.rs" 328 25 328 26
  let%span soption23 = "option.rs" 324 25 324 26
  let%span soption24 = "../../../creusot-contracts/src/std/option.rs" 300 26 303 17
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 306 16 306 65
  let%span soption27 = "../../../creusot-contracts/src/std/option.rs" 307 26 310 17
  let%span sresolve28 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span smodel29 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption30 = "option.rs" 335 18 335 32
  let%span soption31 = "option.rs" 342 19 342 24
  let%span soption32 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__get_or_insert__qyClosure1 as Closure'1
  
  predicate inv'5 (_1 : Closure'1.m_option__get_or_insert__qyClosure1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Closure'1.m_option__get_or_insert__qyClosure1 [inv'5 x] . inv'5 x = true
  
  use T_option__get_or_insert__qyClosure0 as Closure'0
  
  predicate inv'4 (_1 : Closure'0.m_option__get_or_insert__qyClosure0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'0.m_option__get_or_insert__qyClosure0 [inv'4 x] . inv'4 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : borrowed int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'1 [#"option.rs" 342 8 342 26] (self : Closure'1.m_option__get_or_insert__qyClosure1) (_ : ()) (result : int32)
    
   =
    true
  
  predicate precondition'1 [#"option.rs" 342 8 342 26] (self : Closure'1.m_option__get_or_insert__qyClosure1) (_ : ()) =
    [%#soption31] false
  
  let rec get_or_insert_with'1 (self:borrowed (Option'0.t_Option int32)) (f:Closure'1.m_option__get_or_insert__qyClosure1) (return'  (ret:borrowed int32))= {[@expl:precondition] inv'5 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption26] self.current = Option'0.C_None  -> precondition'1 f ()}
    any
    [ return' (result:borrowed int32)-> {inv'2 result}
      {[%#soption27] match self.current with
        | Option'0.C_None -> postcondition_once'1 f () result.current /\ self.final = Option'0.C_Some (result.final)
        | Option'0.C_Some _ -> self.current = Option'0.C_Some (result.current)
        /\ self.final = Option'0.C_Some (result.final)
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 335 8 335 34] (self : Closure'0.m_option__get_or_insert__qyClosure0) (_ : ()) (result : int32)
    
   =
    [%#soption30] result = (2 : int32)
  
  predicate precondition'0 [#"option.rs" 335 8 335 34] (self : Closure'0.m_option__get_or_insert__qyClosure0) (_ : ()) =
    true
  
  let rec get_or_insert_with'0 (self:borrowed (Option'0.t_Option int32)) (f:Closure'0.m_option__get_or_insert__qyClosure0) (return'  (ret:borrowed int32))= {[@expl:precondition] inv'4 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption26] self.current = Option'0.C_None  -> precondition'0 f ()}
    any
    [ return' (result:borrowed int32)-> {inv'2 result}
      {[%#soption27] match self.current with
        | Option'0.C_None -> postcondition_once'0 f () result.current /\ self.final = Option'0.C_Some (result.final)
        | Option'0.C_Some _ -> self.current = Option'0.C_Some (result.current)
        /\ self.final = Option'0.C_Some (result.final)
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum33] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption32] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel29] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:bool)-> {[%#soption25] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed int32) =
    [%#sresolve28] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'2 _1
  
  predicate resolve'1 (_1 : int32) =
    true
  
  let rec get_or_insert'0 (self:borrowed (Option'0.t_Option int32)) (value:int32) (return'  (ret:borrowed int32))= {[@expl:precondition] inv'1 value}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:borrowed int32)-> {inv'2 result}
      {[%#soption24] match self.current with
        | Option'0.C_None -> result.current = value /\ self.final = Option'0.C_Some (result.final)
        | Option'0.C_Some _ -> self.current = Option'0.C_Some (result.current)
        /\ self.final = Option'0.C_Some (result.final) /\ resolve'1 value
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption20] (5 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption21] (3 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption22] (5 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted3 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption23] (3 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec get_or_insert (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_4 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = get_or_insert'0 {_4} {[%#soption1] (2 : int32)} (fun (_ret':borrowed int32) ->  [ &i1 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0
      [ s0 = Int32.eq {i1.current} {[%#soption2] (2 : int32)} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s1)
      | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ]  ]
      
    | bb2 = s0
      [ s0 =  [ &i1 <- { i1 with current = ([%#soption3] (3 : int32)) ; } ] s1
      | s1 = -{resolve'0 i1}- s2
      | s2 = promoted3 (fun (pr3:Option'0.t_Option int32) ->  [ &_58 <- pr3 ] s3)
      | s3 = eq'0 {none} {_58} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = get_or_insert'0 {_16} {[%#soption4] (4 : int32)} (fun (_ret':borrowed int32) ->  [ &i2 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = Int32.eq {i2.current} {[%#soption5] (1 : int32)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &i2 <- { i2 with current = ([%#soption6] (5 : int32)) ; } ] s1
      | s1 = -{resolve'0 i2}- s2
      | s2 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_57 <- pr2 ] s3)
      | s3 = eq'0 {some} {_57} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s4)
      | s4 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_27 <- Option'0.C_None ] s1
      | s1 =  [ &none <- _27 ] s2
      | s2 =  [ &_28 <- Option'0.C_Some ([%#soption7] (1 : int32)) ] s3
      | s3 =  [ &some <- _28 ] s4
      | s4 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_30 <- _ret' ]  [ &none <- _ret'.final ] s5)
      | s5 =  [ &_31 <- Closure'0.M_option__get_or_insert__qyClosure0 ] s6
      | s6 = get_or_insert_with'0 {_30} {_31} (fun (_ret':borrowed int32) ->  [ &i11 <- _ret' ] s7)
      | s7 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int32.eq {i11.current} {[%#soption8] (2 : int32)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb15) | br1 -> {_33} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 =  [ &i11 <- { i11 with current = ([%#soption9] (3 : int32)) ; } ] s1
      | s1 = -{resolve'0 i11}- s2
      | s2 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_56 <- pr1 ] s3)
      | s3 = eq'0 {none} {_56} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s4)
      | s4 = bb16 ]
      
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ] 
    | bb17 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_43 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_44 <- Closure'1.M_option__get_or_insert__qyClosure1 ] s2
      | s2 = get_or_insert_with'1 {_43} {_44} (fun (_ret':borrowed int32) ->  [ &i21 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int32.eq {i21.current} {[%#soption10] (1 : int32)} (fun (_ret':bool) ->  [ &_46 <- _ret' ] s1)
      | s1 = any [ br0 -> {_46 = false} (! bb21) | br1 -> {_46} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &i21 <- { i21 with current = ([%#soption11] (5 : int32)) ; } ] s1
      | s1 = -{resolve'0 i21}- s2
      | s2 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_55 <- pr0 ] s3)
      | s3 = eq'0 {some} {_55} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s4)
      | s4 = bb22 ]
      
    | bb22 = any [ br0 -> {_50 = false} (! bb24) | br1 -> {_50} (! bb23) ] 
    | bb23 = return' {_0}
    | bb24 = {[%#soption12] false} any
    | bb21 = s0 [ s0 = -{resolve'0 i21}- s1 | s1 = {[%#soption13] false} any ] 
    | bb18 = {[%#soption14] false} any
    | bb15 = s0 [ s0 = -{resolve'0 i11}- s1 | s1 = {[%#soption15] false} any ] 
    | bb12 = {[%#soption16] false} any
    | bb9 = s0 [ s0 = -{resolve'0 i2}- s1 | s1 = {[%#soption17] false} any ] 
    | bb6 = {[%#soption18] false} any
    | bb3 = s0 [ s0 = -{resolve'0 i1}- s1 | s1 = {[%#soption19] false} any ]  ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & i1 : borrowed int32 = any_l ()
    | & _4 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _6 : bool = any_l ()
    | & _10 : bool = any_l ()
    | & i2 : borrowed int32 = any_l ()
    | & _16 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _18 : bool = any_l ()
    | & _22 : bool = any_l ()
    | & _27 : Option'0.t_Option int32 = any_l ()
    | & _28 : Option'0.t_Option int32 = any_l ()
    | & i11 : borrowed int32 = any_l ()
    | & _30 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _31 : Closure'0.m_option__get_or_insert__qyClosure0 = any_l ()
    | & _33 : bool = any_l ()
    | & _37 : bool = any_l ()
    | & i21 : borrowed int32 = any_l ()
    | & _43 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _44 : Closure'1.m_option__get_or_insert__qyClosure1 = any_l ()
    | & _46 : bool = any_l ()
    | & _50 : bool = any_l ()
    | & _55 : Option'0.t_Option int32 = any_l ()
    | & _56 : Option'0.t_Option int32 = any_l ()
    | & _57 : Option'0.t_Option int32 = any_l ()
    | & _58 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__take [#"option.rs" 350 0 350 13]
  let%span soption0 = "option.rs" 352 37 352 38
  let%span soption1 = "option.rs" 356 36 356 37
  let%span soption2 = "option.rs" 357 4 357 27
  let%span soption3 = "option.rs" 356 4 356 38
  let%span soption4 = "option.rs" 355 4 355 27
  let%span soption5 = "option.rs" 354 4 354 34
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate inv'3 (_1 : int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int32 [inv'3 x] . inv'3 x = true
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption6] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'3 result} {[%#soption6] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any [ return' (result:bool)-> {[%#soption7] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec take'0 (self:borrowed (Option'0.t_Option int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'1 result}
      {[%#soption6] result = self.current /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec take (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = take'0 {_7} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = is_none'0 {none} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ] 
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_17 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = take'0 {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0 [ s0 = unwrap'0 {_16} (fun (_ret':int32) ->  [ &_15 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = Int32.eq {_15} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = any [ br0 -> {_14 = false} (! bb11) | br1 -> {_14} (! bb10) ]  ]
      
    | bb10 = s0 [ s0 = is_none'0 {some} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = any [ br0 -> {_20 = false} (! bb14) | br1 -> {_20} (! bb13) ] 
    | bb13 = return' {_0}
    | bb14 = {[%#soption2] false} any
    | bb11 = {[%#soption3] false} any
    | bb7 = {[%#soption4] false} any
    | bb4 = {[%#soption5] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _7 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _10 : bool = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : int32 = any_l ()
    | & _16 : Option'0.t_Option int32 = any_l ()
    | & _17 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _20 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__take_if__qyClosure0 [#"option.rs" 366 12 366 30]
  type m_option__take_if__qyClosure0  =
    | M_option__take_if__qyClosure0
  
  let rec m_option__take_if__qyClosure0 (input:m_option__take_if__qyClosure0) (ret  )= any
    [ good -> {M_option__take_if__qyClosure0  = input} (! ret) ]
    
end
module M_option__take_if__qyClosure0 [#"option.rs" 366 12 366 30]
  let%span soption0 = "option.rs" 366 23 366 28
  let%span sresolve1 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use T_option__take_if__qyClosure0 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  predicate resolve'1 (self : borrowed int32) =
    [%#sresolve1] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__take_if__qyClosure0 (_1:Closure'0.m_option__take_if__qyClosure0) (_2:borrowed int32) (return'  (ret:bool))= {[%#soption0] false}
    (! bb0 [ bb0 = s0 [ s0 = -{resolve'0 _2}- s1 | s1 = {false} any ]  ] ) [ & _2 : borrowed int32 = _2 ] 
    [ return' (result:bool)-> (! return' {result}) ]
    
end
module T_option__take_if__qyClosure1 [#"option.rs" 373 12 373 32]
  type m_option__take_if__qyClosure1  =
    | M_option__take_if__qyClosure1
  
  let rec m_option__take_if__qyClosure1 (input:m_option__take_if__qyClosure1) (ret  )= any
    [ good -> {M_option__take_if__qyClosure1  = input} (! ret) ]
    
end
module M_option__take_if__qyClosure1 [#"option.rs" 373 12 373 32]
  let%span soption0 = "option.rs" 374 22 374 23
  let%span soption1 = "option.rs" 372 22 372 44
  let%span soption2 = "option.rs" 373 22 373 30
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use T_option__take_if__qyClosure1 as Closure'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int32
  
  predicate resolve'1 (self : borrowed int32) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__take_if__qyClosure1 (_1:Closure'0.m_option__take_if__qyClosure1) (x:borrowed int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 x}- s1
      | s1 = Int32.eq {x.current} {[%#soption0] (2 : int32)} (fun (_ret':bool) ->  [ &res1 <- _ret' ] s2)
      | s2 =  [ &res <- res1 ] s3
      | s3 =  [ &_0 <- res ] s4
      | s4 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & x : borrowed int32 = x | & res : bool = any_l () | & res1 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption2] x.current = x.final}
      {[@expl:postcondition] [%#soption1] result = (x.current = (2 : int32))}
      (! return' {result}) ]
    
end
module T_option__take_if__qyClosure2 [#"option.rs" 381 12 381 34]
  type m_option__take_if__qyClosure2  =
    | M_option__take_if__qyClosure2
  
  let rec m_option__take_if__qyClosure2 (input:m_option__take_if__qyClosure2) (ret  )= any
    [ good -> {M_option__take_if__qyClosure2  = input} (! ret) ]
    
end
module M_option__take_if__qyClosure2 [#"option.rs" 381 12 381 34]
  let%span soption0 = "option.rs" 383 32 383 33
  let%span soption1 = "option.rs" 384 21 384 22
  let%span soption2 = "option.rs" 380 22 380 44
  let%span soption3 = "option.rs" 381 22 381 32
  let%span sresolve4 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use T_option__take_if__qyClosure2 as Closure'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate resolve'1 (self : borrowed int32) =
    [%#sresolve4] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__take_if__qyClosure2 (_1:Closure'0.m_option__take_if__qyClosure2) (x:borrowed int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Int32.eq {x.current} {[%#soption0] (1 : int32)} (fun (_ret':bool) ->  [ &res2 <- _ret' ] s1)
      | s1 =  [ &x <- { x with current = ([%#soption1] (3 : int32)) ; } ] s2
      | s2 = -{resolve'0 x}- s3
      | s3 =  [ &res1 <- res2 ] s4
      | s4 =  [ &res <- res1 ] s5
      | s5 =  [ &_0 <- res ] s6
      | s6 = return' {_0} ]
       ]
    )
    [ & _0 : bool = any_l ()
    | & x : borrowed int32 = x
    | & res : bool = any_l ()
    | & res1 : bool = any_l ()
    | & res2 : bool = any_l () ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption3] x.final = (3 : int32)}
      {[@expl:postcondition] [%#soption2] result = (x.current = (1 : int32))}
      (! return' {result}) ]
    
end
module M_option__take_if [#"option.rs" 360 0 360 16]
  let%span soption0 = "option.rs" 362 37 362 38
  let%span soption1 = "option.rs" 389 4 389 25
  let%span soption2 = "option.rs" 378 4 388 5
  let%span soption3 = "option.rs" 377 4 377 28
  let%span soption4 = "option.rs" 370 4 376 5
  let%span soption5 = "option.rs" 364 4 369 5
  let%span soption6 = "option.rs" 387 18 387 19
  let%span soption7 = "option.rs" 377 25 377 26
  let%span soption8 = "../../../creusot-contracts/src/std/option.rs" 324 27 327 17
  let%span soption9 = "../../../creusot-contracts/src/std/option.rs" 328 26 337 17
  let%span soption10 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption11 = "option.rs" 366 23 366 28
  let%span smodel12 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  use T_option__take_if__qyClosure2 as Closure'2
  
  predicate inv'6 (_1 : Closure'2.m_option__take_if__qyClosure2)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Closure'2.m_option__take_if__qyClosure2 [inv'6 x] . inv'6 x = true
  
  use T_option__take_if__qyClosure1 as Closure'1
  
  predicate inv'5 (_1 : Closure'1.m_option__take_if__qyClosure1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Closure'1.m_option__take_if__qyClosure1 [inv'5 x] . inv'5 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option int32 [inv'4 x] . inv'4 x = true
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  use T_option__take_if__qyClosure0 as Closure'0
  
  predicate inv'2 (_1 : Closure'0.m_option__take_if__qyClosure0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Closure'0.m_option__take_if__qyClosure0 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : borrowed int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'2 [#"option.rs" 381 12 381 34] (self : Closure'2.m_option__take_if__qyClosure2) (args : borrowed int32) (result : bool)
    
   =
    let (x) = args in x.final = (3 : int32) /\ result = (x.current = (1 : int32))
  
  predicate precondition'2 [#"option.rs" 381 12 381 34] (self : Closure'2.m_option__take_if__qyClosure2) (args : borrowed int32)
    
   =
    let (x) = args in true
  
  let rec take_if'2 (self:borrowed (Option'0.t_Option int32)) (predicate':Closure'2.m_option__take_if__qyClosure2) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'6 predicate'}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption8] match self.current with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> forall b : borrowed int32 . inv'0 b /\ b.current = t  -> precondition'2 predicate' (b)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'3 result}
      {[%#soption9] match self.current with
        | Option'0.C_None -> result = Option'0.C_None /\ self.final = Option'0.C_None
        | Option'0.C_Some cur -> exists b : borrowed int32, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'2 predicate' (b) res
        /\ (if res then
          self.final = Option'0.C_None /\ result = Option'0.C_Some (b.final)
        else
          self.final = Option'0.C_Some (b.final) /\ result = Option'0.C_None
        )
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 373 12 373 32] (self : Closure'1.m_option__take_if__qyClosure1) (args : borrowed int32) (result : bool)
    
   =
    let (x) = args in x.current = x.final /\ result = (x.current = (2 : int32))
  
  predicate precondition'1 [#"option.rs" 373 12 373 32] (self : Closure'1.m_option__take_if__qyClosure1) (args : borrowed int32)
    
   =
    let (x) = args in true
  
  let rec take_if'1 (self:borrowed (Option'0.t_Option int32)) (predicate':Closure'1.m_option__take_if__qyClosure1) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'5 predicate'}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption8] match self.current with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> forall b : borrowed int32 . inv'0 b /\ b.current = t  -> precondition'1 predicate' (b)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'3 result}
      {[%#soption9] match self.current with
        | Option'0.C_None -> result = Option'0.C_None /\ self.final = Option'0.C_None
        | Option'0.C_Some cur -> exists b : borrowed int32, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'1 predicate' (b) res
        /\ (if res then
          self.final = Option'0.C_None /\ result = Option'0.C_Some (b.final)
        else
          self.final = Option'0.C_Some (b.final) /\ result = Option'0.C_None
        )
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum14] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption13] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel12] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'4 other}
    {[@expl:precondition] inv'4 self}
    any
    [ return' (result:bool)-> {[%#soption10] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 366 12 366 30] (self : Closure'0.m_option__take_if__qyClosure0) (args : borrowed int32) (result : bool)
    
   =
    let (_2) = args in true
  
  predicate precondition'0 [#"option.rs" 366 12 366 30] (self : Closure'0.m_option__take_if__qyClosure0) (args : borrowed int32)
    
   =
    [%#soption11] let (_2) = args in false
  
  let rec take_if'0 (self:borrowed (Option'0.t_Option int32)) (predicate':Closure'0.m_option__take_if__qyClosure0) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'2 predicate'}
    {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption8] match self.current with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> forall b : borrowed int32 . inv'0 b /\ b.current = t  -> precondition'0 predicate' (b)
      end}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'3 result}
      {[%#soption9] match self.current with
        | Option'0.C_None -> result = Option'0.C_None /\ self.final = Option'0.C_None
        | Option'0.C_Some cur -> exists b : borrowed int32, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' (b) res
        /\ (if res then
          self.final = Option'0.C_None /\ result = Option'0.C_Some (b.final)
        else
          self.final = Option'0.C_Some (b.final) /\ result = Option'0.C_None
        )
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption6] (3 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption7] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted3 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted4 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec take_if (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 =  [ &_8 <- Closure'0.M_option__take_if__qyClosure0 ] s4
      | s4 = take_if'0 {_7} {_8} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s5)
      | s5 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted4 (fun (pr4:Option'0.t_Option int32) ->  [ &_46 <- pr4 ] s1)
      | s1 = eq'0 {_6} {_46} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_17 <- Closure'1.M_option__take_if__qyClosure1 ] s2
      | s2 = take_if'1 {_16} {_17} (fun (_ret':Option'0.t_Option int32) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted3 (fun (pr3:Option'0.t_Option int32) ->  [ &_45 <- pr3 ] s1)
      | s1 = eq'0 {_15} {_45} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option int32) ->  [ &_44 <- pr2 ] s1)
      | s1 = eq'0 {some} {_44} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = any [ br0 -> {_22 = false} (! bb11) | br1 -> {_22} (! bb10) ] 
    | bb10 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_31 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_32 <- Closure'2.M_option__take_if__qyClosure2 ] s2
      | s2 = take_if'2 {_31} {_32} (fun (_ret':Option'0.t_Option int32) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_43 <- pr1 ] s1)
      | s1 = eq'0 {_30} {_43} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb13 ]
      
    | bb13 = any [ br0 -> {_28 = false} (! bb15) | br1 -> {_28} (! bb14) ] 
    | bb14 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_42 <- pr0 ] s1)
      | s1 = eq'0 {some} {_42} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ] 
    | bb17 = return' {_0}
    | bb18 = {[%#soption1] false} any
    | bb15 = {[%#soption2] false} any
    | bb11 = {[%#soption3] false} any
    | bb8 = {[%#soption4] false} any
    | bb4 = {[%#soption5] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _7 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _8 : Closure'0.m_option__take_if__qyClosure0 = any_l ()
    | & _13 : bool = any_l ()
    | & _15 : Option'0.t_Option int32 = any_l ()
    | & _16 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _17 : Closure'1.m_option__take_if__qyClosure1 = any_l ()
    | & _22 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _30 : Option'0.t_Option int32 = any_l ()
    | & _31 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _32 : Closure'2.m_option__take_if__qyClosure2 = any_l ()
    | & _37 : bool = any_l ()
    | & _42 : Option'0.t_Option int32 = any_l ()
    | & _43 : Option'0.t_Option int32 = any_l ()
    | & _44 : Option'0.t_Option int32 = any_l ()
    | & _45 : Option'0.t_Option int32 = any_l ()
    | & _46 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__copied_cloned [#"option.rs" 392 0 392 22]
  let%span soption0 = "option.rs" 394 37 394 38
  let%span soption1 = "option.rs" 398 47 398 48
  let%span soption2 = "option.rs" 400 47 400 48
  let%span soption3 = "option.rs" 403 47 403 48
  let%span soption4 = "option.rs" 405 47 405 48
  let%span soption5 = "option.rs" 405 4 405 49
  let%span soption6 = "option.rs" 404 4 404 45
  let%span soption7 = "option.rs" 403 4 403 49
  let%span soption8 = "option.rs" 402 4 402 45
  let%span soption9 = "option.rs" 400 4 400 49
  let%span soption10 = "option.rs" 399 4 399 45
  let%span soption11 = "option.rs" 398 4 398 49
  let%span soption12 = "option.rs" 397 4 397 45
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 55 16 55 60
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 56 16 58 18
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 371 16 371 59
  let%span soption16 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption18 = "../../../creusot-contracts/src/std/option.rs" 62 16 62 77
  let%span soption19 = "../../../creusot-contracts/src/std/option.rs" 63 16 66 18
  let%span soption20 = "../../../creusot-contracts/src/std/option.rs" 386 16 386 59
  let%span soption21 = "../../../creusot-contracts/src/std/option.rs" 377 16 377 59
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 395 16 395 59
  let%span sresolve23 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'5 x] . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option int32))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Option'0.t_Option int32) [inv'4 x] . inv'4 x = true
  
  predicate inv'3 (_1 : int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed int32) =
    [%#sresolve23] self.final = self.current
  
  let rec cloned'1 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'5 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption16] self = Option'0.C_None
      \/ (exists t : borrowed int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some (t.current) /\ resolve'0 t)}
      {[%#soption22] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec cloned'0 (self:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption16] self = Option'0.C_None
      \/ (exists t : int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some t)}
      {[%#soption21] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec copied'1 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'5 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption16] self = Option'0.C_None
      \/ (exists t : borrowed int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some (t.current) /\ resolve'0 t)}
      {[%#soption20] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option int32)) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {inv'5 result}
      {[%#soption19] self.current = Option'0.C_None
      \/ (exists r : borrowed int32 . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption18] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'2 self}
    {[@expl:precondition] [%#soption16] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'3 result} {[%#soption16] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec copied'0 (self:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption16] self = Option'0.C_None
      \/ (exists t : int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some t)}
      {[%#soption15] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'1 result}
      {[%#soption14] self = Option'0.C_None
      \/ (exists r : int32 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption13] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec copied_cloned (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &some <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s2
      | s2 = as_ref'0 {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 = copied'0 {_7} (fun (_ret':Option'0.t_Option int32) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_4 = false} (! bb5) | br1 -> {_4} (! bb4) ] 
    | bb4 = s0 [ s0 = as_ref'0 {some} (fun (_ret':Option'0.t_Option int32) ->  [ &_14 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = copied'0 {_14} (fun (_ret':Option'0.t_Option int32) ->  [ &_13 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = unwrap'0 {_13} (fun (_ret':int32) ->  [ &_12 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = Int32.eq {_12} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s1)
      | s1 = any [ br0 -> {_11 = false} (! bb10) | br1 -> {_11} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_22 <- _ret' ]  [ &none <- _ret'.final ] s1)
      | s1 = as_mut'0 {_22} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0 [ s0 = copied'1 {_21} (fun (_ret':Option'0.t_Option int32) ->  [ &_20 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = is_none'0 {_20} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_18 = false} (! bb15) | br1 -> {_18} (! bb14) ] 
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_29 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_29} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = s0 [ s0 = copied'1 {_28} (fun (_ret':Option'0.t_Option int32) ->  [ &_27 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':int32) ->  [ &_26 <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 = Int32.eq {_26} {[%#soption2] (1 : int32)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb20) | br1 -> {_25} (! bb19) ]  ]
      
    | bb19 = s0 [ s0 = as_ref'0 {none} (fun (_ret':Option'0.t_Option int32) ->  [ &_35 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = s0 [ s0 = cloned'0 {_35} (fun (_ret':Option'0.t_Option int32) ->  [ &_34 <- _ret' ] s1) | s1 = bb22 ] 
    | bb22 = s0 [ s0 = is_none'0 {_34} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1) | s1 = bb23 ] 
    | bb23 = any [ br0 -> {_32 = false} (! bb25) | br1 -> {_32} (! bb24) ] 
    | bb24 = s0 [ s0 = as_ref'0 {some} (fun (_ret':Option'0.t_Option int32) ->  [ &_42 <- _ret' ] s1) | s1 = bb26 ] 
    | bb26 = s0 [ s0 = cloned'0 {_42} (fun (_ret':Option'0.t_Option int32) ->  [ &_41 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0 [ s0 = unwrap'0 {_41} (fun (_ret':int32) ->  [ &_40 <- _ret' ] s1) | s1 = bb28 ] 
    | bb28 = s0
      [ s0 = Int32.eq {_40} {[%#soption3] (1 : int32)} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s1)
      | s1 = any [ br0 -> {_39 = false} (! bb30) | br1 -> {_39} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {none}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_50 <- _ret' ]  [ &none <- _ret'.final ] s1)
      | s1 = as_mut'0 {_50} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_49 <- _ret' ] s2)
      | s2 = bb31 ]
      
    | bb31 = s0 [ s0 = cloned'1 {_49} (fun (_ret':Option'0.t_Option int32) ->  [ &_48 <- _ret' ] s1) | s1 = bb32 ] 
    | bb32 = s0 [ s0 = is_none'0 {_48} (fun (_ret':bool) ->  [ &_46 <- _ret' ] s1) | s1 = bb33 ] 
    | bb33 = any [ br0 -> {_46 = false} (! bb35) | br1 -> {_46} (! bb34) ] 
    | bb34 = s0
      [ s0 = Borrow.borrow_mut <Option'0.t_Option int32> {some}
          (fun (_ret':borrowed (Option'0.t_Option int32)) ->  [ &_57 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_57} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_56 <- _ret' ] s2)
      | s2 = bb36 ]
      
    | bb36 = s0 [ s0 = cloned'1 {_56} (fun (_ret':Option'0.t_Option int32) ->  [ &_55 <- _ret' ] s1) | s1 = bb37 ] 
    | bb37 = s0 [ s0 = unwrap'0 {_55} (fun (_ret':int32) ->  [ &_54 <- _ret' ] s1) | s1 = bb38 ] 
    | bb38 = s0
      [ s0 = Int32.eq {_54} {[%#soption4] (1 : int32)} (fun (_ret':bool) ->  [ &_53 <- _ret' ] s1)
      | s1 = any [ br0 -> {_53 = false} (! bb40) | br1 -> {_53} (! bb39) ]  ]
      
    | bb39 = return' {_0}
    | bb40 = {[%#soption5] false} any
    | bb35 = {[%#soption6] false} any
    | bb30 = {[%#soption7] false} any
    | bb25 = {[%#soption8] false} any
    | bb20 = {[%#soption9] false} any
    | bb15 = {[%#soption10] false} any
    | bb10 = {[%#soption11] false} any
    | bb5 = {[%#soption12] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option int32 = any_l ()
    | & some : Option'0.t_Option int32 = any_l ()
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int32 = any_l ()
    | & _7 : Option'0.t_Option int32 = any_l ()
    | & _11 : bool = any_l ()
    | & _12 : int32 = any_l ()
    | & _13 : Option'0.t_Option int32 = any_l ()
    | & _14 : Option'0.t_Option int32 = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : Option'0.t_Option int32 = any_l ()
    | & _21 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _22 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : int32 = any_l ()
    | & _27 : Option'0.t_Option int32 = any_l ()
    | & _28 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _29 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _32 : bool = any_l ()
    | & _34 : Option'0.t_Option int32 = any_l ()
    | & _35 : Option'0.t_Option int32 = any_l ()
    | & _39 : bool = any_l ()
    | & _40 : int32 = any_l ()
    | & _41 : Option'0.t_Option int32 = any_l ()
    | & _42 : Option'0.t_Option int32 = any_l ()
    | & _46 : bool = any_l ()
    | & _48 : Option'0.t_Option int32 = any_l ()
    | & _49 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _50 : borrowed (Option'0.t_Option int32) = any_l ()
    | & _53 : bool = any_l ()
    | & _54 : int32 = any_l ()
    | & _55 : Option'0.t_Option int32 = any_l ()
    | & _56 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _57 : borrowed (Option'0.t_Option int32) = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__zip_unzip [#"option.rs" 408 0 408 18]
  let%span soption0 = "option.rs" 411 37 411 38
  let%span soption1 = "option.rs" 412 39 412 43
  let%span soption2 = "option.rs" 420 49 420 50
  let%span soption3 = "option.rs" 420 52 420 56
  let%span soption4 = "option.rs" 427 4 427 39
  let%span soption5 = "option.rs" 426 4 426 36
  let%span soption6 = "option.rs" 425 4 425 33
  let%span soption7 = "option.rs" 424 4 424 33
  let%span soption8 = "option.rs" 417 4 417 55
  let%span soption9 = "option.rs" 416 4 416 44
  let%span soption10 = "option.rs" 415 4 415 44
  let%span soption11 = "option.rs" 414 4 414 44
  let%span soption12 = "option.rs" 427 33 427 37
  let%span soption13 = "option.rs" 426 33 426 34
  let%span soption14 = "option.rs" 417 45 417 46
  let%span soption15 = "option.rs" 417 48 417 52
  let%span soption16 = "../../../creusot-contracts/src/std/option.rs" 352 26 356 17
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption18 = "../../../creusot-contracts/src/std/option.rs" 362 26 365 17
  let%span sresolve19 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span smodel20 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption21 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span stuples22 = "../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span smodel24 = "../../../creusot-contracts/src/model.rs" 119 8 119 12
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'6 (_1 : Option'0.t_Option bool)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Option'0.t_Option bool [inv'6 x] . inv'6 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Option'0.t_Option int32 [inv'5 x] . inv'5 x = true
  
  predicate inv'4 (_1 : (Option'0.t_Option int32, Option'0.t_Option bool))
  
  axiom inv_axiom'4 [@rewrite] : forall x : (Option'0.t_Option int32, Option'0.t_Option bool) [inv'4 x] . inv'4 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (int32, bool))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option (int32, bool) [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option (int32, bool))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (int32, bool) [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : Option'0.t_Option bool)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option bool [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int32 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  function deep_model'8 (self : bool) : bool =
    [%#smodel24] self
  
  function deep_model'5 (self : Option'0.t_Option bool) : Option'0.t_Option bool =
    [%#soption21] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'8 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'2 (self : Option'0.t_Option bool) : Option'0.t_Option bool =
    [%#smodel20] deep_model'5 self
  
  let rec eq'2 (self:Option'0.t_Option bool) (other:Option'0.t_Option bool) (return'  (ret:bool))= {[@expl:precondition] inv'6 other}
    {[@expl:precondition] inv'6 self}
    any
    [ return' (result:bool)-> {[%#soption17] result = (deep_model'2 self = deep_model'2 other)} (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function deep_model'7 (self : int32) : int =
    [%#snum23] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'4 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption21] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'7 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel20] deep_model'4 self
  
  let rec eq'1 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'5 other}
    {[@expl:precondition] inv'5 self}
    any
    [ return' (result:bool)-> {[%#soption17] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  let rec unzip'0 (self:Option'0.t_Option (int32, bool)) (return'  (ret:(Option'0.t_Option int32, Option'0.t_Option bool)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:(Option'0.t_Option int32, Option'0.t_Option bool))-> {inv'4 result}
      {[%#soption18] match self with
        | Option'0.C_None -> result = (Option'0.C_None, Option'0.C_None)
        | Option'0.C_Some (t, u) -> result = (Option'0.C_Some t, Option'0.C_Some u)
        end}
      (! return' {result}) ]
    
  
  function deep_model'6 (self : (int32, bool)) : (int, bool) =
    [%#stuples22] (deep_model'7 (let (a, _) = self in a), deep_model'8 (let (_, a) = self in a))
  
  use T_core__option__Option as Option'0
  
  function deep_model'3 (self : Option'0.t_Option (int32, bool)) : Option'0.t_Option (int, bool) =
    [%#soption21] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'6 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option (int32, bool)) : Option'0.t_Option (int, bool) =
    [%#smodel20] deep_model'3 self
  
  let rec eq'0 (self:Option'0.t_Option (int32, bool)) (other:Option'0.t_Option (int32, bool)) (return'  (ret:bool))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:bool)-> {[%#soption17] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  predicate resolve'3 (_1 : int32) =
    true
  
  predicate resolve'1 (self : Option'0.t_Option int32) =
    [%#sresolve19] match self with
      | Option'0.C_Some x -> resolve'3 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 (_1 : bool) =
    true
  
  predicate resolve'0 (self : Option'0.t_Option bool) =
    [%#sresolve19] match self with
      | Option'0.C_Some x -> resolve'2 x
      | Option'0.C_None -> true
      end
  
  let rec zip'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option bool) (return'  (ret:Option'0.t_Option (int32, bool)))= {[@expl:precondition] inv'1 other}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option (int32, bool))-> {inv'2 result}
      {[%#soption16] match (self, other) with
        | (Option'0.C_None, _) -> result = Option'0.C_None /\ resolve'0 other
        | (_, Option'0.C_None) -> result = Option'0.C_None /\ resolve'1 self
        | (Option'0.C_Some t, Option'0.C_Some u) -> result = Option'0.C_Some (t, u)
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option bool))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption12] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option bool = any_l () | & _1 : Option'0.t_Option bool = any_l () ] 
    [ return' (result:Option'0.t_Option bool)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption13] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted2 (return'  (ret:Option'0.t_Option bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option bool = any_l () | & _1 : Option'0.t_Option bool = any_l () ] 
    [ return' (result:Option'0.t_Option bool)-> return' {result} ]
    
  
  let rec promoted3 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted4 (return'  (ret:Option'0.t_Option (int32, bool)))= bb0
    [ bb0 = s0
      [ s0 =  [ &_2 <- (([%#soption14] (1 : int32)), ([%#soption15] true)) ] s1
      | s1 =  [ &_1 <- Option'0.C_Some _2 ] s2
      | s2 =  [ &_0 <- _1 ] s3
      | s3 = return' {_0} ]
       ]
    
    [ & _0 : Option'0.t_Option (int32, bool) = any_l ()
    | & _1 : Option'0.t_Option (int32, bool) = any_l ()
    | & _2 : (int32, bool) = any_l () ]
     [ return' (result:Option'0.t_Option (int32, bool))-> return' {result} ] 
  
  let rec promoted5 (return'  (ret:Option'0.t_Option (int32, bool)))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option (int32, bool) = any_l () | & _1 : Option'0.t_Option (int32, bool) = any_l () ] 
    [ return' (result:Option'0.t_Option (int32, bool))-> return' {result} ]
    
  
  let rec promoted6 (return'  (ret:Option'0.t_Option (int32, bool)))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option (int32, bool) = any_l () | & _1 : Option'0.t_Option (int32, bool) = any_l () ] 
    [ return' (result:Option'0.t_Option (int32, bool))-> return' {result} ]
    
  
  let rec promoted7 (return'  (ret:Option'0.t_Option (int32, bool)))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option (int32, bool) = any_l () | & _1 : Option'0.t_Option (int32, bool) = any_l () ] 
    [ return' (result:Option'0.t_Option (int32, bool))-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec zip_unzip (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none_int <- Option'0.C_None ] s1
      | s1 =  [ &none_bool <- Option'0.C_None ] s2
      | s2 =  [ &some_int <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s3
      | s3 =  [ &some_bool <- Option'0.C_Some ([%#soption1] true) ] s4
      | s4 = zip'0 {none_int} {none_bool} (fun (_ret':Option'0.t_Option (int32, bool)) ->  [ &_8 <- _ret' ] s5)
      | s5 = bb1 ]
      
    | bb1 = s0
      [ s0 = promoted7 (fun (pr7:Option'0.t_Option (int32, bool)) ->  [ &_80 <- pr7 ] s1)
      | s1 = eq'0 {_8} {_80} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = any [ br0 -> {_6 = false} (! bb4) | br1 -> {_6} (! bb3) ] 
    | bb3 = s0
      [ s0 = zip'0 {none_int} {some_bool} (fun (_ret':Option'0.t_Option (int32, bool)) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = promoted6 (fun (pr6:Option'0.t_Option (int32, bool)) ->  [ &_79 <- pr6 ] s1)
      | s1 = eq'0 {_17} {_79} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ] 
    | bb7 = s0
      [ s0 = zip'0 {some_int} {none_bool} (fun (_ret':Option'0.t_Option (int32, bool)) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = promoted5 (fun (pr5:Option'0.t_Option (int32, bool)) ->  [ &_78 <- pr5 ] s1)
      | s1 = eq'0 {_26} {_78} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ] 
    | bb11 = s0
      [ s0 = zip'0 {some_int} {some_bool} (fun (_ret':Option'0.t_Option (int32, bool)) ->  [ &_35 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = promoted4 (fun (pr4:Option'0.t_Option (int32, bool)) ->  [ &_77 <- pr4 ] s1)
      | s1 = eq'0 {_35} {_77} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = any [ br0 -> {_33 = false} (! bb16) | br1 -> {_33} (! bb15) ] 
    | bb15 = s0
      [ s0 =  [ &none_zipped <- Option'0.C_None ] s1
      | s1 =  [ &_44 <- (([%#soption2] (1 : int32)), ([%#soption3] true)) ] s2
      | s2 =  [ &some_zipped <- Option'0.C_Some _44 ] s3
      | s3 = unzip'0 {none_zipped}
          (fun (_ret':(Option'0.t_Option int32, Option'0.t_Option bool)) ->  [ &none_unzip <- _ret' ] s4)
      | s4 = bb17 ]
      
    | bb17 = s0
      [ s0 = unzip'0 {some_zipped}
          (fun (_ret':(Option'0.t_Option int32, Option'0.t_Option bool)) ->  [ &some_unzip <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = promoted3 (fun (pr3:Option'0.t_Option int32) ->  [ &_76 <- pr3 ] s1)
      | s1 = eq'1 {let (r'0, _) = none_unzip in r'0} {_76} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = any [ br0 -> {_50 = false} (! bb21) | br1 -> {_50} (! bb20) ] 
    | bb20 = s0
      [ s0 = promoted2 (fun (pr2:Option'0.t_Option bool) ->  [ &_75 <- pr2 ] s1)
      | s1 = eq'2 {let (_, r'0) = none_unzip in r'0} {_75} (fun (_ret':bool) ->  [ &_56 <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = any [ br0 -> {_56 = false} (! bb24) | br1 -> {_56} (! bb23) ] 
    | bb23 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_74 <- pr1 ] s1)
      | s1 = eq'1 {let (r'0, _) = some_unzip in r'0} {_74} (fun (_ret':bool) ->  [ &_62 <- _ret' ] s2)
      | s2 = bb25 ]
      
    | bb25 = any [ br0 -> {_62 = false} (! bb27) | br1 -> {_62} (! bb26) ] 
    | bb26 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option bool) ->  [ &_73 <- pr0 ] s1)
      | s1 = eq'2 {let (_, r'0) = some_unzip in r'0} {_73} (fun (_ret':bool) ->  [ &_68 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = any [ br0 -> {_68 = false} (! bb30) | br1 -> {_68} (! bb29) ] 
    | bb29 = return' {_0}
    | bb30 = {[%#soption4] false} any
    | bb27 = {[%#soption5] false} any
    | bb24 = {[%#soption6] false} any
    | bb21 = {[%#soption7] false} any
    | bb16 = {[%#soption8] false} any
    | bb12 = {[%#soption9] false} any
    | bb8 = {[%#soption10] false} any
    | bb4 = {[%#soption11] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none_int : Option'0.t_Option int32 = any_l ()
    | & none_bool : Option'0.t_Option bool = any_l ()
    | & some_int : Option'0.t_Option int32 = any_l ()
    | & some_bool : Option'0.t_Option bool = any_l ()
    | & _6 : bool = any_l ()
    | & _8 : Option'0.t_Option (int32, bool) = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : Option'0.t_Option (int32, bool) = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : Option'0.t_Option (int32, bool) = any_l ()
    | & _33 : bool = any_l ()
    | & _35 : Option'0.t_Option (int32, bool) = any_l ()
    | & none_zipped : Option'0.t_Option (int32, bool) = any_l ()
    | & some_zipped : Option'0.t_Option (int32, bool) = any_l ()
    | & _44 : (int32, bool) = any_l ()
    | & none_unzip : (Option'0.t_Option int32, Option'0.t_Option bool) = any_l ()
    | & some_unzip : (Option'0.t_Option int32, Option'0.t_Option bool) = any_l ()
    | & _50 : bool = any_l ()
    | & _56 : bool = any_l ()
    | & _62 : bool = any_l ()
    | & _68 : bool = any_l ()
    | & _73 : Option'0.t_Option bool = any_l ()
    | & _74 : Option'0.t_Option int32 = any_l ()
    | & _75 : Option'0.t_Option bool = any_l ()
    | & _76 : Option'0.t_Option int32 = any_l ()
    | & _77 : Option'0.t_Option (int32, bool) = any_l ()
    | & _78 : Option'0.t_Option (int32, bool) = any_l ()
    | & _79 : Option'0.t_Option (int32, bool) = any_l ()
    | & _80 : Option'0.t_Option (int32, bool) = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__transpose [#"option.rs" 430 0 430 18]
  let%span soption0 = "option.rs" 432 53 432 54
  let%span soption1 = "option.rs" 433 55 433 59
  let%span soption2 = "option.rs" 437 49 437 53
  let%span soption3 = "option.rs" 437 4 437 54
  let%span soption4 = "option.rs" 436 4 436 52
  let%span soption5 = "option.rs" 435 4 435 46
  let%span soption6 = "option.rs" 436 49 436 50
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 407 26 411 17
  let%span sresult8 = "../../../creusot-contracts/src/std/result.rs" 53 16 53 55
  let%span sresult9 = "../../../creusot-contracts/src/std/result.rs" 18 0 135 1
  let%span soption10 = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span sresult11 = "../../../creusot-contracts/src/std/result.rs" 67 16 67 56
  let%span smodel12 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  predicate inv'4 (_1 : bool)
  
  axiom inv_axiom'4 [@rewrite] : forall x : bool [inv'4 x] . inv'4 x = true
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_core__result__Result as Result'0
  
  predicate inv'1 (_1 : Result'0.t_Result (Option'0.t_Option int32) bool)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Result'0.t_Result (Option'0.t_Option int32) bool [inv'1 x] . inv'1 x = true
  
  use T_core__result__Result as Result'0
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Result'0.t_Result int32 bool))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Result'0.t_Result int32 bool) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec unwrap_err'0 (self:Result'0.t_Result (Option'0.t_Option int32) bool) (return'  (ret:bool))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#sresult11] exists e : bool . self = Result'0.C_Err e}
    any [ return' (result:bool)-> {inv'4 result} {[%#sresult9] Result'0.C_Err result = self} (! return' {result}) ] 
  
  use prelude.prelude.Int32
  
  function deep_model'2 (self : int32) : int =
    [%#snum14] Int32.to_int self
  
  use T_core__option__Option as Option'0
  
  function deep_model'1 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#soption13] match self with
      | Option'0.C_Some t -> Option'0.C_Some (deep_model'2 t)
      | Option'0.C_None -> Option'0.C_None
      end
  
  function deep_model'0 (self : Option'0.t_Option int32) : Option'0.t_Option int =
    [%#smodel12] deep_model'1 self
  
  let rec eq'0 (self:Option'0.t_Option int32) (other:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:bool)-> {[%#soption10] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Result'0.t_Result (Option'0.t_Option int32) bool) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#sresult8] exists t : Option'0.t_Option int32 . self = Result'0.C_Ok t}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#sresult9] Result'0.C_Ok result = self}
      (! return' {result}) ]
    
  
  let rec transpose'0 (self:Option'0.t_Option (Result'0.t_Result int32 bool)) (return'  (ret:Result'0.t_Result (Option'0.t_Option int32) bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Result'0.t_Result (Option'0.t_Option int32) bool)-> {inv'1 result}
      {[%#soption7] match self with
        | Option'0.C_None -> result = Result'0.C_Ok (Option'0.C_None)
        | Option'0.C_Some (Result'0.C_Ok ok) -> result = Result'0.C_Ok (Option'0.C_Some ok)
        | Option'0.C_Some (Result'0.C_Err err) -> result = Result'0.C_Err err
        end}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Option'0.C_Some ([%#soption6] (1 : int32)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  let rec promoted1 (return'  (ret:Option'0.t_Option int32))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Option'0.C_None ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Option'0.t_Option int32 = any_l () | & _1 : Option'0.t_Option int32 = any_l () ] 
    [ return' (result:Option'0.t_Option int32)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec transpose (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- Option'0.C_None ] s1
      | s1 =  [ &_3 <- Result'0.C_Ok ([%#soption0] (1 : int32)) ] s2
      | s2 =  [ &some_ok <- Option'0.C_Some _3 ] s3
      | s3 =  [ &_5 <- Result'0.C_Err ([%#soption1] true) ] s4
      | s4 =  [ &some_err <- Option'0.C_Some _5 ] s5
      | s5 = transpose'0 {none} (fun (_ret':Result'0.t_Result (Option'0.t_Option int32) bool) ->  [ &_10 <- _ret' ] s6)
      | s6 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':Option'0.t_Option int32) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = promoted1 (fun (pr1:Option'0.t_Option int32) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_9} {_31} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = any [ br0 -> {_7 = false} (! bb5) | br1 -> {_7} (! bb4) ] 
    | bb4 = s0
      [ s0 = transpose'0 {some_ok}
          (fun (_ret':Result'0.t_Result (Option'0.t_Option int32) bool) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb6 ]
      
    | bb6 = s0 [ s0 = unwrap'0 {_19} (fun (_ret':Option'0.t_Option int32) ->  [ &_18 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = promoted0 (fun (pr0:Option'0.t_Option int32) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_18} {_30} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ] 
    | bb9 = s0
      [ s0 = transpose'0 {some_err}
          (fun (_ret':Result'0.t_Result (Option'0.t_Option int32) bool) ->  [ &_27 <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0 [ s0 = unwrap_err'0 {_27} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_25 <- Bool.eq _26 ([%#soption2] true) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb14) | br1 -> {_25} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = {[%#soption3] false} any
    | bb10 = {[%#soption4] false} any
    | bb5 = {[%#soption5] false} any ]
    )
    [ & _0 : () = any_l ()
    | & none : Option'0.t_Option (Result'0.t_Result int32 bool) = any_l ()
    | & some_ok : Option'0.t_Option (Result'0.t_Result int32 bool) = any_l ()
    | & _3 : Result'0.t_Result int32 bool = any_l ()
    | & some_err : Option'0.t_Option (Result'0.t_Result int32 bool) = any_l ()
    | & _5 : Result'0.t_Result int32 bool = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : Option'0.t_Option int32 = any_l ()
    | & _10 : Result'0.t_Result (Option'0.t_Option int32) bool = any_l ()
    | & _16 : bool = any_l ()
    | & _18 : Option'0.t_Option int32 = any_l ()
    | & _19 : Result'0.t_Result (Option'0.t_Option int32) bool = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : Result'0.t_Result (Option'0.t_Option int32) bool = any_l ()
    | & _30 : Option'0.t_Option int32 = any_l ()
    | & _31 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__flatten [#"option.rs" 440 0 440 16]
  let%span soption0 = "option.rs" 445 45 445 46
  let%span soption1 = "option.rs" 446 38 446 39
  let%span soption2 = "option.rs" 446 4 446 40
  let%span soption3 = "option.rs" 444 4 444 36
  let%span soption4 = "option.rs" 442 4 442 36
  let%span soption5 = "../../../creusot-contracts/src/std/option.rs" 417 16 417 59
  let%span soption6 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption7 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  predicate inv'3 (_1 : int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int32 [inv'3 x] . inv'3 x = true
  
  use T_core__option__Option as Option'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int32 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Option'0.t_Option int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Option'0.t_Option int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option int32) (return'  (ret:int32))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#soption6] self <> Option'0.C_None}
    any [ return' (result:int32)-> {inv'3 result} {[%#soption6] Option'0.C_Some result = self} (! return' {result}) ] 
  
  let rec is_none'0 (self:Option'0.t_Option int32) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any [ return' (result:bool)-> {[%#soption7] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec flatten'0 (self:Option'0.t_Option (Option'0.t_Option int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'1 result}
      {[%#soption6] self = Option'0.C_None \/ self = Option'0.C_Some result}
      {[%#soption5] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec flatten (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &opt <- Option'0.C_None ] s1
      | s1 = flatten'0 {opt} (fun (_ret':Option'0.t_Option int32) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_9 <- Option'0.C_None ] s1
      | s1 =  [ &opt1 <- Option'0.C_Some _9 ] s2
      | s2 = flatten'0 {opt1} (fun (_ret':Option'0.t_Option int32) ->  [ &_13 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_13} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_17 <- Option'0.C_Some ([%#soption0] (1 : int32)) ] s1
      | s1 =  [ &opt2 <- Option'0.C_Some _17 ] s2
      | s2 = flatten'0 {opt2} (fun (_ret':Option'0.t_Option int32) ->  [ &_21 <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':int32) ->  [ &_20 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 = Int32.eq {_20} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1)
      | s1 = any [ br0 -> {_19 = false} (! bb12) | br1 -> {_19} (! bb11) ]  ]
      
    | bb11 = return' {_0}
    | bb12 = {[%#soption2] false} any
    | bb8 = {[%#soption3] false} any
    | bb4 = {[%#soption4] false} any ]
    )
    [ & _0 : () = any_l ()
    | & opt : Option'0.t_Option (Option'0.t_Option int32) = any_l ()
    | & _3 : bool = any_l ()
    | & _5 : Option'0.t_Option int32 = any_l ()
    | & opt1 : Option'0.t_Option (Option'0.t_Option int32) = any_l ()
    | & _9 : Option'0.t_Option int32 = any_l ()
    | & _11 : bool = any_l ()
    | & _13 : Option'0.t_Option int32 = any_l ()
    | & opt2 : Option'0.t_Option (Option'0.t_Option int32) = any_l ()
    | & _17 : Option'0.t_Option int32 = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : int32 = any_l ()
    | & _21 : Option'0.t_Option int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_option__resolve__qyClosure0 [#"option.rs" 454 8 454 26]
  type m_option__resolve__qyClosure0  =
    | M_option__resolve__qyClosure0
  
  let rec m_option__resolve__qyClosure0 (input:m_option__resolve__qyClosure0) (ret  )= any
    [ good -> {M_option__resolve__qyClosure0  = input} (! ret) ]
    
end
module M_option__resolve__qyClosure0 [#"option.rs" 454 8 454 26]
  let%span soption0 = "option.rs" 455 12 455 16
  let%span soption1 = "option.rs" 454 18 454 24
  let%span sresolve2 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use T_option__resolve__qyClosure0 as Closure'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed int32) =
    [%#sresolve2] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed int32) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__resolve__qyClosure0 (_1:Closure'0.m_option__resolve__qyClosure0) (_2:borrowed int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 _2}- s1
      | s1 =  [ &res <- [%#soption0] true ] s2
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & _2 : borrowed int32 = _2 | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] result} (! return' {result}) ]
    
end
module T_option__resolve__qyClosure1 [#"option.rs" 474 8 474 27]
  type m_option__resolve__qyClosure1  =
    | M_option__resolve__qyClosure1
  
  let rec m_option__resolve__qyClosure1 (input:m_option__resolve__qyClosure1) (ret  )= any
    [ good -> {M_option__resolve__qyClosure1  = input} (! ret) ]
    
end
module M_option__resolve__qyClosure1 [#"option.rs" 474 8 474 27]
  let%span soption0 = "option.rs" 475 12 475 17
  let%span soption1 = "option.rs" 474 18 474 25
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_option__resolve__qyClosure1 as Closure'0
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec m_option__resolve__qyClosure1 (_1:Closure'0.m_option__resolve__qyClosure1) (_2:borrowed int32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &res <- [%#soption0] false ] s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    ) [ & _0 : bool = any_l () | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#soption1] not result} (! return' {result}) ]
    
end
module M_option__resolve [#"option.rs" 449 0 449 16]
  let%span soption0 = "option.rs" 451 16 451 17
  let%span soption1 = "option.rs" 457 17 457 18
  let%span soption2 = "option.rs" 460 16 460 17
  let%span soption3 = "option.rs" 462 25 462 26
  let%span soption4 = "option.rs" 463 17 463 18
  let%span soption5 = "option.rs" 464 16 464 17
  let%span soption6 = "option.rs" 465 16 465 17
  let%span soption7 = "option.rs" 468 17 468 18
  let%span soption8 = "option.rs" 468 27 468 28
  let%span soption9 = "option.rs" 471 16 471 17
  let%span soption10 = "option.rs" 477 17 477 18
  let%span soption11 = "option.rs" 479 16 479 17
  let%span soption12 = "option.rs" 480 16 480 17
  let%span soption13 = "option.rs" 484 17 484 18
  let%span soption14 = "option.rs" 484 27 484 28
  let%span soption15 = "option.rs" 487 16 487 17
  let%span soption16 = "option.rs" 488 16 488 17
  let%span soption17 = "option.rs" 491 12 491 13
  let%span soption18 = "option.rs" 492 17 492 18
  let%span soption19 = "option.rs" 492 27 492 28
  let%span soption20 = "option.rs" 495 16 495 17
  let%span soption21 = "option.rs" 496 16 496 17
  let%span soption22 = "option.rs" 499 12 499 13
  let%span soption23 = "option.rs" 500 17 500 18
  let%span soption24 = "option.rs" 500 27 500 28
  let%span soption25 = "option.rs" 503 16 503 17
  let%span soption26 = "option.rs" 506 17 506 18
  let%span soption27 = "option.rs" 509 16 509 17
  let%span soption28 = "option.rs" 512 17 512 18
  let%span soption29 = "option.rs" 515 17 515 18
  let%span soption30 = "option.rs" 515 4 515 19
  let%span soption31 = "option.rs" 512 4 512 19
  let%span soption32 = "option.rs" 506 4 506 19
  let%span soption33 = "option.rs" 500 4 500 29
  let%span soption34 = "option.rs" 492 4 492 29
  let%span soption35 = "option.rs" 484 4 484 29
  let%span soption36 = "option.rs" 477 4 477 19
  let%span soption37 = "option.rs" 468 4 468 29
  let%span soption38 = "option.rs" 463 4 463 19
  let%span soption39 = "option.rs" 457 4 457 19
  let%span soption40 = "option.rs" 453 4 456 6
  let%span soption41 = "../../../creusot-contracts/src/std/option.rs" 39 27 42 17
  let%span soption42 = "../../../creusot-contracts/src/std/option.rs" 43 26 46 17
  let%span soption43 = "../../../creusot-contracts/src/std/option.rs" 222 16 222 59
  let%span soption44 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption45 = "../../../creusot-contracts/src/std/option.rs" 264 16 264 59
  let%span soption46 = "../../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption47 = "../../../creusot-contracts/src/std/option.rs" 247 26 253 17
  let%span soption48 = "../../../creusot-contracts/src/std/option.rs" 283 26 288 17
  let%span soption49 = "../../../creusot-contracts/src/std/option.rs" 292 26 295 17
  let%span soption50 = "../../../creusot-contracts/src/std/option.rs" 296 26 296 68
  let%span soption51 = "../../../creusot-contracts/src/std/option.rs" 300 26 303 17
  let%span soption52 = "../../../creusot-contracts/src/std/option.rs" 352 26 356 17
  let%span soption53 = "../../../creusot-contracts/src/std/option.rs" 386 16 386 59
  let%span soption54 = "../../../creusot-contracts/src/std/option.rs" 395 16 395 59
  let%span soption55 = "option.rs" 454 18 454 24
  let%span sresolve56 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span soption57 = "option.rs" 474 18 474 25
  let%span sresolve58 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sresolve59 = "../../../creusot-contracts/src/resolve.rs" 27 8 27 44
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_core__option__Option as Option'0
  
  predicate inv'7 (_1 : Option'0.t_Option (borrowed int32, int32))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (borrowed int32, int32) [inv'7 x] . inv'7 x = true
  
  predicate inv'6 (_1 : borrowed (borrowed int32))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (borrowed int32) [inv'6 x] . inv'6 x = true
  
  predicate inv'5 (_1 : borrowed int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed int32 [inv'5 x] . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option (borrowed int32)))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Option'0.t_Option (borrowed int32)) [inv'4 x] . inv'4 x = true
  
  use T_option__resolve__qyClosure1 as Closure'1
  
  predicate inv'3 (_1 : Closure'1.m_option__resolve__qyClosure1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Closure'1.m_option__resolve__qyClosure1 [inv'3 x] . inv'3 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int32 [inv'2 x] . inv'2 x = true
  
  use T_option__resolve__qyClosure0 as Closure'0
  
  predicate inv'1 (_1 : Closure'0.m_option__resolve__qyClosure0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Closure'0.m_option__resolve__qyClosure0 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'5 (self : borrowed int32) =
    [%#sresolve58] self.final = self.current
  
  let rec cloned'0 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption44] self = Option'0.C_None
      \/ (exists t : borrowed int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some (t.current) /\ resolve'5 t)}
      {[%#soption54] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec copied'0 (self:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption44] self = Option'0.C_None
      \/ (exists t : borrowed int32 . self = Option'0.C_Some t /\ result = Option'0.C_Some (t.current) /\ resolve'5 t)}
      {[%#soption53] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate resolve'9 (_1 : int32) =
    true
  
  predicate resolve'1 (_1 : borrowed int32) =
    resolve'5 _1
  
  predicate resolve'11 (self : (borrowed int32, int32)) =
    [%#sresolve59] resolve'1 (let (a, _) = self in a) /\ resolve'9 (let (_, a) = self in a)
  
  predicate resolve'10 (_1 : (borrowed int32, int32)) =
    resolve'11 _1
  
  predicate resolve'8 (self : Option'0.t_Option (borrowed int32, int32)) =
    [%#sresolve56] match self with
      | Option'0.C_Some x -> resolve'10 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'3 (_1 : Option'0.t_Option (borrowed int32, int32)) =
    resolve'8 _1
  
  predicate resolve'4 (self : Option'0.t_Option (borrowed int32)) =
    [%#sresolve56] match self with
      | Option'0.C_Some x -> resolve'1 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'7 (self : Option'0.t_Option int32) =
    [%#sresolve56] match self with
      | Option'0.C_Some x -> resolve'9 x
      | Option'0.C_None -> true
      end
  
  let rec zip'0 (self:Option'0.t_Option (borrowed int32)) (other:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option (borrowed int32, int32)))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option (borrowed int32, int32))-> {inv'7 result}
      {[%#soption52] match (self, other) with
        | (Option'0.C_None, _) -> result = Option'0.C_None /\ resolve'7 other
        | (_, Option'0.C_None) -> result = Option'0.C_None /\ resolve'4 self
        | (Option'0.C_Some t, Option'0.C_Some u) -> result = Option'0.C_Some (t, u)
        end}
      (! return' {result}) ]
    
  
  let rec get_or_insert'0 (self:borrowed (Option'0.t_Option (borrowed int32))) (value:borrowed int32) (return'  (ret:borrowed (borrowed int32)))= {[@expl:precondition] inv'5 value}
    {[@expl:precondition] inv'4 self}
    any
    [ return' (result:borrowed (borrowed int32))-> {inv'6 result}
      {[%#soption51] match self.current with
        | Option'0.C_None -> result.current = value /\ self.final = Option'0.C_Some (result.final)
        | Option'0.C_Some _ -> self.current = Option'0.C_Some (result.current)
        /\ self.final = Option'0.C_Some (result.final) /\ resolve'1 value
        end}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (borrowed int32)) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (borrowed int32)) =
    resolve'6 _1
  
  let rec insert'0 (self:borrowed (Option'0.t_Option (borrowed int32))) (value:borrowed int32) (return'  (ret:borrowed (borrowed int32)))= {[@expl:precondition] inv'5 value}
    {[@expl:precondition] inv'4 self}
    any
    [ return' (result:borrowed (borrowed int32))-> {inv'6 result}
      {[%#soption50] result.current = value /\ self.final = Option'0.C_Some (result.final)}
      {[%#soption49] match self.current with
        | Option'0.C_Some t -> resolve'1 t
        | Option'0.C_None -> true
        end}
      (! return' {result}) ]
    
  
  let rec xor'0 (self:Option'0.t_Option (borrowed int32)) (optb:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] inv'0 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {inv'0 result}
      {[%#soption48] match (self, optb) with
        | (Option'0.C_None, Option'0.C_None) -> result = Option'0.C_None
        | (Option'0.C_Some t1, Option'0.C_Some t2) -> result = Option'0.C_None /\ resolve'1 t1 /\ resolve'1 t2
        | (Option'0.C_Some t, Option'0.C_None) -> result = Option'0.C_Some t
        | (Option'0.C_None, Option'0.C_Some t) -> result = Option'0.C_Some t
        end}
      (! return' {result}) ]
    
  
  predicate postcondition_once'1 [#"option.rs" 474 8 474 27] (self : Closure'1.m_option__resolve__qyClosure1) (args : borrowed int32) (result : bool)
    
   =
    [%#soption57] let (_2) = args in not result
  
  predicate precondition'1 [#"option.rs" 474 8 474 27] (self : Closure'1.m_option__resolve__qyClosure1) (args : borrowed int32)
    
   =
    let (_2) = args in true
  
  let rec filter'0 (self:Option'0.t_Option (borrowed int32)) (predicate':Closure'1.m_option__resolve__qyClosure1) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] inv'3 predicate'}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption46] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'1 predicate' (t)
      end}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {inv'0 result}
      {[%#soption47] match self with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some t -> match result with
          | Option'0.C_None -> postcondition_once'1 predicate' (t) false /\ resolve'1 t
          | Option'0.C_Some r -> postcondition_once'1 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : Option'0.t_Option (borrowed int32)) =
    resolve'4 _1
  
  let rec or'0 (self:Option'0.t_Option (borrowed int32)) (optb:Option'0.t_Option (borrowed int32)) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] inv'0 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {inv'0 result}
      {[%#soption44] self = Option'0.C_None \/ result = self /\ resolve'4 optb}
      {[%#soption45] self = Option'0.C_None  -> result = optb}
      (! return' {result}) ]
    
  
  let rec and'0 (self:Option'0.t_Option (borrowed int32)) (optb:Option'0.t_Option int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] inv'2 optb}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:Option'0.t_Option int32)-> {inv'2 result}
      {[%#soption44] self = Option'0.C_None \/ result = optb /\ resolve'4 self}
      {[%#soption43] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate postcondition_once'0 [#"option.rs" 454 8 454 26] (self : Closure'0.m_option__resolve__qyClosure0) (args : borrowed int32) (result : bool)
    
   =
    [%#soption55] let (_2) = args in result
  
  predicate precondition'0 [#"option.rs" 454 8 454 26] (self : Closure'0.m_option__resolve__qyClosure0) (args : borrowed int32)
    
   =
    let (_2) = args in true
  
  let rec is_some_and'0 (self:Option'0.t_Option (borrowed int32)) (f:Closure'0.m_option__resolve__qyClosure0) (return'  (ret:bool))= {[@expl:precondition] inv'1 f}
    {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption41] match self with
      | Option'0.C_None -> true
      | Option'0.C_Some t -> precondition'0 f (t)
      end}
    any
    [ return' (result:bool)-> {[%#soption42] match self with
        | Option'0.C_None -> result = false
        | Option'0.C_Some t -> resolve'1 t /\ postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec resolve (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &x <- [%#soption0] (1 : int32) ] s1
      | s1 = Borrow.borrow_mut <int32> {x} (fun (_ret':borrowed int32) ->  [ &_3 <- _ret' ]  [ &x <- _ret'.final ] s2)
      | s2 =  [ &opt <- Option'0.C_Some _3 ] s3
      | s3 =  [ &_7 <- Closure'0.M_option__resolve__qyClosure0 ] s4
      | s4 = is_some_and'0 {opt} {_7} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s5)
      | s5 = bb1 ]
      
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0
      [ s0 = Int32.eq {x} {[%#soption1] (1 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1)
      | s1 = any [ br0 -> {_10 = false} (! bb5) | br1 -> {_10} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &x1 <- [%#soption2] (1 : int32) ] s1
      | s1 = Borrow.borrow_mut <int32> {x1}
          (fun (_ret':borrowed int32) ->  [ &_15 <- _ret' ]  [ &x1 <- _ret'.final ] s2)
      | s2 =  [ &opt1 <- Option'0.C_Some _15 ] s3
      | s3 =  [ &_18 <- Option'0.C_Some ([%#soption3] (2 : int32)) ] s4
      | s4 = and'0 {opt1} {_18} (fun (_ret':Option'0.t_Option int32) ->  [ &_16 <- _ret' ] s5)
      | s5 = bb6 ]
      
    | bb6 = s0
      [ s0 = Int32.eq {x1} {[%#soption4] (1 : int32)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb8) | br1 -> {_20} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 =  [ &x2 <- [%#soption5] (1 : int32) ] s1
      | s1 =  [ &y <- [%#soption6] (2 : int32) ] s2
      | s2 = Borrow.borrow_mut <int32> {x2}
          (fun (_ret':borrowed int32) ->  [ &_26 <- _ret' ]  [ &x2 <- _ret'.final ] s3)
      | s3 =  [ &opt2 <- Option'0.C_Some _26 ] s4
      | s4 = Borrow.borrow_mut <int32> {y} (fun (_ret':borrowed int32) ->  [ &_29 <- _ret' ]  [ &y <- _ret'.final ] s5)
      | s5 =  [ &_28 <- Option'0.C_Some _29 ] s6
      | s6 = or'0 {_28} {opt2} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_27 <- _ret' ] s7)
      | s7 = bb9 ]
      
    | bb9 = s0
      [ s0 = -{resolve'0 _27}- s1
      | s1 = Int32.eq {x2} {[%#soption7] (1 : int32)} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s2)
      | s2 = any [ br0 -> {_32 = false} (! bb13) | br1 -> {_32} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = Int32.eq {y} {[%#soption8] (2 : int32)} (fun (_ret':bool) ->  [ &_34 <- _ret' ] s1)
      | s1 = any [ br0 -> {_34 = false} (! bb12) | br1 -> {_34} (! bb11) ]  ]
      
    | bb11 = s0
      [ s0 =  [ &x3 <- [%#soption9] (1 : int32) ] s1
      | s1 = Borrow.borrow_mut <int32> {x3}
          (fun (_ret':borrowed int32) ->  [ &_39 <- _ret' ]  [ &x3 <- _ret'.final ] s2)
      | s2 =  [ &opt3 <- Option'0.C_Some _39 ] s3
      | s3 =  [ &_42 <- Closure'1.M_option__resolve__qyClosure1 ] s4
      | s4 = filter'0 {opt3} {_42} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_40 <- _ret' ] s5)
      | s5 = bb15 ]
      
    | bb15 = s0
      [ s0 = -{resolve'0 _40}- s1
      | s1 = Int32.eq {x3} {[%#soption10] (1 : int32)} (fun (_ret':bool) ->  [ &_44 <- _ret' ] s2)
      | s2 = any [ br0 -> {_44 = false} (! bb17) | br1 -> {_44} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 =  [ &x4 <- [%#soption11] (1 : int32) ] s1
      | s1 =  [ &y1 <- [%#soption12] (2 : int32) ] s2
      | s2 = Borrow.borrow_mut <int32> {x4}
          (fun (_ret':borrowed int32) ->  [ &_50 <- _ret' ]  [ &x4 <- _ret'.final ] s3)
      | s3 =  [ &optx <- Option'0.C_Some _50 ] s4
      | s4 = Borrow.borrow_mut <int32> {y1}
          (fun (_ret':borrowed int32) ->  [ &_52 <- _ret' ]  [ &y1 <- _ret'.final ] s5)
      | s5 =  [ &opty <- Option'0.C_Some _52 ] s6
      | s6 = xor'0 {optx} {opty} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_53 <- _ret' ] s7)
      | s7 = bb18 ]
      
    | bb18 = s0
      [ s0 = -{resolve'0 _53}- s1
      | s1 = Int32.eq {x4} {[%#soption13] (1 : int32)} (fun (_ret':bool) ->  [ &_57 <- _ret' ] s2)
      | s2 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = Int32.eq {y1} {[%#soption14] (2 : int32)} (fun (_ret':bool) ->  [ &_59 <- _ret' ] s1)
      | s1 = any [ br0 -> {_59 = false} (! bb21) | br1 -> {_59} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &x5 <- [%#soption15] (1 : int32) ] s1
      | s1 =  [ &y2 <- [%#soption16] (2 : int32) ] s2
      | s2 = Borrow.borrow_mut <int32> {x5}
          (fun (_ret':borrowed int32) ->  [ &_65 <- _ret' ]  [ &x5 <- _ret'.final ] s3)
      | s3 =  [ &opt4 <- Option'0.C_Some _65 ] s4
      | s4 = Borrow.borrow_mut <Option'0.t_Option (borrowed int32)> {opt4}
          (fun (_ret':borrowed (Option'0.t_Option (borrowed int32))) ->  [ &_67 <- _ret' ]  [ &opt4 <- _ret'.final ] s5)
      | s5 = Borrow.borrow_mut <int32> {y2}
          (fun (_ret':borrowed int32) ->  [ &_69 <- _ret' ]  [ &y2 <- _ret'.final ] s6)
      | s6 = Borrow.borrow_final <int32> {_69.current} {Borrow.get_id _69}
          (fun (_ret':borrowed int32) ->  [ &_68 <- _ret' ]  [ &_69 <- { _69 with current = _ret'.final ; } ] s7)
      | s7 = insert'0 {_67} {_68} (fun (_ret':borrowed (borrowed int32)) ->  [ &bor <- _ret' ] s8)
      | s8 = bb24 ]
      
    | bb24 = s0
      [ s0 = -{resolve'1 _69}- s1
      | s1 =  [ &bor <- { bor with current = { bor.current with current = ([%#soption17] (3 : int32)) ; } ; } ] s2
      | s2 = -{resolve'2 bor}- s3
      | s3 = -{resolve'0 opt4}- s4
      | s4 = Int32.eq {x5} {[%#soption18] (1 : int32)} (fun (_ret':bool) ->  [ &_71 <- _ret' ] s5)
      | s5 = any [ br0 -> {_71 = false} (! bb28) | br1 -> {_71} (! bb25) ]  ]
      
    | bb25 = s0
      [ s0 = Int32.eq {y2} {[%#soption19] (3 : int32)} (fun (_ret':bool) ->  [ &_73 <- _ret' ] s1)
      | s1 = any [ br0 -> {_73 = false} (! bb27) | br1 -> {_73} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 =  [ &x6 <- [%#soption20] (1 : int32) ] s1
      | s1 =  [ &y3 <- [%#soption21] (2 : int32) ] s2
      | s2 = Borrow.borrow_mut <int32> {x6}
          (fun (_ret':borrowed int32) ->  [ &_79 <- _ret' ]  [ &x6 <- _ret'.final ] s3)
      | s3 =  [ &opt5 <- Option'0.C_Some _79 ] s4
      | s4 = Borrow.borrow_mut <Option'0.t_Option (borrowed int32)> {opt5}
          (fun (_ret':borrowed (Option'0.t_Option (borrowed int32))) ->  [ &_81 <- _ret' ]  [ &opt5 <- _ret'.final ] s5)
      | s5 = Borrow.borrow_mut <int32> {y3}
          (fun (_ret':borrowed int32) ->  [ &_83 <- _ret' ]  [ &y3 <- _ret'.final ] s6)
      | s6 = Borrow.borrow_final <int32> {_83.current} {Borrow.get_id _83}
          (fun (_ret':borrowed int32) ->  [ &_82 <- _ret' ]  [ &_83 <- { _83 with current = _ret'.final ; } ] s7)
      | s7 = get_or_insert'0 {_81} {_82} (fun (_ret':borrowed (borrowed int32)) ->  [ &bor1 <- _ret' ] s8)
      | s8 = bb30 ]
      
    | bb30 = s0
      [ s0 = -{resolve'1 _83}- s1
      | s1 =  [ &bor1 <- { bor1 with current = { bor1.current with current = ([%#soption22] (3 : int32)) ; } ; } ] s2
      | s2 = -{resolve'2 bor1}- s3
      | s3 = -{resolve'0 opt5}- s4
      | s4 = Int32.eq {x6} {[%#soption23] (3 : int32)} (fun (_ret':bool) ->  [ &_85 <- _ret' ] s5)
      | s5 = any [ br0 -> {_85 = false} (! bb34) | br1 -> {_85} (! bb31) ]  ]
      
    | bb31 = s0
      [ s0 = Int32.eq {y3} {[%#soption24] (2 : int32)} (fun (_ret':bool) ->  [ &_87 <- _ret' ] s1)
      | s1 = any [ br0 -> {_87 = false} (! bb33) | br1 -> {_87} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &x7 <- [%#soption25] (1 : int32) ] s1
      | s1 = Borrow.borrow_mut <int32> {x7}
          (fun (_ret':borrowed int32) ->  [ &_92 <- _ret' ]  [ &x7 <- _ret'.final ] s2)
      | s2 =  [ &opt6 <- Option'0.C_Some _92 ] s3
      | s3 =  [ &_95 <- Option'0.C_None ] s4
      | s4 = zip'0 {opt6} {_95} (fun (_ret':Option'0.t_Option (borrowed int32, int32)) ->  [ &_93 <- _ret' ] s5)
      | s5 = bb36 ]
      
    | bb36 = s0
      [ s0 = -{resolve'3 _93}- s1
      | s1 = Int32.eq {x7} {[%#soption26] (1 : int32)} (fun (_ret':bool) ->  [ &_97 <- _ret' ] s2)
      | s2 = any [ br0 -> {_97 = false} (! bb38) | br1 -> {_97} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 =  [ &x8 <- [%#soption27] (1 : int32) ] s1
      | s1 = Borrow.borrow_mut <int32> {x8}
          (fun (_ret':borrowed int32) ->  [ &_102 <- _ret' ]  [ &x8 <- _ret'.final ] s2)
      | s2 =  [ &opt7 <- Option'0.C_Some _102 ] s3
      | s3 = copied'0 {opt7} (fun (_ret':Option'0.t_Option int32) ->  [ &_103 <- _ret' ] s4)
      | s4 = bb39 ]
      
    | bb39 = s0
      [ s0 = Int32.eq {x8} {[%#soption28] (1 : int32)} (fun (_ret':bool) ->  [ &_106 <- _ret' ] s1)
      | s1 = any [ br0 -> {_106 = false} (! bb41) | br1 -> {_106} (! bb40) ]  ]
      
    | bb40 = s0
      [ s0 = Borrow.borrow_mut <int32> {x8}
          (fun (_ret':borrowed int32) ->  [ &_110 <- _ret' ]  [ &x8 <- _ret'.final ] s1)
      | s1 =  [ &opt8 <- Option'0.C_Some _110 ] s2
      | s2 = cloned'0 {opt8} (fun (_ret':Option'0.t_Option int32) ->  [ &_111 <- _ret' ] s3)
      | s3 = bb42 ]
      
    | bb42 = s0
      [ s0 = Int32.eq {x8} {[%#soption29] (1 : int32)} (fun (_ret':bool) ->  [ &_114 <- _ret' ] s1)
      | s1 = any [ br0 -> {_114 = false} (! bb44) | br1 -> {_114} (! bb43) ]  ]
      
    | bb43 = return' {_0}
    | bb44 = {[%#soption30] false} any
    | bb41 = {[%#soption31] false} any
    | bb38 = {[%#soption32] false} any
    | bb33 = bb35
    | bb34 = bb35
    | bb35 = {[%#soption33] false} any
    | bb27 = bb29
    | bb28 = bb29
    | bb29 = {[%#soption34] false} any
    | bb21 = bb23
    | bb22 = bb23
    | bb23 = {[%#soption35] false} any
    | bb17 = {[%#soption36] false} any
    | bb12 = bb14
    | bb13 = bb14
    | bb14 = {[%#soption37] false} any
    | bb8 = {[%#soption38] false} any
    | bb5 = {[%#soption39] false} any
    | bb3 = {[%#soption40] false} any ]
    )
    [ & _0 : () = any_l ()
    | & x : int32 = any_l ()
    | & opt : Option'0.t_Option (borrowed int32) = any_l ()
    | & _3 : borrowed int32 = any_l ()
    | & _5 : bool = any_l ()
    | & _7 : Closure'0.m_option__resolve__qyClosure0 = any_l ()
    | & _10 : bool = any_l ()
    | & x1 : int32 = any_l ()
    | & opt1 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _15 : borrowed int32 = any_l ()
    | & _16 : Option'0.t_Option int32 = any_l ()
    | & _18 : Option'0.t_Option int32 = any_l ()
    | & _20 : bool = any_l ()
    | & x2 : int32 = any_l ()
    | & y : int32 = any_l ()
    | & opt2 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _26 : borrowed int32 = any_l ()
    | & _27 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _28 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _29 : borrowed int32 = any_l ()
    | & _32 : bool = any_l ()
    | & _34 : bool = any_l ()
    | & x3 : int32 = any_l ()
    | & opt3 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _39 : borrowed int32 = any_l ()
    | & _40 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _42 : Closure'1.m_option__resolve__qyClosure1 = any_l ()
    | & _44 : bool = any_l ()
    | & x4 : int32 = any_l ()
    | & y1 : int32 = any_l ()
    | & optx : Option'0.t_Option (borrowed int32) = any_l ()
    | & _50 : borrowed int32 = any_l ()
    | & opty : Option'0.t_Option (borrowed int32) = any_l ()
    | & _52 : borrowed int32 = any_l ()
    | & _53 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _57 : bool = any_l ()
    | & _59 : bool = any_l ()
    | & x5 : int32 = any_l ()
    | & y2 : int32 = any_l ()
    | & opt4 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _65 : borrowed int32 = any_l ()
    | & bor : borrowed (borrowed int32) = any_l ()
    | & _67 : borrowed (Option'0.t_Option (borrowed int32)) = any_l ()
    | & _68 : borrowed int32 = any_l ()
    | & _69 : borrowed int32 = any_l ()
    | & _71 : bool = any_l ()
    | & _73 : bool = any_l ()
    | & x6 : int32 = any_l ()
    | & y3 : int32 = any_l ()
    | & opt5 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _79 : borrowed int32 = any_l ()
    | & bor1 : borrowed (borrowed int32) = any_l ()
    | & _81 : borrowed (Option'0.t_Option (borrowed int32)) = any_l ()
    | & _82 : borrowed int32 = any_l ()
    | & _83 : borrowed int32 = any_l ()
    | & _85 : bool = any_l ()
    | & _87 : bool = any_l ()
    | & x7 : int32 = any_l ()
    | & opt6 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _92 : borrowed int32 = any_l ()
    | & _93 : Option'0.t_Option (borrowed int32, int32) = any_l ()
    | & _95 : Option'0.t_Option int32 = any_l ()
    | & _97 : bool = any_l ()
    | & x8 : int32 = any_l ()
    | & opt7 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _102 : borrowed int32 = any_l ()
    | & _103 : Option'0.t_Option int32 = any_l ()
    | & _106 : bool = any_l ()
    | & opt8 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _110 : borrowed int32 = any_l ()
    | & _111 : Option'0.t_Option int32 = any_l ()
    | & _114 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
