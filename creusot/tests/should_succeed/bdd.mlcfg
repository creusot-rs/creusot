
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Bumpalo_Impl0_Alloc_Interface
  type t
  use prelude.Borrow
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  val alloc [#"../bdd.rs" 17 8 17 48] (self : Bdd_Bumpalo_Bump_Type.t_bump) (val' : t) : borrowed t
    ensures { [#"../bdd.rs" 16 18 16 32]  * result = val' }
    
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module Bdd_Hashmap_Impl0_ShallowModel_Stub
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 44 8 44 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
end
module Bdd_Hashmap_Impl0_ShallowModel_Interface
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 44 8 44 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
end
module Bdd_Hashmap_Impl0_ShallowModel
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 44 8 44 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
  val shallow_model [#"../bdd.rs" 44 8 44 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Bdd_Hashmap_Impl1_Add_Interface
  type k
  type v
  use prelude.Borrow
  use map.Map
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v,
    type ShallowModelTy0.shallowModelTy = Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val add [#"../bdd.rs" 52 8 52 45] (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v)) (key : k) (val' : v) : ()
    ensures { [#"../bdd.rs" 50 8 50 128] forall i : DeepModelTy0.deepModelTy . Map.get (ShallowModel0.shallow_model ( ^ self)) i = (if i = DeepModel0.deep_model key then
      Core_Option_Option_Type.C_Some val'
    else
      Map.get (ShallowModel1.shallow_model self) i
    ) }
    
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl0_DeepModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl0_DeepModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl0_DeepModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = t,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : t) : DeepModelTy0.deepModelTy =
    DeepModel0.deep_model self
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module Bdd_Hashmap_Impl1_Get_Interface
  type k
  type v
  use prelude.Borrow
  use map.Map
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v,
    type ShallowModelTy0.shallowModelTy = Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
  val get [#"../bdd.rs" 61 8 61 65] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) (key : k) : Core_Option_Option_Type.t_option v
    ensures { [#"../bdd.rs" 56 18 59 9] match (result) with
      | Core_Option_Option_Type.C_Some v -> Map.get (ShallowModel0.shallow_model self) (DeepModel0.deep_model key) = Core_Option_Option_Type.C_Some v
      | Core_Option_Option_Type.C_None -> Map.get (ShallowModel0.shallow_model self) (DeepModel0.deep_model key) = Core_Option_Option_Type.C_None
      end }
    
end
module Bdd_Hashmap_Impl1_New_Interface
  type k
  type v
  use map.Const
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val new [#"../bdd.rs" 67 8 67 28] (_1' : ()) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v
    ensures { [#"../bdd.rs" 65 18 65 47] ShallowModel0.shallow_model result = Const.const (Core_Option_Option_Type.C_None) }
    
end
module Bdd_Hashmap_Hash_HashLog_Stub
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 33 8 33 49] (_1' : DeepModelTy0.deepModelTy) : int
end
module Bdd_Hashmap_Hash_HashLog_Interface
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 33 8 33 49] (_1' : DeepModelTy0.deepModelTy) : int
end
module Bdd_Hashmap_Hash_HashLog
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 33 8 33 49] (_1' : DeepModelTy0.deepModelTy) : int
  val hash_log [#"../bdd.rs" 33 8 33 49] (_1' : DeepModelTy0.deepModelTy) : int
    ensures { result = hash_log _1' }
    
end
module Core_Num_Impl9_Max_Stub
  use prelude.Int
  use prelude.UInt64
  val constant mAX'  : uint64
end
module Core_Num_Impl9_Max
  use prelude.Int
  use prelude.UInt64
  let constant mAX'  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
end
module Bdd_Hashmap_Impl2_HashLog_Stub
  type u
  type v
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  function hash_log [#"../bdd.rs" 79 8 79 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
end
module Bdd_Hashmap_Impl2_HashLog_Interface
  type u
  type v
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  function hash_log [#"../bdd.rs" 79 8 79 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
end
module Bdd_Hashmap_Impl2_HashLog
  type u
  type v
  use prelude.Int
  use prelude.UInt64
  clone Core_Num_Impl9_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog1 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog0 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function hash_log [#"../bdd.rs" 79 8 79 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int =
    [#"../bdd.rs" 80 24 80 84] mod (HashLog0.hash_log (let (a, _) = x in a) + HashLog1.hash_log (let (_, a) = x in a) * 17) (UInt64.to_int Max0.mAX' + 1)
  val hash_log [#"../bdd.rs" 79 8 79 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
    ensures { result = hash_log x }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module Bdd_Hashmap_Hash_Hash_Interface
  type self
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val hash [#"../bdd.rs" 30 8 30 30] (self : self) : uint64
    ensures { [#"../bdd.rs" 29 18 29 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
end
module Core_Num_Impl9_Bits_Stub
  use prelude.Int
  use prelude.UInt32
  val constant bITS'  : uint32
end
module Core_Num_Impl9_Bits
  use prelude.Int
  use prelude.UInt32
  let constant bITS'  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (64 : uint32)
end
module Core_Num_Impl9_Min_Stub
  use prelude.Int
  use prelude.UInt64
  val constant mIN'  : uint64
end
module Core_Num_Impl9_Min
  use prelude.Int
  use prelude.UInt64
  let constant mIN'  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint64)
end
module Core_Num_Impl9_WrappingMul_Interface
  use prelude.UInt64
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Core_Num_Impl9_Min_Stub as Min0
  clone Core_Num_Impl9_Bits_Stub as Bits0
  val wrapping_mul (self : uint64) (rhs : uint64) : uint64
    ensures { UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt64.to_int Min0.mIN' }
    ensures { UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int Min0.mIN' /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int Max0.mAX' -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs }
    ensures { UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs + k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    ensures { UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs - k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl9_WrappingAdd_Interface
  use prelude.UInt64
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Core_Num_Impl9_Min_Stub as Min0
  clone Core_Num_Impl9_Bits_Stub as Bits0
  val wrapping_add (self : uint64) (rhs : uint64) : uint64
    ensures { UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt64.to_int Min0.mIN' }
    ensures { UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int Min0.mIN' /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int Max0.mAX' -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs }
    ensures { UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs + k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    ensures { UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs - k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel_Stub
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel_Interface
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = b,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy) =
    (DeepModel0.deep_model (let (a, _) = self in a), DeepModel1.deep_model (let (_, a) = self in a))
  val deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
    ensures { result = deep_model self }
    
end
module Bdd_Hashmap_Impl2_Hash_Interface
  type u
  type v
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone Bdd_Hashmap_Impl2_HashLog_Stub as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
  val hash [#"../bdd.rs" 74 8 74 29] (self : (u, v)) : uint64
    ensures { [#"../bdd.rs" 73 18 73 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
end
module Bdd_Hashmap_Impl2_Hash
  type u
  type v
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel5 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl9_Min as Min0
  clone Core_Num_Impl9_Bits as Bits0
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel3 with
    type t = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel2 with
    type t = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog2 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog1 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel1 with
    type a = u,
    type b = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    function DeepModel1.deep_model = DeepModel5.deep_model
  clone Core_Num_Impl9_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl9_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Bdd_Hashmap_Hash_Hash_Interface as Hash1 with
    type self = v,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function HashLog0.hash_log = HashLog2.hash_log,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = (u, v)
  clone Bdd_Hashmap_Hash_Hash_Interface as Hash0 with
    type self = u,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function HashLog0.hash_log = HashLog1.hash_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Bdd_Hashmap_Impl2_HashLog as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function HashLog0.hash_log = HashLog1.hash_log,
    function HashLog1.hash_log = HashLog2.hash_log,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy),
    function DeepModel0.deep_model = DeepModel1.deep_model
  let rec cfg hash [#"../bdd.rs" 74 8 74 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : (u, v)) : uint64
    ensures { [#"../bdd.rs" 73 18 73 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self_1 : (u, v);
  var _3 : uint64;
  var _4 : u;
  var _5 : uint64;
  var _6 : uint64;
  var _7 : v;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- (let (a, _) = self_1 in a);
    _3 <- ([#"../bdd.rs" 75 12 75 25] Hash0.hash _4);
    goto BB1
  }
  BB1 {
    _7 <- (let (_, a) = self_1 in a);
    assume { Resolve0.resolve self_1 };
    _6 <- ([#"../bdd.rs" 75 39 75 52] Hash1.hash _7);
    goto BB2
  }
  BB2 {
    _5 <- ([#"../bdd.rs" 75 39 75 69] WrappingMul0.wrapping_mul _6 ([#"../bdd.rs" 75 66 75 68] (17 : uint64)));
    goto BB3
  }
  BB3 {
    _0 <- ([#"../bdd.rs" 75 12 75 70] WrappingAdd0.wrapping_add _3 _5);
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Bdd_Bdd_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  type t_bdd  =
    | C_Bdd (t_node) uint64
    with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
    
  let function if_v (self : t_node) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any uint64
      | C_True -> any uint64
      | C_If a _ _ -> a
      end
  let function if_childt (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ a _ -> a
      end
  let function if_childf (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ _ a -> a
      end
  let function bdd_1 (self : t_bdd) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Bdd _ a -> a
      end
  let function bdd_0 (self : t_bdd) : t_node = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl12_AssertReceiverIsTotalEq_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  val assert_receiver_is_total_eq [#"../bdd.rs" 87 9 87 11] (self : Bdd_Node_Type.t_node) : ()
end
module Bdd_Impl12_AssertReceiverIsTotalEq
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 87 9 87 11] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : Bdd_Node_Type.t_node;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
module Bdd_NodeLog_Type
  use prelude.Int
  use prelude.UInt64
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Bdd_Impl5_DeepModel_Stub
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 177 4 177 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl5_DeepModel_Interface
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 177 4 177 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl5_DeepModel
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 177 4 177 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 178 20 178 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model [#"../bdd.rs" 177 4 177 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model self }
    
end
module Bdd_Impl6_ShallowModel_Stub
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function shallow_model [#"../bdd.rs" 186 4 186 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl6_ShallowModel_Interface
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function shallow_model [#"../bdd.rs" 186 4 186 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl6_ShallowModel
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel_Stub as DeepModel0
  function shallow_model [#"../bdd.rs" 186 4 186 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 187 20 187 37] DeepModel0.deep_model self
  val shallow_model [#"../bdd.rs" 186 4 186 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model self }
    
end
module Bdd_Impl7_Eq_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64
  val eq [#"../bdd.rs" 193 4 193 34] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 192 14 192 37] result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model o) }
    
end
module Bdd_Impl7_Eq
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel0
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg eq [#"../bdd.rs" 193 4 193 34] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 192 14 192 37] result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model o) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Bdd_Bdd_Type.t_bdd;
  var o_2 : Bdd_Bdd_Type.t_bdd;
  var _4 : uint64;
  var _5 : uint64;
  {
    self_1 <- self;
    o_2 <- o;
    goto BB0
  }
  BB0 {
    _4 <- Bdd_Bdd_Type.bdd_1 self_1;
    _5 <- Bdd_Bdd_Type.bdd_1 o_2;
    _0 <- ([#"../bdd.rs" 194 8 194 21] _4 = _5);
    return _0
  }
  
end
module Core_Cmp_Impls_Impl25_Eq_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use prelude.Int
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = uint64,
    type DeepModelTy0.deepModelTy = int
  val eq (self : uint64) (other : uint64) : bool
    ensures { result = (DeepModel0.deep_model self = DeepModel0.deep_model other) }
    
end
module Bdd_Impl3_DeepModel_Stub
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 152 4 152 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl3_DeepModel_Interface
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 152 4 152 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl3_DeepModel
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 152 4 152 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 154 12 158 13] match (self) with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model [#"../bdd.rs" 152 4 152 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Num_Impl10_DeepModel_Stub
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl10_DeepModel_Interface
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl10_DeepModel
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int =
    UInt64.to_int self
  val deep_model (self : uint64) : int
    ensures { result = deep_model self }
    
end
module Bdd_Impl13_Eq_Interface
  use prelude.Borrow
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  val eq [#"../bdd.rs" 87 13 87 22] (self : Bdd_Node_Type.t_node) (rhs : Bdd_Node_Type.t_node) : bool
    ensures { [#"../bdd.rs" 87 13 87 22] result = (DeepModel0.deep_model self = DeepModel0.deep_model rhs) }
    
end
module Bdd_Impl13_Eq
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel4
  clone CreusotContracts_Std1_Num_Impl10_DeepModel as DeepModel3
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel4.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel2 with
    type t = uint64,
    type DeepModelTy0.deepModelTy = int,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Bdd_Node_Type as Bdd_Node_Type
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = Bdd_Node_Type.t_node
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone Core_Cmp_Impls_Impl25_Eq_Interface as Eq1 with
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone Bdd_Impl7_Eq_Interface as Eq0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Bdd_Node_Type.t_node,
    type t2 = Bdd_Node_Type.t_node,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve1.resolve
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  let rec cfg eq [#"../bdd.rs" 87 13 87 22] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) (rhs : Bdd_Node_Type.t_node) : bool
    ensures { [#"../bdd.rs" 87 13 87 22] result = (DeepModel0.deep_model self = DeepModel0.deep_model rhs) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Bdd_Node_Type.t_node;
  var rhs_2 : Bdd_Node_Type.t_node;
  var _4 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var _5 : Bdd_Node_Type.t_node;
  var _6 : Bdd_Node_Type.t_node;
  var _7 : isize;
  var _8 : isize;
  var _9 : isize;
  var _10 : isize;
  var v_1_11 : uint64;
  var childt_1_12 : Bdd_Bdd_Type.t_bdd;
  var childf_1_13 : Bdd_Bdd_Type.t_bdd;
  var v_2_14 : uint64;
  var childt_2_15 : Bdd_Bdd_Type.t_bdd;
  var childf_2_16 : Bdd_Bdd_Type.t_bdd;
  var _17 : bool;
  var _18 : bool;
  var _19 : bool;
  var _20 : Bdd_Bdd_Type.t_bdd;
  var _21 : Bdd_Bdd_Type.t_bdd;
  var _22 : bool;
  var _23 : Bdd_Bdd_Type.t_bdd;
  var _24 : Bdd_Bdd_Type.t_bdd;
  var _25 : bool;
  var _26 : uint64;
  var _27 : uint64;
  {
    self_1 <- self;
    rhs_2 <- rhs;
    goto BB0
  }
  BB0 {
    _5 <- self_1;
    _6 <- rhs_2;
    _4 <- (_5, _6);
    switch (let (a, _) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB3
      | Bdd_Node_Type.C_If _ _ _ -> goto BB4
      end
  }
  BB1 {
    assume { Resolve0.resolve _4 };
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB5
      | _ -> goto BB2
      end
  }
  BB2 {
    _0 <- ([#"../bdd.rs" 87 13 87 22] false);
    goto BB20
  }
  BB3 {
    assume { Resolve0.resolve _4 };
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_True -> goto BB6
      | _ -> goto BB2
      end
  }
  BB4 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB7
      | _ -> goto BB23
      end
  }
  BB5 {
    _0 <- ([#"../bdd.rs" 87 13 87 22] true);
    goto BB20
  }
  BB6 {
    _0 <- ([#"../bdd.rs" 87 13 87 22] true);
    goto BB20
  }
  BB7 {
    v_1_11 <- Bdd_Node_Type.if_v (let (a, _) = _4 in a);
    childt_1_12 <- Bdd_Node_Type.if_childt (let (a, _) = _4 in a);
    childf_1_13 <- Bdd_Node_Type.if_childf (let (a, _) = _4 in a);
    v_2_14 <- Bdd_Node_Type.if_v (let (_, a) = _4 in a);
    childt_2_15 <- Bdd_Node_Type.if_childt (let (_, a) = _4 in a);
    childf_2_16 <- Bdd_Node_Type.if_childf (let (_, a) = _4 in a);
    assume { Resolve0.resolve _4 };
    _20 <- childf_1_13;
    _21 <- childf_2_16;
    _19 <- ([#"../bdd.rs" 87 13 87 22] Eq0.eq _20 _21);
    goto BB17
  }
  BB8 {
    _0 <- ([#"../bdd.rs" 87 13 87 22] false);
    goto BB10
  }
  BB9 {
    _0 <- ([#"../bdd.rs" 87 13 87 22] true);
    goto BB10
  }
  BB10 {
    goto BB20
  }
  BB11 {
    _17 <- ([#"../bdd.rs" 87 13 87 22] false);
    goto BB13
  }
  BB12 {
    _26 <- v_1_11;
    _27 <- v_2_14;
    _25 <- ([#"../bdd.rs" 87 13 87 22] Eq1.eq _26 _27);
    goto BB19
  }
  BB13 {
    switch (_17)
      | False -> goto BB8
      | True -> goto BB9
      end
  }
  BB14 {
    _18 <- ([#"../bdd.rs" 87 13 87 22] false);
    goto BB16
  }
  BB15 {
    _23 <- childt_1_12;
    _24 <- childt_2_15;
    _22 <- ([#"../bdd.rs" 87 13 87 22] Eq0.eq _23 _24);
    goto BB18
  }
  BB16 {
    switch (_18)
      | False -> goto BB11
      | True -> goto BB12
      end
  }
  BB17 {
    switch (_19)
      | False -> goto BB14
      | True -> goto BB15
      end
  }
  BB18 {
    _18 <- _22;
    _22 <- any bool;
    goto BB16
  }
  BB19 {
    _17 <- _25;
    _25 <- any bool;
    goto BB13
  }
  BB20 {
    return _0
  }
  BB22 {
    assume { Resolve0.resolve _4 };
    goto BB2
  }
  BB23 {
    assume { Resolve0.resolve _4 };
    goto BB2
  }
  
end
module Core_Clone_Impls_Impl9_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  val clone' (self : uint64) : uint64
    ensures { result = self }
    
end
module Bdd_Impl0_Clone_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  val clone' [#"../bdd.rs" 106 4 106 27] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 105 14 105 29] result = self }
    
end
module Bdd_Impl0_Clone
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec cfg clone' [#"../bdd.rs" 106 4 106 27] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 105 14 105 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _0 <- self_1;
    return _0
  }
  
end
module Bdd_Impl14_Clone_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  val clone' [#"../bdd.rs" 87 24 87 29] (self : Bdd_Node_Type.t_node) : Bdd_Node_Type.t_node
    ensures { [#"../bdd.rs" 87 24 87 29] result = self }
    
end
module Bdd_Impl14_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl0_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl9_Clone_Interface as Clone0
  use Bdd_Node_Type as Bdd_Node_Type
  let rec cfg clone' [#"../bdd.rs" 87 24 87 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : Bdd_Node_Type.t_node
    ensures { [#"../bdd.rs" 87 24 87 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Node_Type.t_node;
  var self_1 : Bdd_Node_Type.t_node;
  var _3 : isize;
  var v_1_4 : uint64;
  var childt_1_5 : Bdd_Bdd_Type.t_bdd;
  var childf_1_6 : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _8 : uint64;
  var _9 : Bdd_Bdd_Type.t_bdd;
  var _10 : Bdd_Bdd_Type.t_bdd;
  var _11 : Bdd_Bdd_Type.t_bdd;
  var _12 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Bdd_Node_Type.C_False -> goto BB3
      | Bdd_Node_Type.C_True -> goto BB4
      | Bdd_Node_Type.C_If _ _ _ -> goto BB1
      end
  }
  BB1 {
    v_1_4 <- Bdd_Node_Type.if_v self_1;
    childt_1_5 <- Bdd_Node_Type.if_childt self_1;
    childf_1_6 <- Bdd_Node_Type.if_childf self_1;
    _8 <- v_1_4;
    _7 <- ([#"../bdd.rs" 87 24 87 29] Clone0.clone' _8);
    goto BB5
  }
  BB2 {
    absurd
  }
  BB3 {
    _0 <- Bdd_Node_Type.C_False;
    goto BB8
  }
  BB4 {
    _0 <- Bdd_Node_Type.C_True;
    goto BB8
  }
  BB5 {
    _10 <- childt_1_5;
    _9 <- ([#"../bdd.rs" 87 24 87 29] Clone1.clone' _10);
    goto BB6
  }
  BB6 {
    _12 <- childf_1_6;
    _11 <- ([#"../bdd.rs" 87 24 87 29] Clone1.clone' _12);
    goto BB7
  }
  BB7 {
    _0 <- Bdd_Node_Type.C_If _7 _9 _11;
    goto BB8
  }
  BB8 {
    return _0
  }
  
end
module Bdd_Impl18_AssertReceiverIsTotalEq_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  val assert_receiver_is_total_eq [#"../bdd.rs" 101 15 101 17] (self : Bdd_Bdd_Type.t_bdd) : ()
end
module Bdd_Impl18_AssertReceiverIsTotalEq
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 101 15 101 17] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
module Bdd_Impl1_HashLog_Stub
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 124 4 124 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
end
module Bdd_Impl1_HashLog_Interface
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 124 4 124 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
end
module Bdd_Impl1_HashLog
  use prelude.Int
  use prelude.UInt64
  clone Core_Num_Impl9_Max_Stub as Max0
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 124 4 124 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 126 12 131 13] match (x) with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5 + UInt64.to_int childf * 7) (UInt64.to_int Max0.mAX' + 1)
      end
  val hash_log [#"../bdd.rs" 124 4 124 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl4_ShallowModel_Stub
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function shallow_model [#"../bdd.rs" 168 4 168 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl4_ShallowModel_Interface
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function shallow_model [#"../bdd.rs" 168 4 168 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl4_ShallowModel
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel_Stub as DeepModel0
  function shallow_model [#"../bdd.rs" 168 4 168 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 169 20 169 37] DeepModel0.deep_model self
  val shallow_model [#"../bdd.rs" 168 4 168 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model self }
    
end
module Bdd_Impl1_Hash_Interface
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl1_HashLog_Stub as HashLog0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  val hash [#"../bdd.rs" 113 4 113 25] (self : Bdd_Node_Type.t_node) : uint64
    ensures { [#"../bdd.rs" 112 14 112 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
end
module Bdd_Impl1_Hash
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use prelude.IntSize
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Core_Num_Impl9_Min as Min0
  clone Core_Num_Impl9_Bits as Bits0
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Core_Num_Impl9_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl9_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Bdd_Impl1_HashLog as HashLog0 with
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg hash [#"../bdd.rs" 113 4 113 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : uint64
    ensures { [#"../bdd.rs" 112 14 112 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self_1 : Bdd_Node_Type.t_node;
  var _3 : isize;
  var v_4 : uint64;
  var childt_5 : Bdd_Bdd_Type.t_bdd;
  var childf_6 : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _8 : uint64;
  var _9 : uint64;
  var _10 : uint64;
  var _11 : uint64;
  var _12 : uint64;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Bdd_Node_Type.C_False -> goto BB3
      | Bdd_Node_Type.C_True -> goto BB4
      | Bdd_Node_Type.C_If _ _ _ -> goto BB1
      end
  }
  BB1 {
    v_4 <- Bdd_Node_Type.if_v self_1;
    childt_5 <- Bdd_Node_Type.if_childt self_1;
    childf_6 <- Bdd_Node_Type.if_childf self_1;
    _8 <- v_4;
    _10 <- Bdd_Bdd_Type.bdd_1 childt_5;
    _9 <- ([#"../bdd.rs" 118 31 118 55] WrappingMul0.wrapping_mul _10 ([#"../bdd.rs" 118 53 118 54] (5 : uint64)));
    goto BB5
  }
  BB2 {
    absurd
  }
  BB3 {
    _0 <- ([#"../bdd.rs" 115 21 115 22] (1 : uint64));
    goto BB9
  }
  BB4 {
    _0 <- ([#"../bdd.rs" 116 20 116 21] (2 : uint64));
    goto BB9
  }
  BB5 {
    _7 <- ([#"../bdd.rs" 118 16 118 56] WrappingAdd0.wrapping_add _8 _9);
    goto BB6
  }
  BB6 {
    _12 <- Bdd_Bdd_Type.bdd_1 childf_6;
    _11 <- ([#"../bdd.rs" 118 70 118 94] WrappingMul0.wrapping_mul _12 ([#"../bdd.rs" 118 92 118 93] (7 : uint64)));
    goto BB7
  }
  BB7 {
    _0 <- ([#"../bdd.rs" 118 16 118 95] WrappingAdd0.wrapping_add _7 _11);
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Bdd_Impl2_HashLog_Stub
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 143 4 143 44] (x : uint64) : int
end
module Bdd_Impl2_HashLog_Interface
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 143 4 143 44] (x : uint64) : int
end
module Bdd_Impl2_HashLog
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 143 4 143 44] (x : uint64) : int =
    [#"../bdd.rs" 144 8 144 24] UInt64.to_int x
  val hash_log [#"../bdd.rs" 143 4 143 44] (x : uint64) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl2_Hash_Interface
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl2_HashLog_Stub as HashLog0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64
  val hash [#"../bdd.rs" 138 4 138 25] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { [#"../bdd.rs" 137 14 137 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
end
module Bdd_Impl2_Hash
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel0
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Bdd_Impl2_HashLog as HashLog0
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg hash [#"../bdd.rs" 138 4 138 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { [#"../bdd.rs" 137 14 137 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self_1 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _0 <- Bdd_Bdd_Type.bdd_1 self_1;
    return _0
  }
  
end
module Bdd_Impl8_Interp_Stub
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 200 4 200 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
end
module Bdd_Impl8_Interp_Interface
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 200 4 200 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
end
module Bdd_Impl8_Interp
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 200 4 200 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 202 12 209 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  val interp [#"../bdd.rs" 200 4 200 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp self vars }
    
end
module Bdd_Impl8_Size_Stub
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 215 4 215 24] (self : Bdd_Bdd_Type.t_bdd) : int
end
module Bdd_Impl8_Size_Interface
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 215 4 215 24] (self : Bdd_Bdd_Type.t_bdd) : int
  axiom size_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 214 14 214 25] size self >= 0
end
module Bdd_Impl8_Size
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 215 4 215 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 217 12 225 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  val size [#"../bdd.rs" 215 4 215 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = size self }
    
  axiom size_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 214 14 214 25] size self >= 0
end
module Bdd_Impl8_Size_Impl
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec ghost function size [#"../bdd.rs" 215 4 215 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { [#"../bdd.rs" 214 14 214 25] result >= 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 217 12 225 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
end
module Bdd_Impl8_Leastvar_Stub
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 230 4 230 28] (self : Bdd_Bdd_Type.t_bdd) : int
end
module Bdd_Impl8_Leastvar_Interface
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 230 4 230 28] (self : Bdd_Bdd_Type.t_bdd) : int
end
module Bdd_Impl8_Leastvar
  use prelude.Int
  use prelude.UInt64
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int
  clone Core_Num_Impl9_Max_Stub as Max0
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 230 4 230 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 232 12 236 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int Max0.mAX' + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int Max0.mAX' + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> ShallowModel0.shallow_model v
      end
  val leastvar [#"../bdd.rs" 230 4 230 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar self }
    
end
module Bdd_Context_Type
  use prelude.Borrow
  use prelude.Ghost
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  type t_context  =
    | C_Context (Bdd_Bumpalo_Bump_Type.t_bump) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) uint64
    
  let function context_hashcons (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ a _ _ _ _ -> a
      end
  let function context_cnt (self : t_context) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ _ _ a -> a
      end
  let function context_hashcons_ghost (self : t_context) : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ a _ _ _ -> a
      end
  let function context_not_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ a _ _ -> a
      end
  let function context_and_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ _ a _ -> a
      end
  let function context_alloc (self : t_context) : Bdd_Bumpalo_Bump_Type.t_bump = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context a _ _ _ _ _ -> a
      end
end
module Bdd_Impl9_IsValidBdd_Stub
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 295 4 295 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd)
end
module Bdd_Impl9_IsValidBdd_Interface
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 295 4 295 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd)
end
module Bdd_Impl9_IsValidBdd
  use map.Map
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 295 4 295 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 297 12 297 47] Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons self)) (ShallowModel1.shallow_model (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd [#"../bdd.rs" 295 4 295 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd self b }
    
end
module Bdd_Impl9_IsValidNode_Stub
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_node [#"../bdd.rs" 302 4 302 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node)
end
module Bdd_Impl9_IsValidNode_Interface
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_node [#"../bdd.rs" 302 4 302 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node)
end
module Bdd_Impl9_IsValidNode
  use prelude.UInt64
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  use Bdd_Node_Type as Bdd_Node_Type
  predicate is_valid_node [#"../bdd.rs" 302 4 302 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 304 12 313 13] match (n) with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ IsValidBdd0.is_valid_bdd self childt /\ IsValidBdd0.is_valid_bdd self childf /\ UInt64.to_int v < Leastvar0.leastvar childt /\ UInt64.to_int v < Leastvar0.leastvar childf
      end
  val is_valid_node [#"../bdd.rs" 302 4 302 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node self n }
    
end
module Bdd_Impl9_Invariant_Stub
  use Bdd_Context_Type as Bdd_Context_Type
  predicate invariant' [#"../bdd.rs" 252 4 252 34] (self : Bdd_Context_Type.t_context)
end
module Bdd_Impl9_Invariant_Interface
  use Bdd_Context_Type as Bdd_Context_Type
  predicate invariant' [#"../bdd.rs" 252 4 252 34] (self : Bdd_Context_Type.t_context)
end
module Bdd_Impl9_Invariant
  use prelude.Int
  use prelude.Ghost
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl9_IsValidNode_Stub as IsValidNode0
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  predicate invariant' [#"../bdd.rs" 252 4 252 34] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 254 12 278 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match (Map.get (ShallowModel1.shallow_model (Bdd_Context_Type.context_hashcons self)) n) with
      | Core_Option_Option_Type.C_Some b -> ShallowModel0.shallow_model (Bdd_Bdd_Type.bdd_0 b) = n /\ IsValidNode0.is_valid_node self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match (Map.get (ShallowModel2.shallow_model (Bdd_Context_Type.context_not_memo self)) bm) with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in IsValidBdd0.is_valid_bdd self n /\ IsValidBdd0.is_valid_bdd self b /\ (forall v : Map.map uint64 bool . Interp0.interp n v = (not Interp0.interp b v)) /\ Leastvar0.leastvar b <= Leastvar0.leastvar n
      end) /\ (forall abm : (uint64, uint64) . match (Map.get (ShallowModel3.shallow_model (Bdd_Context_Type.context_and_memo self)) abm) with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in IsValidBdd0.is_valid_bdd self n /\ IsValidBdd0.is_valid_bdd self a /\ IsValidBdd0.is_valid_bdd self b /\ (forall v : Map.map uint64 bool . Interp0.interp n v = (Interp0.interp a v /\ Interp0.interp b v)) /\ (Leastvar0.leastvar a <= Leastvar0.leastvar n \/ Leastvar0.leastvar b <= Leastvar0.leastvar n)
      end)
  val invariant' [#"../bdd.rs" 252 4 252 34] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant' self }
    
end
module Bdd_Impl9_Grows_Stub
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 283 4 283 35] (self : borrowed (Bdd_Context_Type.t_context))
end
module Bdd_Impl9_Grows_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 283 4 283 35] (self : borrowed (Bdd_Context_Type.t_context))
end
module Bdd_Impl9_Grows
  use prelude.Borrow
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 283 4 283 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 284 8 291 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match (Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons ( * self))) n) with
      | Core_Option_Option_Type.C_Some b -> Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows [#"../bdd.rs" 283 4 283 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows self }
    
end
module Bdd_Impl9_GrowsIsValidBdd_Stub
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 321 4 321 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
end
module Bdd_Impl9_GrowsIsValidBdd_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 321 4 321 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  axiom grows_is_valid_bdd_spec : forall self : borrowed (Bdd_Context_Type.t_context), b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 318 15 318 27] Grows0.grows self) -> ([#"../bdd.rs" 319 15 319 35] IsValidBdd0.is_valid_bdd ( * self) b) -> ([#"../bdd.rs" 320 14 320 37] IsValidBdd0.is_valid_bdd ( ^ self) b)
end
module Bdd_Impl9_GrowsIsValidBdd
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 321 4 321 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
   =
    [#"../bdd.rs" 317 4 317 12] ()
  val grows_is_valid_bdd [#"../bdd.rs" 321 4 321 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 318 15 318 27] Grows0.grows self}
    requires {[#"../bdd.rs" 319 15 319 35] IsValidBdd0.is_valid_bdd ( * self) b}
    ensures { result = grows_is_valid_bdd self b }
    
  axiom grows_is_valid_bdd_spec : forall self : borrowed (Bdd_Context_Type.t_context), b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 318 15 318 27] Grows0.grows self) -> ([#"../bdd.rs" 319 15 319 35] IsValidBdd0.is_valid_bdd ( * self) b) -> ([#"../bdd.rs" 320 14 320 37] IsValidBdd0.is_valid_bdd ( ^ self) b)
end
module Bdd_Impl9_GrowsIsValidBdd_Impl
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel2 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec ghost function grows_is_valid_bdd [#"../bdd.rs" 321 4 321 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 318 15 318 27] Grows0.grows self}
    requires {[#"../bdd.rs" 319 15 319 35] IsValidBdd0.is_valid_bdd ( * self) b}
    ensures { [#"../bdd.rs" 320 14 320 37] IsValidBdd0.is_valid_bdd ( ^ self) b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 317 4 317 12] ()
end
module Bdd_Impl9_GrowsTrans_Stub
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 329 4 329 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
end
module Bdd_Impl9_GrowsTrans_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 329 4 329 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
  axiom grows_trans_spec : forall self : borrowed (Bdd_Context_Type.t_context), o : borrowed (Bdd_Context_Type.t_context), oo : borrowed (Bdd_Context_Type.t_context) . ([#"../bdd.rs" 324 15 324 27] Grows0.grows self) -> ([#"../bdd.rs" 325 15 325 24] Grows0.grows o) -> ([#"../bdd.rs" 326 15 326 26]  ^ self =  * o) -> ([#"../bdd.rs" 327 15 327 43]  * self =  * oo /\  ^ self =  ^ oo) -> ([#"../bdd.rs" 328 14 328 24] Grows0.grows oo)
end
module Bdd_Impl9_GrowsTrans
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 329 4 329 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
   =
    [#"../bdd.rs" 323 4 323 12] ()
  val grows_trans [#"../bdd.rs" 329 4 329 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 324 15 324 27] Grows0.grows self}
    requires {[#"../bdd.rs" 325 15 325 24] Grows0.grows o}
    requires {[#"../bdd.rs" 326 15 326 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 327 15 327 43]  * self =  * oo /\  ^ self =  ^ oo}
    ensures { result = grows_trans self o oo }
    
  axiom grows_trans_spec : forall self : borrowed (Bdd_Context_Type.t_context), o : borrowed (Bdd_Context_Type.t_context), oo : borrowed (Bdd_Context_Type.t_context) . ([#"../bdd.rs" 324 15 324 27] Grows0.grows self) -> ([#"../bdd.rs" 325 15 325 24] Grows0.grows o) -> ([#"../bdd.rs" 326 15 326 26]  ^ self =  * o) -> ([#"../bdd.rs" 327 15 327 43]  * self =  * oo /\  ^ self =  ^ oo) -> ([#"../bdd.rs" 328 14 328 24] Grows0.grows oo)
end
module Bdd_Impl9_GrowsTrans_Impl
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec ghost function grows_trans [#"../bdd.rs" 329 4 329 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 324 15 324 27] Grows0.grows self}
    requires {[#"../bdd.rs" 325 15 325 24] Grows0.grows o}
    requires {[#"../bdd.rs" 326 15 326 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 327 15 327 43]  * self =  * oo /\  ^ self =  ^ oo}
    ensures { [#"../bdd.rs" 328 14 328 24] Grows0.grows oo }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 323 4 323 12] ()
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel_Stub
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel_Interface
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int =
    UInt64.to_int self
  val shallow_model (self : uint64) : int
    ensures { result = shallow_model self }
    
end
module Bdd_Impl9_SetIrreleventVar_Stub
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function set_irrelevent_var [#"../bdd.rs" 336 4 336 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
end
module Bdd_Impl9_SetIrreleventVar_Interface
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function set_irrelevent_var [#"../bdd.rs" 336 4 336 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  axiom set_irrelevent_var_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 332 15 332 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 333 15 333 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 334 15 334 32] UInt64.to_int x < Leastvar0.leastvar a) -> ([#"../bdd.rs" 335 14 335 50] Interp0.interp a v = Interp0.interp a (Map.set v x b))
end
module Bdd_Impl9_SetIrreleventVar
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function set_irrelevent_var [#"../bdd.rs" 336 4 336 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 338 12 344 13] match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  val set_irrelevent_var [#"../bdd.rs" 336 4 336 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 332 15 332 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 333 15 333 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 334 15 334 32] UInt64.to_int x < Leastvar0.leastvar a}
    ensures { result = set_irrelevent_var self a x v b }
    
  axiom set_irrelevent_var_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 332 15 332 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 333 15 333 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 334 15 334 32] UInt64.to_int x < Leastvar0.leastvar a) -> ([#"../bdd.rs" 335 14 335 50] Interp0.interp a v = Interp0.interp a (Map.set v x b))
end
module Bdd_Impl9_SetIrreleventVar_Impl
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone Bdd_Impl4_ShallowModel as ShallowModel5 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  let rec ghost function set_irrelevent_var [#"../bdd.rs" 336 4 336 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 332 15 332 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 333 15 333 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 334 15 334 32] UInt64.to_int x < Leastvar0.leastvar a}
    ensures { [#"../bdd.rs" 335 14 335 50] Interp0.interp a v = Interp0.interp a (Map.set v x b) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 338 12 344 13] match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
end
module Bdd_Impl9_DiscrValuation_Stub
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function discr_valuation [#"../bdd.rs" 356 4 356 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
end
module Bdd_Impl9_DiscrValuation_Interface
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function discr_valuation [#"../bdd.rs" 356 4 356 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  axiom discr_valuation_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 349 15 349 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 350 15 350 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 351 15 351 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 352 15 352 21] a <> b) -> ([#"../bdd.rs" 353 14 353 50] Interp0.interp a (discr_valuation self a b) <> Interp0.interp b (discr_valuation self a b))
end
module Bdd_Impl9_DiscrValuation
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use map.Const
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  clone Bdd_Impl9_SetIrreleventVar_Stub as SetIrreleventVar0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  function discr_valuation [#"../bdd.rs" 356 4 356 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  val discr_valuation [#"../bdd.rs" 356 4 356 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 349 15 349 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 350 15 350 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 351 15 351 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 352 15 352 21] a <> b}
    ensures { result = discr_valuation self a b }
    
  axiom def : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . discr_valuation self a b = ([#"../bdd.rs" 358 12 358 36] let _ = () in if Leastvar0.leastvar a < Leastvar0.leastvar b then
    match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation self childf b) v false
      else
        Map.set (discr_valuation self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if Leastvar0.leastvar a > Leastvar0.leastvar b then
      match (b) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation self a childf) v false
        else
          Map.set (discr_valuation self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match (a) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match (b) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation self childfa childfb) v false
          else
            Map.set (discr_valuation self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  axiom discr_valuation_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 349 15 349 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 350 15 350 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 351 15 351 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 352 15 352 21] a <> b) -> ([#"../bdd.rs" 353 14 353 50] Interp0.interp a (discr_valuation self a b) <> Interp0.interp b (discr_valuation self a b))
end
module Bdd_Impl9_DiscrValuation_Impl
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use map.Const
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone Bdd_Impl4_ShallowModel as ShallowModel5 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl9_SetIrreleventVar as SetIrreleventVar0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  let rec ghost function discr_valuation [#"../bdd.rs" 356 4 356 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 349 15 349 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 350 15 350 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 351 15 351 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 352 15 352 21] a <> b}
    ensures { [#"../bdd.rs" 353 14 353 50] Interp0.interp a result <> Interp0.interp b result }
    variant {[#"../bdd.rs" 354 14 354 33] Size0.size a + Size0.size b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 358 12 358 36] let _ = () in if let b = Leastvar0.leastvar b in let a = Leastvar0.leastvar a in pure {a < b} then
      match (a) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> b} then
          let a' = discr_valuation self childf b in Map.set a' v false
        else
          let a' = discr_valuation self childt b in Map.set a' v true
        
        | _ -> Const.const true
        end
    else
      if let b = Leastvar0.leastvar b in let a = Leastvar0.leastvar a in pure {a > b} then
        match (b) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> a} then
            let a' = discr_valuation self a childf in Map.set a' v false
          else
            let a' = discr_valuation self a childt in Map.set a' v true
          
          | _ -> Const.const true
          end
      else
        match (a) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match (b) with
            | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if pure {childfa <> childfb} then
              let a' = discr_valuation self childfa childfb in Map.set a' v false
            else
              let a' = discr_valuation self childta childtb in Map.set a' v true
            
            | _ -> Const.const true
            end
          | _ -> Const.const true
          end
      
    
end
module Bdd_Impl9_BddCanonical_Stub
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function bdd_canonical [#"../bdd.rs" 404 4 404 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
end
module Bdd_Impl9_BddCanonical_Interface
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  function bdd_canonical [#"../bdd.rs" 404 4 404 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  axiom bdd_canonical_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 398 15 398 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 399 15 399 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 400 15 400 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 401 4 401 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v) -> ([#"../bdd.rs" 402 14 402 20] a = b)
end
module Bdd_Impl9_BddCanonical
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  clone Bdd_Impl9_DiscrValuation_Stub as DiscrValuation0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Size0.size = Size0.size,
    axiom .
  function bdd_canonical [#"../bdd.rs" 404 4 404 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
   =
    [#"../bdd.rs" 405 8 405 29] let _ = () in ()
  val bdd_canonical [#"../bdd.rs" 404 4 404 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 398 15 398 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 399 15 399 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 400 15 400 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 401 4 401 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v}
    ensures { result = bdd_canonical self a b }
    
  axiom bdd_canonical_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 398 15 398 31] Invariant0.invariant' self) -> ([#"../bdd.rs" 399 15 399 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 400 15 400 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 401 4 401 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v) -> ([#"../bdd.rs" 402 14 402 20] a = b)
end
module Bdd_Impl9_BddCanonical_Impl
  use map.Map
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel4 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl9_SetIrreleventVar as SetIrreleventVar0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  clone Bdd_Impl9_DiscrValuation as DiscrValuation0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Size0.size = Size0.size,
    function SetIrreleventVar0.set_irrelevent_var = SetIrreleventVar0.set_irrelevent_var,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    axiom .
  let rec ghost function bdd_canonical [#"../bdd.rs" 404 4 404 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 398 15 398 31] Invariant0.invariant' self}
    requires {[#"../bdd.rs" 399 15 399 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 400 15 400 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 401 4 401 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v}
    ensures { [#"../bdd.rs" 402 14 402 20] a = b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 405 8 405 29] let _ = () in ()
end
module Bdd_Impl10_New_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  val new [#"../bdd.rs" 410 4 410 52] (alloc : Bdd_Bumpalo_Bump_Type.t_bump) : Bdd_Context_Type.t_context
end
module Bdd_Impl10_New
  use prelude.Borrow
  use prelude.Ghost
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use map.Const
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Hashmap_Impl1_New_Interface as New2 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl1_New_Interface as New1 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl1_New_Interface as New0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  use Bdd_Context_Type as Bdd_Context_Type
  let rec cfg new [#"../bdd.rs" 410 4 410 52] [@cfg:stackify] [@cfg:subregion_analysis] (alloc : Bdd_Bumpalo_Bump_Type.t_bump) : Bdd_Context_Type.t_context
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Context_Type.t_context;
  var alloc_1 : Bdd_Bumpalo_Bump_Type.t_bump;
  var _2 : Bdd_Bumpalo_Bump_Type.t_bump;
  var _3 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
  var _4 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  var _7 : ();
  var _8 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _9 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  {
    alloc_1 <- alloc;
    goto BB0
  }
  BB0 {
    _2 <- alloc_1;
    _3 <- ([#"../bdd.rs" 413 22 413 47] New0.new ());
    goto BB1
  }
  BB1 {
    _7 <- ();
    _4 <- ([#"../bdd.rs" 414 28 414 58] Ghost.new (Const.const (Bdd_Node_Type.C_True)));
    goto BB2
  }
  BB2 {
    _8 <- ([#"../bdd.rs" 415 22 415 47] New1.new ());
    goto BB3
  }
  BB3 {
    _9 <- ([#"../bdd.rs" 416 22 416 47] New2.new ());
    goto BB4
  }
  BB4 {
    _0 <- Bdd_Context_Type.C_Context _2 _3 _4 _8 _9 ([#"../bdd.rs" 417 17 417 18] (0 : uint64));
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Bdd_Impl10_Hashcons_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_IsValidNode_Stub as IsValidNode0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val hashcons [#"../bdd.rs" 427 4 427 58] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 421 15 421 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 422 15 422 36] IsValidNode0.is_valid_node ( * self) n}
    ensures { [#"../bdd.rs" 423 14 423 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 424 14 424 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 425 14 425 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 426 14 426 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    
end
module Bdd_Impl10_Hashcons
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt64
  use prelude.Ghost
  use map.Map
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel8
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel7 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel8.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use map.Map
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel6 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel4 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function ShallowModel1.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Node_Type.t_node
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  clone Bdd_Bumpalo_Impl0_Alloc_Interface as Alloc0 with
    type t = Bdd_Node_Type.t_node
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel4.shallow_model
  let rec cfg hashcons [#"../bdd.rs" 427 4 427 58] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 421 15 421 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 422 15 422 36] IsValidNode0.is_valid_node ( * self) n}
    ensures { [#"../bdd.rs" 423 14 423 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 424 14 424 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 425 14 425 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 426 14 426 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var n_2 : Bdd_Node_Type.t_node;
  var _9 : ();
  var _10 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _11 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
  var _12 : Bdd_Node_Type.t_node;
  var _13 : Bdd_Node_Type.t_node;
  var _14 : isize;
  var r_15 : Bdd_Bdd_Type.t_bdd;
  var _16 : ();
  var _17 : ();
  var r_19 : Bdd_Bdd_Type.t_bdd;
  var _20 : Bdd_Node_Type.t_node;
  var _21 : borrowed (Bdd_Node_Type.t_node);
  var _22 : Bdd_Bumpalo_Bump_Type.t_bump;
  var _23 : Bdd_Node_Type.t_node;
  var _24 : uint64;
  var _25 : ();
  var _26 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd));
  var _27 : Bdd_Node_Type.t_node;
  var _28 : Bdd_Bdd_Type.t_bdd;
  var _29 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  var _31 : ();
  var _32 : ();
  var _33 : bool;
  var _34 : uint64;
  var _35 : uint64;
  var _36 : ();
  var _37 : ();
  {
    self_1 <- self;
    n_2 <- n;
    goto BB0
  }
  BB0 {
    _11 <- Bdd_Context_Type.context_hashcons ( * self_1);
    _13 <- n_2;
    _12 <- _13;
    _10 <- ([#"../bdd.rs" 428 26 428 47] Get0.get _11 _12);
    goto BB1
  }
  BB1 {
    switch (_10)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB3
      end
  }
  BB2 {
    assume { Resolve1.resolve self_1 };
    r_15 <- Core_Option_Option_Type.some_0 _10;
    assert { [#"../bdd.rs" 429 28 429 38] ShallowModel0.shallow_model (Bdd_Bdd_Type.bdd_0 r_15) = ShallowModel1.shallow_model n_2 };
    _17 <- ();
    _0 <- r_15;
    goto BB10
  }
  BB3 {
    _9 <- ();
    _22 <- Bdd_Context_Type.context_alloc ( * self_1);
    _23 <- n_2;
    _21 <- ([#"../bdd.rs" 432 20 432 39] Alloc0.alloc _22 _23);
    goto BB4
  }
  BB4 {
    _20 <-  * _21;
    assume { Resolve0.resolve _21 };
    _24 <- Bdd_Context_Type.context_cnt ( * self_1);
    r_19 <- Bdd_Bdd_Type.C_Bdd _20 _24;
    _26 <- borrow_mut (Bdd_Context_Type.context_hashcons ( * self_1));
    self_1 <- { self_1 with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self_1 in Bdd_Context_Type.C_Context a ( ^ _26) c d e f) };
    _27 <- n_2;
    _28 <- r_19;
    _25 <- ([#"../bdd.rs" 433 8 433 31] Add0.add _26 _27 _28);
    goto BB5
  }
  BB5 {
    _31 <- ();
    _29 <- ([#"../bdd.rs" 434 30 434 88] Ghost.new (Map.set (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost ( * self_1))) (Bdd_Bdd_Type.bdd_1 r_19) (Bdd_Bdd_Type.bdd_0 r_19)));
    goto BB6
  }
  BB6 {
    self_1 <- { self_1 with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self_1 in Bdd_Context_Type.C_Context a b _29 d e f) };
    _29 <- any Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
    _34 <- Bdd_Context_Type.context_cnt ( * self_1);
    _35 <- ([#"../bdd.rs" 435 22 435 34] ([#"../bdd.rs" 435 22 435 30] (18446744073709551615 : uint64)) - ([#"../bdd.rs" 435 33 435 34] (1 : uint64)));
    _33 <- ([#"../bdd.rs" 435 11 435 34] _34 > _35);
    switch (_33)
      | False -> goto BB9
      | True -> goto BB7
      end
  }
  BB7 {
    assume { Resolve1.resolve self_1 };
    goto BB8
  }
  BB8 {
    _37 <- ();
    goto BB8
  }
  BB9 {
    _32 <- ();
    self_1 <- { self_1 with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self_1 in Bdd_Context_Type.C_Context a b c d e ([#"../bdd.rs" 438 8 438 21] Bdd_Context_Type.context_cnt ( * self_1) + ([#"../bdd.rs" 438 20 438 21] (1 : uint64)))) };
    assume { Resolve1.resolve self_1 };
    _0 <- r_19;
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Bdd_Impl10_Node_Interface
  use prelude.Borrow
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val node [#"../bdd.rs" 451 4 451 87] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 442 15 442 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 443 15 443 40] IsValidBdd0.is_valid_bdd ( * self) childt}
    requires {[#"../bdd.rs" 444 15 444 40] IsValidBdd0.is_valid_bdd ( * self) childf}
    requires {[#"../bdd.rs" 445 15 445 63] UInt64.to_int x < Leastvar0.leastvar childt /\ UInt64.to_int x < Leastvar0.leastvar childf}
    ensures { [#"../bdd.rs" 446 14 446 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 447 14 447 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 448 14 448 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 449 4 449 106] forall v : Map.map uint64 bool . Interp0.interp result v = (if Map.get v x then
      Interp0.interp childt v
    else
      Interp0.interp childf v
    ) }
    ensures { [#"../bdd.rs" 450 14 450 37] UInt64.to_int x <= Leastvar0.leastvar result }
    
end
module Bdd_Impl10_Node
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel1
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl6_ShallowModel as ShallowModel8 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel7
  clone Bdd_Impl4_ShallowModel as ShallowModel6 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel8.shallow_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_Hashcons_Interface as Hashcons0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl7_Eq_Interface as Eq0 with
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  let rec cfg node [#"../bdd.rs" 451 4 451 87] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 442 15 442 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 443 15 443 40] IsValidBdd0.is_valid_bdd ( * self) childt}
    requires {[#"../bdd.rs" 444 15 444 40] IsValidBdd0.is_valid_bdd ( * self) childf}
    requires {[#"../bdd.rs" 445 15 445 63] UInt64.to_int x < Leastvar0.leastvar childt /\ UInt64.to_int x < Leastvar0.leastvar childf}
    ensures { [#"../bdd.rs" 446 14 446 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 447 14 447 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 448 14 448 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 449 4 449 106] forall v : Map.map uint64 bool . Interp0.interp result v = (if Map.get v x then
      Interp0.interp childt v
    else
      Interp0.interp childf v
    ) }
    ensures { [#"../bdd.rs" 450 14 450 37] UInt64.to_int x <= Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var x_2 : uint64;
  var childt_3 : Bdd_Bdd_Type.t_bdd;
  var childf_4 : Bdd_Bdd_Type.t_bdd;
  var _14 : ();
  var _15 : bool;
  var _16 : Bdd_Bdd_Type.t_bdd;
  var _17 : Bdd_Bdd_Type.t_bdd;
  var _18 : ();
  var _19 : borrowed (Bdd_Context_Type.t_context);
  var _20 : Bdd_Node_Type.t_node;
  var _21 : uint64;
  var _22 : Bdd_Bdd_Type.t_bdd;
  var _23 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    x_2 <- x;
    childt_3 <- childt;
    childf_4 <- childf;
    goto BB0
  }
  BB0 {
    _16 <- childt_3;
    _17 <- childf_4;
    _15 <- ([#"../bdd.rs" 452 11 452 27] Eq0.eq _16 _17);
    goto BB1
  }
  BB1 {
    switch (_15)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    _0 <- childt_3;
    goto BB5
  }
  BB3 {
    _14 <- ();
    _19 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _19) };
    assume { Resolve0.resolve self_1 };
    _21 <- x_2;
    _22 <- childt_3;
    _23 <- childf_4;
    _20 <- Bdd_Node_Type.C_If _21 _22 _23;
    _0 <- ([#"../bdd.rs" 455 8 455 50] Hashcons0.hashcons _19 _20);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Bdd_Impl10_True_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val true_ [#"../bdd.rs" 464 4 464 42] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 459 14 459 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 460 14 460 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 461 14 461 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 462 4 462 44] forall v : Map.map uint64 bool . Interp0.interp result v }
    ensures { [#"../bdd.rs" 463 14 463 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
end
module Bdd_Impl10_True
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone Bdd_Impl4_ShallowModel as ShallowModel5 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_Hashcons_Interface as Hashcons0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  let rec cfg true_ [#"../bdd.rs" 464 4 464 42] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 459 14 459 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 460 14 460 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 461 14 461 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 462 4 462 44] forall v : Map.map uint64 bool . Interp0.interp result v }
    ensures { [#"../bdd.rs" 463 14 463 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var _8 : borrowed (Bdd_Context_Type.t_context);
  var _9 : Bdd_Node_Type.t_node;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _8 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _8) };
    assume { Resolve0.resolve self_1 };
    _9 <- Bdd_Node_Type.C_True;
    _0 <- ([#"../bdd.rs" 465 8 465 27] Hashcons0.hashcons _8 _9);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module Bdd_Impl10_False_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val false_ [#"../bdd.rs" 474 4 474 43] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 468 15 468 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 469 14 469 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 470 14 470 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 471 14 471 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 472 4 472 45] forall v : Map.map uint64 bool . not Interp0.interp result v }
    ensures { [#"../bdd.rs" 473 14 473 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
end
module Bdd_Impl10_False
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone Bdd_Impl4_ShallowModel as ShallowModel5 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_Hashcons_Interface as Hashcons0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  let rec cfg false_ [#"../bdd.rs" 474 4 474 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 468 15 468 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 469 14 469 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 470 14 470 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 471 14 471 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 472 4 472 45] forall v : Map.map uint64 bool . not Interp0.interp result v }
    ensures { [#"../bdd.rs" 473 14 473 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var _8 : borrowed (Bdd_Context_Type.t_context);
  var _9 : Bdd_Node_Type.t_node;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _8 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _8) };
    assume { Resolve0.resolve self_1 };
    _9 <- Bdd_Node_Type.C_False;
    _0 <- ([#"../bdd.rs" 475 8 475 28] Hashcons0.hashcons _8 _9);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module Bdd_Impl10_V_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val v [#"../bdd.rs" 483 4 483 46] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 478 15 478 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 479 14 479 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 480 14 480 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 481 14 481 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 56] forall v : Map.map uint64 bool . Interp0.interp result v = Map.get v x }
    
end
module Bdd_Impl10_V
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Bdd_Impl4_ShallowModel as ShallowModel4 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_Node_Interface as Node0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_False_Interface as False0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl10_True_Interface as True0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  let rec cfg v [#"../bdd.rs" 483 4 483 46] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 478 15 478 31] Invariant0.invariant' ( * self)}
    ensures { [#"../bdd.rs" 479 14 479 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 480 14 480 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 481 14 481 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 56] forall v : Map.map uint64 bool . Interp0.interp result v = Map.get v x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var x_2 : uint64;
  var t_8 : Bdd_Bdd_Type.t_bdd;
  var _9 : borrowed (Bdd_Context_Type.t_context);
  var f_10 : Bdd_Bdd_Type.t_bdd;
  var _11 : borrowed (Bdd_Context_Type.t_context);
  var _12 : borrowed (Bdd_Context_Type.t_context);
  var _13 : uint64;
  var _14 : Bdd_Bdd_Type.t_bdd;
  var _15 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    x_2 <- x;
    goto BB0
  }
  BB0 {
    _9 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _9) };
    t_8 <- ([#"../bdd.rs" 484 16 484 28] True0.true_ _9);
    goto BB1
  }
  BB1 {
    _11 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _11) };
    f_10 <- ([#"../bdd.rs" 485 16 485 29] False0.false_ _11);
    goto BB2
  }
  BB2 {
    _12 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _12) };
    assume { Resolve0.resolve self_1 };
    _13 <- x_2;
    _14 <- t_8;
    _15 <- f_10;
    _0 <- ([#"../bdd.rs" 486 8 486 26] Node0.node _12 _13 _14 _15);
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Bdd_Impl10_Not_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val not' [#"../bdd.rs" 497 4 497 56] (self : borrowed (Bdd_Context_Type.t_context)) (x : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 489 15 489 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 490 15 490 35] IsValidBdd0.is_valid_bdd ( * self) x}
    ensures { [#"../bdd.rs" 491 14 491 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 492 14 492 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 493 14 493 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 494 4 494 60] forall v : Map.map uint64 bool . Interp0.interp result v = (not Interp0.interp x v) }
    ensures { [#"../bdd.rs" 495 14 495 47] Leastvar0.leastvar x <= Leastvar0.leastvar result }
    
end
module Bdd_Impl10_Not
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel2
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel8
  clone Bdd_Impl4_ShallowModel as ShallowModel7 with
    function DeepModel0.deep_model = DeepModel2.deep_model
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use map.Map
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel6 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel8.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function ShallowModel1.shallow_model = ShallowModel6.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_True_Interface as True0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl10_False_Interface as False0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl10_Node_Interface as Node1 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  let rec cfg not' [#"../bdd.rs" 497 4 497 56] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 489 15 489 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 490 15 490 35] IsValidBdd0.is_valid_bdd ( * self) x}
    ensures { [#"../bdd.rs" 491 14 491 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 492 14 492 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 493 14 493 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 494 4 494 60] forall v : Map.map uint64 bool . Interp0.interp result v = (not Interp0.interp x v) }
    ensures { [#"../bdd.rs" 495 14 495 47] Leastvar0.leastvar x <= Leastvar0.leastvar result }
    variant {[#"../bdd.rs" 496 14 496 22] Size0.size x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var x_2 : Bdd_Bdd_Type.t_bdd;
  var _11 : ();
  var _12 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _13 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _14 : Bdd_Bdd_Type.t_bdd;
  var _15 : Bdd_Bdd_Type.t_bdd;
  var _16 : isize;
  var r_17 : Bdd_Bdd_Type.t_bdd;
  var _18 : ();
  var r_19 : Bdd_Bdd_Type.t_bdd;
  var _20 : isize;
  var _21 : borrowed (Bdd_Context_Type.t_context);
  var _22 : borrowed (Bdd_Context_Type.t_context);
  var v_23 : uint64;
  var childt_24 : Bdd_Bdd_Type.t_bdd;
  var childf_25 : Bdd_Bdd_Type.t_bdd;
  var childt_26 : Bdd_Bdd_Type.t_bdd;
  var _27 : borrowed (Bdd_Context_Type.t_context);
  var _28 : Bdd_Bdd_Type.t_bdd;
  var childf_29 : Bdd_Bdd_Type.t_bdd;
  var _30 : borrowed (Bdd_Context_Type.t_context);
  var _31 : Bdd_Bdd_Type.t_bdd;
  var _32 : borrowed (Bdd_Context_Type.t_context);
  var _33 : uint64;
  var _34 : Bdd_Bdd_Type.t_bdd;
  var _35 : Bdd_Bdd_Type.t_bdd;
  var _36 : ();
  var _37 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  var _38 : Bdd_Bdd_Type.t_bdd;
  var _39 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    x_2 <- x;
    goto BB0
  }
  BB0 {
    _13 <- Bdd_Context_Type.context_not_memo ( * self_1);
    _15 <- x_2;
    _14 <- _15;
    _12 <- ([#"../bdd.rs" 498 25 498 46] Get0.get _13 _14);
    goto BB1
  }
  BB1 {
    switch (_12)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB3
      end
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    r_17 <- Core_Option_Option_Type.some_0 _12;
    _0 <- r_17;
    goto BB15
  }
  BB3 {
    _11 <- ();
    switch (Bdd_Bdd_Type.bdd_0 x_2)
      | Bdd_Node_Type.C_False -> goto BB8
      | Bdd_Node_Type.C_True -> goto BB6
      | Bdd_Node_Type.C_If _ _ _ -> goto BB4
      end
  }
  BB4 {
    v_23 <- Bdd_Node_Type.if_v (Bdd_Bdd_Type.bdd_0 x_2);
    childt_24 <- Bdd_Node_Type.if_childt (Bdd_Bdd_Type.bdd_0 x_2);
    childf_25 <- Bdd_Node_Type.if_childf (Bdd_Bdd_Type.bdd_0 x_2);
    _27 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _27) };
    _28 <- childt_24;
    childt_26 <- ([#"../bdd.rs" 505 29 505 45] not' _27 _28);
    goto BB10
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB6 {
    _21 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _21) };
    r_19 <- ([#"../bdd.rs" 502 20 502 33] False0.false_ _21);
    goto BB7
  }
  BB7 {
    goto BB13
  }
  BB8 {
    _22 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _22) };
    r_19 <- ([#"../bdd.rs" 503 21 503 33] True0.true_ _22);
    goto BB9
  }
  BB9 {
    goto BB13
  }
  BB10 {
    _30 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _30) };
    _31 <- childf_25;
    childf_29 <- ([#"../bdd.rs" 506 29 506 45] not' _30 _31);
    goto BB11
  }
  BB11 {
    _32 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _32) };
    _33 <- v_23;
    _34 <- childt_26;
    _35 <- childf_29;
    r_19 <- ([#"../bdd.rs" 507 16 507 44] Node1.node _32 _33 _34 _35);
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    _37 <- borrow_mut (Bdd_Context_Type.context_not_memo ( * self_1));
    self_1 <- { self_1 with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self_1 in Bdd_Context_Type.C_Context a b c ( ^ _37) e f) };
    assume { Resolve0.resolve self_1 };
    _38 <- x_2;
    _39 <- r_19;
    _36 <- ([#"../bdd.rs" 510 8 510 31] Add0.add _37 _38 _39);
    goto BB14
  }
  BB14 {
    _0 <- r_19;
    goto BB15
  }
  BB15 {
    return _0
  }
  
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module CreusotContracts_Logic_Ord_Impl2_CmpLog_Stub
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_Impl2_CmpLog_Interface
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_Impl2_CmpLog
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering =
    if self < o then
      Core_Cmp_Ordering_Type.C_Less
    else
      if self = o then Core_Cmp_Ordering_Type.C_Equal else Core_Cmp_Ordering_Type.C_Greater
    
  val cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self o }
    
end
module Core_Cmp_Impls_Impl63_Cmp_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_Impl2_CmpLog_Stub as CmpLog0
  clone CreusotContracts_Std1_Num_Impl10_DeepModel_Stub as DeepModel0
  val cmp (self : uint64) (other : uint64) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    
end
module Bdd_Impl10_And_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl9_Grows_Stub as Grows0
  clone Bdd_Impl9_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  val and [#"../bdd.rs" 523 4 523 72] (self : borrowed (Bdd_Context_Type.t_context)) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 514 15 514 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 515 15 515 35] IsValidBdd0.is_valid_bdd ( * self) a}
    requires {[#"../bdd.rs" 516 15 516 35] IsValidBdd0.is_valid_bdd ( * self) b}
    ensures { [#"../bdd.rs" 517 14 517 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 518 14 518 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 519 14 519 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 520 4 520 76] forall v : Map.map uint64 bool . Interp0.interp result v = (Interp0.interp a v /\ Interp0.interp b v) }
    ensures { [#"../bdd.rs" 521 14 521 84] Leastvar0.leastvar a <= Leastvar0.leastvar result \/ Leastvar0.leastvar b <= Leastvar0.leastvar result }
    
end
module Bdd_Impl10_And
  use prelude.Borrow
  use prelude.Int
  use prelude.IntSize
  use prelude.UInt64
  use prelude.Int8
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel4
  clone Bdd_Impl5_DeepModel as DeepModel3
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel8
  clone Bdd_Impl4_ShallowModel as ShallowModel7 with
    function DeepModel0.deep_model = DeepModel4.deep_model
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  use map.Map
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel6 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel2 with
    type a = Bdd_Bdd_Type.t_bdd,
    type b = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    type DeepModelTy1.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_Impl2_CmpLog as CmpLog0
  clone CreusotContracts_Std1_Num_Impl10_DeepModel as DeepModel1
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve4 with
    type t = Bdd_Node_Type.t_node
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type DeepModelTy0.deepModelTy = (uint64, uint64),
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel5 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve3 with
    type t = Bdd_Bdd_Type.t_bdd
  use prelude.Int
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel4 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel8.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl0_ShallowModel as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl9_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function ShallowModel1.shallow_model = ShallowModel6.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_False_Interface as False0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl10_Node_Interface as Node1 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone Core_Cmp_Impls_Impl63_Cmp_Interface as Cmp0 with
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve2 with
    type t1 = Bdd_Node_Type.t_node,
    type t2 = Bdd_Node_Type.t_node,
    predicate Resolve0.resolve = Resolve4.resolve,
    predicate Resolve1.resolve = Resolve4.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Bdd_Bdd_Type.t_bdd,
    type t2 = Bdd_Bdd_Type.t_bdd,
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  let rec cfg and [#"../bdd.rs" 523 4 523 72] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 514 15 514 31] Invariant0.invariant' ( * self)}
    requires {[#"../bdd.rs" 515 15 515 35] IsValidBdd0.is_valid_bdd ( * self) a}
    requires {[#"../bdd.rs" 516 15 516 35] IsValidBdd0.is_valid_bdd ( * self) b}
    ensures { [#"../bdd.rs" 517 14 517 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"../bdd.rs" 518 14 518 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 519 14 519 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 520 4 520 76] forall v : Map.map uint64 bool . Interp0.interp result v = (Interp0.interp a v /\ Interp0.interp b v) }
    ensures { [#"../bdd.rs" 521 14 521 84] Leastvar0.leastvar a <= Leastvar0.leastvar result \/ Leastvar0.leastvar b <= Leastvar0.leastvar result }
    variant {[#"../bdd.rs" 522 14 522 33] Size0.size a + Size0.size b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self_1 : borrowed (Bdd_Context_Type.t_context);
  var a_2 : Bdd_Bdd_Type.t_bdd;
  var b_3 : Bdd_Bdd_Type.t_bdd;
  var _13 : ();
  var _14 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _15 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _16 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _17 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _18 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _19 : Bdd_Bdd_Type.t_bdd;
  var _20 : Bdd_Bdd_Type.t_bdd;
  var _21 : isize;
  var r_22 : Bdd_Bdd_Type.t_bdd;
  var _23 : ();
  var r_24 : Bdd_Bdd_Type.t_bdd;
  var _25 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var _26 : Bdd_Node_Type.t_node;
  var _27 : Bdd_Node_Type.t_node;
  var _28 : isize;
  var _29 : isize;
  var _30 : isize;
  var _31 : isize;
  var _32 : isize;
  var _33 : borrowed (Bdd_Context_Type.t_context);
  var va_34 : uint64;
  var childta_35 : Bdd_Bdd_Type.t_bdd;
  var childfa_36 : Bdd_Bdd_Type.t_bdd;
  var vb_37 : uint64;
  var childtb_38 : Bdd_Bdd_Type.t_bdd;
  var childfb_39 : Bdd_Bdd_Type.t_bdd;
  var v_40 : uint64;
  var childt_41 : Bdd_Bdd_Type.t_bdd;
  var childf_42 : Bdd_Bdd_Type.t_bdd;
  var _43 : ();
  var _44 : Core_Cmp_Ordering_Type.t_ordering;
  var _45 : uint64;
  var _46 : uint64;
  var _47 : uint64;
  var _48 : int8;
  var _49 : uint64;
  var _50 : Bdd_Bdd_Type.t_bdd;
  var _51 : borrowed (Bdd_Context_Type.t_context);
  var _52 : Bdd_Bdd_Type.t_bdd;
  var _53 : Bdd_Bdd_Type.t_bdd;
  var _54 : Bdd_Bdd_Type.t_bdd;
  var _55 : borrowed (Bdd_Context_Type.t_context);
  var _56 : Bdd_Bdd_Type.t_bdd;
  var _57 : Bdd_Bdd_Type.t_bdd;
  var _58 : uint64;
  var _59 : Bdd_Bdd_Type.t_bdd;
  var _60 : borrowed (Bdd_Context_Type.t_context);
  var _61 : Bdd_Bdd_Type.t_bdd;
  var _62 : Bdd_Bdd_Type.t_bdd;
  var _63 : Bdd_Bdd_Type.t_bdd;
  var _64 : borrowed (Bdd_Context_Type.t_context);
  var _65 : Bdd_Bdd_Type.t_bdd;
  var _66 : Bdd_Bdd_Type.t_bdd;
  var _67 : uint64;
  var _68 : Bdd_Bdd_Type.t_bdd;
  var _69 : borrowed (Bdd_Context_Type.t_context);
  var _70 : Bdd_Bdd_Type.t_bdd;
  var _71 : Bdd_Bdd_Type.t_bdd;
  var _72 : Bdd_Bdd_Type.t_bdd;
  var _73 : borrowed (Bdd_Context_Type.t_context);
  var _74 : Bdd_Bdd_Type.t_bdd;
  var _75 : Bdd_Bdd_Type.t_bdd;
  var _76 : borrowed (Bdd_Context_Type.t_context);
  var _77 : uint64;
  var _78 : Bdd_Bdd_Type.t_bdd;
  var _79 : Bdd_Bdd_Type.t_bdd;
  var _80 : ();
  var _81 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  var _82 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _83 : Bdd_Bdd_Type.t_bdd;
  var _84 : Bdd_Bdd_Type.t_bdd;
  var _85 : Bdd_Bdd_Type.t_bdd;
  {
    self_1 <- self;
    a_2 <- a;
    b_3 <- b;
    goto BB0
  }
  BB0 {
    _15 <- Bdd_Context_Type.context_and_memo ( * self_1);
    _19 <- a_2;
    _20 <- b_3;
    _18 <- (_19, _20);
    _17 <- _18;
    assume { Resolve0.resolve _18 };
    _16 <- _17;
    _14 <- ([#"../bdd.rs" 524 25 524 51] Get0.get _15 _16);
    goto BB1
  }
  BB1 {
    switch (_14)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB3
      end
  }
  BB2 {
    assume { Resolve1.resolve self_1 };
    r_22 <- Core_Option_Option_Type.some_0 _14;
    _0 <- r_22;
    goto BB29
  }
  BB3 {
    _13 <- ();
    _26 <- Bdd_Bdd_Type.bdd_0 a_2;
    _27 <- Bdd_Bdd_Type.bdd_0 b_3;
    _25 <- (_26, _27);
    switch (let (a, _) = _25 in a)
      | Bdd_Node_Type.C_True -> goto BB10
      | _ -> goto BB4
      end
  }
  BB4 {
    switch (let (_, a) = _25 in a)
      | Bdd_Node_Type.C_True -> goto BB11
      | _ -> goto BB5
      end
  }
  BB5 {
    switch (let (a, _) = _25 in a)
      | Bdd_Node_Type.C_False -> goto BB12
      | _ -> goto BB6
      end
  }
  BB6 {
    switch (let (_, a) = _25 in a)
      | Bdd_Node_Type.C_False -> goto BB12
      | Bdd_Node_Type.C_If _ _ _ -> goto BB8
      | _ -> goto BB7
      end
  }
  BB7 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve _25 };
    absurd
  }
  BB8 {
    switch (let (a, _) = _25 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB9
      | _ -> goto BB7
      end
  }
  BB9 {
    vb_37 <- Bdd_Node_Type.if_v (let (_, a) = _25 in a);
    childtb_38 <- Bdd_Node_Type.if_childt (let (_, a) = _25 in a);
    childfb_39 <- Bdd_Node_Type.if_childf (let (_, a) = _25 in a);
    va_34 <- Bdd_Node_Type.if_v (let (a, _) = _25 in a);
    childta_35 <- Bdd_Node_Type.if_childt (let (a, _) = _25 in a);
    childfa_36 <- Bdd_Node_Type.if_childf (let (a, _) = _25 in a);
    assume { Resolve2.resolve _25 };
    _45 <- va_34;
    _47 <- vb_37;
    _46 <- _47;
    _44 <- ([#"../bdd.rs" 536 22 536 33] Cmp0.cmp _45 _46);
    goto BB14
  }
  BB10 {
    assume { Resolve2.resolve _25 };
    r_24 <- b_3;
    goto BB27
  }
  BB11 {
    assume { Resolve2.resolve _25 };
    r_24 <- a_2;
    goto BB27
  }
  BB12 {
    assume { Resolve2.resolve _25 };
    _33 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _33) };
    r_24 <- ([#"../bdd.rs" 530 39 530 52] False0.false_ _33);
    goto BB13
  }
  BB13 {
    goto BB27
  }
  BB14 {
    switch (_44)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB20
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB15
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB17
      end
  }
  BB15 {
    _67 <- va_34;
    v_40 <- _67;
    _67 <- any uint64;
    _69 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _69) };
    _70 <- childta_35;
    _71 <- childtb_38;
    _68 <- ([#"../bdd.rs" 549 33 549 59] and _69 _70 _71);
    goto BB23
  }
  BB16 {
    assume { Resolve1.resolve self_1 };
    absurd
  }
  BB17 {
    _49 <- vb_37;
    v_40 <- _49;
    _49 <- any uint64;
    _51 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _51) };
    _52 <- a_2;
    _53 <- childtb_38;
    _50 <- ([#"../bdd.rs" 539 33 539 53] and _51 _52 _53);
    goto BB18
  }
  BB18 {
    childt_41 <- _50;
    _50 <- any Bdd_Bdd_Type.t_bdd;
    _55 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _55) };
    _56 <- a_2;
    _57 <- childfb_39;
    _54 <- ([#"../bdd.rs" 540 33 540 53] and _55 _56 _57);
    goto BB19
  }
  BB19 {
    childf_42 <- _54;
    _54 <- any Bdd_Bdd_Type.t_bdd;
    _43 <- ();
    goto BB25
  }
  BB20 {
    _58 <- va_34;
    v_40 <- _58;
    _58 <- any uint64;
    _60 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _60) };
    _61 <- childta_35;
    _62 <- b_3;
    _59 <- ([#"../bdd.rs" 544 33 544 53] and _60 _61 _62);
    goto BB21
  }
  BB21 {
    childt_41 <- _59;
    _59 <- any Bdd_Bdd_Type.t_bdd;
    _64 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _64) };
    _65 <- childfa_36;
    _66 <- b_3;
    _63 <- ([#"../bdd.rs" 545 33 545 53] and _64 _65 _66);
    goto BB22
  }
  BB22 {
    childf_42 <- _63;
    _63 <- any Bdd_Bdd_Type.t_bdd;
    _43 <- ();
    goto BB25
  }
  BB23 {
    childt_41 <- _68;
    _68 <- any Bdd_Bdd_Type.t_bdd;
    _73 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _73) };
    _74 <- childfa_36;
    _75 <- childfb_39;
    _72 <- ([#"../bdd.rs" 550 33 550 59] and _73 _74 _75);
    goto BB24
  }
  BB24 {
    childf_42 <- _72;
    _72 <- any Bdd_Bdd_Type.t_bdd;
    _43 <- ();
    goto BB25
  }
  BB25 {
    _76 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _76) };
    _77 <- v_40;
    _78 <- childt_41;
    _79 <- childf_42;
    r_24 <- ([#"../bdd.rs" 553 16 553 44] Node1.node _76 _77 _78 _79);
    goto BB26
  }
  BB26 {
    goto BB27
  }
  BB27 {
    _81 <- borrow_mut (Bdd_Context_Type.context_and_memo ( * self_1));
    self_1 <- { self_1 with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self_1 in Bdd_Context_Type.C_Context a b c d ( ^ _81) f) };
    assume { Resolve1.resolve self_1 };
    _83 <- a_2;
    _84 <- b_3;
    _82 <- (_83, _84);
    _85 <- r_24;
    _80 <- ([#"../bdd.rs" 556 8 556 36] Add0.add _81 _82 _85);
    goto BB28
  }
  BB28 {
    _0 <- r_24;
    goto BB29
  }
  BB29 {
    return _0
  }
  
end
module Bdd_Hashmap_Impl0
  type k
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel2 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog2 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog1 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel1 with
    type a = u,
    type b = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model
  clone Bdd_Hashmap_Impl2_HashLog as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function HashLog0.hash_log = HashLog1.hash_log,
    function HashLog1.hash_log = HashLog2.hash_log,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy),
    function DeepModel0.deep_model = DeepModel1.deep_model
  goal hash_refn : [#"../bdd.rs" 74 8 74 29] forall self : (u, v) . forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self)
end
module Bdd_Impl1
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Bdd_Impl1_HashLog as HashLog0 with
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal hash_refn : [#"../bdd.rs" 113 4 113 25] forall self : Bdd_Node_Type.t_node . forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self)
end
module Bdd_Impl2
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Bdd_Impl2_HashLog as HashLog0
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal hash_refn : [#"../bdd.rs" 138 4 138 25] forall self : Bdd_Bdd_Type.t_bdd . forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self)
end
module Bdd_Impl11
  
end
module Bdd_Impl17
  
end
module Bdd_Impl12
  
end
module Bdd_Impl18
  
end
module Bdd_Impl13
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  goal eq_refn : [#"../bdd.rs" 87 13 87 22] forall self : Bdd_Node_Type.t_node . forall other : Bdd_Node_Type.t_node . forall result : bool . result = (DeepModel0.deep_model self = DeepModel0.deep_model other) -> result = (DeepModel0.deep_model self = DeepModel0.deep_model other)
end
module Bdd_Impl7
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal eq_refn : [#"../bdd.rs" 193 4 193 34] forall self : Bdd_Bdd_Type.t_bdd . forall other : Bdd_Bdd_Type.t_bdd . forall result : bool . result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model other) -> result = (DeepModel0.deep_model self = DeepModel0.deep_model other)
end
module Bdd_Impl14
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  goal clone'_refn : [#"../bdd.rs" 87 24 87 29] forall self : Bdd_Node_Type.t_node . forall result : Bdd_Node_Type.t_node . result = self -> result = self
end
module Bdd_Impl0
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  goal clone'_refn : [#"../bdd.rs" 106 4 106 27] forall self : Bdd_Bdd_Type.t_bdd . forall result : Bdd_Bdd_Type.t_bdd . result = self -> result = self
end
module Bdd_Impl15
  
end
module Bdd_Impl16
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
