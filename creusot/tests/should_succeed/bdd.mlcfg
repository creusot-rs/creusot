
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Bumpalo_Impl0_Alloc_Interface
  type t
  use prelude.Borrow
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = borrowed t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  val alloc [#"../bdd.rs" 18 8 18 48] (self : Bdd_Bumpalo_Bump_Type.t_bump) (val' : t) : borrowed t
    requires {[#"../bdd.rs" 18 31 18 34] Inv0.inv val'}
    ensures { [#"../bdd.rs" 17 18 17 32]  * result = val' }
    ensures { [#"../bdd.rs" 18 42 18 48] Inv1.inv result }
    
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module Bdd_Hashmap_Impl0_ShallowModel_Stub
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
end
module Bdd_Hashmap_Impl0_ShallowModel_Interface
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
  val shallow_model [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    ensures { result = shallow_model self }
    
end
module Bdd_Hashmap_Impl0_ShallowModel
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  function shallow_model [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    
  val shallow_model [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Bdd_Hashmap_Impl1_Add_Interface
  type k
  type v
  use prelude.Borrow
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel1 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v,
    type ShallowModelTy0.shallowModelTy = Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  val add [#"../bdd.rs" 54 8 54 45] (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v)) (key : k) (val' : v) : ()
    requires {[#"../bdd.rs" 54 30 54 33] Inv0.inv key}
    requires {[#"../bdd.rs" 54 38 54 41] Inv1.inv val'}
    ensures { [#"../bdd.rs" 52 8 52 128] forall i : DeepModelTy0.deepModelTy . Inv2.inv i -> Map.get (ShallowModel0.shallow_model ( ^ self)) i = (if i = DeepModel0.deep_model key then
      Core_Option_Option_Type.C_Some val'
    else
      Map.get (ShallowModel1.shallow_model self) i
    ) }
    
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl4_DeepModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl4_DeepModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Model_Impl4_DeepModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = t,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : t) : DeepModelTy0.deepModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] DeepModel0.deep_model self
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module Bdd_Hashmap_Impl1_Get_Interface
  type k
  type v
  use prelude.Borrow
  use map.Map
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v,
    type ShallowModelTy0.shallowModelTy = Map.map DeepModelTy0.deepModelTy (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  val get [#"../bdd.rs" 63 8 63 65] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"../bdd.rs" 63 37 63 40] Inv0.inv key}
    ensures { [#"../bdd.rs" 58 18 61 9] match (result) with
      | Core_Option_Option_Type.C_Some v -> Map.get (ShallowModel0.shallow_model self) (DeepModel0.deep_model key) = Core_Option_Option_Type.C_Some v
      | Core_Option_Option_Type.C_None -> Map.get (ShallowModel0.shallow_model self) (DeepModel0.deep_model key) = Core_Option_Option_Type.C_None
      end }
    ensures { [#"../bdd.rs" 63 52 63 65] Inv1.inv result }
    
end
module Bdd_Hashmap_Impl1_New_Interface
  type k
  type v
  use map.Const
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = k,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val new [#"../bdd.rs" 69 8 69 28] (_1 : ()) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap k v
    ensures { [#"../bdd.rs" 67 18 67 47] ShallowModel0.shallow_model result = Const.const (Core_Option_Option_Type.C_None) }
    
end
module Bdd_Hashmap_Hash_HashLog_Stub
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 34 8 34 49] (_1 : DeepModelTy0.deepModelTy) : int
end
module Bdd_Hashmap_Hash_HashLog_Interface
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 34 8 34 49] (_1 : DeepModelTy0.deepModelTy) : int
  val hash_log [#"../bdd.rs" 34 8 34 49] (_1 : DeepModelTy0.deepModelTy) : int
    ensures { result = hash_log _1 }
    
end
module Bdd_Hashmap_Hash_HashLog
  type self
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function hash_log [#"../bdd.rs" 34 8 34 49] (_1 : DeepModelTy0.deepModelTy) : int
  val hash_log [#"../bdd.rs" 34 8 34 49] (_1 : DeepModelTy0.deepModelTy) : int
    ensures { result = hash_log _1 }
    
end
module Core_Num_Impl9_Max_Stub
  use prelude.Int
  use prelude.UInt64
  val constant mAX'  : uint64
end
module Core_Num_Impl9_Max
  use prelude.Int
  use prelude.UInt64
  let constant mAX'  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
end
module Bdd_Hashmap_Impl2_HashLog_Stub
  type u
  type v
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  function hash_log [#"../bdd.rs" 82 8 82 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
end
module Bdd_Hashmap_Impl2_HashLog_Interface
  type u
  type v
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  function hash_log [#"../bdd.rs" 82 8 82 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
  val hash_log [#"../bdd.rs" 82 8 82 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
    ensures { result = hash_log x }
    
end
module Bdd_Hashmap_Impl2_HashLog
  type u
  type v
  use prelude.Int
  use prelude.UInt64
  clone Core_Num_Impl9_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog1 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog0 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function hash_log [#"../bdd.rs" 82 8 82 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int =
    [#"../bdd.rs" 83 24 83 84] mod (HashLog0.hash_log (let (a, _) = x in a) + HashLog1.hash_log (let (_, a) = x in a) * 17) (UInt64.to_int Max0.mAX' + 1)
  val hash_log [#"../bdd.rs" 82 8 82 48] (x : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)) : int
    ensures { result = hash_log x }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module Bdd_Hashmap_Hash_Hash_Interface
  type self
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone Bdd_Hashmap_Hash_HashLog_Stub as HashLog0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = self
  val hash [#"../bdd.rs" 31 8 31 30] (self : self) : uint64
    requires {[#"../bdd.rs" 31 17 31 21] Inv0.inv self}
    ensures { [#"../bdd.rs" 30 18 30 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module Core_Num_Impl9_Bits_Stub
  use prelude.Int
  use prelude.UInt32
  val constant bITS'  : uint32
end
module Core_Num_Impl9_Bits
  use prelude.Int
  use prelude.UInt32
  let constant bITS'  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (64 : uint32)
end
module Core_Num_Impl9_Min_Stub
  use prelude.Int
  use prelude.UInt64
  val constant mIN'  : uint64
end
module Core_Num_Impl9_Min
  use prelude.Int
  use prelude.UInt64
  let constant mIN'  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint64)
end
module Core_Num_Impl9_WrappingMul_Interface
  use prelude.UInt64
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Core_Num_Impl9_Min_Stub as Min0
  clone Core_Num_Impl9_Bits_Stub as Bits0
  val wrapping_mul (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt64.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int Min0.mIN' /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int Max0.mAX' -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs + k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs - k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    
end
module Core_Num_Impl9_WrappingAdd_Interface
  use prelude.UInt64
  use prelude.Int
  use prelude.UInt32
  use int.Power
  use int.EuclideanDivision
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Core_Num_Impl9_Min_Stub as Min0
  clone Core_Num_Impl9_Bits_Stub as Bits0
  val wrapping_add (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int Bits0.bITS')) + UInt64.to_int Min0.mIN' }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int Min0.mIN' /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int Max0.mAX' -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int Min0.mIN' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs + k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int Max0.mAX' -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs - k * (UInt64.to_int Max0.mAX' - UInt64.to_int Min0.mIN' + 1)) }
    
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel_Stub
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel_Interface
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
  val deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Tuples_Impl4_DeepModel
  type a
  type b
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = b
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = b,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (DeepModel0.deep_model (let (a, _) = self in a), DeepModel1.deep_model (let (_, a) = self in a))
  val deep_model (self : (a, b)) : (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
    ensures { result = deep_model self }
    
end
module Bdd_Hashmap_Impl2_Hash_Interface
  type u
  type v
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone Bdd_Hashmap_Impl2_HashLog_Stub as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy)
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (u, v)
  val hash [#"../bdd.rs" 76 8 76 29] (self : (u, v)) : uint64
    requires {[#"../bdd.rs" 76 17 76 21] Inv0.inv self}
    ensures { [#"../bdd.rs" 75 18 75 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
end
module Bdd_Hashmap_Impl2_Hash
  type u
  type v
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel5 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = u
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = u,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel3 with
    type a = u,
    type b = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    function DeepModel1.deep_model = DeepModel5.deep_model
  clone Core_Num_Impl9_Max as Max0
  clone Core_Num_Impl9_Min as Min0
  clone Core_Num_Impl9_Bits as Bits0
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog2 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel2 with
    type t = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = (u, v)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = (u, v),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog1 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Bdd_Hashmap_Impl2_HashLog as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function HashLog0.hash_log = HashLog1.hash_log,
    function HashLog1.hash_log = HashLog2.hash_log,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy),
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Core_Num_Impl9_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl9_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Bdd_Hashmap_Hash_Hash_Interface as Hash1 with
    type self = v,
    predicate Inv0.inv = Inv2.inv,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function HashLog0.hash_log = HashLog2.hash_log,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = (u, v)
  clone Bdd_Hashmap_Hash_Hash_Interface as Hash0 with
    type self = u,
    predicate Inv0.inv = Inv1.inv,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function HashLog0.hash_log = HashLog1.hash_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg hash [#"../bdd.rs" 76 8 76 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : (u, v)) : uint64
    requires {[#"../bdd.rs" 76 17 76 21] Inv0.inv self}
    ensures { [#"../bdd.rs" 75 18 75 62] UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : (u, v) = self;
  var _3 : uint64;
  var _5 : uint64;
  var _6 : uint64;
  {
    goto BB0
  }
  BB0 {
    _3 <- ([#"../bdd.rs" 77 12 77 25] Hash0.hash (let (a, _) = self in a));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _6 <- ([#"../bdd.rs" 77 39 77 52] Hash1.hash (let (_, a) = self in a));
    goto BB2
  }
  BB2 {
    _5 <- ([#"../bdd.rs" 77 39 77 69] WrappingMul0.wrapping_mul _6 ([#"../bdd.rs" 77 66 77 68] (17 : uint64)));
    _6 <- any uint64;
    goto BB3
  }
  BB3 {
    _0 <- ([#"../bdd.rs" 77 12 77 70] WrappingAdd0.wrapping_add _3 _5);
    _3 <- any uint64;
    _5 <- any uint64;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Bdd_Bdd_Type
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  type t_bdd  =
    | C_Bdd (t_node) uint64
    with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
    
  let function if_v (self : t_node) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any uint64
      | C_True -> any uint64
      | C_If a _ _ -> a
      end
  let function if_childt (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ a _ -> a
      end
  let function if_childf (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ _ a -> a
      end
  let function bdd_1 (self : t_bdd) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Bdd _ a -> a
      end
  let function bdd_0 (self : t_bdd) : t_node = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl13_AssertReceiverIsTotalEq_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  val assert_receiver_is_total_eq [#"../bdd.rs" 90 9 90 11] (self : Bdd_Node_Type.t_node) : ()
end
module Bdd_Impl13_AssertReceiverIsTotalEq
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 90 9 90 11] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  {
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
module Bdd_NodeLog_Type
  use prelude.Int
  use prelude.UInt64
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Bdd_Impl5_DeepModel_Stub
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl5_DeepModel_Interface
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
  val deep_model [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model self }
    
end
module Bdd_Impl5_DeepModel
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model self }
    
end
module Bdd_Impl6_ShallowModel_Stub
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function shallow_model [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
end
module Bdd_Impl6_ShallowModel_Interface
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function shallow_model [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
  val shallow_model [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model self }
    
end
module Bdd_Impl6_ShallowModel
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel_Stub as DeepModel0
  function shallow_model [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] DeepModel0.deep_model self
  val shallow_model [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model self }
    
end
module Bdd_Impl7_Eq_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64
  val eq [#"../bdd.rs" 202 4 202 34] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 201 14 201 37] result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model o) }
    
end
module Bdd_Impl7_Eq
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel0
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg eq [#"../bdd.rs" 202 4 202 34] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 201 14 201 37] result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model o) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Bdd_Bdd_Type.t_bdd = self;
  var o : Bdd_Bdd_Type.t_bdd = o;
  {
    goto BB0
  }
  BB0 {
    _0 <- ([#"../bdd.rs" 203 8 203 21] Bdd_Bdd_Type.bdd_1 self = Bdd_Bdd_Type.bdd_1 o);
    return _0
  }
  
end
module Core_Cmp_Impls_Impl25_Eq_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use prelude.Int
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = uint64,
    type DeepModelTy0.deepModelTy = int
  val eq (self : uint64) (other : uint64) : bool
    ensures { [#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75] result = (DeepModel0.deep_model self = DeepModel0.deep_model other) }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Bdd_Impl3_DeepModel_Stub
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl3_DeepModel_Interface
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
  val deep_model [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model self }
    
end
module Bdd_Impl3_DeepModel
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match (self) with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Num_Impl10_DeepModel_Stub
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl10_DeepModel_Interface
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int
  val deep_model (self : uint64) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Num_Impl10_DeepModel
  use prelude.Int
  use prelude.UInt64
  function deep_model (self : uint64) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UInt64.to_int self
  val deep_model (self : uint64) : int
    ensures { result = deep_model self }
    
end
module Bdd_Impl14_Eq_Interface
  use prelude.Borrow
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone CreusotContracts_Model_Impl4_DeepModel_Stub as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  val eq [#"../bdd.rs" 90 13 90 22] (self : Bdd_Node_Type.t_node) (rhs : Bdd_Node_Type.t_node) : bool
    ensures { [#"../bdd.rs" 90 13 90 22] result = (DeepModel0.deep_model self = DeepModel0.deep_model rhs) }
    
end
module Bdd_Impl14_Eq
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel4
  clone CreusotContracts_Std1_Num_Impl10_DeepModel as DeepModel3
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel4.deep_model
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel2
  use prelude.Int
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel1 with
    type t = uint64,
    type DeepModelTy0.deepModelTy = int,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = Bdd_Node_Type.t_node
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone Core_Cmp_Impls_Impl25_Eq_Interface as Eq1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Bdd_Impl7_Eq_Interface as Eq0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Bdd_Node_Type.t_node,
    type t2 = Bdd_Node_Type.t_node,
    predicate Resolve0.resolve = Resolve1.resolve,
    predicate Resolve1.resolve = Resolve1.resolve
  let rec cfg eq [#"../bdd.rs" 90 13 90 22] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) (rhs : Bdd_Node_Type.t_node) : bool
    ensures { [#"../bdd.rs" 90 13 90 22] result = (DeepModel0.deep_model self = DeepModel0.deep_model rhs) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Bdd_Node_Type.t_node = self;
  var rhs : Bdd_Node_Type.t_node = rhs;
  var _4 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var v_1 : uint64;
  var childt_1 : Bdd_Bdd_Type.t_bdd;
  var childf_1 : Bdd_Bdd_Type.t_bdd;
  var v_2 : uint64;
  var childt_2 : Bdd_Bdd_Type.t_bdd;
  var childf_2 : Bdd_Bdd_Type.t_bdd;
  var _17 : bool;
  var _18 : bool;
  var _19 : bool;
  var _22 : bool;
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    _4 <- (self, rhs);
    switch (let (a, _) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB4
      | Bdd_Node_Type.C_If _ _ _ -> goto BB6
      end
  }
  BB1 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB2
      | _ -> goto BB3
      end
  }
  BB2 {
    goto BB8
  }
  BB3 {
    assume { Resolve0.resolve _4 };
    _0 <- ([#"../bdd.rs" 90 13 90 22] false);
    goto BB23
  }
  BB4 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_True -> goto BB5
      | _ -> goto BB3
      end
  }
  BB5 {
    goto BB9
  }
  BB6 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB7
      | _ -> goto BB3
      end
  }
  BB7 {
    goto BB10
  }
  BB8 {
    assume { Resolve0.resolve _4 };
    _0 <- ([#"../bdd.rs" 90 13 90 22] true);
    goto BB23
  }
  BB9 {
    assume { Resolve0.resolve _4 };
    _0 <- ([#"../bdd.rs" 90 13 90 22] true);
    goto BB23
  }
  BB10 {
    v_1 <- Bdd_Node_Type.if_v (let (a, _) = _4 in a);
    childt_1 <- Bdd_Node_Type.if_childt (let (a, _) = _4 in a);
    childf_1 <- Bdd_Node_Type.if_childf (let (a, _) = _4 in a);
    v_2 <- Bdd_Node_Type.if_v (let (_, a) = _4 in a);
    childt_2 <- Bdd_Node_Type.if_childt (let (_, a) = _4 in a);
    childf_2 <- Bdd_Node_Type.if_childf (let (_, a) = _4 in a);
    assume { Resolve0.resolve _4 };
    _19 <- ([#"../bdd.rs" 90 13 90 22] Eq0.eq childf_1 childf_2);
    goto BB20
  }
  BB11 {
    _0 <- ([#"../bdd.rs" 90 13 90 22] false);
    goto BB13
  }
  BB12 {
    _0 <- ([#"../bdd.rs" 90 13 90 22] true);
    goto BB13
  }
  BB13 {
    goto BB23
  }
  BB14 {
    _17 <- ([#"../bdd.rs" 90 13 90 22] false);
    goto BB16
  }
  BB15 {
    _25 <- ([#"../bdd.rs" 90 13 90 22] Eq1.eq v_1 v_2);
    goto BB22
  }
  BB16 {
    switch (_17)
      | False -> goto BB11
      | True -> goto BB12
      end
  }
  BB17 {
    _18 <- ([#"../bdd.rs" 90 13 90 22] false);
    goto BB19
  }
  BB18 {
    _22 <- ([#"../bdd.rs" 90 13 90 22] Eq0.eq childt_1 childt_2);
    goto BB21
  }
  BB19 {
    switch (_18)
      | False -> goto BB14
      | True -> goto BB15
      end
  }
  BB20 {
    switch (_19)
      | False -> goto BB17
      | True -> goto BB18
      end
  }
  BB21 {
    _18 <- _22;
    _22 <- any bool;
    goto BB19
  }
  BB22 {
    _17 <- _25;
    _25 <- any bool;
    goto BB16
  }
  BB23 {
    return _0
  }
  
end
module Core_Clone_Impls_Impl9_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  val clone' (self : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Bdd_Impl0_Clone_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  val clone' [#"../bdd.rs" 109 4 109 27] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 108 14 108 29] result = self }
    
end
module Bdd_Impl0_Clone
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec cfg clone' [#"../bdd.rs" 109 4 109 27] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 108 14 108 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : Bdd_Bdd_Type.t_bdd = self;
  {
    goto BB0
  }
  BB0 {
    _0 <- self;
    return _0
  }
  
end
module Bdd_Impl15_Clone_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  val clone' [#"../bdd.rs" 90 24 90 29] (self : Bdd_Node_Type.t_node) : Bdd_Node_Type.t_node
    ensures { [#"../bdd.rs" 90 24 90 29] result = self }
    
end
module Bdd_Impl15_Clone
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl0_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl9_Clone_Interface as Clone0
  use Bdd_Node_Type as Bdd_Node_Type
  let rec cfg clone' [#"../bdd.rs" 90 24 90 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : Bdd_Node_Type.t_node
    ensures { [#"../bdd.rs" 90 24 90 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Node_Type.t_node;
  var self : Bdd_Node_Type.t_node = self;
  var v_1 : uint64;
  var childt_1 : Bdd_Bdd_Type.t_bdd;
  var childf_1 : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _9 : uint64;
  var _10 : Bdd_Bdd_Type.t_bdd;
  var _12 : Bdd_Bdd_Type.t_bdd;
  var _13 : Bdd_Bdd_Type.t_bdd;
  var _15 : Bdd_Bdd_Type.t_bdd;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB2
      | Bdd_Node_Type.C_If _ _ _ -> goto BB3
      end
  }
  BB1 {
    goto BB5
  }
  BB2 {
    goto BB6
  }
  BB3 {
    v_1 <- Bdd_Node_Type.if_v self;
    childt_1 <- Bdd_Node_Type.if_childt self;
    childf_1 <- Bdd_Node_Type.if_childf self;
    _9 <- v_1;
    _7 <- ([#"../bdd.rs" 90 24 90 29] Clone0.clone' _9);
    goto BB7
  }
  BB4 {
    absurd
  }
  BB5 {
    _0 <- Bdd_Node_Type.C_False;
    goto BB10
  }
  BB6 {
    _0 <- Bdd_Node_Type.C_True;
    goto BB10
  }
  BB7 {
    _12 <- childt_1;
    _10 <- ([#"../bdd.rs" 90 24 90 29] Clone1.clone' _12);
    goto BB8
  }
  BB8 {
    _15 <- childf_1;
    _13 <- ([#"../bdd.rs" 90 24 90 29] Clone1.clone' _15);
    goto BB9
  }
  BB9 {
    _0 <- Bdd_Node_Type.C_If _7 _10 _13;
    _7 <- any uint64;
    _10 <- any Bdd_Bdd_Type.t_bdd;
    _13 <- any Bdd_Bdd_Type.t_bdd;
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Bdd_Impl19_AssertReceiverIsTotalEq_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  val assert_receiver_is_total_eq [#"../bdd.rs" 104 15 104 17] (self : Bdd_Bdd_Type.t_bdd) : ()
end
module Bdd_Impl19_AssertReceiverIsTotalEq
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 104 15 104 17] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  {
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
module Bdd_Impl1_HashLog_Stub
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
end
module Bdd_Impl1_HashLog_Interface
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
  val hash_log [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl1_HashLog
  use prelude.Int
  use prelude.UInt64
  clone Core_Num_Impl9_Max_Stub as Max0
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 130 12 135 13] match (x) with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5 + UInt64.to_int childf * 7) (UInt64.to_int Max0.mAX' + 1)
      end
  val hash_log [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl4_ShallowModel_Stub
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function shallow_model [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
end
module Bdd_Impl4_ShallowModel_Interface
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function shallow_model [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
  val shallow_model [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model self }
    
end
module Bdd_Impl4_ShallowModel
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel_Stub as DeepModel0
  function shallow_model [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] DeepModel0.deep_model self
  val shallow_model [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model self }
    
end
module Bdd_Impl1_Hash_Interface
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl1_HashLog_Stub as HashLog0
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  val hash [#"../bdd.rs" 116 4 116 25] (self : Bdd_Node_Type.t_node) : uint64
    ensures { [#"../bdd.rs" 115 14 115 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
end
module Bdd_Impl1_Hash
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Core_Num_Impl9_Max as Max0
  clone Core_Num_Impl9_Min as Min0
  clone Core_Num_Impl9_Bits as Bits0
  clone Bdd_Impl1_HashLog as HashLog0 with
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Core_Num_Impl9_WrappingAdd_Interface as WrappingAdd0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  clone Core_Num_Impl9_WrappingMul_Interface as WrappingMul0 with
    val Bits0.bITS' = Bits0.bITS',
    val Min0.mIN' = Min0.mIN',
    val Max0.mAX' = Max0.mAX'
  let rec cfg hash [#"../bdd.rs" 116 4 116 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : uint64
    ensures { [#"../bdd.rs" 115 14 115 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : Bdd_Node_Type.t_node = self;
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _9 : uint64;
  var _11 : uint64;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB2
      | Bdd_Node_Type.C_If _ _ _ -> goto BB3
      end
  }
  BB1 {
    goto BB5
  }
  BB2 {
    goto BB6
  }
  BB3 {
    v <- Bdd_Node_Type.if_v self;
    childt <- Bdd_Node_Type.if_childt self;
    childf <- Bdd_Node_Type.if_childf self;
    _9 <- ([#"../bdd.rs" 121 31 121 55] WrappingMul0.wrapping_mul (Bdd_Bdd_Type.bdd_1 childt) ([#"../bdd.rs" 121 53 121 54] (5 : uint64)));
    goto BB7
  }
  BB4 {
    absurd
  }
  BB5 {
    _0 <- ([#"../bdd.rs" 118 21 118 22] (1 : uint64));
    goto BB11
  }
  BB6 {
    _0 <- ([#"../bdd.rs" 119 20 119 21] (2 : uint64));
    goto BB11
  }
  BB7 {
    _7 <- ([#"../bdd.rs" 121 16 121 56] WrappingAdd0.wrapping_add v _9);
    _9 <- any uint64;
    goto BB8
  }
  BB8 {
    _11 <- ([#"../bdd.rs" 121 70 121 94] WrappingMul0.wrapping_mul (Bdd_Bdd_Type.bdd_1 childf) ([#"../bdd.rs" 121 92 121 93] (7 : uint64)));
    goto BB9
  }
  BB9 {
    _0 <- ([#"../bdd.rs" 121 16 121 95] WrappingAdd0.wrapping_add _7 _11);
    _7 <- any uint64;
    _11 <- any uint64;
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Bdd_Impl2_HashLog_Stub
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
end
module Bdd_Impl2_HashLog_Interface
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
  val hash_log [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl2_HashLog
  use prelude.Int
  use prelude.UInt64
  function hash_log [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [#"../bdd.rs" 149 8 149 24] UInt64.to_int x
  val hash_log [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
    ensures { result = hash_log x }
    
end
module Bdd_Impl2_Hash_Interface
  use prelude.UInt64
  use prelude.Borrow
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl2_HashLog_Stub as HashLog0
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64
  val hash [#"../bdd.rs" 142 4 142 25] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { [#"../bdd.rs" 141 14 141 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
end
module Bdd_Impl2_Hash
  use prelude.Int
  use prelude.UInt64
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel0
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Bdd_Impl2_HashLog as HashLog0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  let rec cfg hash [#"../bdd.rs" 142 4 142 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { [#"../bdd.rs" 141 14 141 46] UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : Bdd_Bdd_Type.t_bdd = self;
  {
    goto BB0
  }
  BB0 {
    _0 <- Bdd_Bdd_Type.bdd_1 self;
    return _0
  }
  
end
module Bdd_Impl8_Interp_Stub
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
end
module Bdd_Impl8_Interp_Interface
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
  val interp [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp self vars }
    
end
module Bdd_Impl8_Interp
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function interp [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  val interp [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp self vars }
    
end
module Bdd_Impl8_Size_Stub
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
end
module Bdd_Impl8_Size_Interface
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
  val size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { [#"../bdd.rs" 223 14 223 25] result >= 0 }
    ensures { result = size self }
    
  axiom size_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size self >= 0
end
module Bdd_Impl8_Size
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  val size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { [#"../bdd.rs" 223 14 223 25] result >= 0 }
    ensures { result = size self }
    
  axiom size_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size self >= 0
end
module Bdd_Impl8_Size_Impl
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec ghost function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { [#"../bdd.rs" 223 14 223 25] result >= 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 226 12 234 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
end
module Bdd_Impl8_Leastvar_Stub
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
end
module Bdd_Impl8_Leastvar_Interface
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
  val leastvar [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar self }
    
end
module Bdd_Impl8_Leastvar
  use prelude.Int
  use prelude.UInt64
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int
  clone Core_Num_Impl9_Max_Stub as Max0
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function leastvar [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match (self) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int Max0.mAX' + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int Max0.mAX' + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> ShallowModel0.shallow_model v
      end
  val leastvar [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar self }
    
end
module Bdd_Context_Type
  use prelude.Borrow
  use prelude.Ghost
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  type t_context  =
    | C_Context (Bdd_Bumpalo_Bump_Type.t_bump) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) uint64
    
  let function context_hashcons (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ a _ _ _ _ -> a
      end
  let function context_cnt (self : t_context) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ _ _ a -> a
      end
  let function context_hashcons_ghost (self : t_context) : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ a _ _ _ -> a
      end
  let function context_not_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ a _ _ -> a
      end
  let function context_and_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context _ _ _ _ a _ -> a
      end
  let function context_alloc (self : t_context) : Bdd_Bumpalo_Bump_Type.t_bump = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Context a _ _ _ _ _ -> a
      end
end
module Bdd_Impl10_IsValidBdd_Stub
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd)
end
module Bdd_Impl10_IsValidBdd_Interface
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd)
  val is_valid_bdd [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd self b }
    
end
module Bdd_Impl10_IsValidBdd
  use map.Map
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons self)) (ShallowModel1.shallow_model (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd self b }
    
end
module Bdd_Impl10_IsValidNode_Stub
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_node [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node)
end
module Bdd_Impl10_IsValidNode_Interface
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_node [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node)
  val is_valid_node [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node self n }
    
end
module Bdd_Impl10_IsValidNode
  use prelude.UInt64
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  use Bdd_Node_Type as Bdd_Node_Type
  predicate is_valid_node [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match (n) with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ IsValidBdd0.is_valid_bdd self childt /\ IsValidBdd0.is_valid_bdd self childf /\ UInt64.to_int v < Leastvar0.leastvar childt /\ UInt64.to_int v < Leastvar0.leastvar childf
      end
  val is_valid_node [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node self n }
    
end
module Bdd_Impl9_Invariant_Stub
  use Bdd_Context_Type as Bdd_Context_Type
  predicate invariant' [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context)
end
module Bdd_Impl9_Invariant_Interface
  use Bdd_Context_Type as Bdd_Context_Type
  predicate invariant' [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context)
  val invariant' [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant' self }
    
end
module Bdd_Impl9_Invariant
  use prelude.Int
  use prelude.Ghost
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  clone Bdd_Impl10_IsValidNode_Stub as IsValidNode0
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog
  predicate invariant' [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match (Map.get (ShallowModel1.shallow_model (Bdd_Context_Type.context_hashcons self)) n) with
      | Core_Option_Option_Type.C_Some b -> ShallowModel0.shallow_model (Bdd_Bdd_Type.bdd_0 b) = n /\ IsValidNode0.is_valid_node self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match (Map.get (ShallowModel2.shallow_model (Bdd_Context_Type.context_not_memo self)) bm) with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in IsValidBdd0.is_valid_bdd self n /\ IsValidBdd0.is_valid_bdd self b /\ (forall v : Map.map uint64 bool . Interp0.interp n v = (not Interp0.interp b v)) /\ Leastvar0.leastvar b <= Leastvar0.leastvar n
      end) /\ (forall abm : (uint64, uint64) . match (Map.get (ShallowModel3.shallow_model (Bdd_Context_Type.context_and_memo self)) abm) with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in IsValidBdd0.is_valid_bdd self n /\ IsValidBdd0.is_valid_bdd self a /\ IsValidBdd0.is_valid_bdd self b /\ (forall v : Map.map uint64 bool . Interp0.interp n v = (Interp0.interp a v /\ Interp0.interp b v)) /\ (Leastvar0.leastvar a <= Leastvar0.leastvar n \/ Leastvar0.leastvar b <= Leastvar0.leastvar n)
      end)
  val invariant' [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant' self }
    
end
module Bdd_Impl10_Grows_Stub
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context))
end
module Bdd_Impl10_Grows_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context))
  val grows [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows self }
    
end
module Bdd_Impl10_Grows
  use prelude.Borrow
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Stub as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  predicate grows [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match (Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons ( * self))) n) with
      | Core_Option_Option_Type.C_Some b -> Map.get (ShallowModel0.shallow_model (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows self }
    
end
module TyInv_Borrow
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  axiom inv_borrow [@rewrite] : forall self : borrowed t . Inv0.inv self = (Inv1.inv ( * self) /\ Inv1.inv ( ^ self))
end
module Bdd_Context_Type_Inv
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl9_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  axiom inv_t_context [@rewrite] : forall self : Bdd_Context_Type.t_context . Inv0.inv self = Invariant0.invariant' self
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel_Stub
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel_Interface
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int
  val shallow_model (self : uint64) : int
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Num_Impl9_ShallowModel
  use prelude.Int
  use prelude.UInt64
  function shallow_model (self : uint64) : int =
    UInt64.to_int self
  val shallow_model (self : uint64) : int
    ensures { result = shallow_model self }
    
end
module Bdd_Impl10_GrowsIsValidBdd_Stub
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
end
module Bdd_Impl10_GrowsIsValidBdd_Interface
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  val grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 333 15 333 27] Grows0.grows self}
    requires {[#"../bdd.rs" 334 15 334 35] IsValidBdd0.is_valid_bdd ( * self) b}
    requires {[#"../bdd.rs" 336 35 336 39] Inv0.inv self}
    ensures { [#"../bdd.rs" 335 14 335 37] IsValidBdd0.is_valid_bdd ( ^ self) b }
    ensures { result = grows_is_valid_bdd self b }
    
  axiom grows_is_valid_bdd_spec : forall self : borrowed (Bdd_Context_Type.t_context), b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 333 15 333 27] Grows0.grows self) -> ([#"../bdd.rs" 334 15 334 35] IsValidBdd0.is_valid_bdd ( * self) b) -> ([#"../bdd.rs" 336 35 336 39] Inv0.inv self) -> ([#"../bdd.rs" 335 14 335 37] IsValidBdd0.is_valid_bdd ( ^ self) b)
end
module Bdd_Impl10_GrowsIsValidBdd
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
   =
    [#"../bdd.rs" 331 4 331 12] ()
  val grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 333 15 333 27] Grows0.grows self}
    requires {[#"../bdd.rs" 334 15 334 35] IsValidBdd0.is_valid_bdd ( * self) b}
    requires {[#"../bdd.rs" 336 35 336 39] Inv0.inv self}
    ensures { [#"../bdd.rs" 335 14 335 37] IsValidBdd0.is_valid_bdd ( ^ self) b }
    ensures { result = grows_is_valid_bdd self b }
    
  axiom grows_is_valid_bdd_spec : forall self : borrowed (Bdd_Context_Type.t_context), b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 333 15 333 27] Grows0.grows self) -> ([#"../bdd.rs" 334 15 334 35] IsValidBdd0.is_valid_bdd ( * self) b) -> ([#"../bdd.rs" 336 35 336 39] Inv0.inv self) -> ([#"../bdd.rs" 335 14 335 37] IsValidBdd0.is_valid_bdd ( ^ self) b)
end
module Bdd_Impl10_GrowsIsValidBdd_Impl
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel4 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel3 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel2 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec ghost function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 333 15 333 27] Grows0.grows self}
    requires {[#"../bdd.rs" 334 15 334 35] IsValidBdd0.is_valid_bdd ( * self) b}
    requires {[#"../bdd.rs" 336 35 336 39] Inv0.inv self}
    ensures { [#"../bdd.rs" 335 14 335 37] IsValidBdd0.is_valid_bdd ( ^ self) b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 331 4 331 12] ()
end
module Bdd_Impl10_GrowsTrans_Stub
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
end
module Bdd_Impl10_GrowsTrans_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
  val grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 340 15 340 27] Grows0.grows self}
    requires {[#"../bdd.rs" 341 15 341 24] Grows0.grows o}
    requires {[#"../bdd.rs" 342 15 342 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo}
    requires {[#"../bdd.rs" 345 28 345 32] Inv0.inv self}
    requires {[#"../bdd.rs" 345 34 345 35] Inv0.inv o}
    requires {[#"../bdd.rs" 345 48 345 50] Inv0.inv oo}
    ensures { [#"../bdd.rs" 344 14 344 24] Grows0.grows oo }
    ensures { result = grows_trans self o oo }
    
  axiom grows_trans_spec : forall self : borrowed (Bdd_Context_Type.t_context), o : borrowed (Bdd_Context_Type.t_context), oo : borrowed (Bdd_Context_Type.t_context) . ([#"../bdd.rs" 340 15 340 27] Grows0.grows self) -> ([#"../bdd.rs" 341 15 341 24] Grows0.grows o) -> ([#"../bdd.rs" 342 15 342 26]  ^ self =  * o) -> ([#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo) -> ([#"../bdd.rs" 345 28 345 32] Inv0.inv self) -> ([#"../bdd.rs" 345 34 345 35] Inv0.inv o) -> ([#"../bdd.rs" 345 48 345 50] Inv0.inv oo) -> ([#"../bdd.rs" 344 14 344 24] Grows0.grows oo)
end
module Bdd_Impl10_GrowsTrans
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_Grows_Stub as Grows0
  function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
   =
    [#"../bdd.rs" 338 4 338 12] ()
  val grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 340 15 340 27] Grows0.grows self}
    requires {[#"../bdd.rs" 341 15 341 24] Grows0.grows o}
    requires {[#"../bdd.rs" 342 15 342 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo}
    requires {[#"../bdd.rs" 345 28 345 32] Inv0.inv self}
    requires {[#"../bdd.rs" 345 34 345 35] Inv0.inv o}
    requires {[#"../bdd.rs" 345 48 345 50] Inv0.inv oo}
    ensures { [#"../bdd.rs" 344 14 344 24] Grows0.grows oo }
    ensures { result = grows_trans self o oo }
    
  axiom grows_trans_spec : forall self : borrowed (Bdd_Context_Type.t_context), o : borrowed (Bdd_Context_Type.t_context), oo : borrowed (Bdd_Context_Type.t_context) . ([#"../bdd.rs" 340 15 340 27] Grows0.grows self) -> ([#"../bdd.rs" 341 15 341 24] Grows0.grows o) -> ([#"../bdd.rs" 342 15 342 26]  ^ self =  * o) -> ([#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo) -> ([#"../bdd.rs" 345 28 345 32] Inv0.inv self) -> ([#"../bdd.rs" 345 34 345 35] Inv0.inv o) -> ([#"../bdd.rs" 345 48 345 50] Inv0.inv oo) -> ([#"../bdd.rs" 344 14 344 24] Grows0.grows oo)
end
module Bdd_Impl10_GrowsTrans_Impl
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel4 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel3 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel2 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec ghost function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 340 15 340 27] Grows0.grows self}
    requires {[#"../bdd.rs" 341 15 341 24] Grows0.grows o}
    requires {[#"../bdd.rs" 342 15 342 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo}
    requires {[#"../bdd.rs" 345 28 345 32] Inv0.inv self}
    requires {[#"../bdd.rs" 345 34 345 35] Inv0.inv o}
    requires {[#"../bdd.rs" 345 48 345 50] Inv0.inv oo}
    ensures { [#"../bdd.rs" 344 14 344 24] Grows0.grows oo }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 338 4 338 12] ()
end
module Bdd_Impl10_SetIrreleventVar_Stub
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
end
module Bdd_Impl10_SetIrreleventVar_Interface
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  val set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < Leastvar0.leastvar a}
    requires {[#"../bdd.rs" 351 26 351 30] Inv0.inv self}
    ensures { [#"../bdd.rs" 350 14 350 50] Interp0.interp a v = Interp0.interp a (Map.set v x b) }
    ensures { result = set_irrelevent_var self a x v b }
    
  axiom set_irrelevent_var_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < Leastvar0.leastvar a) -> ([#"../bdd.rs" 351 26 351 30] Inv0.inv self) -> ([#"../bdd.rs" 350 14 350 50] Interp0.interp a v = Interp0.interp a (Map.set v x b))
end
module Bdd_Impl10_SetIrreleventVar
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 353 12 359 13] match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  val set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < Leastvar0.leastvar a}
    requires {[#"../bdd.rs" 351 26 351 30] Inv0.inv self}
    ensures { [#"../bdd.rs" 350 14 350 50] Interp0.interp a v = Interp0.interp a (Map.set v x b) }
    ensures { result = set_irrelevent_var self a x v b }
    
  axiom set_irrelevent_var_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < Leastvar0.leastvar a) -> ([#"../bdd.rs" 351 26 351 30] Inv0.inv self) -> ([#"../bdd.rs" 350 14 350 50] Interp0.interp a v = Interp0.interp a (Map.set v x b))
end
module Bdd_Impl10_SetIrreleventVar_Impl
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel6 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel4
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel3 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel5.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec ghost function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < Leastvar0.leastvar a}
    requires {[#"../bdd.rs" 351 26 351 30] Inv0.inv self}
    ensures { [#"../bdd.rs" 350 14 350 50] Interp0.interp a v = Interp0.interp a (Map.set v x b) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 353 12 359 13] match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
end
module Bdd_Impl10_DiscrValuation_Stub
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
end
module Bdd_Impl10_DiscrValuation_Interface
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  val discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 364 15 364 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 365 15 365 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 366 15 366 21] a <> b}
    requires {[#"../bdd.rs" 370 23 370 27] Inv0.inv self}
    ensures { [#"../bdd.rs" 367 14 367 50] Interp0.interp a result <> Interp0.interp b result }
    ensures { result = discr_valuation self a b }
    
  axiom discr_valuation_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 364 15 364 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 365 15 365 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 366 15 366 21] a <> b) -> ([#"../bdd.rs" 370 23 370 27] Inv0.inv self) -> ([#"../bdd.rs" 367 14 367 50] Interp0.interp a (discr_valuation self a b) <> Interp0.interp b (discr_valuation self a b))
end
module Bdd_Impl10_DiscrValuation
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use map.Const
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_SetIrreleventVar_Stub as SetIrreleventVar0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv0.inv,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  val discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 364 15 364 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 365 15 365 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 366 15 366 21] a <> b}
    requires {[#"../bdd.rs" 370 23 370 27] Inv0.inv self}
    ensures { [#"../bdd.rs" 367 14 367 50] Interp0.interp a result <> Interp0.interp b result }
    ensures { result = discr_valuation self a b }
    
  axiom def : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . discr_valuation self a b = ([#"../bdd.rs" 372 12 372 36] let _ = () in if Leastvar0.leastvar a < Leastvar0.leastvar b then
    match (a) with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation self childf b) v false
      else
        Map.set (discr_valuation self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if Leastvar0.leastvar a > Leastvar0.leastvar b then
      match (b) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation self a childf) v false
        else
          Map.set (discr_valuation self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match (a) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match (b) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation self childfa childfb) v false
          else
            Map.set (discr_valuation self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  axiom discr_valuation_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 364 15 364 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 365 15 365 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 366 15 366 21] a <> b) -> ([#"../bdd.rs" 370 23 370 27] Inv0.inv self) -> ([#"../bdd.rs" 367 14 367 50] Interp0.interp a (discr_valuation self a b) <> Interp0.interp b (discr_valuation self a b))
end
module Bdd_Impl10_DiscrValuation_Impl
  use prelude.Int
  use map.Map
  use prelude.UInt64
  use map.Const
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel6 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel4
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel3 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel5.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Bdd_Impl10_SetIrreleventVar as SetIrreleventVar0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv0.inv,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  let rec ghost function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 364 15 364 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 365 15 365 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 366 15 366 21] a <> b}
    requires {[#"../bdd.rs" 370 23 370 27] Inv0.inv self}
    ensures { [#"../bdd.rs" 367 14 367 50] Interp0.interp a result <> Interp0.interp b result }
    variant {[#"../bdd.rs" 368 14 368 33] Size0.size a + Size0.size b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 372 12 372 36] let _ = () in if let b = Leastvar0.leastvar b in let a = Leastvar0.leastvar a in pure {a < b} then
      match (a) with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> b} then
          let a' = discr_valuation self childf b in Map.set a' v false
        else
          let a' = discr_valuation self childt b in Map.set a' v true
        
        | _ -> Const.const true
        end
    else
      if let b = Leastvar0.leastvar b in let a = Leastvar0.leastvar a in pure {a > b} then
        match (b) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> a} then
            let a' = discr_valuation self a childf in Map.set a' v false
          else
            let a' = discr_valuation self a childt in Map.set a' v true
          
          | _ -> Const.const true
          end
      else
        match (a) with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match (b) with
            | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if pure {childfa <> childfb} then
              let a' = discr_valuation self childfa childfb in Map.set a' v false
            else
              let a' = discr_valuation self childta childtb in Map.set a' v true
            
            | _ -> Const.const true
            end
          | _ -> Const.const true
          end
      
    
end
module Bdd_Impl10_BddCanonical_Stub
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
end
module Bdd_Impl10_BddCanonical_Interface
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  val bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 413 15 413 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 414 15 414 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v}
    requires {[#"../bdd.rs" 418 25 418 29] Inv0.inv self}
    ensures { [#"../bdd.rs" 416 14 416 20] a = b }
    ensures { result = bdd_canonical self a b }
    
  axiom bdd_canonical_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 413 15 413 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 414 15 414 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v) -> ([#"../bdd.rs" 418 25 418 29] Inv0.inv self) -> ([#"../bdd.rs" 416 14 416 20] a = b)
end
module Bdd_Impl10_BddCanonical
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_DiscrValuation_Stub as DiscrValuation0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    predicate Inv0.inv = Inv0.inv,
    function Interp0.interp = Interp0.interp,
    function Size0.size = Size0.size,
    axiom .
  function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
   =
    [#"../bdd.rs" 419 8 419 29] let _ = () in ()
  val bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 413 15 413 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 414 15 414 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v}
    requires {[#"../bdd.rs" 418 25 418 29] Inv0.inv self}
    ensures { [#"../bdd.rs" 416 14 416 20] a = b }
    ensures { result = bdd_canonical self a b }
    
  axiom bdd_canonical_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 413 15 413 35] IsValidBdd0.is_valid_bdd self a) -> ([#"../bdd.rs" 414 15 414 35] IsValidBdd0.is_valid_bdd self b) -> ([#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v) -> ([#"../bdd.rs" 418 25 418 29] Inv0.inv self) -> ([#"../bdd.rs" 416 14 416 20] a = b)
end
module Bdd_Impl10_BddCanonical_Impl
  use map.Map
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel4 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel3 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone Bdd_Impl4_ShallowModel as ShallowModel2 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel4.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel5.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl10_SetIrreleventVar as SetIrreleventVar0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv0.inv,
    function Interp0.interp = Interp0.interp,
    axiom .
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Bdd_Impl10_DiscrValuation as DiscrValuation0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    predicate Inv0.inv = Inv0.inv,
    function Interp0.interp = Interp0.interp,
    function Size0.size = Size0.size,
    function SetIrreleventVar0.set_irrelevent_var = SetIrreleventVar0.set_irrelevent_var,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    axiom .
  let rec ghost function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 413 15 413 35] IsValidBdd0.is_valid_bdd self a}
    requires {[#"../bdd.rs" 414 15 414 35] IsValidBdd0.is_valid_bdd self b}
    requires {[#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . Interp0.interp a v = Interp0.interp b v}
    requires {[#"../bdd.rs" 418 25 418 29] Inv0.inv self}
    ensures { [#"../bdd.rs" 416 14 416 20] a = b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 419 8 419 29] let _ = () in ()
end
module Bdd_Impl11_New_Interface
  use prelude.Borrow
  use Bdd_Context_Type as Bdd_Context_Type
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Bdd_Context_Type.t_context
  val new [#"../bdd.rs" 424 4 424 52] (alloc : Bdd_Bumpalo_Bump_Type.t_bump) : Bdd_Context_Type.t_context
    ensures { [#"../bdd.rs" 424 48 424 52] Inv0.inv result }
    
end
module Bdd_Impl11_New
  use map.Const
  use prelude.Ghost
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use prelude.Borrow
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel4 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel3 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel2 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel1 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel2.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  clone Bdd_Hashmap_Impl1_New_Interface as New2 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl1_New_Interface as New1 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Hashmap_Impl1_New_Interface as New0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  let constant promoted0 [#"../bdd.rs" 424 4 424 52]  : Bdd_Node_Type.t_node = [@vc:do_not_keep_trace] [@vc:sp]
    let _1 = Bdd_Node_Type.C_True in let _0 = _1 in _0
  let rec cfg new [#"../bdd.rs" 424 4 424 52] [@cfg:stackify] [@cfg:subregion_analysis] (alloc : Bdd_Bumpalo_Bump_Type.t_bump) : Bdd_Context_Type.t_context
    ensures { [#"../bdd.rs" 424 48 424 52] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Context_Type.t_context;
  var alloc : Bdd_Bumpalo_Bump_Type.t_bump = alloc;
  var t : Bdd_Node_Type.t_node;
  var _5 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
  var _6 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  var _8 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _9 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _10 : Bdd_Node_Type.t_node;
  {
    goto BB0
  }
  BB0 {
    _10 <- ([#"../bdd.rs" 425 16 425 21] promoted0);
    t <- _10;
    _5 <- ([#"../bdd.rs" 428 22 428 47] New0.new ());
    goto BB1
  }
  BB1 {
    _6 <- ([#"../bdd.rs" 429 28 429 51] Ghost.new (Const.const t));
    goto BB2
  }
  BB2 {
    _8 <- ([#"../bdd.rs" 430 22 430 47] New1.new ());
    goto BB3
  }
  BB3 {
    _9 <- ([#"../bdd.rs" 431 22 431 47] New2.new ());
    goto BB4
  }
  BB4 {
    _0 <- Bdd_Context_Type.C_Context alloc _5 _6 _8 _9 ([#"../bdd.rs" 432 17 432 18] (0 : uint64));
    _5 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
    _6 <- any Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
    _8 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
    _9 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Bdd_Impl11_Hashcons_Interface
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Context_Type as Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidNode_Stub as IsValidNode0
  val hashcons [#"../bdd.rs" 440 4 440 58] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] IsValidNode0.is_valid_node ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] Inv0.inv self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 439 14 439 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    
end
module Bdd_Impl11_Hashcons
  use prelude.Borrow
  use prelude.Ghost
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel8 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel7 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl8_Interp as Interp0
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel3 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel8.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv7.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Bdd_NodeLog_Type.t_nodelog
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Bdd_NodeLog_Type.t_nodelog,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Bdd_Node_Type.t_node)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (Bdd_Node_Type.t_node),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel4 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    predicate Inv2.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Bdd_Node_Type.t_node
  clone Bdd_Bumpalo_Impl0_Alloc_Interface as Alloc0 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv2.inv,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  let rec cfg hashcons [#"../bdd.rs" 440 4 440 58] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] IsValidNode0.is_valid_node ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] Inv0.inv self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 439 14 439 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var n : Bdd_Node_Type.t_node = n;
  var _8 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _11 : Bdd_Node_Type.t_node;
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _19 : borrowed (Bdd_Node_Type.t_node);
  var _23 : ();
  var _24 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd));
  var _27 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  {
    goto BB0
  }
  BB0 {
    _11 <- n;
    _8 <- ([#"../bdd.rs" 441 26 441 47] Get0.get (Bdd_Context_Type.context_hashcons ( * self)) _11);
    goto BB1
  }
  BB1 {
    switch (_8)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB4
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    r <- Core_Option_Option_Type.some_0 _8;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    assert { [@expl:assertion] [#"../bdd.rs" 442 28 442 38] ShallowModel0.shallow_model (Bdd_Bdd_Type.bdd_0 r) = ShallowModel1.shallow_model n };
    _0 <- r;
    goto BB12
  }
  BB4 {
    _19 <- ([#"../bdd.rs" 445 20 445 39] Alloc0.alloc (Bdd_Context_Type.context_alloc ( * self)) n);
    goto BB5
  }
  BB5 {
    r1 <- Bdd_Bdd_Type.C_Bdd ( * _19) (Bdd_Context_Type.context_cnt ( * self));
    assume { Resolve1.resolve _19 };
    _24 <- Borrow.borrow_mut (Bdd_Context_Type.context_hashcons ( * self));
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a ( ^ _24) c d e f) };
    _23 <- ([#"../bdd.rs" 446 8 446 31] Add0.add _24 n r1);
    _24 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd));
    goto BB6
  }
  BB6 {
    _27 <- ([#"../bdd.rs" 447 30 447 71] Ghost.new (Map.set (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost ( * self))) (Bdd_Bdd_Type.bdd_1 r1) (Bdd_Bdd_Type.bdd_0 r1)));
    goto BB7
  }
  BB7 {
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a b _27 d e f) };
    _27 <- any Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
    switch ([#"../bdd.rs" 448 11 448 34] Bdd_Context_Type.context_cnt ( * self) > ([#"../bdd.rs" 448 22 448 34] ([#"../bdd.rs" 448 22 448 30] (18446744073709551615 : uint64)) - ([#"../bdd.rs" 448 33 448 34] (1 : uint64))))
      | False -> goto BB11
      | True -> goto BB8
      end
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a b c d e (Bdd_Context_Type.context_cnt ( * self))) };
    goto BB9
  }
  BB11 {
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a b c d e ([#"../bdd.rs" 454 8 454 21] Bdd_Context_Type.context_cnt ( * self) + ([#"../bdd.rs" 454 20 454 21] (1 : uint64)))) };
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _0 <- r1;
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Bdd_Impl11_Node_Interface
  use prelude.Borrow
  use prelude.UInt64
  use prelude.Int
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  val node [#"../bdd.rs" 465 4 465 87] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] IsValidBdd0.is_valid_bdd ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] IsValidBdd0.is_valid_bdd ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < Leastvar0.leastvar childt /\ UInt64.to_int x < Leastvar0.leastvar childf}
    requires {[#"../bdd.rs" 465 17 465 21] Inv0.inv self}
    ensures { [#"../bdd.rs" 461 14 461 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 462 14 462 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . Interp0.interp result v = (if Map.get v x then
      Interp0.interp childt v
    else
      Interp0.interp childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= Leastvar0.leastvar result }
    
end
module Bdd_Impl11_Node
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel8 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel7 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl5_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  clone Bdd_Impl4_ShallowModel as ShallowModel5 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel3 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel1 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel8.shallow_model
  clone Bdd_Impl6_ShallowModel as ShallowModel4 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl11_Hashcons_Interface as Hashcons0 with
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  clone Bdd_Impl7_Eq_Interface as Eq0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec cfg node [#"../bdd.rs" 465 4 465 87] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] IsValidBdd0.is_valid_bdd ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] IsValidBdd0.is_valid_bdd ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < Leastvar0.leastvar childt /\ UInt64.to_int x < Leastvar0.leastvar childf}
    requires {[#"../bdd.rs" 465 17 465 21] Inv1.inv self}
    ensures { [#"../bdd.rs" 461 14 461 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 462 14 462 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . Interp0.interp result v = (if Map.get v x then
      Interp0.interp childt v
    else
      Interp0.interp childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : uint64 = x;
  var childt : Bdd_Bdd_Type.t_bdd = childt;
  var childf : Bdd_Bdd_Type.t_bdd = childf;
  var _13 : bool;
  var _17 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    _13 <- ([#"../bdd.rs" 466 11 466 27] Eq0.eq childt childf);
    goto BB1
  }
  BB1 {
    switch (_13)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    _0 <- childt;
    goto BB5
  }
  BB3 {
    _17 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _17) };
    assume { Inv0.inv ( ^ _17) };
    _0 <- ([#"../bdd.rs" 469 8 469 50] Hashcons0.hashcons _17 (Bdd_Node_Type.C_If x childt childf));
    _17 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Bdd_Impl11_True_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  val true_ [#"../bdd.rs" 476 4 476 42] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 476 22 476 26] Inv0.inv self}
    ensures { [#"../bdd.rs" 472 14 472 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 473 14 473 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . Interp0.interp result v }
    ensures { [#"../bdd.rs" 475 14 475 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
end
module Bdd_Impl11_True
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel6 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel4
  clone Bdd_Impl4_ShallowModel as ShallowModel3 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel5.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl11_Hashcons_Interface as Hashcons0 with
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  let rec cfg true_ [#"../bdd.rs" 476 4 476 42] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 476 22 476 26] Inv1.inv self}
    ensures { [#"../bdd.rs" 472 14 472 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 473 14 473 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . Interp0.interp result v }
    ensures { [#"../bdd.rs" 475 14 475 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var _6 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    _6 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    _0 <- ([#"../bdd.rs" 477 8 477 27] Hashcons0.hashcons _6 (Bdd_Node_Type.C_True));
    _6 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    return _0
  }
  
end
module Bdd_Impl11_False_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Core_Num_Impl9_Max_Stub as Max0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  val false_ [#"../bdd.rs" 484 4 484 43] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] Inv0.inv self}
    ensures { [#"../bdd.rs" 480 14 480 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 481 14 481 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not Interp0.interp result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
end
module Bdd_Impl11_False
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel6 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel4
  clone Bdd_Impl4_ShallowModel as ShallowModel3 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl8_Interp as Interp0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel5.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl11_Hashcons_Interface as Hashcons0 with
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd
  let rec cfg false_ [#"../bdd.rs" 484 4 484 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] Inv1.inv self}
    ensures { [#"../bdd.rs" 480 14 480 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 481 14 481 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not Interp0.interp result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int Max0.mAX' + 1 = Leastvar0.leastvar result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var _6 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    _6 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    _0 <- ([#"../bdd.rs" 485 8 485 28] Hashcons0.hashcons _6 (Bdd_Node_Type.C_False));
    _6 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    return _0
  }
  
end
module Bdd_Impl11_V_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  val v [#"../bdd.rs" 491 4 491 46] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 491 18 491 22] Inv0.inv self}
    ensures { [#"../bdd.rs" 488 14 488 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 489 14 489 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 490 4 490 56] forall v : Map.map uint64 bool . Interp0.interp result v = Map.get v x }
    
end
module Bdd_Impl11_V
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel0
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel6
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel5 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel4 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use prelude.Int
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl4_ShallowModel as ShallowModel3 with
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel0 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel4.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel5.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Context_Type.t_context
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Impl11_Node_Interface as Node0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone Bdd_Impl11_False_Interface as False0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl11_True_Interface as True0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  let rec cfg v [#"../bdd.rs" 491 4 491 46] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 491 18 491 22] Inv1.inv self}
    ensures { [#"../bdd.rs" 488 14 488 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 489 14 489 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 490 4 490 56] forall v : Map.map uint64 bool . Interp0.interp result v = Map.get v x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : uint64 = x;
  var t : Bdd_Bdd_Type.t_bdd;
  var _7 : borrowed (Bdd_Context_Type.t_context);
  var f : Bdd_Bdd_Type.t_bdd;
  var _9 : borrowed (Bdd_Context_Type.t_context);
  var _10 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    _7 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _7) };
    assume { Inv0.inv ( ^ _7) };
    t <- ([#"../bdd.rs" 492 16 492 28] True0.true_ _7);
    _7 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    _9 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _9) };
    assume { Inv0.inv ( ^ _9) };
    f <- ([#"../bdd.rs" 493 16 493 29] False0.false_ _9);
    _9 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB2
  }
  BB2 {
    _10 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _10) };
    assume { Inv0.inv ( ^ _10) };
    _0 <- ([#"../bdd.rs" 494 8 494 26] Node0.node _10 x t f);
    _10 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    return _0
  }
  
end
module Bdd_Impl11_Not_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  val not' [#"../bdd.rs" 503 4 503 56] (self : borrowed (Bdd_Context_Type.t_context)) (x : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 497 15 497 35] IsValidBdd0.is_valid_bdd ( * self) x}
    requires {[#"../bdd.rs" 503 20 503 24] Inv0.inv self}
    ensures { [#"../bdd.rs" 498 14 498 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 499 14 499 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 500 4 500 60] forall v : Map.map uint64 bool . Interp0.interp result v = (not Interp0.interp x v) }
    ensures { [#"../bdd.rs" 501 14 501 47] Leastvar0.leastvar x <= Leastvar0.leastvar result }
    
end
module Bdd_Impl11_Not
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel2
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel8 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel7
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Impl4_ShallowModel as ShallowModel6 with
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel4 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel3 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = uint64
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = uint64,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel1 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel8.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel2 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv4.inv,
    type DeepModelTy0.deepModelTy = uint64,
    predicate Inv2.inv = Inv5.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl11_Node_Interface as Node0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv0.inv,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone Bdd_Impl11_True_Interface as True0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl11_False_Interface as False0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = uint64
  let rec cfg not' [#"../bdd.rs" 503 4 503 56] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 497 15 497 35] IsValidBdd0.is_valid_bdd ( * self) x}
    requires {[#"../bdd.rs" 503 20 503 24] Inv0.inv self}
    ensures { [#"../bdd.rs" 498 14 498 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 499 14 499 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 500 4 500 60] forall v : Map.map uint64 bool . Interp0.interp result v = (not Interp0.interp x v) }
    ensures { [#"../bdd.rs" 501 14 501 47] Leastvar0.leastvar x <= Leastvar0.leastvar result }
    variant {[#"../bdd.rs" 502 14 502 22] Size0.size x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : Bdd_Bdd_Type.t_bdd = x;
  var _10 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _13 : Bdd_Bdd_Type.t_bdd;
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _19 : borrowed (Bdd_Context_Type.t_context);
  var _20 : borrowed (Bdd_Context_Type.t_context);
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var childt1 : Bdd_Bdd_Type.t_bdd;
  var _25 : borrowed (Bdd_Context_Type.t_context);
  var childf1 : Bdd_Bdd_Type.t_bdd;
  var _28 : borrowed (Bdd_Context_Type.t_context);
  var _30 : borrowed (Bdd_Context_Type.t_context);
  var _34 : ();
  var _35 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  {
    goto BB0
  }
  BB0 {
    _13 <- x;
    _10 <- ([#"../bdd.rs" 504 25 504 46] Get0.get (Bdd_Context_Type.context_not_memo ( * self)) _13);
    goto BB1
  }
  BB1 {
    switch (_10)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB5
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    r <- Core_Option_Option_Type.some_0 _10;
    _0 <- r;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    goto BB18
  }
  BB4 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    absurd
  }
  BB5 {
    switch (Bdd_Bdd_Type.bdd_0 x)
      | Bdd_Node_Type.C_False -> goto BB6
      | Bdd_Node_Type.C_True -> goto BB7
      | Bdd_Node_Type.C_If _ _ _ -> goto BB8
      end
  }
  BB6 {
    goto BB11
  }
  BB7 {
    goto BB9
  }
  BB8 {
    v <- Bdd_Node_Type.if_v (Bdd_Bdd_Type.bdd_0 x);
    childt <- Bdd_Node_Type.if_childt (Bdd_Bdd_Type.bdd_0 x);
    childf <- Bdd_Node_Type.if_childf (Bdd_Bdd_Type.bdd_0 x);
    _25 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _25) };
    assume { Inv1.inv ( ^ _25) };
    childt1 <- ([#"../bdd.rs" 511 29 511 45] not' _25 childt);
    _25 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB13
  }
  BB9 {
    _19 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _19) };
    assume { Inv1.inv ( ^ _19) };
    r1 <- ([#"../bdd.rs" 508 20 508 33] False0.false_ _19);
    _19 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB10
  }
  BB10 {
    goto BB16
  }
  BB11 {
    _20 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _20) };
    assume { Inv1.inv ( ^ _20) };
    r1 <- ([#"../bdd.rs" 509 21 509 33] True0.true_ _20);
    _20 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB12
  }
  BB12 {
    goto BB16
  }
  BB13 {
    _28 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _28) };
    assume { Inv1.inv ( ^ _28) };
    childf1 <- ([#"../bdd.rs" 512 29 512 45] not' _28 childf);
    _28 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB14
  }
  BB14 {
    _30 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _30) };
    assume { Inv1.inv ( ^ _30) };
    r1 <- ([#"../bdd.rs" 513 16 513 44] Node0.node _30 v childt1 childf1);
    _30 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    _35 <- Borrow.borrow_mut (Bdd_Context_Type.context_not_memo ( * self));
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a b c ( ^ _35) e f) };
    _34 <- ([#"../bdd.rs" 516 8 516 31] Add0.add _35 x r1);
    _35 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
    goto BB17
  }
  BB17 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve0.resolve self };
    _0 <- r1;
    goto BB18
  }
  BB18 {
    return _0
  }
  
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLog_Stub
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_Impl3_CmpLog_Interface
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self o }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLog
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 137 12 146 17] if self < o then
      Core_Cmp_Ordering_Type.C_Less
    else
      if self = o then Core_Cmp_Ordering_Type.C_Equal else Core_Cmp_Ordering_Type.C_Greater
    
  val cmp_log (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self o }
    
end
module Core_Cmp_Impls_Impl63_Cmp_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_Impl3_CmpLog_Stub as CmpLog0
  clone CreusotContracts_Std1_Num_Impl10_DeepModel_Stub as DeepModel0
  val cmp (self : uint64) (other : uint64) : Core_Cmp_Ordering_Type.t_ordering
    ensures { [#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85] result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLeLog_Stub
  use prelude.Int
  function cmp_le_log (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_CmpLeLog_Interface
  use prelude.Int
  function cmp_le_log (_1 : int) (_2 : int) : ()
  val cmp_le_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_le_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLeLog
  use prelude.Int
  function cmp_le_log (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 79 12 79 14] ()
  val cmp_le_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_le_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLtLog_Stub
  use prelude.Int
  function cmp_lt_log (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_CmpLtLog_Interface
  use prelude.Int
  function cmp_lt_log (_1 : int) (_2 : int) : ()
  val cmp_lt_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_lt_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpLtLog
  use prelude.Int
  function cmp_lt_log (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 85 12 85 14] ()
  val cmp_lt_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_lt_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpGeLog_Stub
  use prelude.Int
  function cmp_ge_log (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_CmpGeLog_Interface
  use prelude.Int
  function cmp_ge_log (_1 : int) (_2 : int) : ()
  val cmp_ge_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_ge_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpGeLog
  use prelude.Int
  function cmp_ge_log (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 91 12 91 14] ()
  val cmp_ge_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_ge_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpGtLog_Stub
  use prelude.Int
  function cmp_gt_log (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_CmpGtLog_Interface
  use prelude.Int
  function cmp_gt_log (_1 : int) (_2 : int) : ()
  val cmp_gt_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_gt_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_CmpGtLog
  use prelude.Int
  function cmp_gt_log (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 97 12 97 14] ()
  val cmp_gt_log (_1 : int) (_2 : int) : ()
    ensures { result = cmp_gt_log _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Refl_Stub
  use prelude.Int
  function refl (_1 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_Refl_Interface
  use prelude.Int
  function refl (_1 : int) : ()
  val refl (_1 : int) : ()
    ensures { result = refl _1 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Refl
  use prelude.Int
  function refl (_1 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 103 12 103 14] ()
  val refl (_1 : int) : ()
    ensures { result = refl _1 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Trans_Stub
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function trans (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
end
module CreusotContracts_Logic_Ord_Impl3_Trans_Interface
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function trans (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
    ensures { result = trans _1 _2 _3 _4 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Trans
  use prelude.Int
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function trans (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 109 12 109 14] ()
  val trans (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
    ensures { result = trans _1 _2 _3 _4 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Antisym1_Stub
  use prelude.Int
  function antisym1 (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_Antisym1_Interface
  use prelude.Int
  function antisym1 (_1 : int) (_2 : int) : ()
  val antisym1 (_1 : int) (_2 : int) : ()
    ensures { result = antisym1 _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Antisym1
  use prelude.Int
  function antisym1 (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 115 12 115 14] ()
  val antisym1 (_1 : int) (_2 : int) : ()
    ensures { result = antisym1 _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Antisym2_Stub
  use prelude.Int
  function antisym2 (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_Antisym2_Interface
  use prelude.Int
  function antisym2 (_1 : int) (_2 : int) : ()
  val antisym2 (_1 : int) (_2 : int) : ()
    ensures { result = antisym2 _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_Antisym2
  use prelude.Int
  function antisym2 (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 121 12 121 14] ()
  val antisym2 (_1 : int) (_2 : int) : ()
    ensures { result = antisym2 _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_EqCmp_Stub
  use prelude.Int
  function eq_cmp (_1 : int) (_2 : int) : ()
end
module CreusotContracts_Logic_Ord_Impl3_EqCmp_Interface
  use prelude.Int
  function eq_cmp (_1 : int) (_2 : int) : ()
  val eq_cmp (_1 : int) (_2 : int) : ()
    ensures { result = eq_cmp _1 _2 }
    
end
module CreusotContracts_Logic_Ord_Impl3_EqCmp
  use prelude.Int
  function eq_cmp (_1 : int) (_2 : int) : () =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 127 12 127 14] ()
  val eq_cmp (_1 : int) (_2 : int) : ()
    ensures { result = eq_cmp _1 _2 }
    
end
module Bdd_Impl11_And_Interface
  use prelude.Borrow
  use map.Map
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl8_Size_Stub as Size0 with
    axiom .
  clone Bdd_Impl8_Leastvar_Stub as Leastvar0
  clone Bdd_Impl8_Interp_Stub as Interp0
  clone Bdd_Impl10_Grows_Stub as Grows0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone Bdd_Impl10_IsValidBdd_Stub as IsValidBdd0
  val and [#"../bdd.rs" 527 4 527 72] (self : borrowed (Bdd_Context_Type.t_context)) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 520 15 520 35] IsValidBdd0.is_valid_bdd ( * self) a}
    requires {[#"../bdd.rs" 521 15 521 35] IsValidBdd0.is_valid_bdd ( * self) b}
    requires {[#"../bdd.rs" 527 20 527 24] Inv0.inv self}
    ensures { [#"../bdd.rs" 522 14 522 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 523 14 523 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 524 4 524 76] forall v : Map.map uint64 bool . Interp0.interp result v = (Interp0.interp a v /\ Interp0.interp b v) }
    ensures { [#"../bdd.rs" 525 14 525 84] Leastvar0.leastvar a <= Leastvar0.leastvar result \/ Leastvar0.leastvar b <= Leastvar0.leastvar result }
    
end
module Bdd_Impl11_And
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use map.Map
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel4
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel8 with
    type k = Bdd_Bdd_Type.t_bdd,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl9_ShallowModel as ShallowModel7
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel5 with
    type t = uint64,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl8_Leastvar as Leastvar0 with
    val Max0.mAX' = Max0.mAX',
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone Bdd_Impl4_ShallowModel as ShallowModel6 with
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel4 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel3 with
    type k = Bdd_Node_Type.t_node,
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog
  use Bdd_Context_Type as Bdd_Context_Type
  clone Bdd_Impl10_IsValidBdd as IsValidBdd0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model
  clone Bdd_Impl10_IsValidNode as IsValidNode0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone Bdd_Impl5_DeepModel as DeepModel3
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = (uint64, uint64)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = (uint64, uint64),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ord_Impl3_EqCmp_Interface as EqCmp0
  clone CreusotContracts_Logic_Ord_Impl3_Antisym2_Interface as Antisym20
  clone CreusotContracts_Logic_Ord_Impl3_Antisym1_Interface as Antisym10
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_Impl3_Trans_Interface as Trans0
  clone CreusotContracts_Logic_Ord_Impl3_Refl_Interface as Refl0
  clone CreusotContracts_Logic_Ord_Impl3_CmpGtLog_Interface as CmpGtLog0
  clone CreusotContracts_Logic_Ord_Impl3_CmpGeLog_Interface as CmpGeLog0
  clone CreusotContracts_Logic_Ord_Impl3_CmpLtLog_Interface as CmpLtLog0
  clone CreusotContracts_Logic_Ord_Impl3_CmpLeLog_Interface as CmpLeLog0
  clone Bdd_Hashmap_Impl0_ShallowModel_Interface as ShallowModel1 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  clone Bdd_Impl8_Interp as Interp0
  clone Bdd_Impl9_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate IsValidNode0.is_valid_node = IsValidNode0.is_valid_node,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    function ShallowModel2.shallow_model = ShallowModel8.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel2 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel2 with
    type a = Bdd_Bdd_Type.t_bdd,
    type b = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    type DeepModelTy1.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Logic_Ord_Impl3_CmpLog as CmpLog0
  clone CreusotContracts_Std1_Num_Impl10_DeepModel as DeepModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Context_Type.t_context
  clone Bdd_Context_Type_Inv as Bdd_Context_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve4 with
    type t = Bdd_Node_Type.t_node
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Bdd_Context_Type.t_context)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Bdd_Context_Type.t_context,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve3 with
    type t = Bdd_Bdd_Type.t_bdd
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type DeepModelTy0.deepModelTy = (uint64, uint64),
    function DeepModel0.deep_model = DeepModel2.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd),
    type ShallowModelTy0.shallowModelTy = Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Bdd_Impl8_Size as Size0 with
    axiom .
  clone Bdd_Impl10_Grows as Grows0 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone Bdd_Hashmap_Impl1_Add_Interface as Add0 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    type DeepModelTy0.deepModelTy = (uint64, uint64),
    predicate Inv2.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  clone Bdd_Impl11_Node_Interface as Node0 with
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Leastvar0.leastvar = Leastvar0.leastvar,
    predicate Inv0.inv = Inv0.inv,
    predicate Grows0.grows = Grows0.grows,
    function Interp0.interp = Interp0.interp
  clone Core_Cmp_Impls_Impl63_Cmp_Interface as Cmp0 with
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log
  clone Bdd_Impl11_False_Interface as False0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Grows0.grows = Grows0.grows,
    predicate IsValidBdd0.is_valid_bdd = IsValidBdd0.is_valid_bdd,
    function Interp0.interp = Interp0.interp,
    val Max0.mAX' = Max0.mAX',
    function Leastvar0.leastvar = Leastvar0.leastvar
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve2 with
    type t1 = Bdd_Node_Type.t_node,
    type t2 = Bdd_Node_Type.t_node,
    predicate Resolve0.resolve = Resolve4.resolve,
    predicate Resolve1.resolve = Resolve4.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Bdd_Context_Type.t_context
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Bdd_Bdd_Type.t_bdd,
    type t2 = Bdd_Bdd_Type.t_bdd,
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone Bdd_Hashmap_Impl1_Get_Interface as Get0 with
    type k = (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd),
    type v = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Inv1.inv = Inv3.inv,
    type DeepModelTy0.deepModelTy = (uint64, uint64)
  let rec cfg and [#"../bdd.rs" 527 4 527 72] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 520 15 520 35] IsValidBdd0.is_valid_bdd ( * self) a}
    requires {[#"../bdd.rs" 521 15 521 35] IsValidBdd0.is_valid_bdd ( * self) b}
    requires {[#"../bdd.rs" 527 20 527 24] Inv0.inv self}
    ensures { [#"../bdd.rs" 522 14 522 26] Grows0.grows self }
    ensures { [#"../bdd.rs" 523 14 523 42] IsValidBdd0.is_valid_bdd ( ^ self) result }
    ensures { [#"../bdd.rs" 524 4 524 76] forall v : Map.map uint64 bool . Interp0.interp result v = (Interp0.interp a v /\ Interp0.interp b v) }
    ensures { [#"../bdd.rs" 525 14 525 84] Leastvar0.leastvar a <= Leastvar0.leastvar result \/ Leastvar0.leastvar b <= Leastvar0.leastvar result }
    variant {[#"../bdd.rs" 526 14 526 33] Size0.size a + Size0.size b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var a : Bdd_Bdd_Type.t_bdd = a;
  var b : Bdd_Bdd_Type.t_bdd = b;
  var _12 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _15 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _16 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _23 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var _31 : borrowed (Bdd_Context_Type.t_context);
  var va : uint64;
  var childta : Bdd_Bdd_Type.t_bdd;
  var childfa : Bdd_Bdd_Type.t_bdd;
  var vb : uint64;
  var childtb : Bdd_Bdd_Type.t_bdd;
  var childfb : Bdd_Bdd_Type.t_bdd;
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var _41 : ();
  var _42 : Core_Cmp_Ordering_Type.t_ordering;
  var _45 : uint64;
  var _48 : Bdd_Bdd_Type.t_bdd;
  var _49 : borrowed (Bdd_Context_Type.t_context);
  var _52 : Bdd_Bdd_Type.t_bdd;
  var _53 : borrowed (Bdd_Context_Type.t_context);
  var _57 : Bdd_Bdd_Type.t_bdd;
  var _58 : borrowed (Bdd_Context_Type.t_context);
  var _61 : Bdd_Bdd_Type.t_bdd;
  var _62 : borrowed (Bdd_Context_Type.t_context);
  var _66 : Bdd_Bdd_Type.t_bdd;
  var _67 : borrowed (Bdd_Context_Type.t_context);
  var _70 : Bdd_Bdd_Type.t_bdd;
  var _71 : borrowed (Bdd_Context_Type.t_context);
  var _74 : borrowed (Bdd_Context_Type.t_context);
  var _78 : ();
  var _79 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  {
    goto BB0
  }
  BB0 {
    _16 <- (a, b);
    _15 <- _16;
    _12 <- ([#"../bdd.rs" 528 25 528 51] Get0.get (Bdd_Context_Type.context_and_memo ( * self)) _15);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _16 };
    switch (_12)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB5
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    r <- Core_Option_Option_Type.some_0 _12;
    _0 <- r;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    goto BB35
  }
  BB4 {
    absurd
  }
  BB5 {
    _23 <- (Bdd_Bdd_Type.bdd_0 a, Bdd_Bdd_Type.bdd_0 b);
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_True -> goto BB7
      | _ -> goto BB6
      end
  }
  BB6 {
    switch (let (_, a) = _23 in a)
      | Bdd_Node_Type.C_True -> goto BB9
      | _ -> goto BB8
      end
  }
  BB7 {
    goto BB15
  }
  BB8 {
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_False -> goto BB10
      | _ -> goto BB11
      end
  }
  BB9 {
    goto BB16
  }
  BB10 {
    goto BB17
  }
  BB11 {
    switch (let (_, a) = _23 in a)
      | Bdd_Node_Type.C_False -> goto BB12
      | Bdd_Node_Type.C_If _ _ _ -> goto BB13
      | _ -> goto BB38
      end
  }
  BB12 {
    goto BB17
  }
  BB13 {
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB14
      | _ -> goto BB39
      end
  }
  BB14 {
    vb <- Bdd_Node_Type.if_v (let (_, a) = _23 in a);
    childtb <- Bdd_Node_Type.if_childt (let (_, a) = _23 in a);
    childfb <- Bdd_Node_Type.if_childf (let (_, a) = _23 in a);
    va <- Bdd_Node_Type.if_v (let (a, _) = _23 in a);
    childta <- Bdd_Node_Type.if_childt (let (a, _) = _23 in a);
    childfa <- Bdd_Node_Type.if_childf (let (a, _) = _23 in a);
    assume { Resolve2.resolve _23 };
    _45 <- vb;
    _42 <- ([#"../bdd.rs" 540 22 540 33] Cmp0.cmp va _45);
    goto BB19
  }
  BB15 {
    assume { Resolve2.resolve _23 };
    r1 <- b;
    goto BB33
  }
  BB16 {
    assume { Resolve2.resolve _23 };
    r1 <- a;
    goto BB33
  }
  BB17 {
    assume { Resolve2.resolve _23 };
    _31 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _31) };
    assume { Inv1.inv ( ^ _31) };
    r1 <- ([#"../bdd.rs" 534 39 534 52] False0.false_ _31);
    _31 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB18
  }
  BB18 {
    goto BB33
  }
  BB19 {
    switch (_42)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB20
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB21
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB22
      end
  }
  BB20 {
    goto BB26
  }
  BB21 {
    v <- va;
    _67 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _67) };
    assume { Inv1.inv ( ^ _67) };
    _66 <- ([#"../bdd.rs" 553 33 553 59] and _67 childta childtb);
    _67 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB29
  }
  BB22 {
    goto BB23
  }
  BB23 {
    v <- vb;
    _49 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _49) };
    assume { Inv1.inv ( ^ _49) };
    _48 <- ([#"../bdd.rs" 543 33 543 53] and _49 a childtb);
    _49 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB24
  }
  BB24 {
    childt <- _48;
    _48 <- any Bdd_Bdd_Type.t_bdd;
    _53 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _53) };
    assume { Inv1.inv ( ^ _53) };
    _52 <- ([#"../bdd.rs" 544 33 544 53] and _53 a childfb);
    _53 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB25
  }
  BB25 {
    childf <- _52;
    _52 <- any Bdd_Bdd_Type.t_bdd;
    _41 <- ();
    goto BB31
  }
  BB26 {
    v <- va;
    _58 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _58) };
    assume { Inv1.inv ( ^ _58) };
    _57 <- ([#"../bdd.rs" 548 33 548 53] and _58 childta b);
    _58 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB27
  }
  BB27 {
    childt <- _57;
    _57 <- any Bdd_Bdd_Type.t_bdd;
    _62 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _62) };
    assume { Inv1.inv ( ^ _62) };
    _61 <- ([#"../bdd.rs" 549 33 549 53] and _62 childfa b);
    _62 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB28
  }
  BB28 {
    childf <- _61;
    _61 <- any Bdd_Bdd_Type.t_bdd;
    _41 <- ();
    goto BB31
  }
  BB29 {
    childt <- _66;
    _66 <- any Bdd_Bdd_Type.t_bdd;
    _71 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _71) };
    assume { Inv1.inv ( ^ _71) };
    _70 <- ([#"../bdd.rs" 554 33 554 59] and _71 childfa childfb);
    _71 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB30
  }
  BB30 {
    childf <- _70;
    _70 <- any Bdd_Bdd_Type.t_bdd;
    _41 <- ();
    goto BB31
  }
  BB31 {
    _74 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _74) };
    assume { Inv1.inv ( ^ _74) };
    r1 <- ([#"../bdd.rs" 557 16 557 44] Node0.node _74 v childt childf);
    _74 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB32
  }
  BB32 {
    goto BB33
  }
  BB33 {
    _79 <- Borrow.borrow_mut (Bdd_Context_Type.context_and_memo ( * self));
    self <- { self with current = (let Bdd_Context_Type.C_Context a b c d e f =  * self in Bdd_Context_Type.C_Context a b c d ( ^ _79) f) };
    _78 <- ([#"../bdd.rs" 560 8 560 36] Add0.add _79 (a, b) r1);
    _79 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
    goto BB34
  }
  BB34 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _0 <- r1;
    goto BB35
  }
  BB35 {
    return _0
  }
  BB37 {
    goto BB21
  }
  BB38 {
    assume { Resolve2.resolve _23 };
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    goto BB4
  }
  BB39 {
    assume { Resolve2.resolve _23 };
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    goto BB4
  }
  BB40 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    goto BB4
  }
  
end
module Bdd_Hashmap_Impl0
  type k
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  type v
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = v
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = u
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel2 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog2 with
    type self = v,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Bdd_Hashmap_Hash_HashLog_Interface as HashLog1 with
    type self = u,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Tuples_Impl4_DeepModel as DeepModel1 with
    type a = u,
    type b = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = (u, v)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = (u, v),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Bdd_Hashmap_Impl2_HashLog as HashLog0 with
    type u = u,
    type v = v,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    function HashLog0.hash_log = HashLog1.hash_log,
    function HashLog1.hash_log = HashLog2.hash_log,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = (u, v),
    type DeepModelTy0.deepModelTy = (DeepModelTy0.deepModelTy, DeepModelTy1.deepModelTy),
    function DeepModel0.deep_model = DeepModel1.deep_model
  goal hash_refn : [#"../bdd.rs" 76 8 76 29] forall self : (u, v) . Inv0.inv self -> Inv0.inv self /\ (forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self))
end
module Bdd_Impl1
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone Core_Num_Impl9_Max as Max0
  clone Bdd_Impl4_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Bdd_Impl1_HashLog as HashLog0 with
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Node_Type.t_node,
    type ShallowModelTy0.shallowModelTy = Bdd_NodeLog_Type.t_nodelog,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal hash_refn : [#"../bdd.rs" 116 4 116 25] forall self : Bdd_Node_Type.t_node . Inv0.inv self -> (forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self))
end
module Bdd_Impl2
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Bdd_Impl2_HashLog as HashLog0
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal hash_refn : [#"../bdd.rs" 142 4 142 25] forall self : Bdd_Bdd_Type.t_bdd . Inv0.inv self -> (forall result : uint64 . UInt64.to_int result = HashLog0.hash_log (ShallowModel0.shallow_model self) -> UInt64.to_int result = HashLog0.hash_log (DeepModel0.deep_model self))
end
module Bdd_Impl12
  
end
module Bdd_Impl18
  
end
module Bdd_Impl13
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 90 9 90 11] true
end
module Bdd_Impl19
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 104 15 104 17] true
end
module Bdd_Impl14
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  clone Bdd_Impl3_DeepModel as DeepModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Node_Type.t_node,
    type DeepModelTy0.deepModelTy = Bdd_NodeLog_Type.t_nodelog,
    function DeepModel0.deep_model = DeepModel1.deep_model
  goal eq_refn : [#"../bdd.rs" 90 13 90 22] forall self : Bdd_Node_Type.t_node . forall other : Bdd_Node_Type.t_node . Inv0.inv other /\ Inv0.inv self -> (forall result : bool . result = (DeepModel0.deep_model self = DeepModel0.deep_model other) -> result = (DeepModel0.deep_model self = DeepModel0.deep_model other))
end
module Bdd_Impl7
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt64
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone Bdd_Impl5_DeepModel as DeepModel1
  clone Bdd_Impl6_ShallowModel as ShallowModel1 with
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl4_DeepModel as DeepModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type DeepModelTy0.deepModelTy = uint64,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Bdd_Bdd_Type.t_bdd,
    type ShallowModelTy0.shallowModelTy = uint64,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  goal eq_refn : [#"../bdd.rs" 202 4 202 34] forall self : Bdd_Bdd_Type.t_bdd . forall other : Bdd_Bdd_Type.t_bdd . Inv0.inv other /\ Inv0.inv self -> (forall result : bool . result = (ShallowModel0.shallow_model self = ShallowModel0.shallow_model other) -> result = (DeepModel0.deep_model self = DeepModel0.deep_model other))
end
module Bdd_Impl15
  use prelude.Borrow
  use Bdd_Node_Type as Bdd_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Node_Type.t_node
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Node_Type.t_node,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal clone'_refn : [#"../bdd.rs" 90 24 90 29] forall self : Bdd_Node_Type.t_node . Inv0.inv self -> (forall result : Bdd_Node_Type.t_node . result = self -> Inv1.inv result /\ result = self)
end
module Bdd_Impl0
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Bdd_Bdd_Type.t_bdd
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Bdd_Bdd_Type.t_bdd,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  goal clone'_refn : [#"../bdd.rs" 109 4 109 27] forall self : Bdd_Bdd_Type.t_bdd . Inv0.inv self -> (forall result : Bdd_Bdd_Type.t_bdd . result = self -> Inv1.inv result /\ result = self)
end
module Bdd_Impl16
  
end
module Bdd_Impl17
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
module Bdd_Impl9
  
end
