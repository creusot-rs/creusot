
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module Bdd_Hashmap_Impl2_Hash
  type u
  type v
  predicate invariant2 (self : v)
  val invariant2 (self : v) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : v)
  val inv2 (_x : v) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : v . inv2 x = true
  predicate invariant1 (self : u)
  val invariant1 (self : u) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : u)
  val inv1 (_x : u) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : u . inv1 x = true
  predicate invariant0 (self : (u, v))
  val invariant0 (self : (u, v)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (u, v))
  val inv0 (_x : (u, v)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (u, v) . inv0 x = true
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  type deep_model_ty1
  function hash_log2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty1) : int
  val hash_log2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty1) : int
    ensures { result = hash_log2 _1 }
    
  type deep_model_ty0
  function hash_log1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty0) : int
  val hash_log1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty0) : int
    ensures { result = hash_log1 _1 }
    
  function hash_log0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty0, deep_model_ty1)) : int =
    [#"../bdd.rs" 83 24 83 84] mod (hash_log1 (let (a, _) = x in a) + hash_log2 (let (_, a) = x in a) * 17) (UInt64.to_int max0 + 1)
  val hash_log0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty0, deep_model_ty1)) : int
    ensures { result = hash_log0 x }
    
  function deep_model5 (self : v) : deep_model_ty1
  val deep_model5 (self : v) : deep_model_ty1
    ensures { result = deep_model5 self }
    
  function deep_model4 (self : u) : deep_model_ty0
  val deep_model4 (self : u) : deep_model_ty0
    ensures { result = deep_model4 self }
    
  function deep_model3 (self : (u, v)) : (deep_model_ty0, deep_model_ty1) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model4 (let (a, _) = self in a), deep_model5 (let (_, a) = self in a))
  val deep_model3 (self : (u, v)) : (deep_model_ty0, deep_model_ty1)
    ensures { result = deep_model3 self }
    
  use prelude.Borrow
  function deep_model0 (self : (u, v)) : (deep_model_ty0, deep_model_ty1) =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model3 self
  val deep_model0 (self : (u, v)) : (deep_model_ty0, deep_model_ty1)
    ensures { result = deep_model0 self }
    
  use prelude.UInt32
  let constant min0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint64)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (64 : uint32)
  val wrapping_add0 (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt64.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int min0 /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int max0 -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int min0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs + k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int max0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs - k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    
  val wrapping_mul0 (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt64.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int min0 /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int max0 -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int min0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs + k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int max0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs - k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    
  function deep_model2 (self : v) : deep_model_ty1 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model5 self
  val deep_model2 (self : v) : deep_model_ty1
    ensures { result = deep_model2 self }
    
  val hash1 [#"../bdd.rs" 31 8 31 30] (self : v) : uint64
    requires {[#"../bdd.rs" 31 17 31 21] inv2 self}
    ensures { [#"../bdd.rs" 30 18 30 62] UInt64.to_int result = hash_log2 (deep_model2 self) }
    
  predicate resolve0 (self : (u, v))
  val resolve0 (self : (u, v)) : bool
    ensures { result = resolve0 self }
    
  function deep_model1 (self : u) : deep_model_ty0 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model4 self
  val deep_model1 (self : u) : deep_model_ty0
    ensures { result = deep_model1 self }
    
  val hash0 [#"../bdd.rs" 31 8 31 30] (self : u) : uint64
    requires {[#"../bdd.rs" 31 17 31 21] inv1 self}
    ensures { [#"../bdd.rs" 30 18 30 62] UInt64.to_int result = hash_log1 (deep_model1 self) }
    
  let rec cfg hash [#"../bdd.rs" 76 8 76 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : (u, v)) : uint64
    requires {[#"../bdd.rs" 76 17 76 21] inv0 self}
    ensures { [#"../bdd.rs" 75 18 75 62] UInt64.to_int result = hash_log0 (deep_model0 self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : (u, v) = self;
  var _3 : uint64;
  var _5 : uint64;
  var _6 : uint64;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 77 12 77 25] _3 <- ([#"../bdd.rs" 77 12 77 25] hash0 ([#"../bdd.rs" 77 12 77 25] let (a, _) = self in a));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    [#"../bdd.rs" 77 39 77 52] _6 <- ([#"../bdd.rs" 77 39 77 52] hash1 ([#"../bdd.rs" 77 39 77 52] let (_, a) = self in a));
    goto BB2
  }
  BB2 {
    [#"../bdd.rs" 77 39 77 69] _5 <- ([#"../bdd.rs" 77 39 77 69] wrapping_mul0 _6 ([#"../bdd.rs" 77 66 77 68] [#"../bdd.rs" 77 66 77 68] (17 : uint64)));
    _6 <- any uint64;
    goto BB3
  }
  BB3 {
    [#"../bdd.rs" 77 12 77 70] _0 <- ([#"../bdd.rs" 77 12 77 70] wrapping_add0 _3 _5);
    _3 <- any uint64;
    _5 <- any uint64;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Bdd_Bdd_Type
  use prelude.UInt64
  use prelude.Int
  use prelude.Borrow
  type t_bdd  =
    | C_Bdd (t_node) uint64
    with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
    
  let function if_v (self : t_node) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_False -> any uint64
      | C_True -> any uint64
      | C_If a _ _ -> a
      end
  let function if_childt (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ a _ -> a
      end
  let function if_childf (self : t_node) : t_bdd = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_False -> any t_bdd
      | C_True -> any t_bdd
      | C_If _ _ a -> a
      end
  let function bdd_1 (self : t_bdd) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Bdd _ a -> a
      end
  let function bdd_0 (self : t_bdd) : t_node = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl13_AssertReceiverIsTotalEq
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 90 9 90 11] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 90 9 90 11] _0 <- ([#"../bdd.rs" 90 9 90 11] ());
    return _0
  }
  
end
module Bdd_Impl7_Eq
  use prelude.UInt64
  use prelude.Int
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  function shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model0 self
  val shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  use prelude.Borrow
  function shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model0 self }
    
  let rec cfg eq [#"../bdd.rs" 202 4 202 34] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 201 14 201 37] result = (shallow_model0 self = shallow_model0 o) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Bdd_Bdd_Type.t_bdd = self;
  var o : Bdd_Bdd_Type.t_bdd = o;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 203 8 203 21] _0 <- ([#"../bdd.rs" 203 8 203 21] ([#"../bdd.rs" 203 8 203 14] Bdd_Bdd_Type.bdd_1 self) = ([#"../bdd.rs" 203 18 203 21] Bdd_Bdd_Type.bdd_1 o));
    return _0
  }
  
end
module Bdd_NodeLog_Type
  use prelude.UInt64
  use prelude.Int
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
    
end
module Bdd_Impl14_Eq
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model2 self }
    
  use prelude.Borrow
  function deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model2 self
  val deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  use prelude.UInt64
  use prelude.Int
  use prelude.Int
  use prelude.UInt64
  function deep_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UInt64.to_int self
  val deep_model3 (self : uint64) : int
    ensures { result = deep_model3 self }
    
  function deep_model1 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model3 self
  val deep_model1 (self : uint64) : int
    ensures { result = deep_model1 self }
    
  val eq1 (self : uint64) (other : uint64) : bool
    ensures { [#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75] result = (deep_model1 self = deep_model1 other) }
    
  function deep_model4 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model4 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model4 self }
    
  function shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model4 self
  val shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  function shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model0 self }
    
  val eq0 [#"../bdd.rs" 202 4 202 34] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 201 14 201 37] result = (shallow_model0 self = shallow_model0 o) }
    
  predicate resolve1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve1 (let (a, _) = self in a) /\ resolve1 (let (_, a) = self in a)
  val resolve0 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg eq [#"../bdd.rs" 90 13 90 22] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) (rhs : Bdd_Node_Type.t_node) : bool
    ensures { [#"../bdd.rs" 90 13 90 22] result = (deep_model0 self = deep_model0 rhs) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self : Bdd_Node_Type.t_node = self;
  var rhs : Bdd_Node_Type.t_node = rhs;
  var _4 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var v_1 : uint64;
  var childt_1 : Bdd_Bdd_Type.t_bdd;
  var childf_1 : Bdd_Bdd_Type.t_bdd;
  var v_2 : uint64;
  var childt_2 : Bdd_Bdd_Type.t_bdd;
  var childf_2 : Bdd_Bdd_Type.t_bdd;
  var _17 : bool;
  var _18 : bool;
  var _19 : bool;
  var _22 : bool;
  var _25 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 90 13 90 22] _4 <- ([#"../bdd.rs" 90 13 90 22] (([#"../bdd.rs" 90 13 90 22] self), ([#"../bdd.rs" 90 13 90 22] rhs)));
    switch (let (a, _) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB4
      | Bdd_Node_Type.C_If _ _ _ -> goto BB6
      end
  }
  BB1 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_False -> goto BB2
      | _ -> goto BB3
      end
  }
  BB2 {
    goto BB8
  }
  BB3 {
    assume { resolve0 _4 };
    [#"../bdd.rs" 90 13 90 22] _0 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] false);
    goto BB23
  }
  BB4 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_True -> goto BB5
      | _ -> goto BB3
      end
  }
  BB5 {
    goto BB9
  }
  BB6 {
    switch (let (_, a) = _4 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB7
      | _ -> goto BB3
      end
  }
  BB7 {
    goto BB10
  }
  BB8 {
    assume { resolve0 _4 };
    [#"../bdd.rs" 90 13 90 22] _0 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] true);
    goto BB23
  }
  BB9 {
    assume { resolve0 _4 };
    [#"../bdd.rs" 90 13 90 22] _0 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] true);
    goto BB23
  }
  BB10 {
    [#"../bdd.rs" 94 9 94 10] v_1 <- ([#"../bdd.rs" 94 9 94 10] Bdd_Node_Type.if_v (let (a, _) = _4 in a));
    [#"../bdd.rs" 94 17 94 23] childt_1 <- ([#"../bdd.rs" 94 17 94 23] Bdd_Node_Type.if_childt (let (a, _) = _4 in a));
    [#"../bdd.rs" 94 38 94 44] childf_1 <- ([#"../bdd.rs" 94 38 94 44] Bdd_Node_Type.if_childf (let (a, _) = _4 in a));
    [#"../bdd.rs" 94 9 94 10] v_2 <- ([#"../bdd.rs" 94 9 94 10] Bdd_Node_Type.if_v (let (_, a) = _4 in a));
    [#"../bdd.rs" 94 17 94 23] childt_2 <- ([#"../bdd.rs" 94 17 94 23] Bdd_Node_Type.if_childt (let (_, a) = _4 in a));
    [#"../bdd.rs" 94 38 94 44] childf_2 <- ([#"../bdd.rs" 94 38 94 44] Bdd_Node_Type.if_childf (let (_, a) = _4 in a));
    assume { resolve0 _4 };
    [#"../bdd.rs" 90 13 90 22] _19 <- ([#"../bdd.rs" 90 13 90 22] eq0 ([#"../bdd.rs" 90 13 90 22] childf_1) ([#"../bdd.rs" 94 38 94 44] childf_2));
    goto BB20
  }
  BB11 {
    [#"../bdd.rs" 90 13 90 22] _0 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] false);
    goto BB13
  }
  BB12 {
    [#"../bdd.rs" 90 13 90 22] _0 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] true);
    goto BB13
  }
  BB13 {
    goto BB23
  }
  BB14 {
    [#"../bdd.rs" 90 13 90 22] _17 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] false);
    goto BB16
  }
  BB15 {
    [#"../bdd.rs" 90 13 90 22] _25 <- ([#"../bdd.rs" 90 13 90 22] eq1 ([#"../bdd.rs" 90 13 90 22] v_1) ([#"../bdd.rs" 94 9 94 10] v_2));
    goto BB22
  }
  BB16 {
    switch (_17)
      | False -> goto BB11
      | True -> goto BB12
      end
  }
  BB17 {
    [#"../bdd.rs" 90 13 90 22] _18 <- ([#"../bdd.rs" 90 13 90 22] [#"../bdd.rs" 90 13 90 22] false);
    goto BB19
  }
  BB18 {
    [#"../bdd.rs" 90 13 90 22] _22 <- ([#"../bdd.rs" 90 13 90 22] eq0 ([#"../bdd.rs" 90 13 90 22] childt_1) ([#"../bdd.rs" 94 17 94 23] childt_2));
    goto BB21
  }
  BB19 {
    switch (_18)
      | False -> goto BB14
      | True -> goto BB15
      end
  }
  BB20 {
    switch (_19)
      | False -> goto BB17
      | True -> goto BB18
      end
  }
  BB21 {
    [#"../bdd.rs" 90 13 90 22] _18 <- ([#"../bdd.rs" 90 13 90 22] _22);
    [#"../bdd.rs" 90 13 90 22] _22 <- any bool;
    goto BB19
  }
  BB22 {
    [#"../bdd.rs" 90 13 90 22] _17 <- ([#"../bdd.rs" 90 13 90 22] _25);
    [#"../bdd.rs" 90 13 90 22] _25 <- any bool;
    goto BB16
  }
  BB23 {
    return _0
  }
  
end
module Bdd_Impl0_Clone
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec cfg clone' [#"../bdd.rs" 109 4 109 27] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 108 14 108 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : Bdd_Bdd_Type.t_bdd = self;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 110 8 110 13] _0 <- ([#"../bdd.rs" 110 8 110 13] self);
    return _0
  }
  
end
module Bdd_Impl15_Clone
  use prelude.Borrow
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.UInt64
  use prelude.Int
  val clone1 [#"../bdd.rs" 109 4 109 27] (self : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    ensures { [#"../bdd.rs" 108 14 108 29] result = self }
    
  val clone0 (self : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
  use Bdd_Node_Type as Bdd_Node_Type
  let rec cfg clone' [#"../bdd.rs" 90 24 90 29] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : Bdd_Node_Type.t_node
    ensures { [#"../bdd.rs" 90 24 90 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Node_Type.t_node;
  var self : Bdd_Node_Type.t_node = self;
  var v_1 : uint64;
  var childt_1 : Bdd_Bdd_Type.t_bdd;
  var childf_1 : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _9 : uint64;
  var _10 : Bdd_Bdd_Type.t_bdd;
  var _12 : Bdd_Bdd_Type.t_bdd;
  var _13 : Bdd_Bdd_Type.t_bdd;
  var _15 : Bdd_Bdd_Type.t_bdd;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB2
      | Bdd_Node_Type.C_If _ _ _ -> goto BB3
      end
  }
  BB1 {
    goto BB5
  }
  BB2 {
    goto BB6
  }
  BB3 {
    [#"../bdd.rs" 94 9 94 10] v_1 <- ([#"../bdd.rs" 94 9 94 10] Bdd_Node_Type.if_v self);
    [#"../bdd.rs" 94 17 94 23] childt_1 <- ([#"../bdd.rs" 94 17 94 23] Bdd_Node_Type.if_childt self);
    [#"../bdd.rs" 94 38 94 44] childf_1 <- ([#"../bdd.rs" 94 38 94 44] Bdd_Node_Type.if_childf self);
    [#"../bdd.rs" 90 24 90 29] _9 <- ([#"../bdd.rs" 90 24 90 29] v_1);
    [#"../bdd.rs" 90 24 90 29] _7 <- ([#"../bdd.rs" 90 24 90 29] clone0 ([#"../bdd.rs" 90 24 90 29] _9));
    goto BB7
  }
  BB4 {
    assert { [#"../bdd.rs" 90 24 90 29] false };
    absurd
  }
  BB5 {
    [#"../bdd.rs" 91 5 92 9] _0 <- ([#"../bdd.rs" 91 5 92 9] Bdd_Node_Type.C_False);
    goto BB10
  }
  BB6 {
    [#"../bdd.rs" 91 5 93 8] _0 <- ([#"../bdd.rs" 91 5 93 8] Bdd_Node_Type.C_True);
    goto BB10
  }
  BB7 {
    [#"../bdd.rs" 90 24 90 29] _12 <- ([#"../bdd.rs" 90 24 90 29] childt_1);
    [#"../bdd.rs" 90 24 90 29] _10 <- ([#"../bdd.rs" 90 24 90 29] clone1 ([#"../bdd.rs" 90 24 90 29] _12));
    goto BB8
  }
  BB8 {
    [#"../bdd.rs" 90 24 90 29] _15 <- ([#"../bdd.rs" 90 24 90 29] childf_1);
    [#"../bdd.rs" 90 24 90 29] _13 <- ([#"../bdd.rs" 90 24 90 29] clone1 ([#"../bdd.rs" 90 24 90 29] _15));
    goto BB9
  }
  BB9 {
    [#"../bdd.rs" 90 24 90 29] _0 <- ([#"../bdd.rs" 90 24 90 29] Bdd_Node_Type.C_If _7 _10 _13);
    _7 <- any uint64;
    _10 <- any Bdd_Bdd_Type.t_bdd;
    _13 <- any Bdd_Bdd_Type.t_bdd;
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Bdd_Impl19_AssertReceiverIsTotalEq
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.Borrow
  let rec cfg assert_receiver_is_total_eq [#"../bdd.rs" 104 15 104 17] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 104 15 104 17] _0 <- ([#"../bdd.rs" 104 15 104 17] ());
    return _0
  }
  
end
module Bdd_Impl1_Hash
  use prelude.UInt64
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  use prelude.UInt64
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 130 12 135 13] match x with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5 + UInt64.to_int childf * 7) (UInt64.to_int max0 + 1)
      end
  val hash_log0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
    ensures { result = hash_log0 x }
    
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model3 self }
    
  use prelude.Borrow
  function shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model1 self }
    
  use prelude.UInt32
  let constant min0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (0 : uint64)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  let constant bits0  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (64 : uint32)
  val wrapping_add0 (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt64.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int min0 /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int max0 -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int min0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs + k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int max0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs - k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    
  val wrapping_mul0 (self : uint64) (rhs : uint64) : uint64
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 135 20 135 93] UInt64.to_int result = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int bits0)) + UInt64.to_int min0 }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 138 16 141 18] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int min0 /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int max0 -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 145 16 149 18] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int min0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs + k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 150 16 154 18] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int max0 -> (exists k : int . k > 0 /\ UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs - k * (UInt64.to_int max0 - UInt64.to_int min0 + 1)) }
    
  let rec cfg hash [#"../bdd.rs" 116 4 116 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Node_Type.t_node) : uint64
    ensures { [#"../bdd.rs" 115 14 115 46] UInt64.to_int result = hash_log0 (shallow_model1 self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : Bdd_Node_Type.t_node = self;
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var _7 : uint64;
  var _9 : uint64;
  var _11 : uint64;
  {
    goto BB0
  }
  BB0 {
    switch (self)
      | Bdd_Node_Type.C_False -> goto BB1
      | Bdd_Node_Type.C_True -> goto BB2
      | Bdd_Node_Type.C_If _ _ _ -> goto BB3
      end
  }
  BB1 {
    goto BB5
  }
  BB2 {
    goto BB6
  }
  BB3 {
    [#"../bdd.rs" 120 17 120 18] v <- ([#"../bdd.rs" 120 17 120 18] Bdd_Node_Type.if_v self);
    [#"../bdd.rs" 120 20 120 26] childt <- ([#"../bdd.rs" 120 20 120 26] Bdd_Node_Type.if_childt self);
    [#"../bdd.rs" 120 28 120 34] childf <- ([#"../bdd.rs" 120 28 120 34] Bdd_Node_Type.if_childf self);
    [#"../bdd.rs" 121 31 121 55] _9 <- ([#"../bdd.rs" 121 31 121 55] wrapping_mul0 ([#"../bdd.rs" 121 31 121 39] Bdd_Bdd_Type.bdd_1 childt) ([#"../bdd.rs" 121 53 121 54] [#"../bdd.rs" 121 53 121 54] (5 : uint64)));
    goto BB7
  }
  BB4 {
    assert { [#"../bdd.rs" 117 14 117 18] false };
    absurd
  }
  BB5 {
    [#"../bdd.rs" 118 21 118 22] _0 <- ([#"../bdd.rs" 118 21 118 22] [#"../bdd.rs" 118 21 118 22] (1 : uint64));
    goto BB11
  }
  BB6 {
    [#"../bdd.rs" 119 20 119 21] _0 <- ([#"../bdd.rs" 119 20 119 21] [#"../bdd.rs" 119 20 119 21] (2 : uint64));
    goto BB11
  }
  BB7 {
    [#"../bdd.rs" 121 16 121 56] _7 <- ([#"../bdd.rs" 121 16 121 56] wrapping_add0 ([#"../bdd.rs" 121 16 121 56] v) _9);
    _9 <- any uint64;
    goto BB8
  }
  BB8 {
    [#"../bdd.rs" 121 70 121 94] _11 <- ([#"../bdd.rs" 121 70 121 94] wrapping_mul0 ([#"../bdd.rs" 121 70 121 78] Bdd_Bdd_Type.bdd_1 childf) ([#"../bdd.rs" 121 92 121 93] [#"../bdd.rs" 121 92 121 93] (7 : uint64)));
    goto BB9
  }
  BB9 {
    [#"../bdd.rs" 121 16 121 95] _0 <- ([#"../bdd.rs" 121 16 121 95] wrapping_add0 _7 _11);
    _7 <- any uint64;
    _11 <- any uint64;
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Bdd_Impl2_Hash
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  function hash_log0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [#"../bdd.rs" 149 8 149 24] UInt64.to_int x
  val hash_log0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
    ensures { result = hash_log0 x }
    
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  function shallow_model2 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model0 self
  val shallow_model2 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model2 self }
    
  use prelude.Borrow
  function shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  let rec cfg hash [#"../bdd.rs" 142 4 142 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { [#"../bdd.rs" 141 14 141 46] UInt64.to_int result = hash_log0 (shallow_model1 self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint64;
  var self : Bdd_Bdd_Type.t_bdd = self;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 143 8 143 14] _0 <- ([#"../bdd.rs" 143 8 143 14] Bdd_Bdd_Type.bdd_1 self);
    return _0
  }
  
end
module Bdd_Impl8_Size_Impl
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.Int
  let rec ghost function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { [#"../bdd.rs" 223 14 223 25] result >= 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
end
module Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use prelude.UInt64
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  use prelude.Ghost
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  use prelude.Borrow
  type t_context  =
    | C_Context (Bdd_Bumpalo_Bump_Type.t_bump) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) uint64
    
  let function context_hashcons (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context _ a _ _ _ _ -> a
      end
  let function context_cnt (self : t_context) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context _ _ _ _ _ a -> a
      end
  let function context_hashcons_ghost (self : t_context) : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node))
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context _ _ a _ _ _ -> a
      end
  let function context_not_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context _ _ _ a _ _ -> a
      end
  let function context_and_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context _ _ _ _ a _ -> a
      end
  let function context_alloc (self : t_context) : Bdd_Bumpalo_Bump_Type.t_bump = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Context a _ _ _ _ _ -> a
      end
end
module Bdd_Impl10_GrowsIsValidBdd_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use map.Map
  function shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model4 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model3 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Context_Type.t_context)
  val inv1 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Context_Type.t_context . inv1 x = (invariant1 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv0 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  let rec ghost function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 333 15 333 27] grows0 self}
    requires {[#"../bdd.rs" 334 15 334 35] is_valid_bdd0 ( * self) b}
    requires {[#"../bdd.rs" 336 35 336 39] inv0 self}
    ensures { [#"../bdd.rs" 335 14 335 37] is_valid_bdd0 ( ^ self) b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 331 4 331 12] ()
end
module Bdd_Impl10_GrowsTrans_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model4 self }
    
  use map.Map
  function shallow_model3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model5 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model5 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model5 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model5 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model3 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model4 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Context_Type.t_context)
  val inv1 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Context_Type.t_context . inv1 x = (invariant1 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv0 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  let rec ghost function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    requires {[#"../bdd.rs" 340 15 340 27] grows0 self}
    requires {[#"../bdd.rs" 341 15 341 24] grows0 o}
    requires {[#"../bdd.rs" 342 15 342 26]  ^ self =  * o}
    requires {[#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo}
    requires {[#"../bdd.rs" 345 28 345 32] inv0 self}
    requires {[#"../bdd.rs" 345 34 345 35] inv0 o}
    requires {[#"../bdd.rs" 345 48 345 50] inv0 oo}
    ensures { [#"../bdd.rs" 344 14 344 24] grows0 oo }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 338 4 338 12] ()
end
module Bdd_Impl10_SetIrreleventVar_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model3 (self : uint64) : int
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model3 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Map
  let rec ghost function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar0 a}
    requires {[#"../bdd.rs" 351 26 351 30] inv0 self}
    ensures { [#"../bdd.rs" 350 14 350 50] interp0 a v = interp0 a (Map.set v x b) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 353 12 359 13] match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
end
module Bdd_Impl10_DiscrValuation_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model3 (self : uint64) : int
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model3 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model1 self }
    
  function shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model0 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) (shallow_model1 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model1 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Const
  use map.Map
  function set_irrelevent_var0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 353 12 359 13] match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var0 self childt x v b in let _ = set_irrelevent_var0 self childf x v b in ()
      | _ -> ()
      end
  val set_irrelevent_var0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar0 a}
    requires {[#"../bdd.rs" 351 26 351 30] inv0 self}
    ensures { result = set_irrelevent_var0 self a x v b }
    
  axiom set_irrelevent_var0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] is_valid_bdd0 self a) -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar0 a) -> ([#"../bdd.rs" 351 26 351 30] inv0 self) -> ([#"../bdd.rs" 350 14 350 50] interp0 a v = interp0 a (Map.set v x b))
  function size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size0 childt in let hf = size0 childf in 1 + ht + hf
      end
  val size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = size0 self }
    
  axiom size0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size0 self >= 0
  let rec ghost function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 364 15 364 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 365 15 365 35] is_valid_bdd0 self b}
    requires {[#"../bdd.rs" 366 15 366 21] a <> b}
    requires {[#"../bdd.rs" 370 23 370 27] inv0 self}
    ensures { [#"../bdd.rs" 367 14 367 50] interp0 a result <> interp0 b result }
    variant {[#"../bdd.rs" 368 14 368 33] size0 a + size0 b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 372 12 372 36] let _ = () in if let x1 = leastvar0 b in let x0 = leastvar0 a in pure {x0 < x1} then
      match a with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> b} then
          let a' = discr_valuation self childf b in Map.set a' v false
        else
          let a' = discr_valuation self childt b in Map.set a' v true
        
        | _ -> Const.const true
        end
    else
      if let x1 = leastvar0 b in let x0 = leastvar0 a in pure {x0 > x1} then
        match b with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if pure {childf <> a} then
            let a' = discr_valuation self a childf in Map.set a' v false
          else
            let a' = discr_valuation self a childt in Map.set a' v true
          
          | _ -> Const.const true
          end
      else
        match a with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match b with
            | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if pure {childfa <> childfb} then
              let a' = discr_valuation self childfa childfb in Map.set a' v false
            else
              let a' = discr_valuation self childta childtb in Map.set a' v true
            
            | _ -> Const.const true
            end
          | _ -> Const.const true
          end
      
    
end
module Bdd_Impl10_BddCanonical_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model4 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model4 (self : uint64) : int
    ensures { result = shallow_model4 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model4 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model1 self }
    
  function shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model0 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) (shallow_model1 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model1 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Const
  use map.Map
  function set_irrelevent_var0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 353 12 359 13] match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var0 self childt x v b in let _ = set_irrelevent_var0 self childf x v b in ()
      | _ -> ()
      end
  val set_irrelevent_var0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    requires {[#"../bdd.rs" 348 15 348 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar0 a}
    requires {[#"../bdd.rs" 351 26 351 30] inv0 self}
    ensures { result = set_irrelevent_var0 self a x v b }
    
  axiom set_irrelevent_var0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] is_valid_bdd0 self a) -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar0 a) -> ([#"../bdd.rs" 351 26 351 30] inv0 self) -> ([#"../bdd.rs" 350 14 350 50] interp0 a v = interp0 a (Map.set v x b))
  function size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size0 childt in let hf = size0 childf in 1 + ht + hf
      end
  val size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = size0 self }
    
  axiom size0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size0 self >= 0
  function discr_valuation0 [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  axiom discr_valuation0_def : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . discr_valuation0 self a b = ([#"../bdd.rs" 372 12 372 36] let _ = () in if leastvar0 a < leastvar0 b then
    match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation0 self childf b) v false
      else
        Map.set (discr_valuation0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar0 a > leastvar0 b then
      match b with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation0 self a childf) v false
        else
          Map.set (discr_valuation0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match b with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation0 self childfa childfb) v false
          else
            Map.set (discr_valuation0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  val discr_valuation0 [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    requires {[#"../bdd.rs" 364 15 364 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 365 15 365 35] is_valid_bdd0 self b}
    requires {[#"../bdd.rs" 366 15 366 21] a <> b}
    requires {[#"../bdd.rs" 370 23 370 27] inv0 self}
    ensures { result = discr_valuation0 self a b }
    
  axiom discr_valuation0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 364 15 364 35] is_valid_bdd0 self a) -> ([#"../bdd.rs" 365 15 365 35] is_valid_bdd0 self b) -> ([#"../bdd.rs" 366 15 366 21] a <> b) -> ([#"../bdd.rs" 370 23 370 27] inv0 self) -> ([#"../bdd.rs" 367 14 367 50] interp0 a (discr_valuation0 self a b) <> interp0 b (discr_valuation0 self a b))
  let rec ghost function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 413 15 413 35] is_valid_bdd0 self a}
    requires {[#"../bdd.rs" 414 15 414 35] is_valid_bdd0 self b}
    requires {[#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . interp0 a v = interp0 b v}
    requires {[#"../bdd.rs" 418 25 418 29] inv0 self}
    ensures { [#"../bdd.rs" 416 14 416 20] a = b }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../bdd.rs" 419 8 419 29] let _ = () in ()
end
module Bdd_Impl11_New
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model2 self }
    
  use map.Map
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model3 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model3 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model3 self }
    
  function shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model0 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) (shallow_model3 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model3 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model2 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  use prelude.Ghost
  use map.Const
  val new3 [#"../bdd.rs" 69 8 69 28] (_1 : ()) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    ensures { [#"../bdd.rs" 67 18 67 47] shallow_model2 result = Const.const (Core_Option_Option_Type.C_None) }
    
  use map.Const
  val new2 [#"../bdd.rs" 69 8 69 28] (_1 : ()) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    ensures { [#"../bdd.rs" 67 18 67 47] shallow_model1 result = Const.const (Core_Option_Option_Type.C_None) }
    
  use prelude.Ghost
  use map.Const
  use map.Const
  val new0 [#"../bdd.rs" 69 8 69 28] (_1 : ()) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    ensures { [#"../bdd.rs" 67 18 67 47] shallow_model0 result = Const.const (Core_Option_Option_Type.C_None) }
    
  let constant promoted0 [#"../bdd.rs" 424 4 424 52]  : Bdd_Node_Type.t_node = [@vc:do_not_keep_trace] [@vc:sp]
    let _1 = [#"../bdd.rs" 425 17 425 21] Bdd_Node_Type.C_True in let _0 = [#"../bdd.rs" 425 16 425 21] _1 in _0
  let rec cfg new [#"../bdd.rs" 424 4 424 52] [@cfg:stackify] [@cfg:subregion_analysis] (alloc : Bdd_Bumpalo_Bump_Type.t_bump) : Bdd_Context_Type.t_context
    ensures { [#"../bdd.rs" 424 48 424 52] inv0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Context_Type.t_context;
  var alloc : Bdd_Bumpalo_Bump_Type.t_bump = alloc;
  var t : Bdd_Node_Type.t_node;
  var _5 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
  var _6 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  var _8 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _9 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
  var _10 : Bdd_Node_Type.t_node;
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 425 16 425 21] _10 <- ([#"../bdd.rs" 425 16 425 21] [#"../bdd.rs" 425 16 425 21] promoted0);
    [#"../bdd.rs" 425 16 425 21] t <- ([#"../bdd.rs" 425 16 425 21] _10);
    [#"../bdd.rs" 428 22 428 47] _5 <- ([#"../bdd.rs" 428 22 428 47] new0 ());
    goto BB1
  }
  BB1 {
    [#"../bdd.rs" 429 28 429 51] _6 <- ([#"../bdd.rs" 429 28 429 51] Ghost.new (Const.const t));
    goto BB2
  }
  BB2 {
    [#"../bdd.rs" 430 22 430 47] _8 <- ([#"../bdd.rs" 430 22 430 47] new2 ());
    goto BB3
  }
  BB3 {
    [#"../bdd.rs" 431 22 431 47] _9 <- ([#"../bdd.rs" 431 22 431 47] new3 ());
    goto BB4
  }
  BB4 {
    [#"../bdd.rs" 426 8 433 9] _0 <- ([#"../bdd.rs" 426 8 433 9] Bdd_Context_Type.C_Context ([#"../bdd.rs" 427 12 427 17] alloc) _5 _6 _8 _9 ([#"../bdd.rs" 432 17 432 18] [#"../bdd.rs" 432 17 432 18] (0 : uint64)));
    _5 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd);
    _6 <- any Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
    _8 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
    _9 <- any Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd);
    return _0
  }
  
end
module Bdd_Impl11_Hashcons
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model8 self }
    
  use map.Map
  function shallow_model7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model7 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model1 self }
    
  function shallow_model1 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model1 self
  val shallow_model1 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model1 self }
    
  function shallow_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model0 self }
    
  function shallow_model3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model3 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model3 (Bdd_Context_Type.context_hashcons self)) (shallow_model0 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant7 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model3 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model0 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model7 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model8 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant7 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : Bdd_Context_Type.t_context)
  val inv7 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : Bdd_Context_Type.t_context . inv7 x = (invariant7 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant6 (self : Bdd_NodeLog_Type.t_nodelog) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : Bdd_NodeLog_Type.t_nodelog) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Bdd_NodeLog_Type.t_nodelog)
  val inv6 (_x : Bdd_NodeLog_Type.t_nodelog) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Bdd_NodeLog_Type.t_nodelog . inv6 x = true
  predicate invariant5 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Bdd_Bdd_Type.t_bdd)
  val inv5 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : Bdd_Bdd_Type.t_bdd . inv5 x = true
  predicate invariant4 (self : borrowed (Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : borrowed (Bdd_Node_Type.t_node)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Bdd_Node_Type.t_node))
  val inv4 (_x : borrowed (Bdd_Node_Type.t_node)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed (Bdd_Node_Type.t_node) . inv4 x = true
  predicate invariant3 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Bdd_Node_Type.t_node)
  val inv3 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Bdd_Node_Type.t_node . inv3 x = true
  predicate invariant2 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  val inv2 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv2 x = true
  predicate invariant1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Node_Type.t_node)
  val inv1 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Node_Type.t_node . inv1 x = true
  predicate invariant0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv0 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv0 x = (inv7 ( * x) /\ inv7 ( ^ x))
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model3 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  use prelude.Ghost
  use prelude.Ghost
  use map.Map
  function shallow_model4 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model3 ( * self)
  val shallow_model4 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model4 self }
    
  val add0 [#"../bdd.rs" 54 8 54 45] (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) (key : Bdd_Node_Type.t_node) (val' : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 54 30 54 33] inv3 key}
    requires {[#"../bdd.rs" 54 38 54 41] inv5 val'}
    ensures { [#"../bdd.rs" 52 8 52 128] forall i : Bdd_NodeLog_Type.t_nodelog . inv6 i -> Map.get (shallow_model3 ( ^ self)) i = (if i = deep_model1 key then
      Core_Option_Option_Type.C_Some val'
    else
      Map.get (shallow_model4 self) i
    ) }
    
  predicate resolve1 (self : borrowed (Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Bdd_Node_Type.t_node)) : bool
    ensures { result = resolve1 self }
    
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  val alloc0 [#"../bdd.rs" 18 8 18 48] (self : Bdd_Bumpalo_Bump_Type.t_bump) (val' : Bdd_Node_Type.t_node) : borrowed (Bdd_Node_Type.t_node)
    requires {[#"../bdd.rs" 18 31 18 34] inv3 val'}
    ensures { [#"../bdd.rs" 17 18 17 32]  * result = val' }
    ensures { [#"../bdd.rs" 18 42 18 48] inv4 result }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  function deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model2 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model2 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model2 self }
    
  val get0 [#"../bdd.rs" 63 8 63 65] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (key : Bdd_Node_Type.t_node) : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    requires {[#"../bdd.rs" 63 37 63 40] inv1 key}
    ensures { [#"../bdd.rs" 58 18 61 9] match result with
      | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model2 self) (deep_model0 key) = Core_Option_Option_Type.C_Some v
      | Core_Option_Option_Type.C_None -> Map.get (shallow_model2 self) (deep_model0 key) = Core_Option_Option_Type.C_None
      end }
    ensures { [#"../bdd.rs" 63 52 63 65] inv2 result }
    
  let rec cfg hashcons [#"../bdd.rs" 440 4 440 58] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] is_valid_node0 ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] inv0 self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] grows0 self }
    ensures { [#"../bdd.rs" 439 14 439 42] is_valid_bdd0 ( ^ self) result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var n : Bdd_Node_Type.t_node = n;
  var _8 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _11 : Bdd_Node_Type.t_node;
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _19 : borrowed (Bdd_Node_Type.t_node);
  var _23 : ();
  var _24 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd));
  var _27 : Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 441 44 441 46] _11 <- ([#"../bdd.rs" 441 44 441 46] n);
    [#"../bdd.rs" 441 26 441 47] _8 <- ([#"../bdd.rs" 441 26 441 47] get0 ([#"../bdd.rs" 441 26 441 47] Bdd_Context_Type.context_hashcons ( * self)) ([#"../bdd.rs" 441 44 441 46] _11));
    goto BB1
  }
  BB1 {
    switch (_8)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB4
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    [#"../bdd.rs" 441 21 441 22] r <- ([#"../bdd.rs" 441 21 441 22] Core_Option_Option_Type.some_0 _8);
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    assert { [@expl:assertion] [#"../bdd.rs" 442 28 442 38] shallow_model0 (Bdd_Bdd_Type.bdd_0 r) = shallow_model1 n };
    [#"../bdd.rs" 443 19 443 20] _0 <- ([#"../bdd.rs" 443 19 443 20] r);
    goto BB12
  }
  BB4 {
    [#"../bdd.rs" 445 20 445 39] _19 <- ([#"../bdd.rs" 445 20 445 39] alloc0 ([#"../bdd.rs" 445 20 445 39] Bdd_Context_Type.context_alloc ( * self)) ([#"../bdd.rs" 445 37 445 38] n));
    goto BB5
  }
  BB5 {
    [#"../bdd.rs" 445 16 445 50] r1 <- ([#"../bdd.rs" 445 16 445 50] Bdd_Bdd_Type.C_Bdd ([#"../bdd.rs" 445 20 445 39]  * _19) ([#"../bdd.rs" 445 41 445 49] Bdd_Context_Type.context_cnt ( * self)));
    assume { resolve1 _19 };
    [#"../bdd.rs" 446 8 446 31] _24 <- Borrow.borrow_mut (Bdd_Context_Type.context_hashcons ( * self));
    [#"../bdd.rs" 446 8 446 31] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 ( ^ _24) x2 x3 x4 x5) };
    [#"../bdd.rs" 446 8 446 31] _23 <- ([#"../bdd.rs" 446 8 446 31] add0 _24 ([#"../bdd.rs" 446 26 446 27] n) ([#"../bdd.rs" 446 29 446 30] r1));
    _24 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd));
    goto BB6
  }
  BB6 {
    [#"../bdd.rs" 447 30 447 71] _27 <- ([#"../bdd.rs" 447 30 447 71] Ghost.new (Map.set (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost ( * self))) (Bdd_Bdd_Type.bdd_1 r1) (Bdd_Bdd_Type.bdd_0 r1)));
    goto BB7
  }
  BB7 {
    [#"../bdd.rs" 447 8 447 71] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 x1 ([#"../bdd.rs" 447 8 447 71] _27) x3 x4 x5) };
    [#"../bdd.rs" 447 8 447 71] _27 <- any Ghost.ghost_ty (Map.map uint64 (Bdd_Node_Type.t_node));
    switch ([#"../bdd.rs" 448 11 448 34] ([#"../bdd.rs" 448 11 448 19] Bdd_Context_Type.context_cnt ( * self)) > ([#"../bdd.rs" 448 22 448 34] ([#"../bdd.rs" 448 22 448 30] [#"../bdd.rs" 448 22 448 30] (18446744073709551615 : uint64)) - ([#"../bdd.rs" 448 33 448 34] [#"../bdd.rs" 448 33 448 34] (1 : uint64))))
      | False -> goto BB11
      | True -> goto BB8
      end
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    [#"../bdd.rs" 451 16 451 35] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 ([#"../bdd.rs" 451 27 451 35] Bdd_Context_Type.context_cnt ( * self))) };
    goto BB9
  }
  BB11 {
    [#"../bdd.rs" 454 8 454 21] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 ([#"../bdd.rs" 454 8 454 21] Bdd_Context_Type.context_cnt ( * self) + ([#"../bdd.rs" 454 20 454 21] [#"../bdd.rs" 454 20 454 21] (1 : uint64)))) };
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    [#"../bdd.rs" 455 8 455 9] _0 <- ([#"../bdd.rs" 455 8 455 9] r1);
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Bdd_Impl11_Node
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv1 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model8 self }
    
  use map.Map
  function shallow_model7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model7 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model4 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model4 (self : uint64) : int
    ensures { result = shallow_model4 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model4 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model1 self }
    
  function shallow_model6 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model1 self
  val shallow_model6 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model6 self }
    
  function shallow_model3 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model6 self
  val shallow_model3 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model3 self }
    
  function shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model2 self }
    
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model2 (Bdd_Context_Type.context_hashcons self)) (shallow_model3 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model2 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model3 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model7 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model8 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model2 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model2 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  val hashcons0 [#"../bdd.rs" 440 4 440 58] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] is_valid_node0 ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] inv1 self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] grows0 self }
    ensures { [#"../bdd.rs" 439 14 439 42] is_valid_bdd0 ( ^ self) result }
    
  function deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  function shallow_model5 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model0 self
  val shallow_model5 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model5 self }
    
  function shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model5 self
  val shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  val eq0 [#"../bdd.rs" 202 4 202 34] (self : Bdd_Bdd_Type.t_bdd) (o : Bdd_Bdd_Type.t_bdd) : bool
    ensures { [#"../bdd.rs" 201 14 201 37] result = (shallow_model1 self = shallow_model1 o) }
    
  let rec cfg node [#"../bdd.rs" 465 4 465 87] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] is_valid_bdd0 ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] is_valid_bdd0 ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar0 childt /\ UInt64.to_int x < leastvar0 childf}
    requires {[#"../bdd.rs" 465 17 465 21] inv1 self}
    ensures { [#"../bdd.rs" 461 14 461 26] grows0 self }
    ensures { [#"../bdd.rs" 462 14 462 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp0 result v = (if Map.get v x then
      interp0 childt v
    else
      interp0 childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : uint64 = x;
  var childt : Bdd_Bdd_Type.t_bdd = childt;
  var childf : Bdd_Bdd_Type.t_bdd = childf;
  var _13 : bool;
  var _17 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 466 11 466 27] _13 <- ([#"../bdd.rs" 466 11 466 27] eq0 ([#"../bdd.rs" 466 11 466 17] childt) ([#"../bdd.rs" 466 21 466 27] childf));
    goto BB1
  }
  BB1 {
    switch (_13)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    assert { [@expl:type invariant] inv1 self };
    assume { resolve0 self };
    [#"../bdd.rs" 467 19 467 25] _0 <- ([#"../bdd.rs" 467 19 467 25] childt);
    goto BB5
  }
  BB3 {
    [#"../bdd.rs" 469 8 469 50] _17 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 469 8 469 50] self <- { self with current =  ^ _17 };
    assume { inv0 ( ^ _17) };
    [#"../bdd.rs" 469 8 469 50] _0 <- ([#"../bdd.rs" 469 8 469 50] hashcons0 _17 ([#"../bdd.rs" 469 22 469 49] Bdd_Node_Type.C_If ([#"../bdd.rs" 469 30 469 31] x) ([#"../bdd.rs" 469 33 469 39] childt) ([#"../bdd.rs" 469 41 469 47] childf)));
    _17 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] inv1 self };
    assume { resolve0 self };
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Bdd_Impl11_True
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv1 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model3 (self : uint64) : int
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model3 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  val hashcons0 [#"../bdd.rs" 440 4 440 58] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] is_valid_node0 ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] inv1 self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] grows0 self }
    ensures { [#"../bdd.rs" 439 14 439 42] is_valid_bdd0 ( ^ self) result }
    
  let rec cfg true_ [#"../bdd.rs" 476 4 476 42] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 476 22 476 26] inv1 self}
    ensures { [#"../bdd.rs" 472 14 472 26] grows0 self }
    ensures { [#"../bdd.rs" 473 14 473 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp0 result v }
    ensures { [#"../bdd.rs" 475 14 475 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var _6 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 477 8 477 27] _6 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 477 8 477 27] self <- { self with current =  ^ _6 };
    assume { inv0 ( ^ _6) };
    [#"../bdd.rs" 477 8 477 27] _0 <- ([#"../bdd.rs" 477 8 477 27] hashcons0 _6 ([#"../bdd.rs" 477 22 477 26] Bdd_Node_Type.C_True));
    _6 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv1 self };
    assume { resolve0 self };
    return _0
  }
  
end
module Bdd_Impl11_False
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv1 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model3 (self : uint64) : int
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model3 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  val hashcons0 [#"../bdd.rs" 440 4 440 58] (self : borrowed (Bdd_Context_Type.t_context)) (n : Bdd_Node_Type.t_node) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 436 15 436 36] is_valid_node0 ( * self) n}
    requires {[#"../bdd.rs" 440 21 440 25] inv1 self}
    ensures { [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n }
    ensures { [#"../bdd.rs" 438 14 438 26] grows0 self }
    ensures { [#"../bdd.rs" 439 14 439 42] is_valid_bdd0 ( ^ self) result }
    
  let rec cfg false_ [#"../bdd.rs" 484 4 484 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] inv1 self}
    ensures { [#"../bdd.rs" 480 14 480 26] grows0 self }
    ensures { [#"../bdd.rs" 481 14 481 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp0 result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var _6 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 485 8 485 28] _6 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 485 8 485 28] self <- { self with current =  ^ _6 };
    assume { inv0 ( ^ _6) };
    [#"../bdd.rs" 485 8 485 28] _0 <- ([#"../bdd.rs" 485 8 485 28] hashcons0 _6 ([#"../bdd.rs" 485 22 485 27] Bdd_Node_Type.C_False));
    _6 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv1 self };
    assume { resolve0 self };
    return _0
  }
  
end
module Bdd_Impl11_V
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Bdd_Context_Type.t_context)
  val inv0 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv1 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model6 self }
    
  use map.Map
  function shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model5 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model3 (self : uint64) : int
    ensures { result = shallow_model3 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model3 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  function shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model0 self
  val shallow_model4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model4 self }
    
  function shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model1 self }
    
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) (shallow_model2 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model2 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model5 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model6 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Bdd_Context_Type.t_context . inv0 x = (invariant0 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model1 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  val node0 [#"../bdd.rs" 465 4 465 87] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] is_valid_bdd0 ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] is_valid_bdd0 ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar0 childt /\ UInt64.to_int x < leastvar0 childf}
    requires {[#"../bdd.rs" 465 17 465 21] inv1 self}
    ensures { [#"../bdd.rs" 461 14 461 26] grows0 self }
    ensures { [#"../bdd.rs" 462 14 462 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp0 result v = (if Map.get v x then
      interp0 childt v
    else
      interp0 childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar0 result }
    
  val false0 [#"../bdd.rs" 484 4 484 43] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] inv1 self}
    ensures { [#"../bdd.rs" 480 14 480 26] grows0 self }
    ensures { [#"../bdd.rs" 481 14 481 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp0 result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
  val true0 [#"../bdd.rs" 476 4 476 42] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 476 22 476 26] inv1 self}
    ensures { [#"../bdd.rs" 472 14 472 26] grows0 self }
    ensures { [#"../bdd.rs" 473 14 473 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp0 result v }
    ensures { [#"../bdd.rs" 475 14 475 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
  let rec cfg v [#"../bdd.rs" 491 4 491 46] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 491 18 491 22] inv1 self}
    ensures { [#"../bdd.rs" 488 14 488 26] grows0 self }
    ensures { [#"../bdd.rs" 489 14 489 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 490 4 490 56] forall v : Map.map uint64 bool . interp0 result v = Map.get v x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : uint64 = x;
  var t : Bdd_Bdd_Type.t_bdd;
  var _7 : borrowed (Bdd_Context_Type.t_context);
  var f : Bdd_Bdd_Type.t_bdd;
  var _9 : borrowed (Bdd_Context_Type.t_context);
  var _10 : borrowed (Bdd_Context_Type.t_context);
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 492 16 492 28] _7 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 492 16 492 28] self <- { self with current =  ^ _7 };
    assume { inv0 ( ^ _7) };
    [#"../bdd.rs" 492 16 492 28] t <- ([#"../bdd.rs" 492 16 492 28] true0 _7);
    _7 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB1
  }
  BB1 {
    [#"../bdd.rs" 493 16 493 29] _9 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 493 16 493 29] self <- { self with current =  ^ _9 };
    assume { inv0 ( ^ _9) };
    [#"../bdd.rs" 493 16 493 29] f <- ([#"../bdd.rs" 493 16 493 29] false0 _9);
    _9 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB2
  }
  BB2 {
    [#"../bdd.rs" 494 8 494 26] _10 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 494 8 494 26] self <- { self with current =  ^ _10 };
    assume { inv0 ( ^ _10) };
    [#"../bdd.rs" 494 8 494 26] _0 <- ([#"../bdd.rs" 494 8 494 26] node0 _10 ([#"../bdd.rs" 494 18 494 19] x) ([#"../bdd.rs" 494 21 494 22] t) ([#"../bdd.rs" 494 24 494 25] f));
    _10 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] inv1 self };
    assume { resolve0 self };
    return _0
  }
  
end
module Bdd_Impl11_Not
  use prelude.UInt64
  predicate invariant5 (self : uint64) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : uint64) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : uint64)
  val inv5 (_x : uint64) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : uint64 . inv5 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant4 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Bdd_Bdd_Type.t_bdd)
  val inv4 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : Bdd_Bdd_Type.t_bdd . inv4 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  val inv3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv3 x = true
  predicate invariant2 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Bdd_Bdd_Type.t_bdd)
  val inv2 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Bdd_Bdd_Type.t_bdd . inv2 x = true
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model8 self }
    
  use map.Map
  function shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model2 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model2 self }
    
  function shallow_model7 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model2 self
  val shallow_model7 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model7 self }
    
  function shallow_model5 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model7 self
  val shallow_model5 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model5 self }
    
  function shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model4 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons self)) (shallow_model5 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model5 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model2 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model8 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Context_Type.t_context)
  val inv1 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Context_Type.t_context . inv1 x = (invariant1 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv0 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  function size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size0 childt in let hf = size0 childf in 1 + ht + hf
      end
  val size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = size0 self }
    
  axiom size0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size0 self >= 0
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  function shallow_model3 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model2 ( * self)
  val shallow_model3 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model3 self }
    
  function deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model1 self }
    
  val add0 [#"../bdd.rs" 54 8 54 45] (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (key : Bdd_Bdd_Type.t_bdd) (val' : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 54 30 54 33] inv4 key}
    requires {[#"../bdd.rs" 54 38 54 41] inv4 val'}
    ensures { [#"../bdd.rs" 52 8 52 128] forall i : uint64 . inv5 i -> Map.get (shallow_model2 ( ^ self)) i = (if i = deep_model1 key then
      Core_Option_Option_Type.C_Some val'
    else
      Map.get (shallow_model3 self) i
    ) }
    
  val node0 [#"../bdd.rs" 465 4 465 87] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] is_valid_bdd0 ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] is_valid_bdd0 ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar0 childt /\ UInt64.to_int x < leastvar0 childf}
    requires {[#"../bdd.rs" 465 17 465 21] inv0 self}
    ensures { [#"../bdd.rs" 461 14 461 26] grows0 self }
    ensures { [#"../bdd.rs" 462 14 462 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp0 result v = (if Map.get v x then
      interp0 childt v
    else
      interp0 childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar0 result }
    
  val true0 [#"../bdd.rs" 476 4 476 42] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 476 22 476 26] inv0 self}
    ensures { [#"../bdd.rs" 472 14 472 26] grows0 self }
    ensures { [#"../bdd.rs" 473 14 473 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp0 result v }
    ensures { [#"../bdd.rs" 475 14 475 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
  val false0 [#"../bdd.rs" 484 4 484 43] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] inv0 self}
    ensures { [#"../bdd.rs" 480 14 480 26] grows0 self }
    ensures { [#"../bdd.rs" 481 14 481 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp0 result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
  predicate resolve0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve0 self }
    
  function deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  function shallow_model0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model0 self }
    
  val get0 [#"../bdd.rs" 63 8 63 65] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (key : Bdd_Bdd_Type.t_bdd) : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    requires {[#"../bdd.rs" 63 37 63 40] inv2 key}
    ensures { [#"../bdd.rs" 58 18 61 9] match result with
      | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model0 self) (deep_model0 key) = Core_Option_Option_Type.C_Some v
      | Core_Option_Option_Type.C_None -> Map.get (shallow_model0 self) (deep_model0 key) = Core_Option_Option_Type.C_None
      end }
    ensures { [#"../bdd.rs" 63 52 63 65] inv3 result }
    
  let rec cfg not' [#"../bdd.rs" 503 4 503 56] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (x : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 497 15 497 35] is_valid_bdd0 ( * self) x}
    requires {[#"../bdd.rs" 503 20 503 24] inv0 self}
    ensures { [#"../bdd.rs" 498 14 498 26] grows0 self }
    ensures { [#"../bdd.rs" 499 14 499 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 500 4 500 60] forall v : Map.map uint64 bool . interp0 result v = (not interp0 x v) }
    ensures { [#"../bdd.rs" 501 14 501 47] leastvar0 x <= leastvar0 result }
    variant {[#"../bdd.rs" 502 14 502 22] size0 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var x : Bdd_Bdd_Type.t_bdd = x;
  var _10 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _13 : Bdd_Bdd_Type.t_bdd;
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _19 : borrowed (Bdd_Context_Type.t_context);
  var _20 : borrowed (Bdd_Context_Type.t_context);
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var childt1 : Bdd_Bdd_Type.t_bdd;
  var _25 : borrowed (Bdd_Context_Type.t_context);
  var childf1 : Bdd_Bdd_Type.t_bdd;
  var _28 : borrowed (Bdd_Context_Type.t_context);
  var _30 : borrowed (Bdd_Context_Type.t_context);
  var _34 : ();
  var _35 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 504 43 504 45] _13 <- ([#"../bdd.rs" 504 43 504 45] x);
    [#"../bdd.rs" 504 25 504 46] _10 <- ([#"../bdd.rs" 504 25 504 46] get0 ([#"../bdd.rs" 504 25 504 46] Bdd_Context_Type.context_not_memo ( * self)) ([#"../bdd.rs" 504 43 504 45] _13));
    goto BB1
  }
  BB1 {
    switch (_10)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB5
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    [#"../bdd.rs" 504 20 504 21] r <- ([#"../bdd.rs" 504 20 504 21] Core_Option_Option_Type.some_0 _10);
    [#"../bdd.rs" 505 19 505 21] _0 <- ([#"../bdd.rs" 505 19 505 21] r);
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    goto BB18
  }
  BB4 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    assert { [#"../bdd.rs" 504 47 506 9] false };
    absurd
  }
  BB5 {
    switch (Bdd_Bdd_Type.bdd_0 x)
      | Bdd_Node_Type.C_False -> goto BB6
      | Bdd_Node_Type.C_True -> goto BB7
      | Bdd_Node_Type.C_If _ _ _ -> goto BB8
      end
  }
  BB6 {
    goto BB11
  }
  BB7 {
    goto BB9
  }
  BB8 {
    [#"../bdd.rs" 510 17 510 18] v <- ([#"../bdd.rs" 510 17 510 18] Bdd_Node_Type.if_v (Bdd_Bdd_Type.bdd_0 x));
    [#"../bdd.rs" 510 20 510 26] childt <- ([#"../bdd.rs" 510 20 510 26] Bdd_Node_Type.if_childt (Bdd_Bdd_Type.bdd_0 x));
    [#"../bdd.rs" 510 28 510 34] childf <- ([#"../bdd.rs" 510 28 510 34] Bdd_Node_Type.if_childf (Bdd_Bdd_Type.bdd_0 x));
    [#"../bdd.rs" 511 29 511 45] _25 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 511 29 511 45] self <- { self with current =  ^ _25 };
    assume { inv1 ( ^ _25) };
    [#"../bdd.rs" 511 29 511 45] childt1 <- ([#"../bdd.rs" 511 29 511 45] not' _25 ([#"../bdd.rs" 511 38 511 44] childt));
    _25 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB13
  }
  BB9 {
    [#"../bdd.rs" 508 20 508 33] _19 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 508 20 508 33] self <- { self with current =  ^ _19 };
    assume { inv1 ( ^ _19) };
    [#"../bdd.rs" 508 20 508 33] r1 <- ([#"../bdd.rs" 508 20 508 33] false0 _19);
    _19 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB10
  }
  BB10 {
    goto BB16
  }
  BB11 {
    [#"../bdd.rs" 509 21 509 33] _20 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 509 21 509 33] self <- { self with current =  ^ _20 };
    assume { inv1 ( ^ _20) };
    [#"../bdd.rs" 509 21 509 33] r1 <- ([#"../bdd.rs" 509 21 509 33] true0 _20);
    _20 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB12
  }
  BB12 {
    goto BB16
  }
  BB13 {
    [#"../bdd.rs" 512 29 512 45] _28 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 512 29 512 45] self <- { self with current =  ^ _28 };
    assume { inv1 ( ^ _28) };
    [#"../bdd.rs" 512 29 512 45] childf1 <- ([#"../bdd.rs" 512 29 512 45] not' _28 ([#"../bdd.rs" 512 38 512 44] childf));
    _28 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB14
  }
  BB14 {
    [#"../bdd.rs" 513 16 513 44] _30 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 513 16 513 44] self <- { self with current =  ^ _30 };
    assume { inv1 ( ^ _30) };
    [#"../bdd.rs" 513 16 513 44] r1 <- ([#"../bdd.rs" 513 16 513 44] node0 _30 ([#"../bdd.rs" 513 26 513 27] v) ([#"../bdd.rs" 513 29 513 35] childt1) ([#"../bdd.rs" 513 37 513 43] childf1));
    _30 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    [#"../bdd.rs" 516 8 516 31] _35 <- Borrow.borrow_mut (Bdd_Context_Type.context_not_memo ( * self));
    [#"../bdd.rs" 516 8 516 31] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 x1 x2 ( ^ _35) x4 x5) };
    [#"../bdd.rs" 516 8 516 31] _34 <- ([#"../bdd.rs" 516 8 516 31] add0 _35 ([#"../bdd.rs" 516 26 516 27] x) ([#"../bdd.rs" 516 29 516 30] r1));
    _35 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
    goto BB17
  }
  BB17 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    [#"../bdd.rs" 517 8 517 9] _0 <- ([#"../bdd.rs" 517 8 517 9] r1);
    goto BB18
  }
  BB18 {
    return _0
  }
  
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module Bdd_Impl11_And
  use prelude.UInt64
  predicate invariant6 (self : (uint64, uint64)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : (uint64, uint64)) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : (uint64, uint64))
  val inv6 (_x : (uint64, uint64)) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : (uint64, uint64) . inv6 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant5 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Bdd_Bdd_Type.t_bdd)
  val inv5 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : Bdd_Bdd_Type.t_bdd . inv5 x = true
  predicate invariant4 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd))
  val inv4 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) . inv4 x = true
  use prelude.Int
  function eq_cmp0 (_1 : int) (_2 : int) : ()
  val eq_cmp0 (_1 : int) (_2 : int) : ()
    ensures { result = eq_cmp0 _1 _2 }
    
  function antisym20 (_1 : int) (_2 : int) : ()
  val antisym20 (_1 : int) (_2 : int) : ()
    ensures { result = antisym20 _1 _2 }
    
  function antisym10 (_1 : int) (_2 : int) : ()
  val antisym10 (_1 : int) (_2 : int) : ()
    ensures { result = antisym10 _1 _2 }
    
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function trans0 (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans0 (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
    ensures { result = trans0 _1 _2 _3 _4 }
    
  function refl0 (_1 : int) : ()
  val refl0 (_1 : int) : ()
    ensures { result = refl0 _1 }
    
  function cmp_gt_log0 (_1 : int) (_2 : int) : ()
  val cmp_gt_log0 (_1 : int) (_2 : int) : ()
    ensures { result = cmp_gt_log0 _1 _2 }
    
  function cmp_ge_log0 (_1 : int) (_2 : int) : ()
  val cmp_ge_log0 (_1 : int) (_2 : int) : ()
    ensures { result = cmp_ge_log0 _1 _2 }
    
  function cmp_lt_log0 (_1 : int) (_2 : int) : ()
  val cmp_lt_log0 (_1 : int) (_2 : int) : ()
    ensures { result = cmp_lt_log0 _1 _2 }
    
  function cmp_le_log0 (_1 : int) (_2 : int) : ()
  val cmp_le_log0 (_1 : int) (_2 : int) : ()
    ensures { result = cmp_le_log0 _1 _2 }
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  val inv3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv3 x = true
  predicate invariant2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd))
  val inv2 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) . inv2 x = true
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model2 self }
    
  use map.Map
  function shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model8 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model8 self }
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model6 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UInt64.to_int self
  val shallow_model6 (self : uint64) : int
    ensures { result = shallow_model6 self }
    
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  function leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int max0 + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model6 v
      end
  val leastvar0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = leastvar0 self }
    
  use map.Map
  function interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp0 childt vars
      else
        interp0 childf vars
      
      end
  val interp0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool
    ensures { result = interp0 self vars }
    
  use map.Map
  function deep_model4 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model4 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model4 self }
    
  function shallow_model7 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model4 self
  val shallow_model7 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model7 self }
    
  function shallow_model5 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model7 self
  val shallow_model5 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model5 self }
    
  function shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  val shallow_model4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model4 self }
    
  use Bdd_Context_Type as Bdd_Context_Type
  predicate is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons self)) (shallow_model5 (Bdd_Bdd_Type.bdd_0 b)) = Core_Option_Option_Type.C_Some b
  val is_valid_bdd0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = is_valid_bdd0 self b }
    
  use map.Map
  use prelude.Ghost
  predicate is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf /\ is_valid_bdd0 self childt /\ is_valid_bdd0 self childf /\ UInt64.to_int v < leastvar0 childt /\ UInt64.to_int v < leastvar0 childf
      end
  val is_valid_node0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) : bool
    ensures { result = is_valid_node0 self n }
    
  predicate invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model5 (Bdd_Bdd_Type.bdd_0 b) = n /\ is_valid_node0 self (Bdd_Bdd_Type.bdd_0 b) /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self /\ Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b) = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end) /\ (forall bm : uint64 . match Map.get (shallow_model8 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd0 self n /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (not interp0 b v)) /\ leastvar0 b <= leastvar0 n
      end) /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model2 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Ghost.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd0 self n /\ is_valid_bdd0 self a /\ is_valid_bdd0 self b /\ (forall v : Map.map uint64 bool . interp0 n v = (interp0 a v /\ interp0 b v)) /\ (leastvar0 a <= leastvar0 n \/ leastvar0 b <= leastvar0 n)
      end)
  val invariant1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Context_Type.t_context)
  val inv1 (_x : Bdd_Context_Type.t_context) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Context_Type.t_context . inv1 x = (invariant1 x /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Bdd_Context_Type.t_context))
  val inv0 (_x : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  function size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size0 childt in let hf = size0 childf in 1 + ht + hf
      end
  val size0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
    ensures { result = size0 self }
    
  axiom size0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size0 self >= 0
  predicate grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self)) <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self)) /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model4 (Bdd_Context_Type.context_hashcons ( ^ self))) n = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  val grows0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = grows0 self }
    
  function shallow_model3 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model2 ( * self)
  val shallow_model3 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model3 self }
    
  function deep_model3 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model3 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model3 self }
    
  function deep_model2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model3 (let (a, _) = self in a), deep_model3 (let (_, a) = self in a))
  val deep_model2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64)
    ensures { result = deep_model2 self }
    
  val add0 [#"../bdd.rs" 54 8 54 45] (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (key : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (val' : Bdd_Bdd_Type.t_bdd) : ()
    requires {[#"../bdd.rs" 54 30 54 33] inv4 key}
    requires {[#"../bdd.rs" 54 38 54 41] inv5 val'}
    ensures { [#"../bdd.rs" 52 8 52 128] forall i : (uint64, uint64) . inv6 i -> Map.get (shallow_model2 ( ^ self)) i = (if i = deep_model2 key then
      Core_Option_Option_Type.C_Some val'
    else
      Map.get (shallow_model3 self) i
    ) }
    
  val node0 [#"../bdd.rs" 465 4 465 87] (self : borrowed (Bdd_Context_Type.t_context)) (x : uint64) (childt : Bdd_Bdd_Type.t_bdd) (childf : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 458 15 458 40] is_valid_bdd0 ( * self) childt}
    requires {[#"../bdd.rs" 459 15 459 40] is_valid_bdd0 ( * self) childf}
    requires {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar0 childt /\ UInt64.to_int x < leastvar0 childf}
    requires {[#"../bdd.rs" 465 17 465 21] inv0 self}
    ensures { [#"../bdd.rs" 461 14 461 26] grows0 self }
    ensures { [#"../bdd.rs" 462 14 462 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp0 result v = (if Map.get v x then
      interp0 childt v
    else
      interp0 childf v
    ) }
    ensures { [#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar0 result }
    
  function cmp_log0 (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 137 12 146 17] if self < o then
      Core_Cmp_Ordering_Type.C_Less
    else
      if self = o then Core_Cmp_Ordering_Type.C_Equal else Core_Cmp_Ordering_Type.C_Greater
    
  val cmp_log0 (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log0 self o }
    
  function deep_model1 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UInt64.to_int self
  val deep_model1 (self : uint64) : int
    ensures { result = deep_model1 self }
    
  val cmp0 (self : uint64) (other : uint64) : Core_Cmp_Ordering_Type.t_ordering
    ensures { [#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85] result = cmp_log0 (deep_model1 self) (deep_model1 other) }
    
  val false0 [#"../bdd.rs" 484 4 484 43] (self : borrowed (Bdd_Context_Type.t_context)) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 484 23 484 27] inv0 self}
    ensures { [#"../bdd.rs" 480 14 480 26] grows0 self }
    ensures { [#"../bdd.rs" 481 14 481 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp0 result v }
    ensures { [#"../bdd.rs" 483 14 483 46] UInt64.to_int max0 + 1 = leastvar0 result }
    
  predicate resolve4 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve4 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = resolve4 self }
    
  predicate resolve2 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve4 (let (a, _) = self in a) /\ resolve4 (let (_, a) = self in a)
  val resolve2 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Bdd_Context_Type.t_context)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve3 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve3 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = resolve3 self }
    
  predicate resolve0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve3 (let (a, _) = self in a) /\ resolve3 (let (_, a) = self in a)
  val resolve0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : bool
    ensures { result = resolve0 self }
    
  function deep_model0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64) =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model2 self
  val deep_model0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64)
    ensures { result = deep_model0 self }
    
  function shallow_model0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    ensures { result = shallow_model0 self }
    
  val get0 [#"../bdd.rs" 63 8 63 65] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (key : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    requires {[#"../bdd.rs" 63 37 63 40] inv2 key}
    ensures { [#"../bdd.rs" 58 18 61 9] match result with
      | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model0 self) (deep_model0 key) = Core_Option_Option_Type.C_Some v
      | Core_Option_Option_Type.C_None -> Map.get (shallow_model0 self) (deep_model0 key) = Core_Option_Option_Type.C_None
      end }
    ensures { [#"../bdd.rs" 63 52 63 65] inv3 result }
    
  let rec cfg and [#"../bdd.rs" 527 4 527 72] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Bdd_Context_Type.t_context)) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Bdd_Bdd_Type.t_bdd
    requires {[#"../bdd.rs" 520 15 520 35] is_valid_bdd0 ( * self) a}
    requires {[#"../bdd.rs" 521 15 521 35] is_valid_bdd0 ( * self) b}
    requires {[#"../bdd.rs" 527 20 527 24] inv0 self}
    ensures { [#"../bdd.rs" 522 14 522 26] grows0 self }
    ensures { [#"../bdd.rs" 523 14 523 42] is_valid_bdd0 ( ^ self) result }
    ensures { [#"../bdd.rs" 524 4 524 76] forall v : Map.map uint64 bool . interp0 result v = (interp0 a v /\ interp0 b v) }
    ensures { [#"../bdd.rs" 525 14 525 84] leastvar0 a <= leastvar0 result \/ leastvar0 b <= leastvar0 result }
    variant {[#"../bdd.rs" 526 14 526 33] size0 a + size0 b}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Bdd_Bdd_Type.t_bdd;
  var self : borrowed (Bdd_Context_Type.t_context) = self;
  var a : Bdd_Bdd_Type.t_bdd = a;
  var b : Bdd_Bdd_Type.t_bdd = b;
  var _12 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd);
  var _15 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var _16 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd);
  var r : Bdd_Bdd_Type.t_bdd;
  var r1 : Bdd_Bdd_Type.t_bdd;
  var _23 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node);
  var _31 : borrowed (Bdd_Context_Type.t_context);
  var va : uint64;
  var childta : Bdd_Bdd_Type.t_bdd;
  var childfa : Bdd_Bdd_Type.t_bdd;
  var vb : uint64;
  var childtb : Bdd_Bdd_Type.t_bdd;
  var childfb : Bdd_Bdd_Type.t_bdd;
  var v : uint64;
  var childt : Bdd_Bdd_Type.t_bdd;
  var childf : Bdd_Bdd_Type.t_bdd;
  var _41 : ();
  var _42 : Core_Cmp_Ordering_Type.t_ordering;
  var _45 : uint64;
  var _48 : Bdd_Bdd_Type.t_bdd;
  var _49 : borrowed (Bdd_Context_Type.t_context);
  var _52 : Bdd_Bdd_Type.t_bdd;
  var _53 : borrowed (Bdd_Context_Type.t_context);
  var _57 : Bdd_Bdd_Type.t_bdd;
  var _58 : borrowed (Bdd_Context_Type.t_context);
  var _61 : Bdd_Bdd_Type.t_bdd;
  var _62 : borrowed (Bdd_Context_Type.t_context);
  var _66 : Bdd_Bdd_Type.t_bdd;
  var _67 : borrowed (Bdd_Context_Type.t_context);
  var _70 : Bdd_Bdd_Type.t_bdd;
  var _71 : borrowed (Bdd_Context_Type.t_context);
  var _74 : borrowed (Bdd_Context_Type.t_context);
  var _78 : ();
  var _79 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
  {
    goto BB0
  }
  BB0 {
    [#"../bdd.rs" 528 44 528 50] _16 <- ([#"../bdd.rs" 528 44 528 50] (([#"../bdd.rs" 528 45 528 46] a), ([#"../bdd.rs" 528 48 528 49] b)));
    [#"../bdd.rs" 528 43 528 50] _15 <- ([#"../bdd.rs" 528 43 528 50] _16);
    [#"../bdd.rs" 528 25 528 51] _12 <- ([#"../bdd.rs" 528 25 528 51] get0 ([#"../bdd.rs" 528 25 528 51] Bdd_Context_Type.context_and_memo ( * self)) ([#"../bdd.rs" 528 43 528 50] _15));
    goto BB1
  }
  BB1 {
    assume { resolve0 _16 };
    switch (_12)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB5
      end
  }
  BB2 {
    goto BB3
  }
  BB3 {
    [#"../bdd.rs" 528 20 528 21] r <- ([#"../bdd.rs" 528 20 528 21] Core_Option_Option_Type.some_0 _12);
    [#"../bdd.rs" 529 19 529 21] _0 <- ([#"../bdd.rs" 529 19 529 21] r);
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    goto BB35
  }
  BB4 {
    assert { [#"../bdd.rs" 528 52 530 9] false };
    absurd
  }
  BB5 {
    [#"../bdd.rs" 531 22 531 34] _23 <- ([#"../bdd.rs" 531 22 531 34] (([#"../bdd.rs" 531 23 531 27] Bdd_Bdd_Type.bdd_0 a), ([#"../bdd.rs" 531 29 531 33] Bdd_Bdd_Type.bdd_0 b)));
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_True -> goto BB7
      | _ -> goto BB6
      end
  }
  BB6 {
    switch (let (_, a) = _23 in a)
      | Bdd_Node_Type.C_True -> goto BB9
      | _ -> goto BB8
      end
  }
  BB7 {
    goto BB15
  }
  BB8 {
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_False -> goto BB10
      | _ -> goto BB11
      end
  }
  BB9 {
    goto BB16
  }
  BB10 {
    goto BB17
  }
  BB11 {
    switch (let (_, a) = _23 in a)
      | Bdd_Node_Type.C_False -> goto BB12
      | Bdd_Node_Type.C_If _ _ _ -> goto BB13
      | _ -> goto BB38
      end
  }
  BB12 {
    goto BB17
  }
  BB13 {
    switch (let (a, _) = _23 in a)
      | Bdd_Node_Type.C_If _ _ _ -> goto BB14
      | _ -> goto BB39
      end
  }
  BB14 {
    [#"../bdd.rs" 537 24 537 26] vb <- ([#"../bdd.rs" 537 24 537 26] Bdd_Node_Type.if_v (let (_, a) = _23 in a));
    [#"../bdd.rs" 537 36 537 43] childtb <- ([#"../bdd.rs" 537 36 537 43] Bdd_Node_Type.if_childt (let (_, a) = _23 in a));
    [#"../bdd.rs" 537 53 537 60] childfb <- ([#"../bdd.rs" 537 53 537 60] Bdd_Node_Type.if_childf (let (_, a) = _23 in a));
    [#"../bdd.rs" 536 24 536 26] va <- ([#"../bdd.rs" 536 24 536 26] Bdd_Node_Type.if_v (let (a, _) = _23 in a));
    [#"../bdd.rs" 536 36 536 43] childta <- ([#"../bdd.rs" 536 36 536 43] Bdd_Node_Type.if_childt (let (a, _) = _23 in a));
    [#"../bdd.rs" 536 53 536 60] childfa <- ([#"../bdd.rs" 536 53 536 60] Bdd_Node_Type.if_childf (let (a, _) = _23 in a));
    assume { resolve2 _23 };
    [#"../bdd.rs" 540 29 540 32] _45 <- ([#"../bdd.rs" 540 29 540 32] vb);
    [#"../bdd.rs" 540 22 540 33] _42 <- ([#"../bdd.rs" 540 22 540 33] cmp0 ([#"../bdd.rs" 540 22 540 33] va) ([#"../bdd.rs" 540 29 540 32] _45));
    goto BB19
  }
  BB15 {
    assume { resolve2 _23 };
    [#"../bdd.rs" 532 25 532 26] r1 <- ([#"../bdd.rs" 532 25 532 26] b);
    goto BB33
  }
  BB16 {
    assume { resolve2 _23 };
    [#"../bdd.rs" 533 25 533 26] r1 <- ([#"../bdd.rs" 533 25 533 26] a);
    goto BB33
  }
  BB17 {
    assume { resolve2 _23 };
    [#"../bdd.rs" 534 39 534 52] _31 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 534 39 534 52] self <- { self with current =  ^ _31 };
    assume { inv1 ( ^ _31) };
    [#"../bdd.rs" 534 39 534 52] r1 <- ([#"../bdd.rs" 534 39 534 52] false0 _31);
    _31 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB18
  }
  BB18 {
    goto BB33
  }
  BB19 {
    switch (_42)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB20
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB21
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB22
      end
  }
  BB20 {
    goto BB26
  }
  BB21 {
    [#"../bdd.rs" 552 24 552 30] v <- ([#"../bdd.rs" 552 28 552 30] va);
    [#"../bdd.rs" 553 33 553 59] _67 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 553 33 553 59] self <- { self with current =  ^ _67 };
    assume { inv1 ( ^ _67) };
    [#"../bdd.rs" 553 33 553 59] _66 <- ([#"../bdd.rs" 553 33 553 59] and _67 ([#"../bdd.rs" 553 42 553 49] childta) ([#"../bdd.rs" 553 51 553 58] childtb));
    _67 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB29
  }
  BB22 {
    goto BB23
  }
  BB23 {
    [#"../bdd.rs" 542 24 542 30] v <- ([#"../bdd.rs" 542 28 542 30] vb);
    [#"../bdd.rs" 543 33 543 53] _49 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 543 33 543 53] self <- { self with current =  ^ _49 };
    assume { inv1 ( ^ _49) };
    [#"../bdd.rs" 543 33 543 53] _48 <- ([#"../bdd.rs" 543 33 543 53] and _49 ([#"../bdd.rs" 543 42 543 43] a) ([#"../bdd.rs" 543 45 543 52] childtb));
    _49 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB24
  }
  BB24 {
    [#"../bdd.rs" 543 24 543 53] childt <- ([#"../bdd.rs" 543 24 543 53] _48);
    [#"../bdd.rs" 543 24 543 53] _48 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 544 33 544 53] _53 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 544 33 544 53] self <- { self with current =  ^ _53 };
    assume { inv1 ( ^ _53) };
    [#"../bdd.rs" 544 33 544 53] _52 <- ([#"../bdd.rs" 544 33 544 53] and _53 ([#"../bdd.rs" 544 42 544 43] a) ([#"../bdd.rs" 544 45 544 52] childfb));
    _53 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB25
  }
  BB25 {
    [#"../bdd.rs" 544 24 544 53] childf <- ([#"../bdd.rs" 544 24 544 53] _52);
    [#"../bdd.rs" 544 24 544 53] _52 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 541 31 545 21] _41 <- ([#"../bdd.rs" 541 31 545 21] ());
    goto BB31
  }
  BB26 {
    [#"../bdd.rs" 547 24 547 30] v <- ([#"../bdd.rs" 547 28 547 30] va);
    [#"../bdd.rs" 548 33 548 53] _58 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 548 33 548 53] self <- { self with current =  ^ _58 };
    assume { inv1 ( ^ _58) };
    [#"../bdd.rs" 548 33 548 53] _57 <- ([#"../bdd.rs" 548 33 548 53] and _58 ([#"../bdd.rs" 548 42 548 49] childta) ([#"../bdd.rs" 548 51 548 52] b));
    _58 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB27
  }
  BB27 {
    [#"../bdd.rs" 548 24 548 53] childt <- ([#"../bdd.rs" 548 24 548 53] _57);
    [#"../bdd.rs" 548 24 548 53] _57 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 549 33 549 53] _62 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 549 33 549 53] self <- { self with current =  ^ _62 };
    assume { inv1 ( ^ _62) };
    [#"../bdd.rs" 549 33 549 53] _61 <- ([#"../bdd.rs" 549 33 549 53] and _62 ([#"../bdd.rs" 549 42 549 49] childfa) ([#"../bdd.rs" 549 51 549 52] b));
    _62 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB28
  }
  BB28 {
    [#"../bdd.rs" 549 24 549 53] childf <- ([#"../bdd.rs" 549 24 549 53] _61);
    [#"../bdd.rs" 549 24 549 53] _61 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 546 28 550 21] _41 <- ([#"../bdd.rs" 546 28 550 21] ());
    goto BB31
  }
  BB29 {
    [#"../bdd.rs" 553 24 553 59] childt <- ([#"../bdd.rs" 553 24 553 59] _66);
    [#"../bdd.rs" 553 24 553 59] _66 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 554 33 554 59] _71 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 554 33 554 59] self <- { self with current =  ^ _71 };
    assume { inv1 ( ^ _71) };
    [#"../bdd.rs" 554 33 554 59] _70 <- ([#"../bdd.rs" 554 33 554 59] and _71 ([#"../bdd.rs" 554 42 554 49] childfa) ([#"../bdd.rs" 554 51 554 58] childfb));
    _71 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB30
  }
  BB30 {
    [#"../bdd.rs" 554 24 554 59] childf <- ([#"../bdd.rs" 554 24 554 59] _70);
    [#"../bdd.rs" 554 24 554 59] _70 <- any Bdd_Bdd_Type.t_bdd;
    [#"../bdd.rs" 551 29 555 21] _41 <- ([#"../bdd.rs" 551 29 555 21] ());
    goto BB31
  }
  BB31 {
    [#"../bdd.rs" 557 16 557 44] _74 <- Borrow.borrow_mut ( * self);
    [#"../bdd.rs" 557 16 557 44] self <- { self with current =  ^ _74 };
    assume { inv1 ( ^ _74) };
    [#"../bdd.rs" 557 16 557 44] r1 <- ([#"../bdd.rs" 557 16 557 44] node0 _74 ([#"../bdd.rs" 557 26 557 27] v) ([#"../bdd.rs" 557 29 557 35] childt) ([#"../bdd.rs" 557 37 557 43] childf));
    _74 <- any borrowed (Bdd_Context_Type.t_context);
    goto BB32
  }
  BB32 {
    goto BB33
  }
  BB33 {
    [#"../bdd.rs" 560 8 560 36] _79 <- Borrow.borrow_mut (Bdd_Context_Type.context_and_memo ( * self));
    [#"../bdd.rs" 560 8 560 36] self <- { self with current = (let Bdd_Context_Type.C_Context x0 x1 x2 x3 x4 x5 =  * self in Bdd_Context_Type.C_Context x0 x1 x2 x3 ( ^ _79) x5) };
    [#"../bdd.rs" 560 8 560 36] _78 <- ([#"../bdd.rs" 560 8 560 36] add0 _79 ([#"../bdd.rs" 560 26 560 32] (([#"../bdd.rs" 560 27 560 28] a), ([#"../bdd.rs" 560 30 560 31] b))) ([#"../bdd.rs" 560 34 560 35] r1));
    _79 <- any borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd));
    goto BB34
  }
  BB34 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    [#"../bdd.rs" 561 8 561 9] _0 <- ([#"../bdd.rs" 561 8 561 9] r1);
    goto BB35
  }
  BB35 {
    return _0
  }
  BB37 {
    goto BB21
  }
  BB38 {
    assume { resolve2 _23 };
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    goto BB4
  }
  BB39 {
    assume { resolve2 _23 };
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    goto BB4
  }
  BB40 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    goto BB4
  }
  
end
module Bdd_Hashmap_Impl0
  type k
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  type v
  predicate invariant0 (self : (u, v))
  val invariant0 (self : (u, v)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (u, v))
  val inv0 (_x : (u, v)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (u, v) . inv0 x = true
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  type deep_model_ty1
  function hash_log2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty1) : int
  val hash_log2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty1) : int
    ensures { result = hash_log2 _1 }
    
  type deep_model_ty0
  function hash_log1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty0) : int
  val hash_log1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty0) : int
    ensures { result = hash_log1 _1 }
    
  function hash_log0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty0, deep_model_ty1)) : int =
    [#"../bdd.rs" 83 24 83 84] mod (hash_log1 (let (a, _) = x in a) + hash_log2 (let (_, a) = x in a) * 17) (UInt64.to_int max0 + 1)
  val hash_log0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty0, deep_model_ty1)) : int
    ensures { result = hash_log0 x }
    
  function deep_model3 (self : v) : deep_model_ty1
  val deep_model3 (self : v) : deep_model_ty1
    ensures { result = deep_model3 self }
    
  function deep_model2 (self : u) : deep_model_ty0
  val deep_model2 (self : u) : deep_model_ty0
    ensures { result = deep_model2 self }
    
  function deep_model1 (self : (u, v)) : (deep_model_ty0, deep_model_ty1) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model2 (let (a, _) = self in a), deep_model3 (let (_, a) = self in a))
  val deep_model1 (self : (u, v)) : (deep_model_ty0, deep_model_ty1)
    ensures { result = deep_model1 self }
    
  use prelude.Borrow
  function deep_model0 (self : (u, v)) : (deep_model_ty0, deep_model_ty1) =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : (u, v)) : (deep_model_ty0, deep_model_ty1)
    ensures { result = deep_model0 self }
    
  goal hash_refn : [#"../bdd.rs" 76 8 76 29] forall self : (u, v) . inv0 self -> inv0 self /\ (forall result : uint64 . UInt64.to_int result = hash_log0 (deep_model0 self) -> UInt64.to_int result = hash_log0 (deep_model0 self))
end
module Bdd_Impl1
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Node_Type.t_node)
  val inv0 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Node_Type.t_node . inv0 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model1 self }
    
  use prelude.Borrow
  function deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  use prelude.UInt64
  use prelude.Int
  let constant max0  : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : uint64)
  use prelude.UInt64
  function hash_log0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 130 12 135 13] match x with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5 + UInt64.to_int childf * 7) (UInt64.to_int max0 + 1)
      end
  val hash_log0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int
    ensures { result = hash_log0 x }
    
  function shallow_model2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model1 self
  val shallow_model2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model2 self }
    
  function shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = shallow_model1 self }
    
  goal hash_refn : [#"../bdd.rs" 116 4 116 25] forall self : Bdd_Node_Type.t_node . inv0 self -> (forall result : uint64 . UInt64.to_int result = hash_log0 (shallow_model1 self) -> UInt64.to_int result = hash_log0 (deep_model0 self))
end
module Bdd_Impl2
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Bdd_Type.t_bdd)
  val inv0 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Bdd_Type.t_bdd . inv0 x = true
  use prelude.UInt64
  use prelude.Int
  function deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model1 self }
    
  use prelude.Borrow
  function deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  use prelude.UInt64
  function hash_log0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [#"../bdd.rs" 149 8 149 24] UInt64.to_int x
  val hash_log0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int
    ensures { result = hash_log0 x }
    
  function shallow_model2 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model1 self
  val shallow_model2 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model2 self }
    
  function shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model2 self
  val shallow_model1 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  goal hash_refn : [#"../bdd.rs" 142 4 142 25] forall self : Bdd_Bdd_Type.t_bdd . inv0 self -> (forall result : uint64 . UInt64.to_int result = hash_log0 (shallow_model1 self) -> UInt64.to_int result = hash_log0 (deep_model0 self))
end
module Bdd_Impl12
  
end
module Bdd_Impl18
  
end
module Bdd_Impl13
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 90 9 90 11] true
end
module Bdd_Impl19
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 104 15 104 17] true
end
module Bdd_Impl14
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Node_Type.t_node)
  val inv0 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Node_Type.t_node . inv0 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  val deep_model1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model1 self }
    
  use prelude.Borrow
  function deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog
    ensures { result = deep_model0 self }
    
  goal eq_refn : [#"../bdd.rs" 90 13 90 22] forall self : Bdd_Node_Type.t_node . forall other : Bdd_Node_Type.t_node . inv0 other /\ inv0 self -> (forall result : bool . result = (deep_model0 self = deep_model0 other) -> result = (deep_model0 self = deep_model0 other))
end
module Bdd_Impl7
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Bdd_Type.t_bdd)
  val inv0 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Bdd_Type.t_bdd . inv0 x = true
  use prelude.UInt64
  use prelude.Int
  function deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  val deep_model1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model1 self }
    
  use prelude.Borrow
  function deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = deep_model0 self }
    
  function shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model1 self
  val shallow_model1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model1 self }
    
  function shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model0 (self : Bdd_Bdd_Type.t_bdd) : uint64
    ensures { result = shallow_model0 self }
    
  goal eq_refn : [#"../bdd.rs" 202 4 202 34] forall self : Bdd_Bdd_Type.t_bdd . forall other : Bdd_Bdd_Type.t_bdd . inv0 other /\ inv0 self -> (forall result : bool . result = (shallow_model0 self = shallow_model0 other) -> result = (deep_model0 self = deep_model0 other))
end
module Bdd_Impl15
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Node_Type.t_node)
  val inv1 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Node_Type.t_node . inv1 x = true
  predicate invariant0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Node_Type.t_node) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Node_Type.t_node)
  val inv0 (_x : Bdd_Node_Type.t_node) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Node_Type.t_node . inv0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../bdd.rs" 90 24 90 29] forall self : Bdd_Node_Type.t_node . inv0 self -> (forall result : Bdd_Node_Type.t_node . result = self -> inv1 result /\ result = self)
end
module Bdd_Impl0
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant1 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Bdd_Bdd_Type.t_bdd)
  val inv1 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Bdd_Bdd_Type.t_bdd . inv1 x = true
  predicate invariant0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Bdd_Bdd_Type.t_bdd)
  val inv0 (_x : Bdd_Bdd_Type.t_bdd) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Bdd_Bdd_Type.t_bdd . inv0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../bdd.rs" 109 4 109 27] forall self : Bdd_Bdd_Type.t_bdd . inv0 self -> (forall result : Bdd_Bdd_Type.t_bdd . result = self -> inv1 result /\ result = self)
end
module Bdd_Impl16
  
end
module Bdd_Impl17
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
module Bdd_Impl9
  
end
