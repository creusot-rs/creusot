
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  function any_l (_ : 'b) : 'a
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Bdd_Hashmap_Impl2_Hash
  type u
  type v
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : v)
  let rec inv'2 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : v . inv'2 x = true
  predicate invariant'1 (self : u)
  let rec invariant'1 (self:u) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : u)
  let rec inv'1 (_x:u) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ] 
  axiom inv'1 : forall x : u . inv'1 x = true
  predicate invariant'0 (self : (u, v))
  let rec invariant'0 (self:(u, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : (u, v))
  let rec inv'0 (_x:(u, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  type deep_model_ty'1
  function hash_log'2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'1) : int
  let rec hash_log'2 (_1:deep_model_ty'1) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'2 _1} (! return' {result}) ]
    
  type deep_model_ty'0
  function hash_log'1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'0) : int
  let rec hash_log'1 (_1:deep_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'1 _1} (! return' {result}) ]
    
  function hash_log'0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [#"../bdd.rs" 83 24 83 84] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  let rec hash_log'0 (x:(deep_model_ty'0, deep_model_ty'1)) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  function deep_model'5 (self : v) : deep_model_ty'1
  let rec deep_model'5 (self:v) (return'  (ret:deep_model_ty'1))= any
    [ return' (result:deep_model_ty'1)-> {result = deep_model'5 self} (! return' {result}) ]
    
  function deep_model'4 (self : u) : deep_model_ty'0
  let rec deep_model'4 (self:u) (return'  (ret:deep_model_ty'0))= any
    [ return' (result:deep_model_ty'0)-> {result = deep_model'4 self} (! return' {result}) ]
    
  function deep_model'3 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model'4 (let (a, _) = self in a), deep_model'5 (let (_, a) = self in a))
  let rec deep_model'3 (self:(u, v)) (return'  (ret:(deep_model_ty'0, deep_model_ty'1)))= any
    [ return' (result:(deep_model_ty'0, deep_model_ty'1))-> {result = deep_model'3 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'3 self
  let rec deep_model'0 (self:(u, v)) (return'  (ret:(deep_model_ty'0, deep_model_ty'1)))= any
    [ return' (result:(deep_model_ty'0, deep_model_ty'1))-> {result = deep_model'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  constant min'0 : uint64 = (0 : uint64)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (64 : uint32)
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt64.to_int self
      + UInt64.to_int rhs
      > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt64.to_int self + UInt64.to_int rhs
      < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt64.to_int self + UInt64.to_int rhs
      >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt64.to_int self
      * UInt64.to_int rhs
      > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt64.to_int self * UInt64.to_int rhs
      < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt64.to_int self * UInt64.to_int rhs
      >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  function deep_model'2 (self : v) : deep_model_ty'1 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'5 self
  let rec deep_model'2 (self:v) (return'  (ret:deep_model_ty'1))= any
    [ return' (result:deep_model_ty'1)-> {result = deep_model'2 self} (! return' {result}) ]
    
  let rec hash'1 (self:v) (return'  (ret:uint64))= {[@expl:precondition] [#"../bdd.rs" 31 17 31 21] inv'2 self}
    any
    [ return' (result:uint64)-> {[#"../bdd.rs" 30 18 30 62] UInt64.to_int result = hash_log'2 (deep_model'2 self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : (u, v))
  let rec resolve'0 (self:(u, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  function deep_model'1 (self : u) : deep_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'4 self
  let rec deep_model'1 (self:u) (return'  (ret:deep_model_ty'0))= any
    [ return' (result:deep_model_ty'0)-> {result = deep_model'1 self} (! return' {result}) ]
    
  let rec hash'0 (self:u) (return'  (ret:uint64))= {[@expl:precondition] [#"../bdd.rs" 31 17 31 21] inv'1 self}
    any
    [ return' (result:uint64)-> {[#"../bdd.rs" 30 18 30 62] UInt64.to_int result = hash_log'1 (deep_model'1 self)}
      (! return' {result}) ]
    
  let rec hash (self:(u, v)) (return'  (ret:uint64))= {[#"../bdd.rs" 76 17 76 21] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {let (r'0, _) = self in r'0} (fun (_ret':uint64) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = hash'1 {let (_, r'0) = self in r'0} (fun (_ret':uint64) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = wrapping_mul'0 {_6} {[#"../bdd.rs" 77 66 77 68] (17 : uint64)} (fun (_ret':uint64) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = wrapping_add'0 {_3} {_5} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : uint64 = any_l () : uint64
    | & self : (u, v) = self
    | & _3 : uint64 = any_l () : uint64
    | & _5 : uint64 = any_l () : uint64
    | & _6 : uint64 = any_l () : uint64 ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [#"../bdd.rs" 75 18 75 62] UInt64.to_int result
      = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Bdd_Type
  use prelude.UInt64
  use prelude.Int
  use prelude.Borrow
  type t_bdd  =
    | C_Bdd (t_node) uint64
    with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
    
  function any_l (_ : 'b) : 'a
  let rec t_bdd (input:t_bdd) (ret  (field_0:t_node) (field_1:uint64))= any
    [ good (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 <> input} {false} any ]
    
  let rec false' (input:t_node) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  let rec true' (input:t_node) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  let rec if' (input:t_node) (ret  (v:uint64) (childt:t_bdd) (childf:t_bdd))= any
    [ good (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf <> input} {false} any ]
    
  function bdd_1 (self : t_bdd) : uint64 =
    match self with
      | C_Bdd _ a -> a
      end
  function bdd_0 (self : t_bdd) : t_node =
    match self with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl12_AssertReceiverIsTotalEq
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use prelude.Intrinsic
  let rec assert_receiver_is_total_eq (self:Bdd_Node_Type.t_node) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 90 9 90 11] () ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : () = any_l () : () ]  [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl7_Eq
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.UInt64
  use prelude.Int
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'0 self
  let rec shallow_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  use Bdd_Node_Type as Bdd_Node_Type
  let rec eq (self:Bdd_Bdd_Type.t_bdd) (o:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {self}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            Bdd_Bdd_Type.t_bdd {o}
              (fun (r0'1:Bdd_Node_Type.t_node) (r1'1:uint64) ->
                UInt64.eq {r1'0} {r1'1} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)))
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool | & self : Bdd_Bdd_Type.t_bdd = self | & o : Bdd_Bdd_Type.t_bdd = o ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../bdd.rs" 201 14 201 37] result
      = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
end
module Bdd_NodeLog_Type
  use prelude.UInt64
  use prelude.Int
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
    
  function any_l (_ : 'b) : 'a
  let rec false' (input:t_nodelog) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  let rec true' (input:t_nodelog) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  let rec if' (input:t_nodelog) (ret  (v:uint64) (childt:uint64) (childf:uint64))= any
    [ good (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf <> input} {false} any ]
    
end
module Bdd_Impl13_Eq
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model'2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'2 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'2 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'2 self
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  use prelude.Int
  use prelude.UInt64
  use prelude.Int
  use prelude.UInt64
  function deep_model'3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UInt64.to_int self
  let rec deep_model'3 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = deep_model'3 self} (! return' {result}) ]
    
  function deep_model'1 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'3 self
  let rec deep_model'1 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = deep_model'1 self} (! return' {result}) ]
    
  let rec eq'1 (self:uint64) (other:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75] result
      = (deep_model'1 self = deep_model'1 other)}
      (! return' {result}) ]
    
  function deep_model'4 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'4 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'4 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'4 self
  let rec shallow_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  let rec eq'0 (self:Bdd_Bdd_Type.t_bdd) (o:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[#"../bdd.rs" 201 14 201 37] result = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
  predicate resolve'1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'1 (let (_, a) = self in a)
  let rec resolve'0 (self:(Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec eq (self:Bdd_Node_Type.t_node) (rhs:Bdd_Node_Type.t_node) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- (self, rhs) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _4 in r'0) = Bdd_Node_Type.C_False } (! bb2)
        | br1 -> {(let (r'0, _) = _4 in r'0) = Bdd_Node_Type.C_True } (! bb4)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (r'0, _) = _4 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb6) ]
         ]
      
    | bb6 = s0
      [ s0 = any
        [ br0 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_False } (! bb1)
        | br1 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_True } (! bb1)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (_, r'0) = _4 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb7) ]
         ]
      
    | bb7 = s0 [ s0 = bb10 ] 
    | bb10 = s0
      [ s0 = Bdd_Node_Type.if' {let (r'0, _) = _4 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd_Bdd_Type.t_bdd) (rchildf'0:Bdd_Bdd_Type.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Bdd_Node_Type.if' {let (r'1, _) = _4 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd_Bdd_Type.t_bdd) (rchildf'1:Bdd_Bdd_Type.t_bdd) ->
             [ &childt_1 <- rchildt'1 ] 
            s2)
      | s2 = Bdd_Node_Type.if' {let (r'2, _) = _4 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd_Bdd_Type.t_bdd) (rchildf'2:Bdd_Bdd_Type.t_bdd) ->
             [ &childf_1 <- rchildf'2 ] 
            s3)
      | s3 = Bdd_Node_Type.if' {let (_, r'3) = _4 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd_Bdd_Type.t_bdd) (rchildf'3:Bdd_Bdd_Type.t_bdd) ->  [ &v_2 <- rv'3 ] s4)
      | s4 = Bdd_Node_Type.if' {let (_, r'4) = _4 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd_Bdd_Type.t_bdd) (rchildf'4:Bdd_Bdd_Type.t_bdd) ->
             [ &childt_2 <- rchildt'4 ] 
            s5)
      | s5 = Bdd_Node_Type.if' {let (_, r'5) = _4 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd_Bdd_Type.t_bdd) (rchildf'5:Bdd_Bdd_Type.t_bdd) ->
             [ &childf_2 <- rchildf'5 ] 
            s6)
      | s6 = -{resolve'0 _4}- s7
      | s7 = eq'0 {childf_1} {childf_2} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s8)
      | s8 = bb11 ]
      
    | bb11 = s0 [ s0 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ]  ] 
    | bb12 = s0 [ s0 = eq'0 {childt_1} {childt_2} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0 [ s0 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ]  ] 
    | bb14 = s0 [ s0 = eq'1 {v_1} {v_2} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0 [ s0 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ]  ] 
    | bb16 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 90 13 90 22] true ] s1 | s1 = bb21 ] 
    | bb17 = s0 [ s0 = bb20 ] 
    | bb18 = s0 [ s0 = bb20 ] 
    | bb19 = s0 [ s0 = bb20 ] 
    | bb20 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 90 13 90 22] false ] s1 | s1 = bb21 ] 
    | bb21 = s0 [ s0 = bb22 ] 
    | bb4 = s0
      [ s0 = any
        [ br0 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_False } (! bb1)
        | br1 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_True } (! bb5)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (_, r'0) = _4 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb1) ]
         ]
      
    | bb5 = s0 [ s0 = bb9 ] 
    | bb9 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [#"../bdd.rs" 90 13 90 22] true ] s2 | s2 = bb22 ] 
    | bb2 = s0
      [ s0 = any
        [ br0 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_False } (! bb3)
        | br1 -> {(let (_, r'0) = _4 in r'0) = Bdd_Node_Type.C_True } (! bb1)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (_, r'0) = _4 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb1) ]
         ]
      
    | bb1 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [#"../bdd.rs" 90 13 90 22] false ] s2 | s2 = bb22 ] 
    | bb3 = s0 [ s0 = bb8 ] 
    | bb8 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [#"../bdd.rs" 90 13 90 22] true ] s2 | s2 = bb22 ] 
    | bb22 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : bool = any_l () : bool
    | & self : Bdd_Node_Type.t_node = self
    | & rhs : Bdd_Node_Type.t_node = rhs
    | & _4 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node) = any_l () : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)
    | & v_1 : uint64 = any_l () : uint64
    | & childt_1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf_1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & v_2 : uint64 = any_l () : uint64
    | & childt_2 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf_2 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _17 : bool = any_l () : bool
    | & _20 : bool = any_l () : bool
    | & _23 : bool = any_l () : bool ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [#"../bdd.rs" 90 13 90 22] result
      = (deep_model'0 self = deep_model'0 rhs)}
      (! return' {result}) ]
    
end
module Bdd_Impl0_Clone
  use prelude.Borrow
  use prelude.Intrinsic
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec clone' (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd | & self : Bdd_Bdd_Type.t_bdd = self ] 
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 108 14 108 29] result = self}
      (! return' {result}) ]
    
end
module Bdd_Impl14_Clone
  use prelude.Borrow
  use prelude.Intrinsic
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  let rec clone'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 108 14 108 29] result = self} (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.Int
  let rec clone'0 (self:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[#"../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self}
      (! return' {result}) ]
    
  use Bdd_Node_Type as Bdd_Node_Type
  let rec clone' (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_Node_Type.t_node))= (! bb0
    [ bb0 = s0
      [ s0 = any
        [ br0 -> {self = Bdd_Node_Type.C_False } (! bb2)
        | br1 -> {self = Bdd_Node_Type.C_True } (! bb3)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {self = Bdd_Node_Type.C_If a b c} (! bb4) ]
         ]
      
    | bb1 = s0 [ s0 = {[#"../bdd.rs" 90 24 90 29] false} any ] 
    | bb4 = s0
      [ s0 = Bdd_Node_Type.if' {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd_Bdd_Type.t_bdd) (rchildf'0:Bdd_Bdd_Type.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Bdd_Node_Type.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd_Bdd_Type.t_bdd) (rchildf'1:Bdd_Bdd_Type.t_bdd) ->
             [ &childt_1 <- rchildt'1 ] 
            s2)
      | s2 = Bdd_Node_Type.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd_Bdd_Type.t_bdd) (rchildf'2:Bdd_Bdd_Type.t_bdd) ->
             [ &childf_1 <- rchildf'2 ] 
            s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone'0 {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1
      | s1 = clone'1 {_12} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1
      | s1 = clone'1 {_15} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 =  [ &_0 <- Bdd_Node_Type.C_If _7 _10 _13 : Bdd_Node_Type.t_node ] 
        (any
        [ any_ (_any:uint64)-> (!  [ &_7 <- _any ] 
          (any
          [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_10 <- _any ] 
            (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_13 <- _any ] s1) ] )) ]
          )) ]
        )
      | s1 = bb10 ]
      
    | bb3 = s0 [ s0 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- Bdd_Node_Type.C_True : Bdd_Node_Type.t_node ] s1 | s1 = bb10 ] 
    | bb2 = s0 [ s0 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- Bdd_Node_Type.C_False : Bdd_Node_Type.t_node ] s1 | s1 = bb10 ] 
    | bb10 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node
    | & self : Bdd_Node_Type.t_node = self
    | & v_1 : uint64 = any_l () : uint64
    | & childt_1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf_1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _7 : uint64 = any_l () : uint64
    | & _9 : uint64 = any_l () : uint64
    | & _10 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _12 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _13 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _15 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd ]
    
    [ return' (result:Bdd_Node_Type.t_node)-> {[@expl:postcondition] [#"../bdd.rs" 90 24 90 29] result = self}
      (! return' {result}) ]
    
end
module Bdd_Impl17_AssertReceiverIsTotalEq
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.Borrow
  use prelude.Intrinsic
  let rec assert_receiver_is_total_eq (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 104 15 104 17] () ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : () = any_l () : () ]  [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl1_Hash
  use prelude.UInt64
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  use prelude.UInt64
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function hash_log'0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 130 12 135 13] match x with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  let rec hash_log'0 (x:Bdd_NodeLog_Type.t_nodelog) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Node_Type as Bdd_Node_Type
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function shallow_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  constant min'0 : uint64 = (0 : uint64)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (64 : uint32)
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt64.to_int self
      + UInt64.to_int rhs
      > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt64.to_int self + UInt64.to_int rhs
      < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt64.to_int self + UInt64.to_int rhs
      >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt64.to_int self
      * UInt64.to_int rhs
      > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt64.to_int self * UInt64.to_int rhs
      < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt64.to_int self * UInt64.to_int rhs
      >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  let rec hash (self:Bdd_Node_Type.t_node) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = any
        [ br0 -> {self = Bdd_Node_Type.C_False } (! bb2)
        | br1 -> {self = Bdd_Node_Type.C_True } (! bb3)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {self = Bdd_Node_Type.C_If a b c} (! bb4) ]
         ]
      
    | bb1 = s0 [ s0 = {[#"../bdd.rs" 117 14 117 18] false} any ] 
    | bb4 = s0
      [ s0 = Bdd_Node_Type.if' {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd_Bdd_Type.t_bdd) (rchildf'0:Bdd_Bdd_Type.t_bdd) ->  [ &v <- rv'0 ] s1)
      | s1 = Bdd_Node_Type.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd_Bdd_Type.t_bdd) (rchildf'1:Bdd_Bdd_Type.t_bdd) ->
             [ &childt <- rchildt'1 ] 
            s2)
      | s2 = Bdd_Node_Type.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd_Bdd_Type.t_bdd) (rchildf'2:Bdd_Bdd_Type.t_bdd) ->
             [ &childf <- rchildf'2 ] 
            s3)
      | s3 = Bdd_Bdd_Type.t_bdd {childt}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[#"../bdd.rs" 121 53 121 54] (5 : uint64)}
              (fun (_ret':uint64) ->  [ &_9 <- _ret' ] s4))
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 = wrapping_add'0 {v} {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {childf}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[#"../bdd.rs" 121 92 121 93] (7 : uint64)}
              (fun (_ret':uint64) ->  [ &_11 <- _ret' ] s1))
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = wrapping_add'0 {_7} {_11} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = bb11 ] 
    | bb3 = s0 [ s0 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 119 20 119 21] (2 : uint64) ] s1 | s1 = bb11 ] 
    | bb2 = s0 [ s0 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [#"../bdd.rs" 118 21 118 22] (1 : uint64) ] s1 | s1 = bb11 ] 
    | bb11 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : uint64 = any_l () : uint64
    | & self : Bdd_Node_Type.t_node = self
    | & v : uint64 = any_l () : uint64
    | & childt : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _7 : uint64 = any_l () : uint64
    | & _9 : uint64 = any_l () : uint64
    | & _11 : uint64 = any_l () : uint64 ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [#"../bdd.rs" 115 14 115 46] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl2_Hash
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  function hash_log'0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [#"../bdd.rs" 149 8 149 24] UInt64.to_int x
  let rec hash_log'0 (x:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'0 self
  let rec shallow_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  use Bdd_Node_Type as Bdd_Node_Type
  let rec hash (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {self} (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->  [ &_0 <- r1'0 ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () : uint64 | & self : Bdd_Bdd_Type.t_bdd = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [#"../bdd.rs" 141 14 141 46] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl8_Size_Impl
  use Bdd_Node_Type as Bdd_Node_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use prelude.Int
  constant self  : Bdd_Bdd_Type.t_bdd
  function size [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int
  goal vc_size : match self with
    | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> [#"../bdd.rs" 223 14 223 25] 0 >= 0
    | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> [#"../bdd.rs" 223 14 223 25] 0 >= 0
    | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> ([#"../bdd.rs" 223 14 223 25] size childt >= 0)
     -> (let ht = size childt in ([#"../bdd.rs" 223 14 223 25] size childf >= 0)
     -> (let hf = size childf in [#"../bdd.rs" 223 14 223 25] 1 + ht + hf >= 0))
    end
end
module Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use prelude.UInt64
  use prelude.Int
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  use prelude.Snapshot
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  use prelude.Borrow
  type t_context  =
    | C_Context (Bdd_Bumpalo_Bump_Type.t_bump) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) uint64
    
  function any_l (_ : 'b) : 'a
  let rec t_context (input:t_context) (ret  (alloc:Bdd_Bumpalo_Bump_Type.t_bump) (hashcons:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (not_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (and_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (cnt:uint64))= any
    [ good (alloc:Bdd_Bumpalo_Bump_Type.t_bump) (hashcons:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (not_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (and_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      = input}
      (! ret {alloc} {hashcons} {hashcons_ghost} {not_memo} {and_memo} {cnt})
    | bad (alloc:Bdd_Bumpalo_Bump_Type.t_bump) (hashcons:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (not_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (and_memo:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      <> input}
      {false}
      any ]
    
  function context_hashcons (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    
   =
    match self with
      | C_Context _ a _ _ _ _ -> a
      end
  function context_cnt (self : t_context) : uint64 =
    match self with
      | C_Context _ _ _ _ _ a -> a
      end
  function context_hashcons_ghost (self : t_context) : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)) =
    match self with
      | C_Context _ _ a _ _ _ -> a
      end
  function context_not_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   =
    match self with
      | C_Context _ _ _ a _ _ -> a
      end
  function context_and_memo (self : t_context) : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    
   =
    match self with
      | C_Context _ _ _ _ a _ -> a
      end
end
module Bdd_Impl10_GrowsIsValidBdd_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'3 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'3 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'2 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'2 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'3 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'4 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'1 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Context_Type.t_context)
  let rec inv'1 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Context_Type.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  constant self  : borrowed (Bdd_Context_Type.t_context)
  constant b  : Bdd_Bdd_Type.t_bdd
  function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Bdd_Context_Type.t_context)) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  goal vc_grows_is_valid_bdd : ([#"../bdd.rs" 336 35 336 39] inv'0 self)
   -> ([#"../bdd.rs" 334 15 334 35] is_valid_bdd'0 ( * self) b)
   -> ([#"../bdd.rs" 333 15 333 27] grows'0 self)  -> ([#"../bdd.rs" 335 14 335 37] is_valid_bdd'0 ( ^ self) b)
end
module Bdd_Impl10_GrowsTrans_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'3 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'3 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'2 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'2 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'4 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'4 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'4 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'2 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'3 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'1 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Context_Type.t_context)
  let rec inv'1 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Context_Type.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  constant self  : borrowed (Bdd_Context_Type.t_context)
  constant o  : borrowed (Bdd_Context_Type.t_context)
  constant oo  : borrowed (Bdd_Context_Type.t_context)
  function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Bdd_Context_Type.t_context)) (o : borrowed (Bdd_Context_Type.t_context)) (oo : borrowed (Bdd_Context_Type.t_context)) : ()
    
  goal vc_grows_trans : ([#"../bdd.rs" 345 48 345 50] inv'0 oo)
   -> ([#"../bdd.rs" 345 34 345 35] inv'0 o)
   -> ([#"../bdd.rs" 345 28 345 32] inv'0 self)
   -> ([#"../bdd.rs" 343 15 343 43]  * self =  * oo /\  ^ self =  ^ oo)
   -> ([#"../bdd.rs" 342 15 342 26]  ^ self =  * o)
   -> ([#"../bdd.rs" 341 15 341 24] grows'0 o)
   -> ([#"../bdd.rs" 340 15 340 27] grows'0 self)  -> ([#"../bdd.rs" 344 14 344 24] grows'0 oo)
end
module Bdd_Impl10_SetIrreleventVar_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'2 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'2 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'2 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Map
  constant self  : Bdd_Context_Type.t_context
  constant a  : Bdd_Bdd_Type.t_bdd
  constant x  : uint64
  constant v  : Map.map uint64 bool
  constant b  : bool
  function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  goal vc_set_irrelevent_var : ([#"../bdd.rs" 351 26 351 30] inv'0 self)
   -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 a)
   -> ([#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self a)
   -> match a with
    | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> (([#"../bdd.rs" 351 26 351 30] inv'0 self)
    && ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 childt)
    && ([#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self childt))
    /\ (([#"../bdd.rs" 350 14 350 50] interp'0 childt v = interp'0 childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([#"../bdd.rs" 351 26 351 30] inv'0 self)
    && ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 childf)
    && ([#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self childf))
    /\ (([#"../bdd.rs" 350 14 350 50] interp'0 childf v = interp'0 childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [#"../bdd.rs" 350 14 350 50] interp'0 a v
    = interp'0 a (Map.set v x b)))))
    | _ -> [#"../bdd.rs" 350 14 350 50] interp'0 a v = interp'0 a (Map.set v x b)
    end
end
module Bdd_Impl10_DiscrValuation_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'2 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'2 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'2 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Const
  use map.Map
  function set_irrelevent_var'0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 353 12 359 13] match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  let rec set_irrelevent_var'0 (self:Bdd_Context_Type.t_context) (a:Bdd_Bdd_Type.t_bdd) (x:uint64) (v:Map.map uint64 bool) (b:bool) (return'  (ret:()))= {[@expl:precondition] [#"../bdd.rs" 351 26 351 30] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 a}
    {[@expl:precondition] [#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self a}
    any [ return' (result:())-> {result = set_irrelevent_var'0 self a x v b} (! return' {result}) ] 
  axiom set_irrelevent_var'0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self a)
   -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 a)
   -> ([#"../bdd.rs" 351 26 351 30] inv'0 self)
   -> ([#"../bdd.rs" 350 14 350 50] interp'0 a v = interp'0 a (Map.set v x b))
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1
      + ht
      + hf
      end
  let rec size'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = size'0 self} (! return' {result}) ]
    
  axiom size'0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size'0 self >= 0
  constant self  : Bdd_Context_Type.t_context
  constant a  : Bdd_Bdd_Type.t_bdd
  constant b  : Bdd_Bdd_Type.t_bdd
  function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  goal vc_discr_valuation : ([#"../bdd.rs" 370 23 370 27] inv'0 self)
   -> ([#"../bdd.rs" 366 15 366 21] a <> b)
   -> ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self b)
   -> ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self a)
   -> (let _ = set_irrelevent_var'0 in match leastvar'0 a < leastvar'0 b with
    | True -> match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> match childf <> b with
        | True -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
        && ([#"../bdd.rs" 366 15 366 21] childf <> b)
        && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self b)
        && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self childf))
        /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
        /\ ([#"../bdd.rs" 368 14 368 33] size'0 childf + size'0 b) < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
        /\ (([#"../bdd.rs" 367 14 367 50] interp'0 childf (discr_valuation self childf b)
        <> interp'0 b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [#"../bdd.rs" 367 14 367 50] interp'0 a result
        <> interp'0 b result))
        | False -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
        && ([#"../bdd.rs" 366 15 366 21] childt <> b)
        && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self b)
        && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self childt))
        /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
        /\ ([#"../bdd.rs" 368 14 368 33] size'0 childt + size'0 b) < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
        /\ (([#"../bdd.rs" 367 14 367 50] interp'0 childt (discr_valuation self childt b)
        <> interp'0 b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [#"../bdd.rs" 367 14 367 50] interp'0 a result
        <> interp'0 b result))
        end
      | _ -> let result = Const.const true in [#"../bdd.rs" 367 14 367 50] interp'0 a result <> interp'0 b result
      end
    | False -> match leastvar'0 a > leastvar'0 b with
      | True -> match b with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> match childf <> a with
          | True -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
          && ([#"../bdd.rs" 366 15 366 21] a <> childf)
          && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self childf)
          && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self a))
          /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
          /\ ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 childf)
          < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
          /\ (([#"../bdd.rs" 367 14 367 50] interp'0 a (discr_valuation self a childf)
          <> interp'0 childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [#"../bdd.rs" 367 14 367 50] interp'0 a result
          <> interp'0 b result))
          | False -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
          && ([#"../bdd.rs" 366 15 366 21] a <> childt)
          && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self childt)
          && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self a))
          /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
          /\ ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 childt)
          < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
          /\ (([#"../bdd.rs" 367 14 367 50] interp'0 a (discr_valuation self a childt)
          <> interp'0 childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [#"../bdd.rs" 367 14 367 50] interp'0 a result
          <> interp'0 b result))
          end
        | _ -> let result = Const.const true in [#"../bdd.rs" 367 14 367 50] interp'0 a result <> interp'0 b result
        end
      | False -> match a with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match b with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> match childfa <> childfb with
            | True -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
            && ([#"../bdd.rs" 366 15 366 21] childfa <> childfb)
            && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self childfb)
            && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self childfa))
            /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
            /\ ([#"../bdd.rs" 368 14 368 33] size'0 childfa + size'0 childfb)
            < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
            /\ (([#"../bdd.rs" 367 14 367 50] interp'0 childfa (discr_valuation self childfa childfb)
            <> interp'0 childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [#"../bdd.rs" 367 14 367 50] interp'0 a result
            <> interp'0 b result))
            | False -> ((([#"../bdd.rs" 370 23 370 27] inv'0 self)
            && ([#"../bdd.rs" 366 15 366 21] childta <> childtb)
            && ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self childtb)
            && ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self childta))
            /\ 0 <= ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b)
            /\ ([#"../bdd.rs" 368 14 368 33] size'0 childta + size'0 childtb)
            < ([#"../bdd.rs" 368 14 368 33] size'0 a + size'0 b))
            /\ (([#"../bdd.rs" 367 14 367 50] interp'0 childta (discr_valuation self childta childtb)
            <> interp'0 childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [#"../bdd.rs" 367 14 367 50] interp'0 a result
            <> interp'0 b result))
            end
          | _ -> let result = Const.const true in [#"../bdd.rs" 367 14 367 50] interp'0 a result <> interp'0 b result
          end
        | _ -> let result = Const.const true in [#"../bdd.rs" 367 14 367 50] interp'0 a result <> interp'0 b result
        end
      end
    end)
end
module Bdd_Impl10_BddCanonical_Impl
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'3 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'3 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'2 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'2 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'2 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use map.Const
  use map.Map
  function set_irrelevent_var'0 [#"../bdd.rs" 351 4 351 87] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [#"../bdd.rs" 353 12 359 13] match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  let rec set_irrelevent_var'0 (self:Bdd_Context_Type.t_context) (a:Bdd_Bdd_Type.t_bdd) (x:uint64) (v:Map.map uint64 bool) (b:bool) (return'  (ret:()))= {[@expl:precondition] [#"../bdd.rs" 351 26 351 30] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 a}
    {[@expl:precondition] [#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self a}
    any [ return' (result:())-> {result = set_irrelevent_var'0 self a x v b} (! return' {result}) ] 
  axiom set_irrelevent_var'0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([#"../bdd.rs" 348 15 348 35] is_valid_bdd'0 self a)
   -> ([#"../bdd.rs" 349 15 349 32] UInt64.to_int x < leastvar'0 a)
   -> ([#"../bdd.rs" 351 26 351 30] inv'0 self)
   -> ([#"../bdd.rs" 350 14 350 50] interp'0 a v = interp'0 a (Map.set v x b))
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1
      + ht
      + hf
      end
  let rec size'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = size'0 self} (! return' {result}) ]
    
  axiom size'0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size'0 self >= 0
  function discr_valuation'0 [#"../bdd.rs" 370 4 370 82] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : Map.map uint64 bool
    
  axiom discr_valuation'0_def : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . discr_valuation'0 self a b
  = ([#"../bdd.rs" 372 12 372 36] let _ = () in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation'0 self childf b) v false
      else
        Map.set (discr_valuation'0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation'0 self a childf) v false
        else
          Map.set (discr_valuation'0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childta childfa) _ -> match b with
          | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation'0 self childfa childfb) v false
          else
            Map.set (discr_valuation'0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  let rec discr_valuation'0 (self:Bdd_Context_Type.t_context) (a:Bdd_Bdd_Type.t_bdd) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:Map.map uint64 bool))= {[@expl:precondition] [#"../bdd.rs" 370 23 370 27] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 366 15 366 21] a <> b}
    {[@expl:precondition] [#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self b}
    {[@expl:precondition] [#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self a}
    any [ return' (result:Map.map uint64 bool)-> {result = discr_valuation'0 self a b} (! return' {result}) ] 
  axiom discr_valuation'0_spec : forall self : Bdd_Context_Type.t_context, a : Bdd_Bdd_Type.t_bdd, b : Bdd_Bdd_Type.t_bdd . ([#"../bdd.rs" 364 15 364 35] is_valid_bdd'0 self a)
   -> ([#"../bdd.rs" 365 15 365 35] is_valid_bdd'0 self b)
   -> ([#"../bdd.rs" 366 15 366 21] a <> b)
   -> ([#"../bdd.rs" 370 23 370 27] inv'0 self)
   -> ([#"../bdd.rs" 367 14 367 50] interp'0 a (discr_valuation'0 self a b) <> interp'0 b (discr_valuation'0 self a b))
  constant self  : Bdd_Context_Type.t_context
  constant a  : Bdd_Bdd_Type.t_bdd
  constant b  : Bdd_Bdd_Type.t_bdd
  function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Bdd_Context_Type.t_context) (a : Bdd_Bdd_Type.t_bdd) (b : Bdd_Bdd_Type.t_bdd) : ()
    
  goal vc_bdd_canonical : ([#"../bdd.rs" 418 25 418 29] inv'0 self)
   -> ([#"../bdd.rs" 415 4 415 56] forall v : Map.map uint64 bool . interp'0 a v = interp'0 b v)
   -> ([#"../bdd.rs" 414 15 414 35] is_valid_bdd'0 self b)
   -> ([#"../bdd.rs" 413 15 413 35] is_valid_bdd'0 self a)
   -> (let _ = discr_valuation'0 in [#"../bdd.rs" 416 14 416 20] a = b)
end
module Bdd_Impl11_New
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'2 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'2 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'2 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'1 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'1 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'4 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'4 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'4 self} (! return' {result}) ]
    
  function shallow_model'3 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'4 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'3 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'3 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'2 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  use prelude.Intrinsic
  use map.Const
  let rec new'2 (_1:()) (return'  (ret:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)))= any
    [ return' (result:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 67 18 67 47] shallow_model'2 result
      = Const.const (Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use map.Const
  let rec new'1 (_1:()) (return'  (ret:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)))= any
    [ return' (result:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 67 18 67 47] shallow_model'1 result
      = Const.const (Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Snapshot
  use map.Const
  use map.Const
  let rec new'0 (_1:()) (return'  (ret:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)))= any
    [ return' (result:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 67 18 67 47] shallow_model'0 result
      = Const.const (Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec promoted0 (return'  (ret:Bdd_Node_Type.t_node))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Bdd_Node_Type.C_True : Bdd_Node_Type.t_node ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
       ]
    
    [ & _0 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node
    | & _1 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node ]
     [ return' (result:Bdd_Node_Type.t_node)-> return' {result} ] 
  let rec new (alloc:Bdd_Bumpalo_Bump_Type.t_bump) (return'  (ret:Bdd_Context_Type.t_context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0 (fun (pr0:Bdd_Node_Type.t_node) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new'0 {[#"../bdd.rs" 428 22 428 47] ()}
          (fun (_ret':Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) ->
             [ &_5 <- _ret' ] 
            s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = 
        [ &_6 <- ([#"../bdd.rs" 429 28 429 57] Snapshot.new (Const.const t)) : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)) ]
        
        s1
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = new'1 {[#"../bdd.rs" 430 22 430 47] ()}
          (fun (_ret':Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) ->
             [ &_8 <- _ret' ] 
            s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = new'2 {[#"../bdd.rs" 431 22 431 47] ()}
          (fun (_ret':Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) ->
             [ &_9 <- _ret' ] 
            s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = 
        [ &_0 <- Bdd_Context_Type.C_Context alloc _5 _6 _8 _9 ([#"../bdd.rs" 432 17 432 18] (0 : uint64)) : Bdd_Context_Type.t_context ]
        
        (any
        [ any_ (_any:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))-> (! 
          [ &_5 <- _any ]
          
          (any
          [ any_ (_any:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)))-> (!  [ &_6 <- _any ] 
            (any
            [ any_ (_any:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))-> (! 
              [ &_8 <- _any ]
              
              (any
              [ any_ (_any:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))-> (! 
                [ &_9 <- _any ]
                
                s1) ]
              )) ]
            )) ]
          )) ]
        )
      | s1 = return' {_0} ]
       ]
    )
    [ & _0 : Bdd_Context_Type.t_context = any_l () : Bdd_Context_Type.t_context
    | & alloc : Bdd_Bumpalo_Bump_Type.t_bump = alloc
    | & t : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node
    | & _5 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd) = any_l () : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)
    | & _6 : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)) = any_l () : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))
    | & _8 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd) = any_l () : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    | & _9 : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd) = any_l () : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)
    | & _10 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node ]
    
    [ return' (result:Bdd_Context_Type.t_context)-> {[@expl:postcondition] [#"../bdd.rs" 424 48 424 52] inv'0 result}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Hashcons
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'7 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'7 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'6 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'6 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'1 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'1 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'3 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'3 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'0 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'7 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'0 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'7 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : Bdd_Context_Type.t_context)
  let rec inv'7 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : Bdd_Context_Type.t_context . inv'7 x
  = (invariant'7 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'6 (self : Bdd_NodeLog_Type.t_nodelog) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'6 (self:Bdd_NodeLog_Type.t_nodelog) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : Bdd_NodeLog_Type.t_nodelog)
  let rec inv'6 (_x:Bdd_NodeLog_Type.t_nodelog) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : Bdd_NodeLog_Type.t_nodelog . inv'6 x = true
  predicate invariant'5 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'5 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'5 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : Bdd_Bdd_Type.t_bdd . inv'5 x = true
  predicate invariant'4 (self : borrowed (Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'4 (self:borrowed (Bdd_Node_Type.t_node)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (Bdd_Node_Type.t_node))
  let rec inv'4 (_x:borrowed (Bdd_Node_Type.t_node)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (Bdd_Node_Type.t_node) . inv'4 x = true
  predicate invariant'3 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'3 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Bdd_Node_Type.t_node)
  let rec inv'3 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Bdd_Node_Type.t_node . inv'3 x = true
  predicate invariant'2 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  let rec inv'2 (_x:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv'2 x = true
  predicate invariant'1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Node_Type.t_node)
  let rec inv'1 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Node_Type.t_node . inv'1 x = true
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'7 ( * x) /\ inv'7 ( ^ x))
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use map.Map
  function shallow_model'4 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 31] shallow_model'3 ( * self)
  let rec shallow_model'4 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  let rec add'0 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) (key:Bdd_Node_Type.t_node) (val':Bdd_Bdd_Type.t_bdd) (return'  (ret:()))= {[@expl:precondition] [#"../bdd.rs" 54 38 54 41] inv'5 val'}
    {[@expl:precondition] [#"../bdd.rs" 54 30 54 33] inv'3 key}
    any
    [ return' (result:())-> {[#"../bdd.rs" 52 8 52 128] forall i : Bdd_NodeLog_Type.t_nodelog . inv'6 i
       -> Map.get (shallow_model'3 ( ^ self)) i
      = (if i = deep_model'1 key then Core_Option_Option_Type.C_Some val' else Map.get (shallow_model'4 self) i)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Node_Type.t_node)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  let rec alloc'0 (self:Bdd_Bumpalo_Bump_Type.t_bump) (val':Bdd_Node_Type.t_node) (return'  (ret:borrowed (Bdd_Node_Type.t_node)))= {[@expl:precondition] [#"../bdd.rs" 18 31 18 34] inv'3 val'}
    any
    [ return' (result:borrowed (Bdd_Node_Type.t_node))-> {[#"../bdd.rs" 18 42 18 48] inv'4 result}
      {[#"../bdd.rs" 17 18 17 32]  * result = val'}
      (! return' {result}) ]
    
  function deep_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'2 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'2 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'2 self}
      (! return' {result}) ]
    
  let rec get'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (key:Bdd_Node_Type.t_node) (return'  (ret:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))= {[@expl:precondition] [#"../bdd.rs" 63 37 63 40] inv'1 key}
    any
    [ return' (result:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 63 52 63 65] inv'2 result}
      {[#"../bdd.rs" 58 18 61 9] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model'2 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (shallow_model'2 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
  use prelude.Snapshot
  let rec hashcons (self:borrowed (Bdd_Context_Type.t_context)) (n:Bdd_Node_Type.t_node) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 440 21 440 25] inv'0 self}
    {[#"../bdd.rs" 436 15 436 36] is_valid_node'0 ( * self) n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n ] s1
      | s1 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rhashcons'0} {_11}
              (fun (_ret':Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) ->  [ &_8 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = any
        [ br0 -> {_8 = Core_Option_Option_Type.C_None } (! bb4)
        | br1 (a:Bdd_Bdd_Type.t_bdd)-> {_8 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb4 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            alloc'0 {ralloc'0} {n} (fun (_ret':borrowed (Bdd_Node_Type.t_node)) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
             [ &r1 <- Bdd_Bdd_Type.C_Bdd ( * _19) rcnt'0 : Bdd_Bdd_Type.t_bdd ] 
            s1)
      | s1 = -{resolve'0 _19}- s2
      | s2 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'1:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'1:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'1:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'1:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'1:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'1:uint64) ->
            Borrow.borrow_final
              <Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)>
              {rhashcons'1}
              {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))) ->
                 [ &_24 <- _ret' ] 
                Bdd_Context_Type.t_context { * self}
                  (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 ( ^ _24) l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 l_cnt'0 : Bdd_Context_Type.t_context) ; } ]
                    
                    s3)))
      | s3 = add'0 {_24} {n} {r1} (fun (_ret':()) ->  [ &_23 <- _ret' ] s4)
      | s4 = bb6 ]
      
    | bb6 = s0
      [ s0 = 
        [ &_27 <- ([#"../bdd.rs" 447 30 447 77] Snapshot.new (Map.set (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost ( * self))) (Bdd_Bdd_Type.bdd_1 r1) (Bdd_Bdd_Type.bdd_0 r1))) : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)) ]
        
        s1
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
            
            [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 l_hashcons'0 _27 l_not_memo'0 l_and_memo'0 l_cnt'0 : Bdd_Context_Type.t_context) ; } ]
            
            (any [ any_ (_any:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)))-> (!  [ &_27 <- _any ] s1) ] ))
      | s1 = UInt64.sub
          {[#"../bdd.rs" 448 22 448 30] (18446744073709551615 : uint64)}
          {[#"../bdd.rs" 448 33 448 34] (1 : uint64)}
          (fun (_ret':uint64) ->  [ &_32 <- _ret' ] s2)
      | s2 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            UInt64.gt {rcnt'0} {_32}
              (fun (_ret':bool) ->  [ &_30 <- _ret' ] (any [ any_ (_any:uint64)-> (!  [ &_32 <- _any ] s3) ] )))
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 = bb9 ] 
    | bb9 = bb9
      [ bb9 = (! s0 [ s0 = bb10 ] )
        [ bb10 = s0
          [ s0 = Bdd_Context_Type.t_context { * self}
              (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
                Bdd_Context_Type.t_context { * self}
                  (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 rcnt'0 : Bdd_Context_Type.t_context) ; } ]
                    
                    s1))
          | s1 = bb9 ]
           ]
         ]
      
    | bb11 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            UInt64.add {rcnt'0} {[#"../bdd.rs" 454 20 454 21] (1 : uint64)}
              (fun (_ret':uint64) ->
                Bdd_Context_Type.t_context { * self}
                  (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 _ret' : Bdd_Context_Type.t_context) ; } ]
                    
                    s1)))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 =  [ &_0 <- r1 ] s4
      | s4 = bb12 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <Bdd_Bdd_Type.t_bdd> {_8}
          (fun (r0'0:Bdd_Bdd_Type.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 = {[@expl:assertion] [#"../bdd.rs" 442 28 442 38] shallow_model'0 (Bdd_Bdd_Type.bdd_0 r) = shallow_model'1 n}
        s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb12 ]
      
    | bb12 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & n : Bdd_Node_Type.t_node = n
    | & _8 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) = any_l () : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    | & _11 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node
    | & r : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & r1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _19 : borrowed (Bdd_Node_Type.t_node) = any_l () : borrowed (Bdd_Node_Type.t_node)
    | & _23 : () = any_l () : ()
    | & _24 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) = any_l () : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd))
    | & _27 : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node)) = any_l () : Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))
    | & _30 : bool = any_l () : bool
    | & _32 : uint64 = any_l () : uint64 ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 439 14 439 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 438 14 438 26] grows'0 self}
      {[@expl:postcondition] [#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Node
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'7 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'7 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'6 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'6 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'6 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'3 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'3 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'3 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'1 self} (! return' {result}) ]
    
  function shallow_model'5 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'1 self
  let rec shallow_model'5 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  function shallow_model'2 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'5 self
  let rec shallow_model'2 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'1 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'1 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) (shallow_model'2 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'2 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'1 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Context_Type.t_context)
  let rec inv'1 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Context_Type.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  let rec hashcons'0 (self:borrowed (Bdd_Context_Type.t_context)) (n:Bdd_Node_Type.t_node) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 440 21 440 25] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 436 15 436 36] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 439 14 439 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 438 14 438 26] grows'0 self}
      {[#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'4 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'0 self
  let rec shallow_model'4 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'4 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'4 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  let rec eq'0 (self:Bdd_Bdd_Type.t_bdd) (o:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[#"../bdd.rs" 201 14 201 37] result = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
  let rec node (self:borrowed (Bdd_Context_Type.t_context)) (x:uint64) (childt:Bdd_Bdd_Type.t_bdd) (childf:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 465 17 465 21] inv'0 self}
    {[#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[#"../bdd.rs" 459 15 459 40] is_valid_bdd'0 ( * self) childf}
    {[#"../bdd.rs" 458 15 458 40] is_valid_bdd'0 ( * self) childt}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {childt} {childf} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ]  ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- childt ] s3
      | s3 = bb5 ]
      
    | bb3 = s0
      [ s0 = Borrow.borrow_final <Bdd_Context_Type.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_17 <- _ret' ] 
             [ &self <- { self with current = ( ^ _17) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _17)}- s2
      | s2 =  [ &_18 <- Bdd_Node_Type.C_If x childt childf : Bdd_Node_Type.t_node ] s3
      | s3 = hashcons'0 {_17} {_18} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ] 
    | bb5 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & x : uint64 = x
    | & childt : Bdd_Bdd_Type.t_bdd = childt
    | & childf : Bdd_Bdd_Type.t_bdd = childf
    | & _13 : bool = any_l () : bool
    | & _17 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _18 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 464 14 464 37] UInt64.to_int x
      <= leastvar'0 result}
      {[@expl:postcondition] [#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[@expl:postcondition] [#"../bdd.rs" 462 14 462 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 461 14 461 26] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_True
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant'1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'1 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'2 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'2 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'2 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec hashcons'0 (self:borrowed (Bdd_Context_Type.t_context)) (n:Bdd_Node_Type.t_node) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 440 21 440 25] inv'1 self}
    {[@expl:precondition] [#"../bdd.rs" 436 15 436 36] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 439 14 439 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 438 14 438 26] grows'0 self}
      {[#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  let rec true_ (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 476 22 476 26] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Bdd_Context_Type.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = ( ^ _6) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _6)}- s2
      | s2 =  [ &_7 <- Bdd_Node_Type.C_True : Bdd_Node_Type.t_node ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & _6 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _7 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 475 14 475 46] UInt64.to_int (max'0 : uint64)
      + 1
      = leastvar'0 result}
      {[@expl:postcondition] [#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp'0 result v}
      {[@expl:postcondition] [#"../bdd.rs" 473 14 473 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 472 14 472 26] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_False
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant'1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'1 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'2 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'2 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'2 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec hashcons'0 (self:borrowed (Bdd_Context_Type.t_context)) (n:Bdd_Node_Type.t_node) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 440 21 440 25] inv'1 self}
    {[@expl:precondition] [#"../bdd.rs" 436 15 436 36] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 439 14 439 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 438 14 438 26] grows'0 self}
      {[#"../bdd.rs" 437 14 437 28] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  let rec false_ (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 484 23 484 27] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Bdd_Context_Type.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = ( ^ _6) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _6)}- s2
      | s2 =  [ &_7 <- Bdd_Node_Type.C_False : Bdd_Node_Type.t_node ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & _6 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _7 : Bdd_Node_Type.t_node = any_l () : Bdd_Node_Type.t_node ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 483 14 483 46] UInt64.to_int (max'0 : uint64)
      + 1
      = leastvar'0 result}
      {[@expl:postcondition] [#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp'0 result v}
      {[@expl:postcondition] [#"../bdd.rs" 481 14 481 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 480 14 480 26] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_V
  use Bdd_Context_Type as Bdd_Context_Type
  use prelude.Borrow
  predicate invariant'1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Context_Type.t_context)
  let rec inv'0 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'1 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.UInt64
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use map.Map
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'5 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'5 self}
      (! return' {result}) ]
    
  use map.Map
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'4 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'4 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'2 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'2 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'2 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'2 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'0 self
  let rec shallow_model'3 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'3 self} (! return' {result}) ]
    
  function shallow_model'1 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'3 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'0 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Context_Type.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec node'0 (self:borrowed (Bdd_Context_Type.t_context)) (x:uint64) (childt:Bdd_Bdd_Type.t_bdd) (childf:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 465 17 465 21] inv'1 self}
    {[@expl:precondition] [#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar'0 childt
    /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [#"../bdd.rs" 459 15 459 40] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [#"../bdd.rs" 458 15 458 40] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar'0 result}
      {[#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[#"../bdd.rs" 462 14 462 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 461 14 461 26] grows'0 self}
      (! return' {result}) ]
    
  let rec false'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 484 23 484 27] inv'1 self}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 483 14 483 46] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp'0 result v}
      {[#"../bdd.rs" 481 14 481 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 480 14 480 26] grows'0 self}
      (! return' {result}) ]
    
  let rec true'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 476 22 476 26] inv'1 self}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 475 14 475 46] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp'0 result v}
      {[#"../bdd.rs" 473 14 473 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 472 14 472 26] grows'0 self}
      (! return' {result}) ]
    
  let rec v (self:borrowed (Bdd_Context_Type.t_context)) (x:uint64) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 491 18 491 22] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_7 <- _ret' ] 
             [ &self <- { self with current = ( ^ _7) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _7)}- s2
      | s2 = true'0 {_7} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &t <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_9 <- _ret' ] 
             [ &self <- { self with current = ( ^ _9) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _9)}- s2
      | s2 = false'0 {_9} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &f <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <Bdd_Context_Type.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_10 <- _ret' ] 
             [ &self <- { self with current = ( ^ _10) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _10)}- s2
      | s2 = node'0 {_10} {x} {t} {f} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & x : uint64 = x
    | & t : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _7 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & f : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _9 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _10 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context) ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 490 4 490 56] forall v : Map.map uint64 bool . interp'0 result v
      = Map.get v x}
      {[@expl:postcondition] [#"../bdd.rs" 489 14 489 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 488 14 488 26] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Not
  use prelude.UInt64
  predicate invariant'5 (self : uint64) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'5 (self:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : uint64)
  let rec inv'5 (_x:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : uint64 . inv'5 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant'4 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'4 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'4 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Bdd_Bdd_Type.t_bdd . inv'4 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'3 (self:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  let rec inv'3 (_x:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv'3 x = true
  predicate invariant'2 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'2 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Bdd_Bdd_Type.t_bdd . inv'2 x = true
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'7 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'7 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'1 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'1 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'2 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'2 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'2 self} (! return' {result}) ]
    
  function shallow_model'6 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'2 self
  let rec shallow_model'6 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'6 self} (! return' {result}) ]
    
  function shallow_model'4 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'6 self
  let rec shallow_model'4 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'4 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'3 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'3 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'1 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Context_Type.t_context)
  let rec inv'1 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Context_Type.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1
      + ht
      + hf
      end
  let rec size'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = size'0 self} (! return' {result}) ]
    
  axiom size'0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size'0 self >= 0
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  function shallow_model'2 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 31] shallow_model'1 ( * self)
  let rec shallow_model'2 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'2 self}
      (! return' {result}) ]
    
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'1 self} (! return' {result}) ]
    
  let rec add'0 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (key:Bdd_Bdd_Type.t_bdd) (val':Bdd_Bdd_Type.t_bdd) (return'  (ret:()))= {[@expl:precondition] [#"../bdd.rs" 54 38 54 41] inv'4 val'}
    {[@expl:precondition] [#"../bdd.rs" 54 30 54 33] inv'4 key}
    any
    [ return' (result:())-> {[#"../bdd.rs" 52 8 52 128] forall i : uint64 . inv'5 i
       -> Map.get (shallow_model'1 ( ^ self)) i
      = (if i = deep_model'1 key then Core_Option_Option_Type.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  let rec true'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 476 22 476 26] inv'0 self}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 475 14 475 46] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[#"../bdd.rs" 474 4 474 44] forall v : Map.map uint64 bool . interp'0 result v}
      {[#"../bdd.rs" 473 14 473 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 472 14 472 26] grows'0 self}
      (! return' {result}) ]
    
  let rec false'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 484 23 484 27] inv'0 self}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 483 14 483 46] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp'0 result v}
      {[#"../bdd.rs" 481 14 481 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 480 14 480 26] grows'0 self}
      (! return' {result}) ]
    
  let rec node'0 (self:borrowed (Bdd_Context_Type.t_context)) (x:uint64) (childt:Bdd_Bdd_Type.t_bdd) (childf:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 465 17 465 21] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar'0 childt
    /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [#"../bdd.rs" 459 15 459 40] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [#"../bdd.rs" 458 15 458 40] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar'0 result}
      {[#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[#"../bdd.rs" 462 14 462 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 461 14 461 26] grows'0 self}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  function deep_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  let rec get'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (key:Bdd_Bdd_Type.t_bdd) (return'  (ret:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))= {[@expl:precondition] [#"../bdd.rs" 63 37 63 40] inv'2 key}
    any
    [ return' (result:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 63 52 63 65] inv'3 result}
      {[#"../bdd.rs" 58 18 61 9] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
  use prelude.Snapshot
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  let rec not' (self:borrowed (Bdd_Context_Type.t_context)) (x:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 503 20 503 24] inv'0 self}
    {[#"../bdd.rs" 497 15 497 35] is_valid_bdd'0 ( * self) x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x ] s1
      | s1 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rnot_memo'0} {_13}
              (fun (_ret':Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = any
        [ br0 -> {_10 = Core_Option_Option_Type.C_None } (! bb4)
        | br1 (a:Bdd_Bdd_Type.t_bdd)-> {_10 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb4 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {x}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            any
            [ br0 -> {r0'0 = Bdd_Node_Type.C_False } (! bb7)
            | br1 -> {r0'0 = Bdd_Node_Type.C_True } (! bb6)
            | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {r0'0 = Bdd_Node_Type.C_If a b c} (! bb8) ]
            ) ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = {[#"../bdd.rs" 507 22 507 26] false} any ]
      
    | bb8 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {x}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            Bdd_Node_Type.if' {r0'0}
              (fun (rv'0:uint64) (rchildt'0:Bdd_Bdd_Type.t_bdd) (rchildf'0:Bdd_Bdd_Type.t_bdd) ->  [ &v <- rv'0 ] s1))
      | s1 = Bdd_Bdd_Type.t_bdd {x}
          (fun (r0'1:Bdd_Node_Type.t_node) (r1'1:uint64) ->
            Bdd_Node_Type.if' {r0'1}
              (fun (rv'1:uint64) (rchildt'1:Bdd_Bdd_Type.t_bdd) (rchildf'1:Bdd_Bdd_Type.t_bdd) ->
                 [ &childt <- rchildt'1 ] 
                s2))
      | s2 = Bdd_Bdd_Type.t_bdd {x}
          (fun (r0'2:Bdd_Node_Type.t_node) (r1'2:uint64) ->
            Bdd_Node_Type.if' {r0'2}
              (fun (rv'2:uint64) (rchildt'2:Bdd_Bdd_Type.t_bdd) (rchildf'2:Bdd_Bdd_Type.t_bdd) ->
                 [ &childf <- rchildf'2 ] 
                s3))
      | s3 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_25 <- _ret' ] 
             [ &self <- { self with current = ( ^ _25) ; } ] 
            s4)
      | s4 = -{inv'1 ( ^ _25)}- s5
      | s5 = not' {_25} {childt} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &childt1 <- _ret' ] s6)
      | s6 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = ( ^ _28) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _28)}- s2
      | s2 = not' {_28} {childf} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &childf1 <- _ret' ] s3)
      | s3 = bb14 ]
      
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = ( ^ _30) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _30)}- s2
      | s2 = node'0 {_30} {v} {childt1} {childf1} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb15 ]
      
    | bb15 = s0 [ s0 = bb16 ] 
    | bb6 = s0 [ s0 = bb9 ] 
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_19 <- _ret' ] 
             [ &self <- { self with current = ( ^ _19) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _19)}- s2
      | s2 = false'0 {_19} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = s0 [ s0 = bb16 ] 
    | bb7 = s0 [ s0 = bb11 ] 
    | bb11 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_20 <- _ret' ] 
             [ &self <- { self with current = ( ^ _20) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _20)}- s2
      | s2 = true'0 {_20} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0 [ s0 = bb16 ] 
    | bb16 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)>
              {rnot_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 4}
              (fun (_ret':borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) ->
                 [ &_35 <- _ret' ] 
                Bdd_Context_Type.t_context { * self}
                  (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 ( ^ _35) l_and_memo'0 l_cnt'0 : Bdd_Context_Type.t_context) ; } ]
                    
                    s1)))
      | s1 = add'0 {_35} {x} {r1} (fun (_ret':()) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb18 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <Bdd_Bdd_Type.t_bdd> {_10}
          (fun (r0'0:Bdd_Bdd_Type.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb18 ]
      
    | bb18 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & x : Bdd_Bdd_Type.t_bdd = x
    | & _10 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) = any_l () : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    | & _13 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & r : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & r1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _19 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _20 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & v : uint64 = any_l () : uint64
    | & childt : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childt1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _25 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & childf1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _28 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _30 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _34 : () = any_l () : ()
    | & _35 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) = any_l () : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 501 14 501 47] leastvar'0 x
      <= leastvar'0 result}
      {[@expl:postcondition] [#"../bdd.rs" 500 4 500 60] forall v : Map.map uint64 bool . interp'0 result v
      = (not interp'0 x v)}
      {[@expl:postcondition] [#"../bdd.rs" 499 14 499 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 498 14 498 26] grows'0 self}
      (! return' {result}) ]
    
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
  function any_l (_ : 'b) : 'a
  let rec less (input:t_ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} {false} any ]
    
  let rec equal (input:t_ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} {false} any ]
    
  let rec greater (input:t_ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} {false} any ]
    
end
module Bdd_Impl11_And
  use prelude.UInt64
  predicate invariant'6 (self : (uint64, uint64)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'6 (self:(uint64, uint64)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : (uint64, uint64))
  let rec inv'6 (_x:(uint64, uint64)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : (uint64, uint64) . inv'6 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant'5 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'5 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'5 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : Bdd_Bdd_Type.t_bdd . inv'5 x = true
  predicate invariant'4 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'4 (self:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd))
  let rec inv'4 (_x:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) . inv'4 x = true
  use prelude.Int
  function eq_cmp'0 (_1 : int) (_2 : int) : ()
  let rec eq_cmp'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = eq_cmp'0 _1 _2} (! return' {result}) ]
    
  function antisym2'0 (_1 : int) (_2 : int) : ()
  let rec antisym2'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = antisym2'0 _1 _2} (! return' {result}) ]
    
  function antisym1'0 (_1 : int) (_2 : int) : ()
  let rec antisym1'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = antisym1'0 _1 _2} (! return' {result}) ]
    
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function trans'0 (_1 : int) (_2 : int) (_3 : int) (_4 : Core_Cmp_Ordering_Type.t_ordering) : ()
  let rec trans'0 (_1:int) (_2:int) (_3:int) (_4:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= any
    [ return' (result:())-> {result = trans'0 _1 _2 _3 _4} (! return' {result}) ]
    
  function refl'0 (_1 : int) : ()
  let rec refl'0 (_1:int) (return'  (ret:()))= any [ return' (result:())-> {result = refl'0 _1} (! return' {result}) ] 
  function cmp_gt_log'0 (_1 : int) (_2 : int) : ()
  let rec cmp_gt_log'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = cmp_gt_log'0 _1 _2} (! return' {result}) ]
    
  function cmp_ge_log'0 (_1 : int) (_2 : int) : ()
  let rec cmp_ge_log'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = cmp_ge_log'0 _1 _2} (! return' {result}) ]
    
  function cmp_lt_log'0 (_1 : int) (_2 : int) : ()
  let rec cmp_lt_log'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = cmp_lt_log'0 _1 _2} (! return' {result}) ]
    
  function cmp_le_log'0 (_1 : int) (_2 : int) : ()
  let rec cmp_le_log'0 (_1:int) (_2:int) (return'  (ret:()))= any
    [ return' (result:())-> {result = cmp_le_log'0 _1 _2} (! return' {result}) ]
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'3 (self : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'3 (self:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
  let rec inv'3 (_x:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) . inv'3 x = true
  predicate invariant'2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd))
  let rec inv'2 (_x:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) . inv'2 x = true
  use map.Map
  use Bdd_Hashmap_MyHashMap_Type as Bdd_Hashmap_MyHashMap_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  use Bdd_Node_Type as Bdd_Node_Type
  use prelude.Borrow
  use map.Map
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'1 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'1 self}
      (! return' {result}) ]
    
  use Bdd_Context_Type as Bdd_Context_Type
  use map.Map
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'7 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map uint64 (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'7 self}
      (! return' {result}) ]
    
  use prelude.Int
  use prelude.UInt64
  function shallow_model'5 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] UInt64.to_int self
  let rec shallow_model'5 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = shallow_model'5 self} (! return' {result}) ]
    
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 241 12 245 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v _ _) _ -> shallow_model'5 v
      end
  let rec leastvar'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = leastvar'0 self} (! return' {result}) ]
    
  use map.Map
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd_Bdd_Type.t_bdd) (vars : Map.map uint64 bool) : bool =
    [#"../bdd.rs" 211 12 218 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> true
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> false
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  let rec interp'0 (self:Bdd_Bdd_Type.t_bdd) (vars:Map.map uint64 bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = interp'0 self vars} (! return' {result}) ]
    
  use map.Map
  function deep_model'4 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'4 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'4 self} (! return' {result}) ]
    
  function shallow_model'6 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'4 self
  let rec shallow_model'6 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'6 self} (! return' {result}) ]
    
  function shallow_model'4 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'6 self
  let rec shallow_model'4 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'4 self} (! return' {result}) ]
    
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) : Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
  let rec shallow_model'3 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (Bdd_NodeLog_Type.t_nodelog) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'3 self}
      (! return' {result}) ]
    
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Bdd_Context_Type.t_context) (b : Bdd_Bdd_Type.t_bdd) =
    [#"../bdd.rs" 311 12 311 47] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Core_Option_Option_Type.C_Some b
  let rec is_valid_bdd'0 (self:Bdd_Context_Type.t_context) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_bdd'0 self b} (! return' {result}) ]
    
  use map.Map
  use prelude.Snapshot
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Bdd_Context_Type.t_context) (n : Bdd_Node_Type.t_node) =
    [#"../bdd.rs" 318 12 327 13] match n with
      | Bdd_Node_Type.C_True -> true
      | Bdd_Node_Type.C_False -> true
      | Bdd_Node_Type.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  let rec is_valid_node'0 (self:Bdd_Context_Type.t_context) (n:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_valid_node'0 self n} (! return' {result}) ]
    
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Bdd_Context_Type.t_context) =
    [#"../bdd.rs" 264 12 288 19] (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Core_Option_Option_Type.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Core_Option_Option_Type.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'7 (Bdd_Context_Type.context_not_memo self)) bm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'1 (Bdd_Context_Type.context_and_memo self)) abm with
      | Core_Option_Option_Type.C_None -> true
      | Core_Option_Option_Type.C_Some n -> let a = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd_Bdd_Type.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  let rec invariant'1 (self:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Context_Type.t_context)
  let rec inv'1 (_x:Bdd_Context_Type.t_context) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Context_Type.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Bdd_Context_Type.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  predicate invariant'0 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : borrowed (Bdd_Context_Type.t_context))
  let rec inv'0 (_x:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : borrowed (Bdd_Context_Type.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd_Bdd_Type.t_bdd) : int =
    [#"../bdd.rs" 226 12 234 13] match self with
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_True) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_False) _ -> 0
      | Bdd_Bdd_Type.C_Bdd (Bdd_Node_Type.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1
      + ht
      + hf
      end
  let rec size'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:int))= any
    [ return' (result:int)-> {result = size'0 self} (! return' {result}) ]
    
  axiom size'0_spec : forall self : Bdd_Bdd_Type.t_bdd . [#"../bdd.rs" 223 14 223 25] size'0 self >= 0
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../bdd.rs" 297 8 304 9] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : Bdd_NodeLog_Type.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Core_Option_Option_Type.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Core_Option_Option_Type.C_Some b
      | Core_Option_Option_Type.C_None -> true
      end)
  let rec grows'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = grows'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  function shallow_model'2 (self : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 31] shallow_model'1 ( * self)
  let rec shallow_model'2 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'2 self}
      (! return' {result}) ]
    
  function deep_model'3 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'3 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'3 self} (! return' {result}) ]
    
  function deep_model'2 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model'3 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  let rec deep_model'2 (self:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:(uint64, uint64)))= any
    [ return' (result:(uint64, uint64))-> {result = deep_model'2 self} (! return' {result}) ]
    
  let rec add'0 (self:borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) (key:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (val':Bdd_Bdd_Type.t_bdd) (return'  (ret:()))= {[@expl:precondition] [#"../bdd.rs" 54 38 54 41] inv'5 val'}
    {[@expl:precondition] [#"../bdd.rs" 54 30 54 33] inv'4 key}
    any
    [ return' (result:())-> {[#"../bdd.rs" 52 8 52 128] forall i : (uint64, uint64) . inv'6 i
       -> Map.get (shallow_model'1 ( ^ self)) i
      = (if i = deep_model'2 key then Core_Option_Option_Type.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  let rec false'0 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 484 23 484 27] inv'0 self}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 483 14 483 46] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[#"../bdd.rs" 482 4 482 45] forall v : Map.map uint64 bool . not interp'0 result v}
      {[#"../bdd.rs" 481 14 481 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 480 14 480 26] grows'0 self}
      (! return' {result}) ]
    
  let rec node'0 (self:borrowed (Bdd_Context_Type.t_context)) (x:uint64) (childt:Bdd_Bdd_Type.t_bdd) (childf:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[@expl:precondition] [#"../bdd.rs" 465 17 465 21] inv'0 self}
    {[@expl:precondition] [#"../bdd.rs" 460 15 460 63] UInt64.to_int x < leastvar'0 childt
    /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [#"../bdd.rs" 459 15 459 40] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [#"../bdd.rs" 458 15 458 40] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[#"../bdd.rs" 464 14 464 37] UInt64.to_int x <= leastvar'0 result}
      {[#"../bdd.rs" 463 4 463 106] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[#"../bdd.rs" 462 14 462 42] is_valid_bdd'0 ( ^ self) result}
      {[#"../bdd.rs" 461 14 461 26] grows'0 self}
      (! return' {result}) ]
    
  function cmp_log'0 (self : int) (o : int) : Core_Cmp_Ordering_Type.t_ordering =
    [#"../../../../creusot-contracts/src/logic/ord.rs" 140 16 146 17] if self < o then
      Core_Cmp_Ordering_Type.C_Less
    else
      if self = o then Core_Cmp_Ordering_Type.C_Equal else Core_Cmp_Ordering_Type.C_Greater
    
  let rec cmp_log'0 (self:int) (o:int) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self o} (! return' {result}) ]
    
  function deep_model'1 (self : uint64) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UInt64.to_int self
  let rec deep_model'1 (self:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = deep_model'1 self} (! return' {result}) ]
    
  let rec cmp'0 (self:uint64) (other:uint64) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85] result
      = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  predicate resolve'4 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'4 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'2 (self : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'4 (let (a, _) = self in a)
    /\ resolve'4 (let (_, a) = self in a)
  let rec resolve'2 (self:(Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Bdd_Context_Type.t_context)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Bdd_Context_Type.t_context)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'3 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'3 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'3 (let (a, _) = self in a)
    /\ resolve'3 (let (_, a) = self in a)
  let rec resolve'0 (self:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  function deep_model'0 (self : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) : (uint64, uint64) =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'2 self
  let rec deep_model'0 (self:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:(uint64, uint64)))= any
    [ return' (result:(uint64, uint64))-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) : Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (return'  (ret:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))))= any
    [ return' (result:Map.map (uint64, uint64) (Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))-> {result
      = shallow_model'0 self}
      (! return' {result}) ]
    
  let rec get'0 (self:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (key:(Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)) (return'  (ret:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)))= {[@expl:precondition] [#"../bdd.rs" 63 37 63 40] inv'2 key}
    any
    [ return' (result:Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd))-> {[#"../bdd.rs" 63 52 63 65] inv'3 result}
      {[#"../bdd.rs" 58 18 61 9] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key)
        = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
  use prelude.Snapshot
  use Bdd_Bumpalo_Bump_Type as Bdd_Bumpalo_Bump_Type
  let rec and (self:borrowed (Bdd_Context_Type.t_context)) (a:Bdd_Bdd_Type.t_bdd) (b:Bdd_Bdd_Type.t_bdd) (return'  (ret:Bdd_Bdd_Type.t_bdd))= {[#"../bdd.rs" 527 20 527 24] inv'0 self}
    {[#"../bdd.rs" 521 15 521 35] is_valid_bdd'0 ( * self) b}
    {[#"../bdd.rs" 520 15 520 35] is_valid_bdd'0 ( * self) a}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- (a, b) ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rand_memo'0} {_15}
              (fun (_ret':Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)) ->  [ &_12 <- _ret' ] s3))
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = any
        [ br0 -> {_12 = Core_Option_Option_Type.C_None } (! bb4)
        | br1 (a:Bdd_Bdd_Type.t_bdd)-> {_12 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb4 = s0
      [ s0 = Bdd_Bdd_Type.t_bdd {a}
          (fun (r0'0:Bdd_Node_Type.t_node) (r1'0:uint64) ->
            Bdd_Bdd_Type.t_bdd {b} (fun (r0'1:Bdd_Node_Type.t_node) (r1'1:uint64) ->  [ &_23 <- (r0'0, r0'1) ] s1))
      | s1 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_False } (! bb6)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_True } (! bb12)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (r'0, _) = _23 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb6) ]
         ]
      
    | bb6 = s0
      [ s0 = any
        [ br0 -> {(let (_, r'0) = _23 in r'0) = Bdd_Node_Type.C_False } (! bb7)
        | br1 -> {(let (_, r'0) = _23 in r'0) = Bdd_Node_Type.C_True } (! bb11)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (_, r'0) = _23 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb7) ]
         ]
      
    | bb7 = s0
      [ s0 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_False } (! bb13)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_True } (! bb8)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (r'0, _) = _23 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb8) ]
         ]
      
    | bb8 = s0
      [ s0 = any
        [ br0 -> {(let (_, r'0) = _23 in r'0) = Bdd_Node_Type.C_False } (! bb13)
        | br1 -> {(let (_, r'0) = _23 in r'0) = Bdd_Node_Type.C_True } (! bb5)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (_, r'0) = _23 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb9) ]
         ]
      
    | bb9 = s0
      [ s0 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_False } (! bb5)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Bdd_Node_Type.C_True } (! bb5)
        | br2 (a:uint64) (b:Bdd_Bdd_Type.t_bdd) (c:Bdd_Bdd_Type.t_bdd)-> {(let (r'0, _) = _23 in r'0)
          = Bdd_Node_Type.C_If a b c}
          (! bb10) ]
         ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 = -{resolve'2 _23}- s3
      | s3 = {[#"../bdd.rs" 531 22 531 34] false} any ]
      
    | bb10 = s0
      [ s0 = Bdd_Node_Type.if' {let (r'0, _) = _23 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd_Bdd_Type.t_bdd) (rchildf'0:Bdd_Bdd_Type.t_bdd) ->  [ &va <- rv'0 ] s1)
      | s1 = Bdd_Node_Type.if' {let (r'1, _) = _23 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd_Bdd_Type.t_bdd) (rchildf'1:Bdd_Bdd_Type.t_bdd) ->
             [ &childta <- rchildt'1 ] 
            s2)
      | s2 = Bdd_Node_Type.if' {let (r'2, _) = _23 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd_Bdd_Type.t_bdd) (rchildf'2:Bdd_Bdd_Type.t_bdd) ->
             [ &childfa <- rchildf'2 ] 
            s3)
      | s3 = Bdd_Node_Type.if' {let (_, r'3) = _23 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd_Bdd_Type.t_bdd) (rchildf'3:Bdd_Bdd_Type.t_bdd) ->  [ &vb <- rv'3 ] s4)
      | s4 = Bdd_Node_Type.if' {let (_, r'4) = _23 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd_Bdd_Type.t_bdd) (rchildf'4:Bdd_Bdd_Type.t_bdd) ->
             [ &childtb <- rchildt'4 ] 
            s5)
      | s5 = Bdd_Node_Type.if' {let (_, r'5) = _23 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd_Bdd_Type.t_bdd) (rchildf'5:Bdd_Bdd_Type.t_bdd) ->
             [ &childfb <- rchildf'5 ] 
            s6)
      | s6 = -{resolve'2 _23}- s7
      | s7 =  [ &_45 <- vb ] s8
      | s8 = cmp'0 {va} {_45} (fun (_ret':Core_Cmp_Ordering_Type.t_ordering) ->  [ &_42 <- _ret' ] s9)
      | s9 = bb18 ]
      
    | bb18 = s0
      [ s0 = any
        [ br0 -> {_42 = Core_Cmp_Ordering_Type.C_Less } (! bb21)
        | br1 -> {_42 = Core_Cmp_Ordering_Type.C_Equal } (! bb22)
        | br2 -> {_42 = Core_Cmp_Ordering_Type.C_Greater } (! bb20) ]
         ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 = {[#"../bdd.rs" 540 22 540 33] false} any ]
      
    | bb20 = s0 [ s0 = bb23 ] 
    | bb23 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_49 <- _ret' ] 
             [ &self <- { self with current = ( ^ _49) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _49)}- s3
      | s3 = and {_49} {a} {childtb} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_48 <- _ret' ] s4)
      | s4 = bb24 ]
      
    | bb24 = s0
      [ s0 =  [ &childt <- _48 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_48 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_53 <- _ret' ] 
             [ &self <- { self with current = ( ^ _53) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _53)}- s3
      | s3 = and {_53} {a} {childfb} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_52 <- _ret' ] s4)
      | s4 = bb25 ]
      
    | bb25 = s0
      [ s0 =  [ &childf <- _52 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_52 <- _any ] s1) ] )
      | s1 =  [ &_41 <- [#"../bdd.rs" 541 31 545 21] () ] s2
      | s2 = bb31 ]
      
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_67 <- _ret' ] 
             [ &self <- { self with current = ( ^ _67) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _67)}- s3
      | s3 = and {_67} {childta} {childtb} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_66 <- _ret' ] s4)
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_66 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_71 <- _ret' ] 
             [ &self <- { self with current = ( ^ _71) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _71)}- s3
      | s3 = and {_71} {childfa} {childfb} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_70 <- _ret' ] s4)
      | s4 = bb30 ]
      
    | bb30 = s0
      [ s0 =  [ &childf <- _70 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_70 <- _any ] s1) ] )
      | s1 =  [ &_41 <- [#"../bdd.rs" 551 29 555 21] () ] s2
      | s2 = bb31 ]
      
    | bb21 = s0 [ s0 = bb26 ] 
    | bb26 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_58 <- _ret' ] 
             [ &self <- { self with current = ( ^ _58) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _58)}- s3
      | s3 = and {_58} {childta} {b} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_57 <- _ret' ] s4)
      | s4 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_57 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_62 <- _ret' ] 
             [ &self <- { self with current = ( ^ _62) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _62)}- s3
      | s3 = and {_62} {childfa} {b} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &_61 <- _ret' ] s4)
      | s4 = bb28 ]
      
    | bb28 = s0
      [ s0 =  [ &childf <- _61 ] (any [ any_ (_any:Bdd_Bdd_Type.t_bdd)-> (!  [ &_61 <- _any ] s1) ] )
      | s1 =  [ &_41 <- [#"../bdd.rs" 546 28 550 21] () ] s2
      | s2 = bb31 ]
      
    | bb31 = s0
      [ s0 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_74 <- _ret' ] 
             [ &self <- { self with current = ( ^ _74) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _74)}- s2
      | s2 = node'0 {_74} {v} {childt} {childf} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb32 ]
      
    | bb32 = s0 [ s0 = bb33 ] 
    | bb13 = s0 [ s0 = bb16 ] 
    | bb16 = s0
      [ s0 = -{resolve'2 _23}- s1
      | s1 = Borrow.borrow_mut <Bdd_Context_Type.t_context> { * self}
          (fun (_ret':borrowed (Bdd_Context_Type.t_context)) ->
             [ &_31 <- _ret' ] 
             [ &self <- { self with current = ( ^ _31) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _31)}- s3
      | s3 = false'0 {_31} (fun (_ret':Bdd_Bdd_Type.t_bdd) ->  [ &r1 <- _ret' ] s4)
      | s4 = bb17 ]
      
    | bb17 = s0 [ s0 = bb33 ] 
    | bb11 = s0 [ s0 = bb15 ] 
    | bb15 = s0 [ s0 = -{resolve'2 _23}- s1 | s1 =  [ &r1 <- a ] s2 | s2 = bb33 ] 
    | bb12 = s0 [ s0 = bb14 ] 
    | bb14 = s0 [ s0 = -{resolve'2 _23}- s1 | s1 =  [ &r1 <- b ] s2 | s2 = bb33 ] 
    | bb33 = s0
      [ s0 = Bdd_Context_Type.t_context { * self}
          (fun (ralloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (rhashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (rnot_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rand_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)>
              {rand_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 5}
              (fun (_ret':borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))) ->
                 [ &_79 <- _ret' ] 
                Bdd_Context_Type.t_context { * self}
                  (fun (l_alloc'0:Bdd_Bumpalo_Bump_Type.t_bump) (l_hashcons'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Node_Type.t_node) (Bdd_Bdd_Type.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Bdd_Node_Type.t_node))) (l_not_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_and_memo'0:Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = (Bdd_Context_Type.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 ( ^ _79) l_cnt'0 : Bdd_Context_Type.t_context) ; } ]
                    
                    s1)))
      | s1 =  [ &_80 <- (a, b) ] s2
      | s2 = add'0 {_79} {_80} {r1} (fun (_ret':()) ->  [ &_78 <- _ret' ] s3)
      | s3 = bb34 ]
      
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'1 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb35 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <Bdd_Bdd_Type.t_bdd> {_12}
          (fun (r0'0:Bdd_Bdd_Type.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb35 ]
      
    | bb35 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & self : borrowed (Bdd_Context_Type.t_context) = self
    | & a : Bdd_Bdd_Type.t_bdd = a
    | & b : Bdd_Bdd_Type.t_bdd = b
    | & _12 : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd) = any_l () : Core_Option_Option_Type.t_option (Bdd_Bdd_Type.t_bdd)
    | & _15 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) = any_l () : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)
    | & _16 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) = any_l () : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd)
    | & r : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & r1 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _23 : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node) = any_l () : (Bdd_Node_Type.t_node, Bdd_Node_Type.t_node)
    | & _31 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & va : uint64 = any_l () : uint64
    | & childta : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childfa : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & vb : uint64 = any_l () : uint64
    | & childtb : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childfb : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & v : uint64 = any_l () : uint64
    | & childt : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & childf : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _41 : () = any_l () : ()
    | & _42 : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _45 : uint64 = any_l () : uint64
    | & _48 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _49 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _52 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _53 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _57 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _58 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _61 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _62 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _66 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _67 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _70 : Bdd_Bdd_Type.t_bdd = any_l () : Bdd_Bdd_Type.t_bdd
    | & _71 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _74 : borrowed (Bdd_Context_Type.t_context) = any_l () : borrowed (Bdd_Context_Type.t_context)
    | & _78 : () = any_l () : ()
    | & _79 : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd)) = any_l () : borrowed (Bdd_Hashmap_MyHashMap_Type.t_myhashmap (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) (Bdd_Bdd_Type.t_bdd))
    | & _80 : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) = any_l () : (Bdd_Bdd_Type.t_bdd, Bdd_Bdd_Type.t_bdd) ]
    
    [ return' (result:Bdd_Bdd_Type.t_bdd)-> {[@expl:postcondition] [#"../bdd.rs" 525 14 525 84] leastvar'0 a
      <= leastvar'0 result
      \/ leastvar'0 b <= leastvar'0 result}
      {[@expl:postcondition] [#"../bdd.rs" 524 4 524 76] forall v : Map.map uint64 bool . interp'0 result v
      = (interp'0 a v /\ interp'0 b v)}
      {[@expl:postcondition] [#"../bdd.rs" 523 14 523 42] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [#"../bdd.rs" 522 14 522 26] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Hashmap_Impl0
  type k
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  type v
  predicate invariant'0 (self : (u, v))
  let rec invariant'0 (self:(u, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : (u, v))
  let rec inv'0 (_x:(u, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  use prelude.UInt64
  use prelude.UInt64
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  type deep_model_ty'1
  function hash_log'2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'1) : int
  let rec hash_log'2 (_1:deep_model_ty'1) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'2 _1} (! return' {result}) ]
    
  type deep_model_ty'0
  function hash_log'1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'0) : int
  let rec hash_log'1 (_1:deep_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'1 _1} (! return' {result}) ]
    
  function hash_log'0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [#"../bdd.rs" 83 24 83 84] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  let rec hash_log'0 (x:(deep_model_ty'0, deep_model_ty'1)) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  function deep_model'3 (self : v) : deep_model_ty'1
  let rec deep_model'3 (self:v) (return'  (ret:deep_model_ty'1))= any
    [ return' (result:deep_model_ty'1)-> {result = deep_model'3 self} (! return' {result}) ]
    
  function deep_model'2 (self : u) : deep_model_ty'0
  let rec deep_model'2 (self:u) (return'  (ret:deep_model_ty'0))= any
    [ return' (result:deep_model_ty'0)-> {result = deep_model'2 self} (! return' {result}) ]
    
  function deep_model'1 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [#"../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57] (deep_model'2 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  let rec deep_model'1 (self:(u, v)) (return'  (ret:(deep_model_ty'0, deep_model_ty'1)))= any
    [ return' (result:(deep_model_ty'0, deep_model_ty'1))-> {result = deep_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:(u, v)) (return'  (ret:(deep_model_ty'0, deep_model_ty'1)))= any
    [ return' (result:(deep_model_ty'0, deep_model_ty'1))-> {result = deep_model'0 self} (! return' {result}) ]
    
  goal hash_refn : [#"../bdd.rs" 76 8 76 29] forall self : (u, v) . inv'0 self
   -> inv'0 self
  /\ (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl1
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant'0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Node_Type.t_node)
  let rec inv'0 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Node_Type.t_node . inv'0 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.Int
  constant max'0 : uint64 = (18446744073709551615 : uint64)
  use prelude.UInt64
  function hash_log'0 [#"../bdd.rs" 128 4 128 44] (x : Bdd_NodeLog_Type.t_nodelog) : int =
    [#"../bdd.rs" 130 12 135 13] match x with
      | Bdd_NodeLog_Type.C_False -> 1
      | Bdd_NodeLog_Type.C_True -> 2
      | Bdd_NodeLog_Type.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  let rec hash_log'0 (x:Bdd_NodeLog_Type.t_nodelog) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 176 20 176 37] deep_model'1 self
  let rec shallow_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  goal hash_refn : [#"../bdd.rs" 116 4 116 25] forall self : Bdd_Node_Type.t_node . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl2
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant'0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'0 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Bdd_Type.t_bdd . inv'0 x = true
  use prelude.UInt64
  use prelude.Int
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  use prelude.UInt64
  function hash_log'0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [#"../bdd.rs" 149 8 149 24] UInt64.to_int x
  let rec hash_log'0 (x:uint64) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'1 self
  let rec shallow_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  goal hash_refn : [#"../bdd.rs" 142 4 142 25] forall self : Bdd_Bdd_Type.t_bdd . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl12
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 90 9 90 11] true
end
module Bdd_Impl17
  goal assert_receiver_is_total_eq_refn : [#"../bdd.rs" 104 15 104 17] true
end
module Bdd_Impl13
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant'0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Node_Type.t_node)
  let rec inv'0 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Node_Type.t_node . inv'0 x = true
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  use Bdd_NodeLog_Type as Bdd_NodeLog_Type
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../bdd.rs" 160 12 164 13] match self with
      | Bdd_Node_Type.C_False -> Bdd_NodeLog_Type.C_False
      | Bdd_Node_Type.C_True -> Bdd_NodeLog_Type.C_True
      | Bdd_Node_Type.C_If v childt childf -> Bdd_NodeLog_Type.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  let rec deep_model'1 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : Bdd_Node_Type.t_node) : Bdd_NodeLog_Type.t_nodelog =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Node_Type.t_node) (return'  (ret:Bdd_NodeLog_Type.t_nodelog))= any
    [ return' (result:Bdd_NodeLog_Type.t_nodelog)-> {result = deep_model'0 self} (! return' {result}) ]
    
  goal eq_refn : [#"../bdd.rs" 90 13 90 22] forall self : Bdd_Node_Type.t_node . forall other : Bdd_Node_Type.t_node . inv'0 other
  /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl7
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant'0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'0 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Bdd_Type.t_bdd . inv'0 x = true
  use prelude.UInt64
  use prelude.Int
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 186 20 186 26] Bdd_Bdd_Type.bdd_1 self
  let rec deep_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'1 self} (! return' {result}) ]
    
  use prelude.Borrow
  function deep_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 28] deep_model'1 self
  let rec deep_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = deep_model'0 self} (! return' {result}) ]
    
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../bdd.rs" 196 20 196 37] deep_model'1 self
  let rec shallow_model'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'1 self} (! return' {result}) ]
    
  function shallow_model'0 (self : Bdd_Bdd_Type.t_bdd) : uint64 =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 31] shallow_model'1 self
  let rec shallow_model'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {result = shallow_model'0 self} (! return' {result}) ]
    
  goal eq_refn : [#"../bdd.rs" 202 4 202 34] forall self : Bdd_Bdd_Type.t_bdd . forall other : Bdd_Bdd_Type.t_bdd . inv'0 other
  /\ inv'0 self
   -> (forall result : bool . result = (shallow_model'0 self = shallow_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl14
  use Bdd_Node_Type as Bdd_Node_Type
  predicate invariant'1 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Node_Type.t_node)
  let rec inv'1 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Node_Type.t_node . inv'1 x = true
  predicate invariant'0 (self : Bdd_Node_Type.t_node) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Node_Type.t_node)
  let rec inv'0 (_x:Bdd_Node_Type.t_node) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Node_Type.t_node . inv'0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../bdd.rs" 90 24 90 29] forall self : Bdd_Node_Type.t_node . inv'0 self
   -> (forall result : Bdd_Node_Type.t_node . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl0
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  predicate invariant'1 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'1 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Bdd_Bdd_Type.t_bdd . inv'1 x = true
  predicate invariant'0 (self : Bdd_Bdd_Type.t_bdd) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Bdd_Bdd_Type.t_bdd)
  let rec inv'0 (_x:Bdd_Bdd_Type.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Bdd_Bdd_Type.t_bdd . inv'0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../bdd.rs" 109 4 109 27] forall self : Bdd_Bdd_Type.t_bdd . inv'0 self
   -> (forall result : Bdd_Bdd_Type.t_bdd . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl15
  
end
module Bdd_Impl16
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
module Bdd_Impl9
  
end
