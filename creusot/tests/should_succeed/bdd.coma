module M_bdd__hashmap__qyi11648407051195780326__hash [#"bdd.rs" 79 8 79 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 80 66 80 68
  let%span sbdd1 = "bdd.rs" 79 17 79 21
  let%span sbdd2 = "bdd.rs" 78 18 78 62
  let%span sbdd3 = "bdd.rs" 35 17 35 21
  let%span sbdd4 = "bdd.rs" 34 18 34 62
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd14 = "bdd.rs" 86 24 86 84
  let%span stuples15 = "../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span sinvariant16 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_U'0
  
  predicate inv'4 (_1 : t_U'0)
  
  predicate invariant'1 (self : t_U'0) =
    [%#sinvariant16] inv'4 self
  
  predicate inv'1 (_1 : t_U'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_U'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  type t_DeepModelTy'0
  
  function deep_model'4 (self : t_U'0) : t_DeepModelTy'0
  
  function deep_model'1 (self : t_U'0) : t_DeepModelTy'0 =
    [%#smodel13] deep_model'4 self
  
  use prelude.prelude.Int
  
  function hash_log'1 [#"bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'0) : int
  
  use prelude.prelude.UInt64
  
  let rec hash'1 (self:t_U'0) (return'  (ret:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd3] inv'1 self}
    any
    [ return' (result:UInt64.t)-> {[%#sbdd4] UInt64.t'int result = hash_log'1 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  type t_V'0
  
  predicate inv'5 (_1 : t_V'0)
  
  predicate invariant'2 (self : t_V'0) =
    [%#sinvariant16] inv'5 self
  
  predicate inv'2 (_1 : t_V'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_V'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  type t_DeepModelTy'1
  
  function deep_model'5 (self : t_V'0) : t_DeepModelTy'1
  
  function deep_model'2 (self : t_V'0) : t_DeepModelTy'1 =
    [%#smodel13] deep_model'5 self
  
  function hash_log'2 [#"bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'1) : int
  
  let rec hash'2 (self:t_V'0) (return'  (ret:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd3] inv'2 self}
    any
    [ return' (result:UInt64.t)-> {[%#sbdd4] UInt64.t'int result = hash_log'2 (deep_model'2 self)}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (64 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  let rec wrapping_mul'0 (self:UInt64.t) (rhs:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#snum5] UInt64.t'int result
      = EuclideanDivision.mod (UInt64.t'int self
      * UInt64.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt64.t'int (v_MIN'0 : UInt64.t)}
      {[%#snum6] UInt64.t'int self * UInt64.t'int rhs >= UInt64.t'int (v_MIN'0 : UInt64.t)
      /\ UInt64.t'int self * UInt64.t'int rhs <= UInt64.t'int (v_MAX'0 : UInt64.t)
       -> UInt64.t'int result = UInt64.t'int self * UInt64.t'int rhs}
      {[%#snum7] UInt64.t'int self * UInt64.t'int rhs < UInt64.t'int (v_MIN'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self * UInt64.t'int rhs
      + k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      {[%#snum8] UInt64.t'int self * UInt64.t'int rhs > UInt64.t'int (v_MAX'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self * UInt64.t'int rhs
      - k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:UInt64.t) (rhs:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#snum9] UInt64.t'int result
      = EuclideanDivision.mod (UInt64.t'int self
      + UInt64.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt64.t'int (v_MIN'0 : UInt64.t)}
      {[%#snum10] UInt64.t'int self + UInt64.t'int rhs >= UInt64.t'int (v_MIN'0 : UInt64.t)
      /\ UInt64.t'int self + UInt64.t'int rhs <= UInt64.t'int (v_MAX'0 : UInt64.t)
       -> UInt64.t'int result = UInt64.t'int self + UInt64.t'int rhs}
      {[%#snum11] UInt64.t'int self + UInt64.t'int rhs < UInt64.t'int (v_MIN'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self + UInt64.t'int rhs
      + k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      {[%#snum12] UInt64.t'int self + UInt64.t'int rhs > UInt64.t'int (v_MAX'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self + UInt64.t'int rhs
      - k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  predicate inv'3 (_1 : (t_U'0, t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : (t_U'0, t_V'0) [inv'3 x] . inv'3 x
  = (let (x0, x1) = x in inv'4 x0 /\ inv'5 x1)
  
  predicate invariant'0 (self : (t_U'0, t_V'0)) =
    [%#sinvariant16] inv'3 self
  
  predicate inv'0 (_1 : (t_U'0, t_V'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (t_U'0, t_V'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  function deep_model'3 (self : (t_U'0, t_V'0)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#stuples15] (deep_model'4 (let (a, _) = self in a), deep_model'5 (let (_, a) = self in a))
  
  function deep_model'0 (self : (t_U'0, t_V'0)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#smodel13] deep_model'3 self
  
  function hash_log'0 [#"bdd.rs" 85 8 85 48] (x : (t_DeepModelTy'0, t_DeepModelTy'1)) : int =
    [%#sbdd14] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.t'int (v_MAX'0 : UInt64.t) + 1)
  
  meta "compute_max_steps" 1000000
  
  let rec hash'0 (self:(t_U'0, t_V'0)) (return'  (ret:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd1] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'1 {let (r'0, _) = self in r'0} (fun (_ret':UInt64.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = hash'2 {let (_, r'0) = self in r'0} (fun (_ret':UInt64.t) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = wrapping_mul'0 {_6} {[%#sbdd0] (17 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_5 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = wrapping_add'0 {_3} {_5} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = return' {_0} ]
    )
    [ & _0 : UInt64.t = any_l ()
    | & self : (t_U'0, t_V'0) = self
    | & _3 : UInt64.t = any_l ()
    | & _5 : UInt64.t = any_l ()
    | & _6 : UInt64.t = any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd2] UInt64.t'int result = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq [#"bdd.rs" 93 9 93 11] (* <Node<'arena> as std::cmp::Eq> *)
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq'0 (self:t_Node'0) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi4854841669736991510__eq [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "bdd.rs" 93 13 93 22
  let%span sbdd1 = "bdd.rs" 204 14 204 37
  let%span scmp2 = "../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span smodel3 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd5 = "bdd.rs" 163 12 167 13
  let%span sbdd6 = "bdd.rs" 199 20 199 37
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 54 32 54 37
  let%span sbdd8 = "bdd.rs" 189 20 189 26
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  let rec v_If'0 (input:t_Node'0) (ret  (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0))= any
    [ good (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0)-> {C_If'0 v childt childf = input}
      (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd'0, childf : t_Bdd'0 [C_If'0 v childt childf : t_Node'0] . C_If'0 v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  function deep_model'4 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd8] self.t_Bdd__1'0
  
  function view'1 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd6] deep_model'4 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel4] view'1 self
  
  let rec eq'1 (self:t_Bdd'0) (o:t_Bdd'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sbdd1] result = (view'0 self = view'0 o)} (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  function deep_model'3 (self : UInt64.t) : int =
    [%#snum7] UInt64.t'int self
  
  function deep_model'1 (self : UInt64.t) : int =
    [%#smodel3] deep_model'3 self
  
  let rec eq'2 (self:UInt64.t) (other:UInt64.t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#scmp2] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'2 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd5] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function deep_model'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel3] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'0 (self:t_Node'0) (rhs:t_Node'0) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- (self, rhs) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _4 in r'0) = C_False'0 } (! bb2)
        | br1 -> {(let (r'0, _) = _4 in r'0) = C_True'0 } (! bb4)
        | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (r'0, _) = _4 in r'0) = C_If'0 x0 x1 x2} (! bb6) ]
         ]
      
    | bb6 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = C_False'0 } (! bb25)
      | br1 -> {(let (_, r'0) = _4 in r'0) = C_True'0 } (! bb25)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (_, r'0) = _4 in r'0) = C_If'0 x0 x1 x2} (! bb7) ]
      
    | bb25 = bb1
    | bb7 = bb10
    | bb10 = s0
      [ s0 = v_If'0 {let (r'0, _) = _4 in r'0}
          (fun (rv'0:UInt64.t) (rchildt'0:t_Bdd'0) (rchildf'0:t_Bdd'0) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = v_If'0 {let (r'1, _) = _4 in r'1}
          (fun (rv'1:UInt64.t) (rchildt'1:t_Bdd'0) (rchildf'1:t_Bdd'0) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = v_If'0 {let (r'2, _) = _4 in r'2}
          (fun (rv'2:UInt64.t) (rchildt'2:t_Bdd'0) (rchildf'2:t_Bdd'0) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 = v_If'0 {let (_, r'3) = _4 in r'3}
          (fun (rv'3:UInt64.t) (rchildt'3:t_Bdd'0) (rchildf'3:t_Bdd'0) ->  [ &v_2 <- rv'3 ] s4)
      | s4 = v_If'0 {let (_, r'4) = _4 in r'4}
          (fun (rv'4:UInt64.t) (rchildt'4:t_Bdd'0) (rchildf'4:t_Bdd'0) ->  [ &childt_2 <- rchildt'4 ] s5)
      | s5 = v_If'0 {let (_, r'5) = _4 in r'5}
          (fun (rv'5:UInt64.t) (rchildt'5:t_Bdd'0) (rchildf'5:t_Bdd'0) ->  [ &childf_2 <- rchildf'5 ] s6)
      | s6 = eq'1 {childf_1} {childf_2} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s7)
      | s7 = bb11 ]
      
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq'1 {childt_1} {childt_2} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0 [ s0 = eq'2 {v_1} {v_2} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ] 
    | bb16 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb21 ] 
    | bb17 = bb20
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb4 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = C_False'0 } (! bb1)
      | br1 -> {(let (_, r'0) = _4 in r'0) = C_True'0 } (! bb5)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (_, r'0) = _4 in r'0) = C_If'0 x0 x1 x2} (! bb1) ]
      
    | bb5 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb2 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = C_False'0 } (! bb3)
      | br1 -> {(let (_, r'0) = _4 in r'0) = C_True'0 } (! bb1)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (_, r'0) = _4 in r'0) = C_If'0 x0 x1 x2} (! bb1) ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb22 ] 
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb22 = return' {_0} ]
    )
    [ & _0 : bool = any_l ()
    | & self : t_Node'0 = self
    | & rhs : t_Node'0 = rhs
    | & _4 : (t_Node'0, t_Node'0) = any_l ()
    | & v_1 : UInt64.t = any_l ()
    | & childt_1 : t_Bdd'0 = any_l ()
    | & childf_1 : t_Bdd'0 = any_l ()
    | & v_2 : UInt64.t = any_l ()
    | & childt_2 : t_Bdd'0 = any_l ()
    | & childf_2 : t_Bdd'0 = any_l ()
    | & _17 : bool = any_l ()
    | & _20 : bool = any_l ()
    | & _23 : bool = any_l () ]
    
    [ return' (result:bool)-> {[@expl:eq ensures] [%#sbdd0] result = (deep_model'0 self = deep_model'0 rhs)}
      (! return' {result}) ]
    
end
module M_bdd__qyi17981791245757283426__clone [#"bdd.rs" 93 24 93 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "bdd.rs" 93 24 93 29
  let%span sclone1 = "../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  let%span sbdd2 = "bdd.rs" 111 14 111 29
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  let rec v_If'0 (input:t_Node'0) (ret  (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0))= any
    [ good (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0)-> {C_If'0 v childt childf = input}
      (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd'0, childf : t_Bdd'0 [C_If'0 v childt childf : t_Node'0] . C_If'0 v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  let rec clone'1 (self:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#sclone1] result = self} (! return' {result}) ]
    
  
  let rec clone'2 (self:t_Bdd'0) (return'  (ret:t_Bdd'0))= any
    [ return' (result:t_Bdd'0)-> {[%#sbdd2] result = self} (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0 (self:t_Node'0) (return'  (ret:t_Node'0))= (! bb0
    [ bb0 = any
      [ br0 -> {self = C_False'0 } (! bb2)
      | br1 -> {self = C_True'0 } (! bb3)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {self = C_If'0 x0 x1 x2} (! bb4) ]
      
    | bb4 = s0
      [ s0 = v_If'0 {self} (fun (rv'0:UInt64.t) (rchildt'0:t_Bdd'0) (rchildf'0:t_Bdd'0) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = v_If'0 {self}
          (fun (rv'1:UInt64.t) (rchildt'1:t_Bdd'0) (rchildf'1:t_Bdd'0) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = v_If'0 {self}
          (fun (rv'2:UInt64.t) (rchildt'2:t_Bdd'0) (rchildf'2:t_Bdd'0) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone'1 {_9} (fun (_ret':UInt64.t) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1 | s1 = clone'2 {_12} (fun (_ret':t_Bdd'0) ->  [ &_10 <- _ret' ] s2) | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1 | s1 = clone'2 {_15} (fun (_ret':t_Bdd'0) ->  [ &_13 <- _ret' ] s2) | s2 = bb9 ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- C_If'0 _7 _10 _13 ] s1 | s1 = bb10 ] 
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- C_True'0 ] s1 | s1 = bb10 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- C_False'0 ] s1 | s1 = bb10 ] 
    | bb10 = return' {_0} ]
    )
    [ & _0 : t_Node'0 = any_l ()
    | & self : t_Node'0 = self
    | & v_1 : UInt64.t = any_l ()
    | & childt_1 : t_Bdd'0 = any_l ()
    | & childf_1 : t_Bdd'0 = any_l ()
    | & _7 : UInt64.t = any_l ()
    | & _9 : UInt64.t = any_l ()
    | & _10 : t_Bdd'0 = any_l ()
    | & _12 : t_Bdd'0 = any_l ()
    | & _13 : t_Bdd'0 = any_l ()
    | & _15 : t_Bdd'0 = any_l () ]
     [ return' (result:t_Node'0)-> {[@expl:clone ensures] [%#sbdd0] result = self} (! return' {result}) ] 
end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq [#"bdd.rs" 107 15 107 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq'0 (self:t_Bdd'0) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi2820858787824331484__clone [#"bdd.rs" 112 4 112 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "bdd.rs" 111 14 111 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0 (self:t_Bdd'0) (return'  (ret:t_Bdd'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Bdd'0 = any_l () | & self : t_Bdd'0 = self ] 
    [ return' (result:t_Bdd'0)-> {[@expl:clone ensures] [%#sbdd0] result = self} (! return' {result}) ]
    
end
module M_bdd__qyi699402059438633899__hash [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 124 53 124 54
  let%span sbdd1 = "bdd.rs" 124 92 124 93
  let%span sbdd2 = "bdd.rs" 122 20 122 21
  let%span sbdd3 = "bdd.rs" 121 21 121 22
  let%span sbdd4 = "bdd.rs" 118 14 118 46
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd14 = "bdd.rs" 133 12 138 13
  let%span sbdd15 = "bdd.rs" 179 20 179 37
  let%span sbdd16 = "bdd.rs" 163 12 167 13
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  let rec v_If'0 (input:t_Node'0) (ret  (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0))= any
    [ good (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0)-> {C_If'0 v childt childf = input}
      (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd'0, childf : t_Bdd'0 [C_If'0 v childt childf : t_Node'0] . C_If'0 v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (64 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  let rec wrapping_mul'0 (self:UInt64.t) (rhs:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#snum5] UInt64.t'int result
      = EuclideanDivision.mod (UInt64.t'int self
      * UInt64.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt64.t'int (v_MIN'0 : UInt64.t)}
      {[%#snum6] UInt64.t'int self * UInt64.t'int rhs >= UInt64.t'int (v_MIN'0 : UInt64.t)
      /\ UInt64.t'int self * UInt64.t'int rhs <= UInt64.t'int (v_MAX'0 : UInt64.t)
       -> UInt64.t'int result = UInt64.t'int self * UInt64.t'int rhs}
      {[%#snum7] UInt64.t'int self * UInt64.t'int rhs < UInt64.t'int (v_MIN'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self * UInt64.t'int rhs
      + k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      {[%#snum8] UInt64.t'int self * UInt64.t'int rhs > UInt64.t'int (v_MAX'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self * UInt64.t'int rhs
      - k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:UInt64.t) (rhs:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#snum9] UInt64.t'int result
      = EuclideanDivision.mod (UInt64.t'int self
      + UInt64.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt64.t'int (v_MIN'0 : UInt64.t)}
      {[%#snum10] UInt64.t'int self + UInt64.t'int rhs >= UInt64.t'int (v_MIN'0 : UInt64.t)
      /\ UInt64.t'int self + UInt64.t'int rhs <= UInt64.t'int (v_MAX'0 : UInt64.t)
       -> UInt64.t'int result = UInt64.t'int self + UInt64.t'int rhs}
      {[%#snum11] UInt64.t'int self + UInt64.t'int rhs < UInt64.t'int (v_MIN'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self + UInt64.t'int rhs
      + k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      {[%#snum12] UInt64.t'int self + UInt64.t'int rhs > UInt64.t'int (v_MAX'0 : UInt64.t)
       -> (exists k : int . k > 0
      /\ UInt64.t'int result
      = UInt64.t'int self + UInt64.t'int rhs
      - k * (UInt64.t'int (v_MAX'0 : UInt64.t) - UInt64.t'int (v_MIN'0 : UInt64.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd16] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'1 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd15] deep_model'0 self
  
  function view'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel13] view'1 self
  
  function hash_log'0 [#"bdd.rs" 131 4 131 44] (x : t_NodeLog'0) : int =
    [%#sbdd14] match x with
      | C_False'1 -> 1
      | C_True'1 -> 2
      | C_If'1 v childt childf -> mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int (v_MAX'0 : UInt64.t) + 1)
      end
  
  meta "compute_max_steps" 1000000
  
  let rec hash'0 (self:t_Node'0) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = any
      [ br0 -> {self = C_False'0 } (! bb2)
      | br1 -> {self = C_True'0 } (! bb3)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {self = C_If'0 x0 x1 x2} (! bb4) ]
      
    | bb4 = s0
      [ s0 = v_If'0 {self} (fun (rv'0:UInt64.t) (rchildt'0:t_Bdd'0) (rchildf'0:t_Bdd'0) ->  [ &v <- rv'0 ] s1)
      | s1 = v_If'0 {self} (fun (rv'1:UInt64.t) (rchildt'1:t_Bdd'0) (rchildf'1:t_Bdd'0) ->  [ &childt <- rchildt'1 ] s2)
      | s2 = v_If'0 {self} (fun (rv'2:UInt64.t) (rchildt'2:t_Bdd'0) (rchildf'2:t_Bdd'0) ->  [ &childf <- rchildf'2 ] s3)
      | s3 = wrapping_mul'0 {childt.t_Bdd__1'0} {[%#sbdd0] (5 : UInt64.t)}
          (fun (_ret':UInt64.t) ->  [ &_9 <- _ret' ] s4)
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 = wrapping_add'0 {v} {_9} (fun (_ret':UInt64.t) ->  [ &_7 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = wrapping_mul'0 {childf.t_Bdd__1'0} {[%#sbdd1] (7 : UInt64.t)}
          (fun (_ret':UInt64.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = wrapping_add'0 {_7} {_11} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = bb11
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd2] (2 : UInt64.t) ] s1 | s1 = bb11 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd3] (1 : UInt64.t) ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : UInt64.t = any_l ()
    | & self : t_Node'0 = self
    | & v : UInt64.t = any_l ()
    | & childt : t_Bdd'0 = any_l ()
    | & childf : t_Bdd'0 = any_l ()
    | & _7 : UInt64.t = any_l ()
    | & _9 : UInt64.t = any_l ()
    | & _11 : UInt64.t = any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd4] UInt64.t'int result = hash_log'0 (view'0 self)}
      (! return' {result}) ]
    
end
module M_bdd__qyi14323183011761258016__hash [#"bdd.rs" 145 4 145 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 144 14 144 46
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd2 = "bdd.rs" 152 20 152 22
  let%span sbdd3 = "bdd.rs" 199 20 199 37
  let%span sbdd4 = "bdd.rs" 189 20 189 26
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt64
  
  function deep_model'0 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd4] self.t_Bdd__1'0
  
  function view'1 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd3] deep_model'0 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel1] view'1 self
  
  function hash_log'0 [#"bdd.rs" 151 4 151 44] (x : UInt64.t) : int =
    [%#sbdd2] UInt64.t'int x
  
  meta "compute_max_steps" 1000000
  
  let rec hash'0 (self:t_Bdd'0) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self.t_Bdd__1'0 ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = any_l () | & self : t_Bdd'0 = self ] 
    [ return' (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd0] UInt64.t'int result = hash_log'0 (view'0 self)}
      (! return' {result}) ]
    
end
module M_bdd__qyi2581120635339165136__eq [#"bdd.rs" 205 4 205 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "bdd.rs" 204 14 204 37
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd2 = "bdd.rs" 199 20 199 37
  let%span sbdd3 = "bdd.rs" 189 20 189 26
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  use prelude.prelude.Intrinsic
  
  function deep_model'0 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd3] self.t_Bdd__1'0
  
  function view'1 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd2] deep_model'0 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel1] view'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'0 (self:t_Bdd'0) (o:t_Bdd'0) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.eq {self.t_Bdd__1'0} {o.t_Bdd__1'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & self : t_Bdd'0 = self | & o : t_Bdd'0 = o ] 
    [ return' (result:bool)-> {[@expl:eq ensures] [%#sbdd0] result = (view'0 self = view'0 o)} (! return' {result}) ]
    
end
module M_bdd__qyi13535665294507397779__size [#"bdd.rs" 227 4 227 24] (* Bdd<'arena> *)
  let%span sbdd0 = "bdd.rs" 226 14 226 25
  let%span sbdd1 = "bdd.rs" 229 12 237 13
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  constant self  : t_Bdd'0
  
  function size'0 [#"bdd.rs" 227 4 227 24] (self : t_Bdd'0) : int
  
  goal vc_size'0 : match self with
    | {t_Bdd__0'0 = C_True'0} -> [%#sbdd0] 0 >= 0
    | {t_Bdd__0'0 = C_False'0} -> [%#sbdd0] 0 >= 0
    | {t_Bdd__0'0 = C_If'0 _ childt childf} -> ([%#sbdd0] size'0 childt >= 0)
     -> (let ht = size'0 childt in ([%#sbdd0] size'0 childf >= 0)
     -> (let hf = size'0 childf in [%#sbdd0] 1 + ht + hf >= 0))
    end
end
module M_bdd__qyi11078426090797403070__grows_is_valid_bdd [#"bdd.rs" 339 4 339 56] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 336 15 336 27
  let%span sbdd1 = "bdd.rs" 337 15 337 35
  let%span sbdd2 = "bdd.rs" 338 14 338 37
  let%span sbdd3 = "bdd.rs" 334 4 334 12
  let%span sbdd4 = "bdd.rs" 301 12 306 17
  let%span sbdd5 = "bdd.rs" 314 12 314 47
  let%span smodel6 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd7 = "bdd.rs" 179 20 179 37
  let%span sbdd8 = "bdd.rs" 163 12 167 13
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  use prelude.prelude.UInt64
  
  type t_NodeLog'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd4] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'0 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'0 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd8] match self with
      | C_False'1 -> C_False'0
      | C_True'1 -> C_True'0
      | C_If'1 v childt childf -> C_If'0 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd7] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel6] view'2 self
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd5] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  constant self  : borrowed (t_Context'0)
  
  constant b  : t_Bdd'0
  
  function grows_is_valid_bdd'0 [#"bdd.rs" 339 4 339 56] (self : borrowed (t_Context'0)) (b : t_Bdd'0) : ()
  
  goal vc_grows_is_valid_bdd'0 : ([%#sbdd1] is_valid_bdd'0 self.current b)
   -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd2] is_valid_bdd'0 self.final b)
end
module M_bdd__qyi11078426090797403070__grows_trans [#"bdd.rs" 348 4 348 62] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 343 15 343 27
  let%span sbdd1 = "bdd.rs" 344 15 344 24
  let%span sbdd2 = "bdd.rs" 345 15 345 26
  let%span sbdd3 = "bdd.rs" 346 15 346 43
  let%span sbdd4 = "bdd.rs" 347 14 347 24
  let%span sbdd5 = "bdd.rs" 341 4 341 12
  let%span sbdd6 = "bdd.rs" 301 12 306 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  use prelude.prelude.UInt64
  
  type t_NodeLog'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd6] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'0 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'0 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  constant self  : borrowed (t_Context'0)
  
  constant o  : borrowed (t_Context'0)
  
  constant oo  : borrowed (t_Context'0)
  
  function grows_trans'0 [#"bdd.rs" 348 4 348 62] (self : borrowed (t_Context'0)) (o : borrowed (t_Context'0)) (oo : borrowed (t_Context'0)) : ()
    
  
  goal vc_grows_trans'0 : ([%#sbdd3] self.current = oo.current /\ self.final = oo.final)
   -> ([%#sbdd2] self.final = o.current)
   -> ([%#sbdd1] grows'0 o)  -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd4] grows'0 oo)
end
module M_bdd__qyi11078426090797403070__set_irrelevent_var [#"bdd.rs" 355 4 355 87] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 351 15 351 24
  let%span sbdd1 = "bdd.rs" 352 15 352 35
  let%span sbdd2 = "bdd.rs" 353 15 353 32
  let%span sbdd3 = "bdd.rs" 354 14 354 50
  let%span sbdd4 = "bdd.rs" 357 12 363 13
  let%span sbdd5 = "bdd.rs" 314 12 314 47
  let%span sbdd6 = "bdd.rs" 244 12 248 13
  let%span sbdd7 = "bdd.rs" 214 12 221 13
  let%span smodel8 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd9 = "bdd.rs" 267 12 291 19
  let%span sbdd10 = "bdd.rs" 179 20 179 37
  let%span sbdd11 = "bdd.rs" 321 12 330 13
  let%span sbdd12 = "bdd.rs" 163 12 167 13
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd12] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'3 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd10] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel8] view'3 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd5] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel8] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd6] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'2 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd11] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord26] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord25] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord23] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord24] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord21] cmp_log'0 x y = C_Less'0)
   -> ([%#sord22] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord18] cmp_log'0 x y
  = o)  -> ([%#sord19] cmp_log'0 y z = o)  -> ([%#sord20] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord17] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord14] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord13] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd7] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd9] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  use map.Map
  
  constant self  : t_Context'0
  
  constant a  : t_Bdd'0
  
  constant x  : UInt64.t
  
  constant v  : Map.map UInt64.t bool
  
  constant b  : bool
  
  function set_irrelevent_var'0 [#"bdd.rs" 355 4 355 87] (self : t_Context'0) (a : t_Bdd'0) (x : UInt64.t) (v : Map.map UInt64.t bool) (b : bool) : ()
    
  
  goal vc_set_irrelevent_var'0 : ([%#sbdd2] UInt64.t'int x < leastvar'0 a)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> match a with
    | {t_Bdd__0'0 = C_If'0 _ childt childf} -> (([@expl:set_irrelevent_var requires #0] [%#sbdd0] inv'0 self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd1] is_valid_bdd'0 self childt)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd2] UInt64.t'int x < leastvar'0 childt))
    /\ (([%#sbdd3] interp'0 childt v = interp'0 childt (Map.set v x b))
     -> (let _ = set_irrelevent_var'0 self childt x v b in (([@expl:set_irrelevent_var requires #0] [%#sbdd0] inv'0 self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd1] is_valid_bdd'0 self childf)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd2] UInt64.t'int x < leastvar'0 childf))
    /\ (([%#sbdd3] interp'0 childf v = interp'0 childf (Map.set v x b))
     -> (let _ = set_irrelevent_var'0 self childf x v b in [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)))))
    | _ -> [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)
    end
end
module M_bdd__qyi11078426090797403070__discr_valuation [#"bdd.rs" 375 4 375 82] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 368 15 368 24
  let%span sbdd1 = "bdd.rs" 369 15 369 35
  let%span sbdd2 = "bdd.rs" 370 15 370 35
  let%span sbdd3 = "bdd.rs" 371 15 371 21
  let%span sbdd4 = "bdd.rs" 372 14 372 50
  let%span sbdd5 = "bdd.rs" 373 14 373 33
  let%span sbdd6 = "bdd.rs" 377 12 377 36
  let%span sbdd7 = "bdd.rs" 314 12 314 47
  let%span sbdd8 = "bdd.rs" 214 12 221 13
  let%span sbdd9 = "bdd.rs" 226 14 226 25
  let%span sbdd10 = "bdd.rs" 229 12 237 13
  let%span sbdd11 = "bdd.rs" 351 15 351 24
  let%span sbdd12 = "bdd.rs" 352 15 352 35
  let%span sbdd13 = "bdd.rs" 353 15 353 32
  let%span sbdd14 = "bdd.rs" 354 14 354 50
  let%span sbdd15 = "bdd.rs" 357 12 363 13
  let%span sbdd16 = "bdd.rs" 244 12 248 13
  let%span smodel17 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd18 = "bdd.rs" 267 12 291 19
  let%span sbdd19 = "bdd.rs" 179 20 179 37
  let%span sbdd20 = "bdd.rs" 321 12 330 13
  let%span sbdd21 = "bdd.rs" 163 12 167 13
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd21] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'3 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd19] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel17] view'3 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd7] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel17] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd16] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'2 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd20] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord35] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord34] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord32] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord33] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord30] cmp_log'0 x y = C_Less'0)
   -> ([%#sord31] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord27] cmp_log'0 x y
  = o)  -> ([%#sord28] cmp_log'0 y z = o)  -> ([%#sord29] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord26] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord25] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord24] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord23] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord22] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd8] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd18] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  function size'0 [#"bdd.rs" 227 4 227 24] (self : t_Bdd'0) : int =
    [%#sbdd10] match self with
      | {t_Bdd__0'0 = C_True'0} -> 0
      | {t_Bdd__0'0 = C_False'0} -> 0
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : t_Bdd'0 . [%#sbdd9] size'0 self >= 0
  
  use map.Map
  
  function set_irrelevent_var'0 [#"bdd.rs" 355 4 355 87] (self : t_Context'0) (a : t_Bdd'0) (x : UInt64.t) (v : Map.map UInt64.t bool) (b : bool) : ()
    
   =
    [%#sbdd15] match a with
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : t_Context'0, a : t_Bdd'0, x : UInt64.t, v : Map.map UInt64.t bool, b : bool . ([%#sbdd11] inv'0 self)
   -> ([%#sbdd12] is_valid_bdd'0 self a)
   -> ([%#sbdd13] UInt64.t'int x < leastvar'0 a)  -> ([%#sbdd14] interp'0 a v = interp'0 a (Map.set v x b))
  
  use map.Const
  
  constant self  : t_Context'0
  
  constant a  : t_Bdd'0
  
  constant b  : t_Bdd'0
  
  function discr_valuation'0 [#"bdd.rs" 375 4 375 82] (self : t_Context'0) (a : t_Bdd'0) (b : t_Bdd'0) : Map.map UInt64.t bool
    
  
  goal vc_discr_valuation'0 : ([%#sbdd3] a <> b)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> (let _ = set_irrelevent_var'0 in if leastvar'0 a < leastvar'0 b then
    match a with
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if childf <> b then
        ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
        && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self childf)
        && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd3] childf <> b))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childf + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childf (discr_valuation'0 self childf b)
        <> interp'0 b (discr_valuation'0 self childf b))
         -> (let result = Map.set (discr_valuation'0 self childf b) v false in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      else
        ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
        && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self childt)
        && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd3] childt <> b))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childt + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childt (discr_valuation'0 self childt b)
        <> interp'0 b (discr_valuation'0 self childt b))
         -> (let result = Map.set (discr_valuation'0 self childt b) v true in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      
      | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | {t_Bdd__0'0 = C_If'0 v childt childf} -> if childf <> a then
          ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
          && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self childf)
          && ([@expl:discr_valuation requires #3] [%#sbdd3] a <> childf))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childf) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation'0 self a childf)
          <> interp'0 childf (discr_valuation'0 self a childf))
           -> (let result = Map.set (discr_valuation'0 self a childf) v false in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        else
          ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
          && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self childt)
          && ([@expl:discr_valuation requires #3] [%#sbdd3] a <> childt))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childt) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation'0 self a childt)
          <> interp'0 childt (discr_valuation'0 self a childt))
           -> (let result = Map.set (discr_valuation'0 self a childt) v true in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    else
      match a with
        | {t_Bdd__0'0 = C_If'0 v childta childfa} -> match b with
          | {t_Bdd__0'0 = C_If'0 _ childtb childfb} -> if childfa <> childfb then
            ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
            && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self childfa)
            && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self childfb)
            && ([@expl:discr_valuation requires #3] [%#sbdd3] childfa <> childfb))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childfa + size'0 childfb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childfa (discr_valuation'0 self childfa childfb)
            <> interp'0 childfb (discr_valuation'0 self childfa childfb))
             -> (let result = Map.set (discr_valuation'0 self childfa childfb) v false in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          else
            ((([@expl:discr_valuation requires #0] [%#sbdd0] inv'0 self)
            && ([@expl:discr_valuation requires #1] [%#sbdd1] is_valid_bdd'0 self childta)
            && ([@expl:discr_valuation requires #2] [%#sbdd2] is_valid_bdd'0 self childtb)
            && ([@expl:discr_valuation requires #3] [%#sbdd3] childta <> childtb))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childta + size'0 childtb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childta (discr_valuation'0 self childta childtb)
            <> interp'0 childtb (discr_valuation'0 self childta childtb))
             -> (let result = Map.set (discr_valuation'0 self childta childtb) v true in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          
          | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
          end
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    
  )
end
module M_bdd__qyi11078426090797403070__bdd_canonical [#"bdd.rs" 424 4 424 62] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 418 15 418 24
  let%span sbdd1 = "bdd.rs" 419 15 419 35
  let%span sbdd2 = "bdd.rs" 420 15 420 35
  let%span sbdd3 = "bdd.rs" 421 15 421 54
  let%span sbdd4 = "bdd.rs" 422 14 422 20
  let%span sbdd5 = "bdd.rs" 425 8 425 29
  let%span sbdd6 = "bdd.rs" 314 12 314 47
  let%span sbdd7 = "bdd.rs" 214 12 221 13
  let%span sbdd8 = "bdd.rs" 368 15 368 24
  let%span sbdd9 = "bdd.rs" 369 15 369 35
  let%span sbdd10 = "bdd.rs" 370 15 370 35
  let%span sbdd11 = "bdd.rs" 371 15 371 21
  let%span sbdd12 = "bdd.rs" 372 14 372 50
  let%span sbdd13 = "bdd.rs" 373 14 373 33
  let%span sbdd14 = "bdd.rs" 377 12 377 36
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd16 = "bdd.rs" 226 14 226 25
  let%span sbdd17 = "bdd.rs" 229 12 237 13
  let%span sbdd18 = "bdd.rs" 351 15 351 24
  let%span sbdd19 = "bdd.rs" 352 15 352 35
  let%span sbdd20 = "bdd.rs" 353 15 353 32
  let%span sbdd21 = "bdd.rs" 354 14 354 50
  let%span sbdd22 = "bdd.rs" 357 12 363 13
  let%span sbdd23 = "bdd.rs" 244 12 248 13
  let%span sbdd24 = "bdd.rs" 267 12 291 19
  let%span sbdd25 = "bdd.rs" 179 20 179 37
  let%span sbdd26 = "bdd.rs" 321 12 330 13
  let%span sbdd27 = "bdd.rs" 163 12 167 13
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd27] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd25] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel15] view'2 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd6] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'3 (self : UInt64.t) : int =
    [%#smodel15] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd23] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'3 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd26] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord41] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord40] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord38] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord39] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord36] cmp_log'0 x y = C_Less'0)
   -> ([%#sord37] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord33] cmp_log'0 x y
  = o)  -> ([%#sord34] cmp_log'0 y z = o)  -> ([%#sord35] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord32] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord31] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord30] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord29] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord28] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd7] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd24] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  function size'0 [#"bdd.rs" 227 4 227 24] (self : t_Bdd'0) : int =
    [%#sbdd17] match self with
      | {t_Bdd__0'0 = C_True'0} -> 0
      | {t_Bdd__0'0 = C_False'0} -> 0
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : t_Bdd'0 . [%#sbdd16] size'0 self >= 0
  
  use map.Map
  
  function set_irrelevent_var'0 [#"bdd.rs" 355 4 355 87] (self : t_Context'0) (a : t_Bdd'0) (x : UInt64.t) (v : Map.map UInt64.t bool) (b : bool) : ()
    
   =
    [%#sbdd22] match a with
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : t_Context'0, a : t_Bdd'0, x : UInt64.t, v : Map.map UInt64.t bool, b : bool . ([%#sbdd18] inv'0 self)
   -> ([%#sbdd19] is_valid_bdd'0 self a)
   -> ([%#sbdd20] UInt64.t'int x < leastvar'0 a)  -> ([%#sbdd21] interp'0 a v = interp'0 a (Map.set v x b))
  
  use map.Const
  
  function discr_valuation'0 [#"bdd.rs" 375 4 375 82] (self : t_Context'0) (a : t_Bdd'0) (b : t_Bdd'0) : Map.map UInt64.t bool
    
  
  axiom discr_valuation'0_def : forall self : t_Context'0, a : t_Bdd'0, b : t_Bdd'0 . ([%#sbdd8] inv'0 self)
   -> ([%#sbdd9] is_valid_bdd'0 self a)
   -> ([%#sbdd10] is_valid_bdd'0 self b)
   -> ([%#sbdd11] a <> b)
   -> discr_valuation'0 self a b
  = ([%#sbdd14] let _ = () in if leastvar'0 a < leastvar'0 b then
    match a with
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if childf <> b then
        Map.set (discr_valuation'0 self childf b) v false
      else
        Map.set (discr_valuation'0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | {t_Bdd__0'0 = C_If'0 v childt childf} -> if childf <> a then
          Map.set (discr_valuation'0 self a childf) v false
        else
          Map.set (discr_valuation'0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | {t_Bdd__0'0 = C_If'0 v childta childfa} -> match b with
          | {t_Bdd__0'0 = C_If'0 _ childtb childfb} -> if childfa <> childfb then
            Map.set (discr_valuation'0 self childfa childfb) v false
          else
            Map.set (discr_valuation'0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  
  axiom discr_valuation'0_spec : forall self : t_Context'0, a : t_Bdd'0, b : t_Bdd'0 . ([%#sbdd8] inv'0 self)
   -> ([%#sbdd9] is_valid_bdd'0 self a)
   -> ([%#sbdd10] is_valid_bdd'0 self b)
   -> ([%#sbdd11] a <> b)
   -> ([%#sbdd12] interp'0 a (discr_valuation'0 self a b) <> interp'0 b (discr_valuation'0 self a b))
  
  constant self  : t_Context'0
  
  constant a  : t_Bdd'0
  
  constant b  : t_Bdd'0
  
  function bdd_canonical'0 [#"bdd.rs" 424 4 424 62] (self : t_Context'0) (a : t_Bdd'0) (b : t_Bdd'0) : ()
  
  goal vc_bdd_canonical'0 : ([%#sbdd3] forall v : Map.map UInt64.t bool . interp'0 a v = interp'0 b v)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)  -> ([%#sbdd0] inv'0 self)  -> (let _ = discr_valuation'0 in [%#sbdd4] a = b)
end
module M_bdd__qyi11078426090797403070__new [#"bdd.rs" 430 4 430 52] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 434 22 434 47
  let%span sbdd1 = "bdd.rs" 435 28 435 57
  let%span sbdd2 = "bdd.rs" 436 22 436 47
  let%span sbdd3 = "bdd.rs" 437 22 437 47
  let%span sbdd4 = "bdd.rs" 438 17 438 18
  let%span sbdd5 = "bdd.rs" 430 48 430 52
  let%span sbdd6 = "bdd.rs" 70 18 70 47
  let%span sbdd7 = "bdd.rs" 267 12 291 19
  let%span smodel8 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd9 = "bdd.rs" 321 12 330 13
  let%span sbdd10 = "bdd.rs" 314 12 314 47
  let%span sbdd11 = "bdd.rs" 214 12 221 13
  let%span sbdd12 = "bdd.rs" 244 12 248 13
  let%span sbdd13 = "bdd.rs" 179 20 179 37
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sbdd27 = "bdd.rs" 163 12 167 13
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Borrow
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use prelude.prelude.Intrinsic
  
  let rec promoted0__new'0 (return'  (ret:t_Node'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_True'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Node'0 = any_l () | & _1 : t_Node'0 = any_l () ]  [ return' (result:t_Node'0)-> return' {result} ] 
  
  type t_MyHashMap'0
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Const
  
  let rec new'1 (_1:()) (return'  (ret:t_MyHashMap'0))= any
    [ return' (result:t_MyHashMap'0)-> {[%#sbdd6] view'0 result = Const.const (C_None'0)} (! return' {result}) ]
    
  
  use map.Const
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  use map.Map
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Const
  
  let rec new'2 (_1:()) (return'  (ret:t_MyHashMap'1))= any
    [ return' (result:t_MyHashMap'1)-> {[%#sbdd6] view'1 result = Const.const (C_None'0)} (! return' {result}) ]
    
  
  type t_MyHashMap'2
  
  use map.Map
  
  function view'2 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Const
  
  let rec new'3 (_1:()) (return'  (ret:t_MyHashMap'2))= any
    [ return' (result:t_MyHashMap'2)-> {[%#sbdd6] view'2 result = Const.const (C_None'0)} (! return' {result}) ]
    
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd27] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'4 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd13] deep_model'0 self
  
  function view'3 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel8] view'4 self
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd10] Map.get (view'0 self.t_Context__hashcons'0) (view'3 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'5 (self : UInt64.t) : int =
    [%#smodel8] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd12] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'5 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd9] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord28] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord26] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord24] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord25] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord22] cmp_log'0 x y = C_Less'0)
   -> ([%#sord23] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord19] cmp_log'0 x y
  = o)  -> ([%#sord20] cmp_log'0 y z = o)  -> ([%#sord21] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord18] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord17] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord14] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd11] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd7] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'1 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'2 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'0 (alloc:()) (return'  (ret:t_Context'0))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0__new'0 (fun (pr0:t_Node'0) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new'1 {[%#sbdd0] ()} (fun (_ret':t_MyHashMap'0) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd1] Snapshot.new (Const.const t) ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new'2 {[%#sbdd2] ()} (fun (_ret':t_MyHashMap'1) ->  [ &_8 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new'3 {[%#sbdd3] ()} (fun (_ret':t_MyHashMap'2) ->  [ &_9 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = 
        [ &_0 <- { t_Context__alloc'0 = alloc;
                   t_Context__hashcons'0 = _5;
                   t_Context__hashcons_ghost'0 = _6;
                   t_Context__not_memo'0 = _8;
                   t_Context__and_memo'0 = _9;
                   t_Context__cnt'0 = ([%#sbdd4] (0 : UInt64.t)) } ]
        
        s1
      | s1 = return' {_0} ]
       ]
    )
    [ & _0 : t_Context'0 = any_l ()
    | & alloc : () = alloc
    | & t : t_Node'0 = any_l ()
    | & _5 : t_MyHashMap'0 = any_l ()
    | & _6 : Snapshot.snap_ty (Map.map UInt64.t (t_Node'0)) = any_l ()
    | & _8 : t_MyHashMap'1 = any_l ()
    | & _9 : t_MyHashMap'2 = any_l ()
    | & _10 : t_Node'0 = any_l () ]
     [ return' (result:t_Context'0)-> {[@expl:new result type invariant] [%#sbdd5] inv'0 result} (! return' {result}) ] 
end
module M_bdd__qyi11078426090797403070__hashcons [#"bdd.rs" 446 4 446 58] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 453 30 453 77
  let%span sbdd1 = "bdd.rs" 454 33 454 34
  let%span sbdd2 = "bdd.rs" 454 22 454 30
  let%span sbdd3 = "bdd.rs" 460 20 460 21
  let%span sbdd4 = "bdd.rs" 448 28 448 38
  let%span sbdd5 = "bdd.rs" 446 21 446 25
  let%span sbdd6 = "bdd.rs" 442 15 442 36
  let%span sbdd7 = "bdd.rs" 443 14 443 28
  let%span sbdd8 = "bdd.rs" 444 14 444 26
  let%span sbdd9 = "bdd.rs" 445 14 445 42
  let%span sbdd10 = "bdd.rs" 66 37 66 40
  let%span sbdd11 = "bdd.rs" 66 52 66 65
  let%span sbdd12 = "bdd.rs" 61 18 64 9
  let%span sbdd13 = "bdd.rs" 22 31 22 34
  let%span sbdd14 = "bdd.rs" 22 42 22 48
  let%span sbdd15 = "bdd.rs" 21 18 21 32
  let%span sbdd16 = "bdd.rs" 57 30 57 33
  let%span sbdd17 = "bdd.rs" 57 38 57 41
  let%span sbdd18 = "bdd.rs" 55 18 55 126
  let%span smodel19 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd20 = "bdd.rs" 179 20 179 37
  let%span sbdd21 = "bdd.rs" 321 12 330 13
  let%span sbdd22 = "bdd.rs" 301 12 306 17
  let%span sbdd23 = "bdd.rs" 314 12 314 47
  let%span smodel24 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sresolve25 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sbdd26 = "bdd.rs" 163 12 167 13
  let%span smodel27 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sbdd28 = "bdd.rs" 244 12 248 13
  let%span sinvariant29 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd30 = "bdd.rs" 267 12 291 19
  let%span sbdd31 = "bdd.rs" 214 12 221 13
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  predicate inv'1 (_1 : t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (t_Bdd'0)
  
  use map.Map
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'1)
  
  function view'2 (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'1) =
    [%#smodel19] view'3 self
  
  function deep_model'1 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd26] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function deep_model'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel24] deep_model'1 self
  
  use map.Map
  
  let rec get'0 (self:t_MyHashMap'0) (key:t_Node'0) (return'  (ret:t_Option'0))= {[@expl:get 'key' type invariant] [%#sbdd10] inv'1 key}
    any
    [ return' (result:t_Option'0)-> {[%#sbdd11] inv'2 result}
      {[%#sbdd12] match result with
        | C_Some'0 v -> Map.get (view'2 self) (deep_model'0 key) = C_Some'1 v
        | C_None'0 -> Map.get (view'2 self) (deep_model'0 key) = C_None'1
        end}
      (! return' {result}) ]
    
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = true
  
  predicate inv'4 (_1 : borrowed (t_Node'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (t_Node'0) [inv'4 x] . inv'4 x = true
  
  let rec alloc'0 (self:()) (val':t_Node'0) (return'  (ret:borrowed (t_Node'0)))= {[@expl:alloc 'val' type invariant] [%#sbdd13] inv'3 val'}
    any
    [ return' (result:borrowed (t_Node'0))-> {[%#sbdd14] inv'4 result}
      {[%#sbdd15] result.current = val'}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (t_Node'0)) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Node'0)) =
    resolve'2 _1
  
  predicate inv'5 (_1 : t_Bdd'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Bdd'0 [inv'5 x] . inv'5 x = true
  
  function view'4 (self : borrowed (t_MyHashMap'0)) : Map.map (t_NodeLog'0) (t_Option'1) =
    [%#smodel27] view'3 self.current
  
  let rec add'0 (self:borrowed (t_MyHashMap'0)) (key:t_Node'0) (val':t_Bdd'0) (return'  (ret:()))= {[@expl:add 'key' type invariant] [%#sbdd16] inv'3 key}
    {[@expl:add 'val' type invariant] [%#sbdd17] inv'5 val'}
    any
    [ return' (result:())-> {[%#sbdd18] forall i : t_NodeLog'0 . Map.get (view'3 self.final) i
      = (if i = deep_model'1 key then C_Some'1 val' else Map.get (view'4 self) i)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  function view'1 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd20] deep_model'1 self
  
  function view'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel19] view'1 self
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd23] Map.get (view'3 self.t_Context__hashcons'0) (view'0 b.t_Bdd__0'0) = C_Some'1 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'5 (self : UInt64.t) : int =
    [%#smodel19] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd28] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'5 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd21] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord45] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord44] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord42] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord43] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord40] cmp_log'0 x y = C_Less'0)
   -> ([%#sord41] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord37] cmp_log'0 x y
  = o)  -> ([%#sord38] cmp_log'0 y z = o)  -> ([%#sord39] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord36] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord35] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord34] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord33] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord32] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd31] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'6 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'1)
  
  use map.Map
  
  use map.Map
  
  function view'7 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'1)
  
  use map.Map
  
  predicate invariant'1 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd30] (forall n : t_NodeLog'0 . match Map.get (view'3 self.t_Context__hashcons'0) n with
      | C_Some'1 b -> view'0 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'1 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'6 self.t_Context__not_memo'0) bm with
      | C_None'1 -> true
      | C_Some'1 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'7 self.t_Context__and_memo'0) abm with
      | C_None'1 -> true
      | C_Some'1 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'6 (_1 : t_Context'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Context'0 [inv'6 x] . inv'6 x
  = (invariant'1 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'0 (self : borrowed (t_Context'0)) =
    [%#sinvariant29] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'0 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Context'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 (self : borrowed (t_Context'0)) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (t_Context'0)) =
    resolve'3 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Bdd'0))= any
    [ good (field_0:t_Bdd'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd22] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'3 (self.current).t_Context__hashcons'0) n with
      | C_Some'1 b -> Map.get (view'3 (self.final).t_Context__hashcons'0) n = C_Some'1 b
      | C_None'1 -> true
      end)
  
  meta "compute_max_steps" 1000000
  
  let rec hashcons'0 (self:borrowed (t_Context'0)) (n:t_Node'0) (return'  (ret:t_Bdd'0))= {[@expl:hashcons 'self' type invariant] [%#sbdd5] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd6] is_valid_node'0 self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n ] s1
      | s1 = get'0 {(self.current).t_Context__hashcons'0} {_11} (fun (_ret':t_Option'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_8 = C_None'0 } (! bb4) | br1 (x0:t_Bdd'0)-> {_8 = C_Some'0 x0} (! bb2) ] 
    | bb4 = s0
      [ s0 = alloc'0 {(self.current).t_Context__alloc'0} {n} (fun (_ret':borrowed (t_Node'0)) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 =  [ &r1 <- { t_Bdd__0'0 = _19.current; t_Bdd__1'0 = (self.current).t_Context__cnt'0 } ] s1
      | s1 = -{resolve'0 _19}- s2
      | s2 = Borrow.borrow_final
          <t_MyHashMap'0>
          {(self.current).t_Context__hashcons'0}
          {Borrow.inherit_id (Borrow.get_id self) 2}
          (fun (_ret':borrowed (t_MyHashMap'0)) ->
             [ &_24 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Context__hashcons'0 = _ret'.final } } ] 
            s3)
      | s3 = add'0 {_24} {n} {r1} (fun (_ret':()) ->  [ &_23 <- _ret' ] s4)
      | s4 = bb6 ]
      
    | bb6 = s0
      [ s0 = 
        [ &_27 <- [%#sbdd0] Snapshot.new (Map.set (Snapshot.inner (self.current).t_Context__hashcons_ghost'0) r1.t_Bdd__1'0 r1.t_Bdd__0'0) ]
        
        s1
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_Context__hashcons_ghost'0 = _27 } } ] s1
      | s1 = UInt64.sub {[%#sbdd2] (18446744073709551615 : UInt64.t)} {[%#sbdd1] (1 : UInt64.t)}
          (fun (_ret':UInt64.t) ->  [ &_32 <- _ret' ] s2)
      | s2 = UInt64.gt {(self.current).t_Context__cnt'0} {_32} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s3)
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new self ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:mut invariant] (Snapshot.inner old_9_0).final = self.final}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = 
            [ &self <- { self with current = { self.current with t_Context__cnt'0 = (self.current).t_Context__cnt'0 } } ]
            
            s1
          | s1 = bb9 ]
           ]
         ]
      
    | bb11 = s0
      [ s0 = UInt64.add {(self.current).t_Context__cnt'0} {[%#sbdd3] (1 : UInt64.t)}
          (fun (_ret':UInt64.t) ->
             [ &self <- { self with current = { self.current with t_Context__cnt'0 = _ret' } } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 =  [ &_0 <- r1 ] s4
      | s4 = bb12 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_8} (fun (r0'0:t_Bdd'0) ->  [ &r <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 = {[@expl:assertion] [%#sbdd4] view'0 r.t_Bdd__0'0 = view'1 n} s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb12 ]
      
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & n : t_Node'0 = n
    | & _8 : t_Option'0 = any_l ()
    | & _11 : t_Node'0 = any_l ()
    | & r : t_Bdd'0 = any_l ()
    | & r1 : t_Bdd'0 = any_l ()
    | & _19 : borrowed (t_Node'0) = any_l ()
    | & _23 : () = any_l ()
    | & _24 : borrowed (t_MyHashMap'0) = any_l ()
    | & _27 : Snapshot.snap_ty (Map.map UInt64.t (t_Node'0)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : UInt64.t = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (t_Context'0)) = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:hashcons ensures #0] [%#sbdd7] result.t_Bdd__0'0 = n}
      {[@expl:hashcons ensures #1] [%#sbdd8] grows'0 self}
      {[@expl:hashcons ensures #2] [%#sbdd9] is_valid_bdd'0 self.final result}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__node [#"bdd.rs" 471 4 471 87] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 471 17 471 21
  let%span sbdd1 = "bdd.rs" 464 15 464 40
  let%span sbdd2 = "bdd.rs" 465 15 465 40
  let%span sbdd3 = "bdd.rs" 466 15 466 63
  let%span sbdd4 = "bdd.rs" 467 14 467 26
  let%span sbdd5 = "bdd.rs" 468 14 468 42
  let%span sbdd6 = "bdd.rs" 469 14 469 104
  let%span sbdd7 = "bdd.rs" 470 14 470 37
  let%span sbdd8 = "bdd.rs" 204 14 204 37
  let%span sbdd9 = "bdd.rs" 446 21 446 25
  let%span sbdd10 = "bdd.rs" 442 15 442 36
  let%span sbdd11 = "bdd.rs" 443 14 443 28
  let%span sbdd12 = "bdd.rs" 444 14 444 26
  let%span sbdd13 = "bdd.rs" 445 14 445 42
  let%span sbdd14 = "bdd.rs" 314 12 314 47
  let%span sbdd15 = "bdd.rs" 244 12 248 13
  let%span sbdd16 = "bdd.rs" 301 12 306 17
  let%span sbdd17 = "bdd.rs" 214 12 221 13
  let%span smodel18 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sresolve19 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sbdd20 = "bdd.rs" 321 12 330 13
  let%span sbdd21 = "bdd.rs" 199 20 199 37
  let%span sinvariant22 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd23 = "bdd.rs" 267 12 291 19
  let%span sbdd24 = "bdd.rs" 179 20 179 37
  let%span sbdd25 = "bdd.rs" 189 20 189 26
  let%span sbdd26 = "bdd.rs" 163 12 167 13
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  function deep_model'0 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd25] self.t_Bdd__1'0
  
  function view'4 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd21] deep_model'0 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel18] view'4 self
  
  let rec eq'0 (self:t_Bdd'0) (o:t_Bdd'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sbdd8] result = (view'0 self = view'0 o)} (! return' {result}) ]
    
  
  type t_MyHashMap'0
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'1 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd26] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'5 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd24] deep_model'1 self
  
  function view'2 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel18] view'5 self
  
  use map.Map
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd14] Map.get (view'1 self.t_Context__hashcons'0) (view'2 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'3 (self : UInt64.t) : int =
    [%#smodel18] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd15] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'3 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd20] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord40] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord39] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord37] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord38] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord35] cmp_log'0 x y = C_Less'0)
   -> ([%#sord36] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord32] cmp_log'0 x y
  = o)  -> ([%#sord33] cmp_log'0 y z = o)  -> ([%#sord34] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord31] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord30] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord29] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord28] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord27] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd17] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'6 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'7 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'1 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd23] (forall n : t_NodeLog'0 . match Map.get (view'1 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'2 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'6 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'7 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_1 : t_Context'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Context'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'0 (self : borrowed (t_Context'0)) =
    [%#sinvariant22] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Context'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd16] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'1 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'1 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec hashcons'0 (self:borrowed (t_Context'0)) (n:t_Node'0) (return'  (ret:t_Bdd'0))= {[@expl:hashcons 'self' type invariant] [%#sbdd9] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd10] is_valid_node'0 self.current n}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd11] result.t_Bdd__0'0 = n}
      {[%#sbdd12] grows'0 self}
      {[%#sbdd13] is_valid_bdd'0 self.final result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec node'0 (self:borrowed (t_Context'0)) (x:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:node 'self' type invariant] [%#sbdd0] inv'0 self}
    {[@expl:node requires #0] [%#sbdd1] is_valid_bdd'0 self.current childt}
    {[@expl:node requires #1] [%#sbdd2] is_valid_bdd'0 self.current childf}
    {[@expl:node requires #2] [%#sbdd3] UInt64.t'int x < leastvar'0 childt /\ UInt64.t'int x < leastvar'0 childf}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {childt} {childf} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- childt ] s3
      | s3 = bb5 ]
      
    | bb3 = s0
      [ s0 = {inv'1 self.current}
        Borrow.borrow_final <t_Context'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_17 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 =  [ &_18 <- C_If'0 x childt childf ] s2
      | s2 = hashcons'0 {_17} {_18} (fun (_ret':t_Bdd'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & x : UInt64.t = x
    | & childt : t_Bdd'0 = childt
    | & childf : t_Bdd'0 = childf
    | & _13 : bool = any_l ()
    | & _17 : borrowed (t_Context'0) = any_l ()
    | & _18 : t_Node'0 = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:node ensures #0] [%#sbdd4] grows'0 self}
      {[@expl:node ensures #1] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:node ensures #2] [%#sbdd6] forall v : Map.map UInt64.t bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[@expl:node ensures #3] [%#sbdd7] UInt64.t'int x <= leastvar'0 result}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__trueqy95z [#"bdd.rs" 482 4 482 42] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 482 22 482 26
  let%span sbdd1 = "bdd.rs" 478 14 478 26
  let%span sbdd2 = "bdd.rs" 479 14 479 42
  let%span sbdd3 = "bdd.rs" 480 14 480 42
  let%span sbdd4 = "bdd.rs" 481 14 481 46
  let%span sbdd5 = "bdd.rs" 446 21 446 25
  let%span sbdd6 = "bdd.rs" 442 15 442 36
  let%span sbdd7 = "bdd.rs" 443 14 443 28
  let%span sbdd8 = "bdd.rs" 444 14 444 26
  let%span sbdd9 = "bdd.rs" 445 14 445 42
  let%span sbdd10 = "bdd.rs" 301 12 306 17
  let%span sbdd11 = "bdd.rs" 314 12 314 47
  let%span sbdd12 = "bdd.rs" 214 12 221 13
  let%span sbdd13 = "bdd.rs" 244 12 248 13
  let%span sbdd14 = "bdd.rs" 321 12 330 13
  let%span sresolve15 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel16 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd17 = "bdd.rs" 267 12 291 19
  let%span sinvariant18 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd19 = "bdd.rs" 179 20 179 37
  let%span sbdd20 = "bdd.rs" 163 12 167 13
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd20] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'3 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd19] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel16] view'3 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd11] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel16] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd13] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'2 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd14] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord34] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord33] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord31] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord32] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord29] cmp_log'0 x y = C_Less'0)
   -> ([%#sord30] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord26] cmp_log'0 x y
  = o)  -> ([%#sord27] cmp_log'0 y z = o)  -> ([%#sord28] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord25] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord24] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord23] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord22] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord21] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd12] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd17] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'1 (self : borrowed (t_Context'0)) =
    [%#sinvariant18] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_Context'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd10] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'0 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'0 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec hashcons'0 (self:borrowed (t_Context'0)) (n:t_Node'0) (return'  (ret:t_Bdd'0))= {[@expl:hashcons 'self' type invariant] [%#sbdd5] inv'1 self}
    {[@expl:hashcons requires] [%#sbdd6] is_valid_node'0 self.current n}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd7] result.t_Bdd__0'0 = n}
      {[%#sbdd8] grows'0 self}
      {[%#sbdd9] is_valid_bdd'0 self.final result}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve15] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec trueqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:true_ 'self' type invariant] [%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <t_Context'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 =  [ &_7 <- C_True'0 ] s2
      | s2 = hashcons'0 {_6} {_7} (fun (_ret':t_Bdd'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & _6 : borrowed (t_Context'0) = any_l ()
    | & _7 : t_Node'0 = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:true_ ensures #0] [%#sbdd1] grows'0 self}
      {[@expl:true_ ensures #1] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:true_ ensures #2] [%#sbdd3] forall v : Map.map UInt64.t bool . interp'0 result v}
      {[@expl:true_ ensures #3] [%#sbdd4] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__falseqy95z [#"bdd.rs" 490 4 490 43] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 490 23 490 27
  let%span sbdd1 = "bdd.rs" 486 14 486 26
  let%span sbdd2 = "bdd.rs" 487 14 487 42
  let%span sbdd3 = "bdd.rs" 488 14 488 43
  let%span sbdd4 = "bdd.rs" 489 14 489 46
  let%span sbdd5 = "bdd.rs" 446 21 446 25
  let%span sbdd6 = "bdd.rs" 442 15 442 36
  let%span sbdd7 = "bdd.rs" 443 14 443 28
  let%span sbdd8 = "bdd.rs" 444 14 444 26
  let%span sbdd9 = "bdd.rs" 445 14 445 42
  let%span sbdd10 = "bdd.rs" 301 12 306 17
  let%span sbdd11 = "bdd.rs" 314 12 314 47
  let%span sbdd12 = "bdd.rs" 214 12 221 13
  let%span sbdd13 = "bdd.rs" 244 12 248 13
  let%span sbdd14 = "bdd.rs" 321 12 330 13
  let%span sresolve15 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel16 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd17 = "bdd.rs" 267 12 291 19
  let%span sinvariant18 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd19 = "bdd.rs" 179 20 179 37
  let%span sbdd20 = "bdd.rs" 163 12 167 13
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd20] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'3 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd19] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel16] view'3 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd11] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel16] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd13] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'2 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd14] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord34] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord33] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord31] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord32] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord29] cmp_log'0 x y = C_Less'0)
   -> ([%#sord30] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord26] cmp_log'0 x y
  = o)  -> ([%#sord27] cmp_log'0 y z = o)  -> ([%#sord28] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord25] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord24] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord23] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord22] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord21] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd12] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd17] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'1 (self : borrowed (t_Context'0)) =
    [%#sinvariant18] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_Context'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd10] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'0 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'0 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec hashcons'0 (self:borrowed (t_Context'0)) (n:t_Node'0) (return'  (ret:t_Bdd'0))= {[@expl:hashcons 'self' type invariant] [%#sbdd5] inv'1 self}
    {[@expl:hashcons requires] [%#sbdd6] is_valid_node'0 self.current n}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd7] result.t_Bdd__0'0 = n}
      {[%#sbdd8] grows'0 self}
      {[%#sbdd9] is_valid_bdd'0 self.final result}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve15] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec falseqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:false_ 'self' type invariant] [%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <t_Context'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 =  [ &_7 <- C_False'0 ] s2
      | s2 = hashcons'0 {_6} {_7} (fun (_ret':t_Bdd'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & _6 : borrowed (t_Context'0) = any_l ()
    | & _7 : t_Node'0 = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:false_ ensures #0] [%#sbdd1] grows'0 self}
      {[@expl:false_ ensures #1] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:false_ ensures #2] [%#sbdd3] forall v : Map.map UInt64.t bool . not interp'0 result v}
      {[@expl:false_ ensures #3] [%#sbdd4] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__v [#"bdd.rs" 497 4 497 46] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 497 18 497 22
  let%span sbdd1 = "bdd.rs" 494 14 494 26
  let%span sbdd2 = "bdd.rs" 495 14 495 42
  let%span sbdd3 = "bdd.rs" 496 14 496 54
  let%span sbdd4 = "bdd.rs" 482 22 482 26
  let%span sbdd5 = "bdd.rs" 478 14 478 26
  let%span sbdd6 = "bdd.rs" 479 14 479 42
  let%span sbdd7 = "bdd.rs" 480 14 480 42
  let%span sbdd8 = "bdd.rs" 481 14 481 46
  let%span sbdd9 = "bdd.rs" 490 23 490 27
  let%span sbdd10 = "bdd.rs" 486 14 486 26
  let%span sbdd11 = "bdd.rs" 487 14 487 42
  let%span sbdd12 = "bdd.rs" 488 14 488 43
  let%span sbdd13 = "bdd.rs" 489 14 489 46
  let%span sbdd14 = "bdd.rs" 471 17 471 21
  let%span sbdd15 = "bdd.rs" 464 15 464 40
  let%span sbdd16 = "bdd.rs" 465 15 465 40
  let%span sbdd17 = "bdd.rs" 466 15 466 63
  let%span sbdd18 = "bdd.rs" 467 14 467 26
  let%span sbdd19 = "bdd.rs" 468 14 468 42
  let%span sbdd20 = "bdd.rs" 469 14 469 104
  let%span sbdd21 = "bdd.rs" 470 14 470 37
  let%span sbdd22 = "bdd.rs" 301 12 306 17
  let%span sbdd23 = "bdd.rs" 314 12 314 47
  let%span sbdd24 = "bdd.rs" 214 12 221 13
  let%span sbdd25 = "bdd.rs" 244 12 248 13
  let%span sresolve26 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel27 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd28 = "bdd.rs" 267 12 291 19
  let%span sinvariant29 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd30 = "bdd.rs" 179 20 179 37
  let%span sbdd31 = "bdd.rs" 321 12 330 13
  let%span sbdd32 = "bdd.rs" 163 12 167 13
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'0
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'1
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'0;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'1;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd32] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'3 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd30] deep_model'0 self
  
  function view'1 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel27] view'3 self
  
  use map.Map
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (t_NodeLog'0) (t_Option'0)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd23] Map.get (view'0 self.t_Context__hashcons'0) (view'1 b.t_Bdd__0'0) = C_Some'0 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel27] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd25] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'2 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd31] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord46] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord45] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord43] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord44] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord41] cmp_log'0 x y = C_Less'0)
   -> ([%#sord42] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord38] cmp_log'0 x y
  = o)  -> ([%#sord39] cmp_log'0 y z = o)  -> ([%#sord40] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord37] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord36] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord35] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord34] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord33] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd24] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map UInt64.t (t_Option'0)
  
  use map.Map
  
  use map.Map
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'0)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd28] (forall n : t_NodeLog'0 . match Map.get (view'0 self.t_Context__hashcons'0) n with
      | C_Some'0 b -> view'1 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'4 self.t_Context__not_memo'0) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'5 self.t_Context__and_memo'0) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'1 (self : borrowed (t_Context'0)) =
    [%#sinvariant29] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_Context'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd22] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'0 (self.current).t_Context__hashcons'0) n with
      | C_Some'0 b -> Map.get (view'0 (self.final).t_Context__hashcons'0) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec trueqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:true_ 'self' type invariant] [%#sbdd4] inv'1 self}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd5] grows'0 self}
      {[%#sbdd6] is_valid_bdd'0 self.final result}
      {[%#sbdd7] forall v : Map.map UInt64.t bool . interp'0 result v}
      {[%#sbdd8] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
  
  let rec falseqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:false_ 'self' type invariant] [%#sbdd9] inv'1 self}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd10] grows'0 self}
      {[%#sbdd11] is_valid_bdd'0 self.final result}
      {[%#sbdd12] forall v : Map.map UInt64.t bool . not interp'0 result v}
      {[%#sbdd13] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (t_Context'0)) (x:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:node 'self' type invariant] [%#sbdd14] inv'1 self}
    {[@expl:node requires #0] [%#sbdd15] is_valid_bdd'0 self.current childt}
    {[@expl:node requires #1] [%#sbdd16] is_valid_bdd'0 self.current childf}
    {[@expl:node requires #2] [%#sbdd17] UInt64.t'int x < leastvar'0 childt /\ UInt64.t'int x < leastvar'0 childf}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd18] grows'0 self}
      {[%#sbdd19] is_valid_bdd'0 self.final result}
      {[%#sbdd20] forall v : Map.map UInt64.t bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#sbdd21] UInt64.t'int x <= leastvar'0 result}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec v'0 (self:borrowed (t_Context'0)) (x:UInt64.t) (return'  (ret:t_Bdd'0))= {[@expl:v 'self' type invariant] [%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_7 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = trueqy95z'0 {_7} (fun (_ret':t_Bdd'0) ->  [ &t <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = falseqy95z'0 {_9} (fun (_ret':t_Bdd'0) ->  [ &f <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <t_Context'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = node'0 {_10} {x} {t} {f} (fun (_ret':t_Bdd'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & x : UInt64.t = x
    | & t : t_Bdd'0 = any_l ()
    | & _7 : borrowed (t_Context'0) = any_l ()
    | & f : t_Bdd'0 = any_l ()
    | & _9 : borrowed (t_Context'0) = any_l ()
    | & _10 : borrowed (t_Context'0) = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:v ensures #0] [%#sbdd1] grows'0 self}
      {[@expl:v ensures #1] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:v ensures #2] [%#sbdd3] forall v : Map.map UInt64.t bool . interp'0 result v = Map.get v x}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__not [#"bdd.rs" 509 4 509 56] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 509 20 509 24
  let%span sbdd1 = "bdd.rs" 503 15 503 35
  let%span sbdd2 = "bdd.rs" 504 14 504 26
  let%span sbdd3 = "bdd.rs" 505 14 505 42
  let%span sbdd4 = "bdd.rs" 506 14 506 58
  let%span sbdd5 = "bdd.rs" 507 14 507 47
  let%span sbdd6 = "bdd.rs" 508 14 508 22
  let%span sbdd7 = "bdd.rs" 66 37 66 40
  let%span sbdd8 = "bdd.rs" 66 52 66 65
  let%span sbdd9 = "bdd.rs" 61 18 64 9
  let%span sbdd10 = "bdd.rs" 471 17 471 21
  let%span sbdd11 = "bdd.rs" 464 15 464 40
  let%span sbdd12 = "bdd.rs" 465 15 465 40
  let%span sbdd13 = "bdd.rs" 466 15 466 63
  let%span sbdd14 = "bdd.rs" 467 14 467 26
  let%span sbdd15 = "bdd.rs" 468 14 468 42
  let%span sbdd16 = "bdd.rs" 469 14 469 104
  let%span sbdd17 = "bdd.rs" 470 14 470 37
  let%span sbdd18 = "bdd.rs" 490 23 490 27
  let%span sbdd19 = "bdd.rs" 486 14 486 26
  let%span sbdd20 = "bdd.rs" 487 14 487 42
  let%span sbdd21 = "bdd.rs" 488 14 488 43
  let%span sbdd22 = "bdd.rs" 489 14 489 46
  let%span sbdd23 = "bdd.rs" 482 22 482 26
  let%span sbdd24 = "bdd.rs" 478 14 478 26
  let%span sbdd25 = "bdd.rs" 479 14 479 42
  let%span sbdd26 = "bdd.rs" 480 14 480 42
  let%span sbdd27 = "bdd.rs" 481 14 481 46
  let%span sbdd28 = "bdd.rs" 57 30 57 33
  let%span sbdd29 = "bdd.rs" 57 38 57 41
  let%span sbdd30 = "bdd.rs" 55 18 55 126
  let%span sbdd31 = "bdd.rs" 314 12 314 47
  let%span sbdd32 = "bdd.rs" 301 12 306 17
  let%span sbdd33 = "bdd.rs" 214 12 221 13
  let%span sbdd34 = "bdd.rs" 244 12 248 13
  let%span sbdd35 = "bdd.rs" 226 14 226 25
  let%span sbdd36 = "bdd.rs" 229 12 237 13
  let%span smodel37 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span smodel38 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd39 = "bdd.rs" 189 20 189 26
  let%span smodel40 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sresolve41 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sbdd42 = "bdd.rs" 267 12 291 19
  let%span sinvariant43 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sbdd44 = "bdd.rs" 179 20 179 37
  let%span sbdd45 = "bdd.rs" 321 12 330 13
  let%span sbdd46 = "bdd.rs" 163 12 167 13
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord56 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord57 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord58 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord59 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord60 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'1
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'0
  
  type t_MyHashMap'2
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'1;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'0;
      t_Context__and_memo'0: t_MyHashMap'2;
      t_Context__cnt'0: UInt64.t }
  
  predicate inv'2 (_1 : t_Bdd'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Bdd'0 [inv'2 x] . inv'2 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = true
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (t_Bdd'0)
  
  use map.Map
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t (t_Option'1)
  
  function view'0 (self : t_MyHashMap'0) : Map.map UInt64.t (t_Option'1) =
    [%#smodel37] view'1 self
  
  function deep_model'1 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd39] self.t_Bdd__1'0
  
  function deep_model'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel38] deep_model'1 self
  
  use map.Map
  
  let rec get'0 (self:t_MyHashMap'0) (key:t_Bdd'0) (return'  (ret:t_Option'0))= {[@expl:get 'key' type invariant] [%#sbdd7] inv'2 key}
    any
    [ return' (result:t_Option'0)-> {[%#sbdd8] inv'3 result}
      {[%#sbdd9] match result with
        | C_Some'0 v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'1 v
        | C_None'0 -> Map.get (view'0 self) (deep_model'0 key) = C_None'1
        end}
      (! return' {result}) ]
    
  
  let rec v_If'0 (input:t_Node'0) (ret  (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0))= any
    [ good (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0)-> {C_If'0 v childt childf = input}
      (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd'0, childf : t_Bdd'0 [C_If'0 v childt childf : t_Node'0] . C_If'0 v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'2 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd46] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'6 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd44] deep_model'2 self
  
  function view'4 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel37] view'6 self
  
  use map.Map
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map (t_NodeLog'0) (t_Option'1)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd31] Map.get (view'3 self.t_Context__hashcons'0) (view'4 b.t_Bdd__0'0) = C_Some'1 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'5 (self : UInt64.t) : int =
    [%#smodel37] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd34] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'5 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd45] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord60] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord59] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord57] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord58] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord55] cmp_log'0 x y = C_Less'0)
   -> ([%#sord56] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord52] cmp_log'0 x y
  = o)  -> ([%#sord53] cmp_log'0 y z = o)  -> ([%#sord54] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord51] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord50] UInt64.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord49] UInt64.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord48] UInt64.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord47] UInt64.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd33] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'7 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map (UInt64.t, UInt64.t) (t_Option'1)
  
  use map.Map
  
  predicate invariant'0 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd42] (forall n : t_NodeLog'0 . match Map.get (view'3 self.t_Context__hashcons'0) n with
      | C_Some'1 b -> view'4 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'1 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'1 self.t_Context__not_memo'0) bm with
      | C_None'1 -> true
      | C_Some'1 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'7 self.t_Context__and_memo'0) abm with
      | C_None'1 -> true
      | C_Some'1 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : t_Context'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Context'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'1 (self : borrowed (t_Context'0)) =
    [%#sinvariant43] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_Context'0) [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd32] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'3 (self.current).t_Context__hashcons'0) n with
      | C_Some'1 b -> Map.get (view'3 (self.final).t_Context__hashcons'0) n = C_Some'1 b
      | C_None'1 -> true
      end)
  
  let rec node'0 (self:borrowed (t_Context'0)) (x:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:node 'self' type invariant] [%#sbdd10] inv'1 self}
    {[@expl:node requires #0] [%#sbdd11] is_valid_bdd'0 self.current childt}
    {[@expl:node requires #1] [%#sbdd12] is_valid_bdd'0 self.current childf}
    {[@expl:node requires #2] [%#sbdd13] UInt64.t'int x < leastvar'0 childt /\ UInt64.t'int x < leastvar'0 childf}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd14] grows'0 self}
      {[%#sbdd15] is_valid_bdd'0 self.final result}
      {[%#sbdd16] forall v : Map.map UInt64.t bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#sbdd17] UInt64.t'int x <= leastvar'0 result}
      (! return' {result}) ]
    
  
  let rec falseqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:false_ 'self' type invariant] [%#sbdd18] inv'1 self}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd19] grows'0 self}
      {[%#sbdd20] is_valid_bdd'0 self.final result}
      {[%#sbdd21] forall v : Map.map UInt64.t bool . not interp'0 result v}
      {[%#sbdd22] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
  
  let rec trueqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:true_ 'self' type invariant] [%#sbdd23] inv'1 self}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd24] grows'0 self}
      {[%#sbdd25] is_valid_bdd'0 self.final result}
      {[%#sbdd26] forall v : Map.map UInt64.t bool . interp'0 result v}
      {[%#sbdd27] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
  
  predicate inv'4 (_1 : t_Bdd'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Bdd'0 [inv'4 x] . inv'4 x = true
  
  function view'2 (self : borrowed (t_MyHashMap'0)) : Map.map UInt64.t (t_Option'1) =
    [%#smodel40] view'1 self.current
  
  let rec add'0 (self:borrowed (t_MyHashMap'0)) (key:t_Bdd'0) (val':t_Bdd'0) (return'  (ret:()))= {[@expl:add 'key' type invariant] [%#sbdd28] inv'4 key}
    {[@expl:add 'val' type invariant] [%#sbdd29] inv'4 val'}
    any
    [ return' (result:())-> {[%#sbdd30] forall i : UInt64.t . Map.get (view'1 self.final) i
      = (if i = deep_model'1 key then C_Some'1 val' else Map.get (view'2 self) i)}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve41] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Bdd'0))= any
    [ good (field_0:t_Bdd'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  function size'0 [#"bdd.rs" 227 4 227 24] (self : t_Bdd'0) : int =
    [%#sbdd36] match self with
      | {t_Bdd__0'0 = C_True'0} -> 0
      | {t_Bdd__0'0 = C_False'0} -> 0
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : t_Bdd'0 . [%#sbdd35] size'0 self >= 0
  
  meta "compute_max_steps" 1000000
  
  let rec not'0 (self:borrowed (t_Context'0)) (x:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:not 'self' type invariant] [%#sbdd0] inv'1 self}
    {[@expl:not requires] [%#sbdd1] is_valid_bdd'0 self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x ] s1
      | s1 = get'0 {(self.current).t_Context__not_memo'0} {_13} (fun (_ret':t_Option'0) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_10 = C_None'0 } (! bb4) | br1 (x0:t_Bdd'0)-> {_10 = C_Some'0 x0} (! bb2) ] 
    | bb4 = any
      [ br0 -> {x.t_Bdd__0'0 = C_False'0 } (! bb7)
      | br1 -> {x.t_Bdd__0'0 = C_True'0 } (! bb6)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {x.t_Bdd__0'0 = C_If'0 x0 x1 x2} (! bb8) ]
      
    | bb8 = s0
      [ s0 = v_If'0 {x.t_Bdd__0'0} (fun (rv'0:UInt64.t) (rchildt'0:t_Bdd'0) (rchildf'0:t_Bdd'0) ->  [ &v <- rv'0 ] s1)
      | s1 = v_If'0 {x.t_Bdd__0'0}
          (fun (rv'1:UInt64.t) (rchildt'1:t_Bdd'0) (rchildf'1:t_Bdd'0) ->  [ &childt <- rchildt'1 ] s2)
      | s2 = v_If'0 {x.t_Bdd__0'0}
          (fun (rv'2:UInt64.t) (rchildt'2:t_Bdd'0) (rchildf'2:t_Bdd'0) ->  [ &childf <- rchildf'2 ] s3)
      | s3 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s4)
      | s4 = not'0 {_25} {childt} (fun (_ret':t_Bdd'0) ->  [ &childt1 <- _ret' ] s5)
      | s5 = bb13 ]
      
    | bb13 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_28 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = not'0 {_28} {childf} (fun (_ret':t_Bdd'0) ->  [ &childf1 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = node'0 {_30} {v} {childt1} {childf1} (fun (_ret':t_Bdd'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = bb16
    | bb6 = bb9
    | bb9 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_19 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = falseqy95z'0 {_19} (fun (_ret':t_Bdd'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = bb16
    | bb7 = bb11
    | bb11 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_20 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = trueqy95z'0 {_20} (fun (_ret':t_Bdd'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = bb16
    | bb16 = s0
      [ s0 = Borrow.borrow_final
          <t_MyHashMap'0>
          {(self.current).t_Context__not_memo'0}
          {Borrow.inherit_id (Borrow.get_id self) 4}
          (fun (_ret':borrowed (t_MyHashMap'0)) ->
             [ &_35 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Context__not_memo'0 = _ret'.final } } ] 
            s1)
      | s1 = add'0 {_35} {x} {r1} (fun (_ret':()) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_10} (fun (r0'0:t_Bdd'0) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'1 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb18 ]
      
    | bb18 = return' {_0} ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & x : t_Bdd'0 = x
    | & _10 : t_Option'0 = any_l ()
    | & _13 : t_Bdd'0 = any_l ()
    | & r : t_Bdd'0 = any_l ()
    | & r1 : t_Bdd'0 = any_l ()
    | & _19 : borrowed (t_Context'0) = any_l ()
    | & _20 : borrowed (t_Context'0) = any_l ()
    | & v : UInt64.t = any_l ()
    | & childt : t_Bdd'0 = any_l ()
    | & childf : t_Bdd'0 = any_l ()
    | & childt1 : t_Bdd'0 = any_l ()
    | & _25 : borrowed (t_Context'0) = any_l ()
    | & childf1 : t_Bdd'0 = any_l ()
    | & _28 : borrowed (t_Context'0) = any_l ()
    | & _30 : borrowed (t_Context'0) = any_l ()
    | & _34 : () = any_l ()
    | & _35 : borrowed (t_MyHashMap'0) = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:not ensures #0] [%#sbdd2] grows'0 self}
      {[@expl:not ensures #1] [%#sbdd3] is_valid_bdd'0 self.final result}
      {[@expl:not ensures #2] [%#sbdd4] forall v : Map.map UInt64.t bool . interp'0 result v = (not interp'0 x v)}
      {[@expl:not ensures #3] [%#sbdd5] leastvar'0 x <= leastvar'0 result}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__and [#"bdd.rs" 533 4 533 72] (* Context<'arena> *)
  let%span sbdd0 = "bdd.rs" 537 22 537 34
  let%span sbdd1 = "bdd.rs" 533 20 533 24
  let%span sbdd2 = "bdd.rs" 526 15 526 35
  let%span sbdd3 = "bdd.rs" 527 15 527 35
  let%span sbdd4 = "bdd.rs" 528 14 528 26
  let%span sbdd5 = "bdd.rs" 529 14 529 42
  let%span sbdd6 = "bdd.rs" 530 14 530 74
  let%span sbdd7 = "bdd.rs" 531 14 531 84
  let%span sbdd8 = "bdd.rs" 532 14 532 33
  let%span sbdd9 = "bdd.rs" 66 37 66 40
  let%span sbdd10 = "bdd.rs" 66 52 66 65
  let%span sbdd11 = "bdd.rs" 61 18 64 9
  let%span scmp12 = "../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span sbdd13 = "bdd.rs" 471 17 471 21
  let%span sbdd14 = "bdd.rs" 464 15 464 40
  let%span sbdd15 = "bdd.rs" 465 15 465 40
  let%span sbdd16 = "bdd.rs" 466 15 466 63
  let%span sbdd17 = "bdd.rs" 467 14 467 26
  let%span sbdd18 = "bdd.rs" 468 14 468 42
  let%span sbdd19 = "bdd.rs" 469 14 469 104
  let%span sbdd20 = "bdd.rs" 470 14 470 37
  let%span sbdd21 = "bdd.rs" 490 23 490 27
  let%span sbdd22 = "bdd.rs" 486 14 486 26
  let%span sbdd23 = "bdd.rs" 487 14 487 42
  let%span sbdd24 = "bdd.rs" 488 14 488 43
  let%span sbdd25 = "bdd.rs" 489 14 489 46
  let%span sbdd26 = "bdd.rs" 57 30 57 33
  let%span sbdd27 = "bdd.rs" 57 38 57 41
  let%span sbdd28 = "bdd.rs" 55 18 55 126
  let%span sbdd29 = "bdd.rs" 314 12 314 47
  let%span sbdd30 = "bdd.rs" 301 12 306 17
  let%span sbdd31 = "bdd.rs" 214 12 221 13
  let%span sbdd32 = "bdd.rs" 244 12 248 13
  let%span sbdd33 = "bdd.rs" 226 14 226 25
  let%span sbdd34 = "bdd.rs" 229 12 237 13
  let%span smodel35 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span smodel36 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sresolve37 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span snum38 = "../../../creusot-contracts/src/std/num.rs" 54 32 54 37
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  let%span stuples40 = "../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span smodel41 = "../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sinvariant42 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sbdd56 = "bdd.rs" 267 12 291 19
  let%span sbdd57 = "bdd.rs" 189 20 189 26
  let%span sbdd58 = "bdd.rs" 179 20 179 37
  let%span sbdd59 = "bdd.rs" 321 12 330 13
  let%span sbdd60 = "bdd.rs" 163 12 167 13
  let%span sord61 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord62 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord63 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord64 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord65 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord66 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord67 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord68 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord69 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord70 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord71 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord72 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord73 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sord74 = "../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  
  use prelude.prelude.Borrow
  
  type t_MyHashMap'1
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  type t_MyHashMap'2
  
  type t_MyHashMap'0
  
  type t_Context'0  =
    { t_Context__alloc'0: ();
      t_Context__hashcons'0: t_MyHashMap'1;
      t_Context__hashcons_ghost'0: Snapshot.snap_ty (Map.map UInt64.t (t_Node'0));
      t_Context__not_memo'0: t_MyHashMap'2;
      t_Context__and_memo'0: t_MyHashMap'0;
      t_Context__cnt'0: UInt64.t }
  
  predicate inv'2 (_1 : (t_Bdd'0, t_Bdd'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : (t_Bdd'0, t_Bdd'0) [inv'2 x] . inv'2 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_Bdd'0)
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = true
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (t_Bdd'0)
  
  use map.Map
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map (UInt64.t, UInt64.t) (t_Option'1)
  
  function view'0 (self : t_MyHashMap'0) : Map.map (UInt64.t, UInt64.t) (t_Option'1) =
    [%#smodel35] view'1 self
  
  function deep_model'3 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd57] self.t_Bdd__1'0
  
  function deep_model'2 (self : (t_Bdd'0, t_Bdd'0)) : (UInt64.t, UInt64.t) =
    [%#stuples40] (deep_model'3 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  function deep_model'0 (self : (t_Bdd'0, t_Bdd'0)) : (UInt64.t, UInt64.t) =
    [%#smodel36] deep_model'2 self
  
  use map.Map
  
  let rec get'0 (self:t_MyHashMap'0) (key:(t_Bdd'0, t_Bdd'0)) (return'  (ret:t_Option'0))= {[@expl:get 'key' type invariant] [%#sbdd9] inv'2 key}
    any
    [ return' (result:t_Option'0)-> {[%#sbdd10] inv'3 result}
      {[%#sbdd11] match result with
        | C_Some'0 v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'1 v
        | C_None'0 -> Map.get (view'0 self) (deep_model'0 key) = C_None'1
        end}
      (! return' {result}) ]
    
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'4 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd60] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'6 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd58] deep_model'4 self
  
  function view'4 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel35] view'6 self
  
  use map.Map
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map (t_NodeLog'0) (t_Option'1)
  
  use map.Map
  
  predicate is_valid_bdd'0 [#"bdd.rs" 312 4 312 53] (self : t_Context'0) (b : t_Bdd'0) =
    [%#sbdd29] Map.get (view'3 self.t_Context__hashcons'0) (view'4 b.t_Bdd__0'0) = C_Some'1 b
  
  use prelude.prelude.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'5 (self : UInt64.t) : int =
    [%#smodel35] UInt64.t'int self
  
  function leastvar'0 [#"bdd.rs" 242 4 242 28] (self : t_Bdd'0) : int =
    [%#sbdd32] match self with
      | {t_Bdd__0'0 = C_True'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_False'0} -> UInt64.t'int (v_MAX'0 : UInt64.t) + 1
      | {t_Bdd__0'0 = C_If'0 v _ _} -> view'5 v
      end
  
  predicate is_valid_node'0 [#"bdd.rs" 319 4 319 51] (self : t_Context'0) (n : t_Node'0) =
    [%#sbdd59] match n with
      | C_True'0 -> true
      | C_False'0 -> true
      | C_If'0 v childt childf -> childt.t_Bdd__0'0 <> childf.t_Bdd__0'0
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.t'int v < leastvar'0 childt /\ UInt64.t'int v < leastvar'0 childf
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt64
  
  function cmp_log'1 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord74] if UInt64.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'1_spec : forall x : UInt64.t, y : UInt64.t . [%#sord73] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord71] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord72] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord69] cmp_log'1 x y = C_Less'0)
   -> ([%#sord70] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'1_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord66] cmp_log'1 x y
  = o)  -> ([%#sord67] cmp_log'1 y z = o)  -> ([%#sord68] cmp_log'1 x z = o)
  
  function refl'1 (x : UInt64.t) : ()
  
  axiom refl'1_spec : forall x : UInt64.t . [%#sord65] cmp_log'1 x x = C_Equal'0
  
  use prelude.prelude.UInt64
  
  function cmp_gt_log'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'1_spec : forall x : UInt64.t, y : UInt64.t . [%#sord64] UInt64.ugt x y
  = (cmp_log'1 x y = C_Greater'0)
  
  use prelude.prelude.UInt64
  
  function cmp_ge_log'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'1_spec : forall x : UInt64.t, y : UInt64.t . [%#sord63] UInt64.uge x y = (cmp_log'1 x y <> C_Less'0)
  
  function cmp_lt_log'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'1_spec : forall x : UInt64.t, y : UInt64.t . [%#sord62] UInt64.ult x y = (cmp_log'1 x y = C_Less'0)
  
  use prelude.prelude.UInt64
  
  function cmp_le_log'1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'1_spec : forall x : UInt64.t, y : UInt64.t . [%#sord61] UInt64.ule x y
  = (cmp_log'1 x y <> C_Greater'0)
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function interp'0 [#"bdd.rs" 212 4 212 53] (self : t_Bdd'0) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd31] match self with
      | {t_Bdd__0'0 = C_True'0} -> true
      | {t_Bdd__0'0 = C_False'0} -> false
      | {t_Bdd__0'0 = C_If'0 v childt childf} -> if Map.get vars v then interp'0 childt vars else interp'0 childf vars
      end
  
  use map.Map
  
  function view'7 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'2) : Map.map UInt64.t (t_Option'1)
  
  use map.Map
  
  predicate invariant'1 [#"bdd.rs" 265 4 265 30] (self : t_Context'0) =
    [%#sbdd56] (forall n : t_NodeLog'0 . match Map.get (view'3 self.t_Context__hashcons'0) n with
      | C_Some'1 b -> view'4 b.t_Bdd__0'0 = n
      /\ is_valid_node'0 self b.t_Bdd__0'0
      /\ UInt64.ult b.t_Bdd__1'0 self.t_Context__cnt'0
      /\ Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) b.t_Bdd__1'0 = b.t_Bdd__0'0
      | C_None'1 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'7 self.t_Context__not_memo'0) bm with
      | C_None'1 -> true
      | C_Some'1 n -> let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) bm;
                                t_Bdd__1'0 = bm } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (UInt64.t, UInt64.t) . match Map.get (view'1 self.t_Context__and_memo'0) abm with
      | C_None'1 -> true
      | C_Some'1 n -> let a = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (a, _) = abm in a);
                                t_Bdd__1'0 = (let (a, _) = abm in a) } in let b = { t_Bdd__0'0 = Map.get (Snapshot.inner self.t_Context__hashcons_ghost'0) (let (_, a) = abm in a);
                                                                                    t_Bdd__1'0 = (let (_, a) = abm in a) } in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map UInt64.t bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_1 : t_Context'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Context'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Context__alloc'0 = alloc ; t_Context__hashcons'0 = hashcons ; t_Context__hashcons_ghost'0 = hashcons_ghost ; t_Context__not_memo'0 = not_memo ; t_Context__and_memo'0 = and_memo ; t_Context__cnt'0 = cnt} -> true
    end)
  
  predicate invariant'0 (self : borrowed (t_Context'0)) =
    [%#sinvariant42] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_1 : borrowed (t_Context'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Context'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 (self : borrowed (t_Context'0)) =
    [%#sresolve37] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Context'0)) =
    resolve'1 _1
  
  let rec v_If'0 (input:t_Node'0) (ret  (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0))= any
    [ good (v:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0)-> {C_If'0 v childt childf = input}
      (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd'0, childf : t_Bdd'0 [C_If'0 v childt childf : t_Node'0] . C_If'0 v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  function deep_model'1 (self : UInt64.t) : int =
    [%#snum38] UInt64.t'int self
  
  function cmp_log'0 (self : int) (o : int) : t_Ordering'0 =
    [%#sord39] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : int) (y : int) : ()
  
  axiom eq_cmp'0_spec : forall x : int, y : int . [%#sord55] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : int) (y : int) : ()
  
  axiom antisym2'0_spec : forall x : int, y : int . ([%#sord53] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord54] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : int) (y : int) : ()
  
  axiom antisym1'0_spec : forall x : int, y : int . ([%#sord51] cmp_log'0 x y = C_Less'0)
   -> ([%#sord52] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : int) (y : int) (z : int) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : int, y : int, z : int, o : t_Ordering'0 . ([%#sord48] cmp_log'0 x y = o)
   -> ([%#sord49] cmp_log'0 y z = o)  -> ([%#sord50] cmp_log'0 x z = o)
  
  function refl'0 (x : int) : ()
  
  axiom refl'0_spec : forall x : int . [%#sord47] cmp_log'0 x x = C_Equal'0
  
  function cmp_gt_log'0 (x : int) (y : int) : ()
  
  axiom cmp_gt_log'0_spec : forall x : int, y : int . [%#sord46] (x > y) = (cmp_log'0 x y = C_Greater'0)
  
  function cmp_ge_log'0 (x : int) (y : int) : ()
  
  axiom cmp_ge_log'0_spec : forall x : int, y : int . [%#sord45] (x >= y) = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : int) (y : int) : ()
  
  axiom cmp_lt_log'0_spec : forall x : int, y : int . [%#sord44] (x < y) = (cmp_log'0 x y = C_Less'0)
  
  function cmp_le_log'0 (x : int) (y : int) : ()
  
  axiom cmp_le_log'0_spec : forall x : int, y : int . [%#sord43] (x <= y) = (cmp_log'0 x y <> C_Greater'0)
  
  let rec cmp'0 (self:UInt64.t) (other:UInt64.t) (return'  (ret:t_Ordering'0))= any
    [ return' (result:t_Ordering'0)-> {[%#scmp12] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate grows'0 [#"bdd.rs" 299 4 299 35] (self : borrowed (t_Context'0)) =
    [%#sbdd30] UInt64.t'int (self.current).t_Context__cnt'0 <= UInt64.t'int (self.final).t_Context__cnt'0
    /\ (forall n : t_NodeLog'0 . match Map.get (view'3 (self.current).t_Context__hashcons'0) n with
      | C_Some'1 b -> Map.get (view'3 (self.final).t_Context__hashcons'0) n = C_Some'1 b
      | C_None'1 -> true
      end)
  
  let rec node'0 (self:borrowed (t_Context'0)) (x:UInt64.t) (childt:t_Bdd'0) (childf:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:node 'self' type invariant] [%#sbdd13] inv'0 self}
    {[@expl:node requires #0] [%#sbdd14] is_valid_bdd'0 self.current childt}
    {[@expl:node requires #1] [%#sbdd15] is_valid_bdd'0 self.current childf}
    {[@expl:node requires #2] [%#sbdd16] UInt64.t'int x < leastvar'0 childt /\ UInt64.t'int x < leastvar'0 childf}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd17] grows'0 self}
      {[%#sbdd18] is_valid_bdd'0 self.final result}
      {[%#sbdd19] forall v : Map.map UInt64.t bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#sbdd20] UInt64.t'int x <= leastvar'0 result}
      (! return' {result}) ]
    
  
  let rec falseqy95z'0 (self:borrowed (t_Context'0)) (return'  (ret:t_Bdd'0))= {[@expl:false_ 'self' type invariant] [%#sbdd21] inv'0 self}
    any
    [ return' (result:t_Bdd'0)-> {[%#sbdd22] grows'0 self}
      {[%#sbdd23] is_valid_bdd'0 self.final result}
      {[%#sbdd24] forall v : Map.map UInt64.t bool . not interp'0 result v}
      {[%#sbdd25] UInt64.t'int (v_MAX'0 : UInt64.t) + 1 = leastvar'0 result}
      (! return' {result}) ]
    
  
  predicate inv'4 (_1 : (t_Bdd'0, t_Bdd'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : (t_Bdd'0, t_Bdd'0) [inv'4 x] . inv'4 x = true
  
  predicate inv'5 (_1 : t_Bdd'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Bdd'0 [inv'5 x] . inv'5 x = true
  
  function view'2 (self : borrowed (t_MyHashMap'0)) : Map.map (UInt64.t, UInt64.t) (t_Option'1) =
    [%#smodel41] view'1 self.current
  
  let rec add'0 (self:borrowed (t_MyHashMap'0)) (key:(t_Bdd'0, t_Bdd'0)) (val':t_Bdd'0) (return'  (ret:()))= {[@expl:add 'key' type invariant] [%#sbdd26] inv'4 key}
    {[@expl:add 'val' type invariant] [%#sbdd27] inv'5 val'}
    any
    [ return' (result:())-> {[%#sbdd28] forall i : (UInt64.t, UInt64.t) . Map.get (view'1 self.final) i
      = (if i = deep_model'2 key then C_Some'1 val' else Map.get (view'2 self) i)}
      (! return' {result}) ]
    
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Bdd'0))= any
    [ good (field_0:t_Bdd'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  function size'0 [#"bdd.rs" 227 4 227 24] (self : t_Bdd'0) : int =
    [%#sbdd34] match self with
      | {t_Bdd__0'0 = C_True'0} -> 0
      | {t_Bdd__0'0 = C_False'0} -> 0
      | {t_Bdd__0'0 = C_If'0 _ childt childf} -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : t_Bdd'0 . [%#sbdd33] size'0 self >= 0
  
  meta "compute_max_steps" 1000000
  
  let rec and'0 (self:borrowed (t_Context'0)) (a:t_Bdd'0) (b:t_Bdd'0) (return'  (ret:t_Bdd'0))= {[@expl:and 'self' type invariant] [%#sbdd1] inv'0 self}
    {[@expl:and requires #0] [%#sbdd2] is_valid_bdd'0 self.current a}
    {[@expl:and requires #1] [%#sbdd3] is_valid_bdd'0 self.current b}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- (a, b) ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = get'0 {(self.current).t_Context__and_memo'0} {_15} (fun (_ret':t_Option'0) ->  [ &_12 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = any [ br0 -> {_12 = C_None'0 } (! bb4) | br1 (x0:t_Bdd'0)-> {_12 = C_Some'0 x0} (! bb2) ] 
    | bb4 = s0
      [ s0 =  [ &_23 <- (a.t_Bdd__0'0, b.t_Bdd__0'0) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = C_False'0 } (! bb5)
        | br1 -> {(let (r'0, _) = _23 in r'0) = C_True'0 } (! bb6)
        | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (r'0, _) = _23 in r'0) = C_If'0 x0 x1 x2} (! bb5) ]
         ]
      
    | bb5 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = C_False'0 } (! bb7)
      | br1 -> {(let (_, r'0) = _23 in r'0) = C_True'0 } (! bb8)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (_, r'0) = _23 in r'0) = C_If'0 x0 x1 x2} (! bb7) ]
      
    | bb7 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = C_False'0 } (! bb13)
      | br1 -> {(let (r'0, _) = _23 in r'0) = C_True'0 } (! bb9)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (r'0, _) = _23 in r'0) = C_If'0 x0 x1 x2} (! bb9) ]
      
    | bb9 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = C_False'0 } (! bb13)
      | br1 -> {(let (_, r'0) = _23 in r'0) = C_True'0 } (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (_, r'0) = _23 in r'0) = C_If'0 x0 x1 x2} (! bb11) ]
      
    | bb11 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = C_False'0 } (! bb10)
      | br1 -> {(let (r'0, _) = _23 in r'0) = C_True'0 } (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd'0) (x2:t_Bdd'0)-> {(let (r'0, _) = _23 in r'0) = C_If'0 x0 x1 x2} (! bb12) ]
      
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {[%#sbdd0] false} any ]
      
    | bb12 = s0
      [ s0 = v_If'0 {let (r'0, _) = _23 in r'0}
          (fun (rv'0:UInt64.t) (rchildt'0:t_Bdd'0) (rchildf'0:t_Bdd'0) ->  [ &va <- rv'0 ] s1)
      | s1 = v_If'0 {let (r'1, _) = _23 in r'1}
          (fun (rv'1:UInt64.t) (rchildt'1:t_Bdd'0) (rchildf'1:t_Bdd'0) ->  [ &childta <- rchildt'1 ] s2)
      | s2 = v_If'0 {let (r'2, _) = _23 in r'2}
          (fun (rv'2:UInt64.t) (rchildt'2:t_Bdd'0) (rchildf'2:t_Bdd'0) ->  [ &childfa <- rchildf'2 ] s3)
      | s3 = v_If'0 {let (_, r'3) = _23 in r'3}
          (fun (rv'3:UInt64.t) (rchildt'3:t_Bdd'0) (rchildf'3:t_Bdd'0) ->  [ &vb <- rv'3 ] s4)
      | s4 = v_If'0 {let (_, r'4) = _23 in r'4}
          (fun (rv'4:UInt64.t) (rchildt'4:t_Bdd'0) (rchildf'4:t_Bdd'0) ->  [ &childtb <- rchildt'4 ] s5)
      | s5 = v_If'0 {let (_, r'5) = _23 in r'5}
          (fun (rv'5:UInt64.t) (rchildt'5:t_Bdd'0) (rchildf'5:t_Bdd'0) ->  [ &childfb <- rchildf'5 ] s6)
      | s6 =  [ &_45 <- vb ] s7
      | s7 = cmp'0 {va} {_45} (fun (_ret':t_Ordering'0) ->  [ &_42 <- _ret' ] s8)
      | s8 = bb18 ]
      
    | bb18 = any
      [ br0 -> {_42 = C_Less'0 } (! bb21) | br1 -> {_42 = C_Equal'0 } (! bb22) | br2 -> {_42 = C_Greater'0 } (! bb20) ]
      
    | bb20 = bb23
    | bb23 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_49 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_49} {a} {childtb} (fun (_ret':t_Bdd'0) ->  [ &_48 <- _ret' ] s3)
      | s3 = bb24 ]
      
    | bb24 = s0
      [ s0 =  [ &childt <- _48 ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_53 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_53} {a} {childfb} (fun (_ret':t_Bdd'0) ->  [ &_52 <- _ret' ] s3)
      | s3 = bb25 ]
      
    | bb25 = s0 [ s0 =  [ &childf <- _52 ] s1 | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_67 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_67} {childta} {childtb} (fun (_ret':t_Bdd'0) ->  [ &_66 <- _ret' ] s3)
      | s3 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_71 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_71} {childfa} {childfb} (fun (_ret':t_Bdd'0) ->  [ &_70 <- _ret' ] s3)
      | s3 = bb30 ]
      
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] s1 | s1 = bb31 ] 
    | bb21 = bb26
    | bb26 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_58 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_58} {childta} {b} (fun (_ret':t_Bdd'0) ->  [ &_57 <- _ret' ] s3)
      | s3 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] s1
      | s1 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_62 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = and'0 {_62} {childfa} {b} (fun (_ret':t_Bdd'0) ->  [ &_61 <- _ret' ] s3)
      | s3 = bb28 ]
      
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] s1 | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_74 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = node'0 {_74} {v} {childt} {childf} (fun (_ret':t_Bdd'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb32 ]
      
    | bb32 = bb33
    | bb13 = bb16
    | bb16 = s0
      [ s0 = {inv'1 self.current}
        Borrow.borrow_mut <t_Context'0> {self.current}
          (fun (_ret':borrowed (t_Context'0)) ->
             [ &_31 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = falseqy95z'0 {_31} (fun (_ret':t_Bdd'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = bb33
    | bb8 = bb15
    | bb15 = s0 [ s0 =  [ &r1 <- a ] s1 | s1 = bb33 ] 
    | bb6 = bb14
    | bb14 = s0 [ s0 =  [ &r1 <- b ] s1 | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = Borrow.borrow_final
          <t_MyHashMap'0>
          {(self.current).t_Context__and_memo'0}
          {Borrow.inherit_id (Borrow.get_id self) 5}
          (fun (_ret':borrowed (t_MyHashMap'0)) ->
             [ &_79 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Context__and_memo'0 = _ret'.final } } ] 
            s1)
      | s1 =  [ &_80 <- (a, b) ] s2
      | s2 = add'0 {_79} {_80} {r1} (fun (_ret':()) ->  [ &_78 <- _ret' ] s3)
      | s3 = bb34 ]
      
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb35 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_12} (fun (r0'0:t_Bdd'0) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb35 ]
      
    | bb35 = return' {_0} ]
    )
    [ & _0 : t_Bdd'0 = any_l ()
    | & self : borrowed (t_Context'0) = self
    | & a : t_Bdd'0 = a
    | & b : t_Bdd'0 = b
    | & _12 : t_Option'0 = any_l ()
    | & _15 : (t_Bdd'0, t_Bdd'0) = any_l ()
    | & _16 : (t_Bdd'0, t_Bdd'0) = any_l ()
    | & r : t_Bdd'0 = any_l ()
    | & r1 : t_Bdd'0 = any_l ()
    | & _23 : (t_Node'0, t_Node'0) = any_l ()
    | & _31 : borrowed (t_Context'0) = any_l ()
    | & va : UInt64.t = any_l ()
    | & childta : t_Bdd'0 = any_l ()
    | & childfa : t_Bdd'0 = any_l ()
    | & vb : UInt64.t = any_l ()
    | & childtb : t_Bdd'0 = any_l ()
    | & childfb : t_Bdd'0 = any_l ()
    | & v : UInt64.t = any_l ()
    | & childt : t_Bdd'0 = any_l ()
    | & childf : t_Bdd'0 = any_l ()
    | & _42 : t_Ordering'0 = any_l ()
    | & _45 : UInt64.t = any_l ()
    | & _48 : t_Bdd'0 = any_l ()
    | & _49 : borrowed (t_Context'0) = any_l ()
    | & _52 : t_Bdd'0 = any_l ()
    | & _53 : borrowed (t_Context'0) = any_l ()
    | & _57 : t_Bdd'0 = any_l ()
    | & _58 : borrowed (t_Context'0) = any_l ()
    | & _61 : t_Bdd'0 = any_l ()
    | & _62 : borrowed (t_Context'0) = any_l ()
    | & _66 : t_Bdd'0 = any_l ()
    | & _67 : borrowed (t_Context'0) = any_l ()
    | & _70 : t_Bdd'0 = any_l ()
    | & _71 : borrowed (t_Context'0) = any_l ()
    | & _74 : borrowed (t_Context'0) = any_l ()
    | & _78 : () = any_l ()
    | & _79 : borrowed (t_MyHashMap'0) = any_l ()
    | & _80 : (t_Bdd'0, t_Bdd'0) = any_l () ]
    
    [ return' (result:t_Bdd'0)-> {[@expl:and ensures #0] [%#sbdd4] grows'0 self}
      {[@expl:and ensures #1] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:and ensures #2] [%#sbdd6] forall v : Map.map UInt64.t bool . interp'0 result v
      = (interp'0 a v /\ interp'0 b v)}
      {[@expl:and ensures #3] [%#sbdd7] leastvar'0 a <= leastvar'0 result \/ leastvar'0 b <= leastvar'0 result}
      (! return' {result}) ]
    
end
module M_bdd__hashmap__qyi11648407051195780326__hash__refines [#"bdd.rs" 79 8 79 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 79 8 79 29
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd2 = "bdd.rs" 86 24 86 84
  let%span stuples3 = "../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Borrow
  
  type t_U'0
  
  type t_V'0
  
  predicate inv'2 (_1 : t_U'0)
  
  predicate inv'3 (_1 : t_V'0)
  
  predicate inv'1 (_1 : (t_U'0, t_V'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : (t_U'0, t_V'0) [inv'1 x] . inv'1 x
  = (let (x0, x1) = x in inv'2 x0 /\ inv'3 x1)
  
  predicate invariant'0 (self : (t_U'0, t_V'0)) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : (t_U'0, t_V'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (t_U'0, t_V'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  type t_DeepModelTy'0
  
  type t_DeepModelTy'1
  
  function deep_model'2 (self : t_U'0) : t_DeepModelTy'0
  
  function deep_model'3 (self : t_V'0) : t_DeepModelTy'1
  
  function deep_model'1 (self : (t_U'0, t_V'0)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#stuples3] (deep_model'2 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  function deep_model'0 (self : (t_U'0, t_V'0)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#smodel1] deep_model'1 self
  
  function hash_log'1 [#"bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'0) : int
  
  function hash_log'2 [#"bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'1) : int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log'0 [#"bdd.rs" 85 8 85 48] (x : (t_DeepModelTy'0, t_DeepModelTy'1)) : int =
    [%#sbdd2] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.t'int (v_MAX'0 : UInt64.t) + 1)
  
  goal refines : [%#sbdd0] forall self : (t_U'0, t_V'0) . inv'0 self
   -> inv'0 self
  /\ (forall result : UInt64.t . UInt64.t'int result = hash_log'0 (deep_model'0 self)
   -> UInt64.t'int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi699402059438633899__hash__refines [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 119 4 119 25
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd2 = "bdd.rs" 133 12 138 13
  let%span smodel3 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd4 = "bdd.rs" 179 20 179 37
  let%span sbdd5 = "bdd.rs" 163 12 167 13
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'1 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd5] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function view'1 [#"bdd.rs" 178 4 178 33] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd4] deep_model'1 self
  
  function view'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel1] view'1 self
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log'0 [#"bdd.rs" 131 4 131 44] (x : t_NodeLog'0) : int =
    [%#sbdd2] match x with
      | C_False'1 -> 1
      | C_True'1 -> 2
      | C_If'1 v childt childf -> mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int (v_MAX'0 : UInt64.t) + 1)
      end
  
  function deep_model'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel3] deep_model'1 self
  
  goal refines : [%#sbdd0] forall self : t_Node'0 . inv'0 self
   -> (forall result : UInt64.t . UInt64.t'int result = hash_log'0 (view'0 self)
   -> UInt64.t'int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi14323183011761258016__hash__refines [#"bdd.rs" 145 4 145 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "bdd.rs" 145 4 145 25
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sbdd2 = "bdd.rs" 152 20 152 22
  let%span smodel3 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd4 = "bdd.rs" 199 20 199 37
  let%span sbdd5 = "bdd.rs" 189 20 189 26
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Bdd'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Bdd'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  function deep_model'1 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd5] self.t_Bdd__1'0
  
  function view'1 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd4] deep_model'1 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel1] view'1 self
  
  function hash_log'0 [#"bdd.rs" 151 4 151 44] (x : UInt64.t) : int =
    [%#sbdd2] UInt64.t'int x
  
  function deep_model'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel3] deep_model'1 self
  
  goal refines : [%#sbdd0] forall self : t_Bdd'0 . inv'0 self
   -> (forall result : UInt64.t . UInt64.t'int result = hash_log'0 (view'0 self)
   -> UInt64.t'int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq__refines [#"bdd.rs" 93 9 93 11] (* <Node<'arena> as std::cmp::Eq> *)
  let%span sbdd0 = "bdd.rs" 93 9 93 11
  
  goal refines : [%#sbdd0] true
end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq__refines [#"bdd.rs" 107 15 107 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  let%span sbdd0 = "bdd.rs" 107 15 107 17
  
  goal refines : [%#sbdd0] true
end
module M_bdd__qyi4854841669736991510__eq__refines [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "bdd.rs" 93 13 93 22
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd2 = "bdd.rs" 163 12 167 13
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x = true
  
  type t_NodeLog'0  =
    | C_False'1
    | C_True'1
    | C_If'1 UInt64.t UInt64.t UInt64.t
  
  function deep_model'1 [#"bdd.rs" 161 4 161 44] (self : t_Node'0) : t_NodeLog'0 =
    [%#sbdd2] match self with
      | C_False'0 -> C_False'1
      | C_True'0 -> C_True'1
      | C_If'0 v childt childf -> C_If'1 v (childt.t_Bdd__1'0) (childf.t_Bdd__1'0)
      end
  
  function deep_model'0 (self : t_Node'0) : t_NodeLog'0 =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sbdd0] forall self : t_Node'0 . forall other : t_Node'0 . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_bdd__qyi2581120635339165136__eq__refines [#"bdd.rs" 205 4 205 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "bdd.rs" 205 4 205 34
  let%span smodel1 = "../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span smodel2 = "../../../creusot-contracts/src/model.rs" 79 8 79 28
  let%span sbdd3 = "bdd.rs" 199 20 199 37
  let%span sbdd4 = "bdd.rs" 189 20 189 26
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Bdd'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Bdd'0 [inv'0 x] . inv'0 x = true
  
  function deep_model'1 [#"bdd.rs" 188 4 188 44] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd4] self.t_Bdd__1'0
  
  function view'1 [#"bdd.rs" 198 4 198 33] (self : t_Bdd'0) : UInt64.t =
    [%#sbdd3] deep_model'1 self
  
  function view'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel1] view'1 self
  
  function deep_model'0 (self : t_Bdd'0) : UInt64.t =
    [%#smodel2] deep_model'1 self
  
  goal refines : [%#sbdd0] forall self : t_Bdd'0 . forall other : t_Bdd'0 . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (view'0 self = view'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_bdd__qyi17981791245757283426__clone__refines [#"bdd.rs" 93 24 93 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "bdd.rs" 93 24 93 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  with t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sbdd0] forall self : t_Node'0 . inv'0 self
   -> (forall result : t_Node'0 . result = self  -> result = self /\ inv'1 result)
end
module M_bdd__qyi2820858787824331484__clone__refines [#"bdd.rs" 112 4 112 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "bdd.rs" 112 4 112 27
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Node'0  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t (t_Bdd'0) (t_Bdd'0)
  with t_Bdd'0  =
    { t_Bdd__0'0: t_Node'0; t_Bdd__1'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Bdd'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Bdd'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Bdd'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Bdd'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sbdd0] forall self : t_Bdd'0 . inv'0 self
   -> (forall result : t_Bdd'0 . result = self  -> result = self /\ inv'1 result)
end
