
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Bdd_Hashmap_Impl2_Hash
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 81 66 81 68
  
  let%span sbdd1 = "../bdd.rs" 80 17 80 21
  
  let%span sbdd2 = "../bdd.rs" 79 18 79 62
  
  let%span span3 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 87 24 87 84
  
  let%span span7 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "" 0 0 0 0
  
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span19 = "../bdd.rs" 35 17 35 21
  
  let%span span20 = "../bdd.rs" 34 18 34 62
  
  predicate invariant'5 (self : v)
  
  predicate inv'5 (_x : v)
  
  axiom inv'5 : forall x : v . inv'5 x = true
  
  predicate invariant'4 (self : u)
  
  predicate inv'4 (_x : u)
  
  axiom inv'4 : forall x : u . inv'4 x = true
  
  predicate invariant'3 (self : (u, v)) =
    [%#span3] true
  
  predicate inv'3 (_x : (u, v))
  
  axiom inv'3 : forall x : (u, v) . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : v) =
    [%#span4] inv'5 self
  
  predicate inv'2 (_x : v)
  
  axiom inv'2 : forall x : v . inv'2 x = true
  
  predicate invariant'1 (self : u) =
    [%#span4] inv'4 self
  
  predicate inv'1 (_x : u)
  
  axiom inv'1 : forall x : u . inv'1 x = true
  
  predicate invariant'0 (self : (u, v)) =
    [%#span4] inv'3 self
  
  predicate inv'0 (_x : (u, v))
  
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  type deep_model_ty'1
  
  function hash_log'2 [#"../bdd.rs" 38 8 38 49] (_1 : deep_model_ty'1) : int
  
  type deep_model_ty'0
  
  function hash_log'1 [#"../bdd.rs" 38 8 38 49] (_1 : deep_model_ty'0) : int
  
  function hash_log'0 [#"../bdd.rs" 86 8 86 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [%#span6] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  
  function deep_model'5 (self : v) : deep_model_ty'1
  
  function deep_model'4 (self : u) : deep_model_ty'0
  
  function deep_model'3 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span7] (deep_model'4 (let (a, _) = self in a), deep_model'5 (let (_, a) = self in a))
  
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span8] deep_model'3 self
  
  use prelude.prelude.Intrinsic
  
  constant min'0 : uint64 = [%#span9] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant bits'0 : uint32 = [%#span10] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span14] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span13] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span12] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span11] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span18] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span17] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span16] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span15] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  function deep_model'2 (self : v) : deep_model_ty'1 =
    [%#span8] deep_model'5 self
  
  let rec hash'1 (self:v) (return'  (ret:uint64))= {[@expl:precondition] [%#span19] inv'2 self}
    any
    [ return' (result:uint64)-> {[%#span20] UInt64.to_int result = hash_log'2 (deep_model'2 self)}
      (! return' {result}) ]
    
  
  function deep_model'1 (self : u) : deep_model_ty'0 =
    [%#span8] deep_model'4 self
  
  let rec hash'0 (self:u) (return'  (ret:uint64))= {[@expl:precondition] [%#span19] inv'1 self}
    any
    [ return' (result:uint64)-> {[%#span20] UInt64.to_int result = hash_log'1 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  let rec hash (self:(u, v)) (return'  (ret:uint64))= {[%#sbdd1] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {let (r'0, _) = self in r'0} (fun (_ret':uint64) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = hash'1 {let (_, r'0) = self in r'0} (fun (_ret':uint64) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = wrapping_mul'0 {_6} {[%#sbdd0] (17 : uint64)} (fun (_ret':uint64) ->  [ &_5 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = wrapping_add'0 {_3} {_5} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : (u, v) = self
    | & _3 : uint64 = any_l ()
    | & _5 : uint64 = any_l ()
    | & _6 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd2] UInt64.to_int result = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Bdd_Type
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  type t_bdd  =
    | C_Bdd (t_node) uint64
  with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_bdd (input:t_bdd) (ret  (field_0:t_node) (field_1:uint64))= any
    [ good (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 <> input} {false} any ]
    
  
  let rec false' (input:t_node) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  
  let rec true' (input:t_node) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  
  let rec if' (input:t_node) (ret  (v:uint64) (childt:t_bdd) (childf:t_bdd))= any
    [ good (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf <> input} {false} any ]
    
  
  function bdd_1 (self : t_bdd) : uint64 =
    match self with
      | C_Bdd _ a -> a
      end
  
  function bdd_0 (self : t_bdd) : t_node =
    match self with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl12_AssertReceiverIsTotalEq
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  let rec assert_receiver_is_total_eq (self:Node'0.t_node) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl7_Eq
  let%span sbdd0 = "../bdd.rs" 205 14 205 37
  
  let%span span1 = "../bdd.rs" 190 20 190 26
  
  let%span span2 = "../bdd.rs" 200 20 200 37
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span1] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Node_Type as Node'0
  
  let rec eq (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_bdd {self}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Bdd'0.t_bdd {o}
              (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->
                UInt64.eq {r1'0} {r1'1} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)))
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & self : Bdd'0.t_bdd = self | & o : Bdd'0.t_bdd = o ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
end
module Bdd_NodeLog_Type
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec false' (input:t_nodelog) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  
  let rec true' (input:t_nodelog) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  
  let rec if' (input:t_nodelog) (ret  (v:uint64) (childt:uint64) (childf:uint64))= any
    [ good (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf <> input} {false} any ]
    
end
module Bdd_Impl13_Eq
  let%span sbdd0 = "../bdd.rs" 94 13 94 22
  
  let%span span1 = "../bdd.rs" 164 12 168 13
  
  let%span span2 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span3 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span4 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span5 = "../bdd.rs" 190 20 190 26
  
  let%span span6 = "../bdd.rs" 200 20 200 37
  
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span8 = "../bdd.rs" 205 14 205 37
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  function deep_model'2 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span1] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span2] deep_model'2 self
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function deep_model'3 (self : uint64) : int =
    [%#span3] UInt64.to_int self
  
  function deep_model'1 (self : uint64) : int =
    [%#span2] deep_model'3 self
  
  let rec eq'1 (self:uint64) (other:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span4] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'4 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span5] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span6] deep_model'4 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span7] shallow_model'1 self
  
  let rec eq'0 (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span8] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  let rec eq (self:Node'0.t_node) (rhs:Node'0.t_node) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- (self, rhs) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_False } (! bb2)
        | br1 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_True } (! bb4)
        | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _4 in r'0) = Node'0.C_If a b c} (! bb6) ]
         ]
      
    | bb6 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb25)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb25)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb25 = bb1
    | bb7 = bb10
    | bb10 = s0
      [ s0 = Node'0.if' {let (r'0, _) = _4 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.if' {let (r'1, _) = _4 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.if' {let (r'2, _) = _4 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 = Node'0.if' {let (_, r'3) = _4 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_bdd) (rchildf'3:Bdd'0.t_bdd) ->  [ &v_2 <- rv'3 ] s4)
      | s4 = Node'0.if' {let (_, r'4) = _4 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_bdd) (rchildf'4:Bdd'0.t_bdd) ->  [ &childt_2 <- rchildt'4 ] s5)
      | s5 = Node'0.if' {let (_, r'5) = _4 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_bdd) (rchildf'5:Bdd'0.t_bdd) ->  [ &childf_2 <- rchildf'5 ] s6)
      | s6 = eq'0 {childf_1} {childf_2} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s7)
      | s7 = bb11 ]
      
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq'0 {childt_1} {childt_2} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0 [ s0 = eq'1 {v_1} {v_2} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ] 
    | bb16 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb21 ] 
    | bb17 = bb20
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb4 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb1)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb5)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb5 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb2 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb3)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb1)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb22 ] 
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb22 = return' {_0} ]
    )
    [ & _0 : bool = any_l ()
    | & self : Node'0.t_node = self
    | & rhs : Node'0.t_node = rhs
    | & _4 : (Node'0.t_node, Node'0.t_node) = any_l ()
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_bdd = any_l ()
    | & childf_1 : Bdd'0.t_bdd = any_l ()
    | & v_2 : uint64 = any_l ()
    | & childt_2 : Bdd'0.t_bdd = any_l ()
    | & childf_2 : Bdd'0.t_bdd = any_l ()
    | & _17 : bool = any_l ()
    | & _20 : bool = any_l ()
    | & _23 : bool = any_l () ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (deep_model'0 self = deep_model'0 rhs)}
      (! return' {result}) ]
    
end
module Bdd_Impl0_Clone
  let%span sbdd0 = "../bdd.rs" 112 14 112 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec clone' (self:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : Bdd'0.t_bdd = any_l () | & self : Bdd'0.t_bdd = self ] 
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ]
    
end
module Bdd_Impl14_Clone
  let%span sbdd0 = "../bdd.rs" 94 24 94 29
  
  let%span span1 = "../bdd.rs" 112 14 112 29
  
  let%span span2 = "../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec clone'1 (self:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span1] result = self} (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  let rec clone'0 (self:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span2] result = self} (! return' {result}) ]
    
  
  use Bdd_Node_Type as Node'0
  
  let rec clone' (self:Node'0.t_node) (return'  (ret:Node'0.t_node))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb4 = s0
      [ s0 = Node'0.if' {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone'0 {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1
      | s1 = clone'1 {_12} (fun (_ret':Bdd'0.t_bdd) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1
      | s1 = clone'1 {_15} (fun (_ret':Bdd'0.t_bdd) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- Node'0.C_If _7 _10 _13 ] s1 | s1 = bb10 ] 
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- Node'0.C_True ] s1 | s1 = bb10 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- Node'0.C_False ] s1 | s1 = bb10 ] 
    | bb10 = return' {_0} ]
    )
    [ & _0 : Node'0.t_node = any_l ()
    | & self : Node'0.t_node = self
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_bdd = any_l ()
    | & childf_1 : Bdd'0.t_bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _10 : Bdd'0.t_bdd = any_l ()
    | & _12 : Bdd'0.t_bdd = any_l ()
    | & _13 : Bdd'0.t_bdd = any_l ()
    | & _15 : Bdd'0.t_bdd = any_l () ]
     [ return' (result:Node'0.t_node)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ] 
end
module Bdd_Impl17_AssertReceiverIsTotalEq
  use Bdd_Bdd_Type as Bdd'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  let rec assert_receiver_is_total_eq (self:Bdd'0.t_bdd) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl1_Hash
  let%span sbdd0 = "../bdd.rs" 125 53 125 54
  
  let%span sbdd1 = "../bdd.rs" 125 92 125 93
  
  let%span sbdd2 = "../bdd.rs" 123 20 123 21
  
  let%span sbdd3 = "../bdd.rs" 122 21 122 22
  
  let%span sbdd4 = "../bdd.rs" 119 14 119 46
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 134 12 139 13
  
  let%span span7 = "../bdd.rs" 164 12 168 13
  
  let%span span8 = "../bdd.rs" 180 20 180 37
  
  let%span span9 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span10 = "" 0 0 0 0
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function hash_log'0 [#"../bdd.rs" 132 4 132 44] (x : NodeLog'0.t_nodelog) : int =
    [%#span6] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_Node_Type as Node'0
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span7] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  constant min'0 : uint64 = [%#span10] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant bits'0 : uint32 = [%#span11] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span15] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span14] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span13] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span12] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span19] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span18] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span17] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span16] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec hash (self:Node'0.t_node) (return'  (ret:uint64))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb4 = s0
      [ s0 = Node'0.if' {self} (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v <- rv'0 ] s1)
      | s1 = Node'0.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt <- rchildt'1 ] s2)
      | s2 = Node'0.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf <- rchildf'2 ] s3)
      | s3 = Bdd'0.t_bdd {childt}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd0] (5 : uint64)} (fun (_ret':uint64) ->  [ &_9 <- _ret' ] s4))
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 = wrapping_add'0 {v} {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = Bdd'0.t_bdd {childf}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd1] (7 : uint64)} (fun (_ret':uint64) ->  [ &_11 <- _ret' ] s1))
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = wrapping_add'0 {_7} {_11} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = bb11
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd2] (2 : uint64) ] s1 | s1 = bb11 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd3] (1 : uint64) ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : Node'0.t_node = self
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _11 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl2_Hash
  let%span sbdd0 = "../bdd.rs" 145 14 145 46
  
  let%span span1 = "../bdd.rs" 153 8 153 24
  
  let%span span2 = "../bdd.rs" 190 20 190 26
  
  let%span span3 = "../bdd.rs" 200 20 200 37
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../bdd.rs" 152 4 152 44] (x : uint64) : int =
    [%#span1] UInt64.to_int x
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span4] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Node_Type as Node'0
  
  let rec hash (self:Bdd'0.t_bdd) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_bdd {self} (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->  [ &_0 <- r1'0 ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () | & self : Bdd'0.t_bdd = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd0] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl8_Size_Impl
  let%span sbdd0 = "../bdd.rs" 227 14 227 25
  
  use Bdd_Node_Type as Node'0
  
  use Bdd_Bdd_Type as Bdd'0
  
  use prelude.prelude.Int
  
  constant self  : Bdd'0.t_bdd
  
  function size [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_bdd) : int
  
  goal vc_size : match self with
    | Bdd'0.C_Bdd (Node'0.C_True) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_False) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> ([%#sbdd0] size childt >= 0)
     -> (let ht = size childt in ([%#sbdd0] size childf >= 0)  -> (let hf = size childf in [%#sbdd0] 1 + ht + hf >= 0))
    end
end
module Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd'0
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  use prelude.prelude.Borrow
  
  type t_context  =
    | C_Context (Bump'0.t_bump) (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec t_context (input:t_context) (ret  (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64))= any
    [ good (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      = input}
      (! ret {alloc} {hashcons} {hashcons_ghost} {not_memo} {and_memo} {cnt})
    | bad (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      <> input}
      {false}
      any ]
    
  
  function context_hashcons (self : t_context) : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ a _ _ _ _ -> a
      end
  
  function context_cnt (self : t_context) : uint64 =
    match self with
      | C_Context _ _ _ _ _ a -> a
      end
  
  function context_hashcons_ghost (self : t_context) : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) =
    match self with
      | C_Context _ _ a _ _ _ -> a
      end
  
  function context_not_memo (self : t_context) : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ _ _ a _ _ -> a
      end
  
  function context_and_memo (self : t_context) : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ _ _ _ a _ -> a
      end
end
module Bdd_Impl10_GrowsIsValidBdd_Impl
  let%span sbdd0 = "../bdd.rs" 337 15 337 27
  
  let%span sbdd1 = "../bdd.rs" 338 15 338 35
  
  let%span sbdd2 = "../bdd.rs" 339 14 339 37
  
  let%span span3 = "../bdd.rs" 164 12 168 13
  
  let%span span4 = "../bdd.rs" 180 20 180 37
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span6 = "../bdd.rs" 315 12 315 47
  
  let%span span7 = "../bdd.rs" 301 8 308 9
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Bdd_Context_Type as Context'0
  
  use prelude.prelude.Borrow
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Node_Type as Node'0
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span3] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span5] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span6] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span7] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_context)
  
  constant b  : Bdd'0.t_bdd
  
  function grows_is_valid_bdd [#"../bdd.rs" 340 4 340 56] (self : borrowed (Context'0.t_context)) (b : Bdd'0.t_bdd) : ()
  
  goal vc_grows_is_valid_bdd : ([%#sbdd1] is_valid_bdd'0 self.current b)
   -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd2] is_valid_bdd'0 self.final b)
end
module Bdd_Impl10_GrowsTrans_Impl
  let%span sbdd0 = "../bdd.rs" 344 15 344 27
  
  let%span sbdd1 = "../bdd.rs" 345 15 345 24
  
  let%span sbdd2 = "../bdd.rs" 346 15 346 26
  
  let%span sbdd3 = "../bdd.rs" 347 15 347 43
  
  let%span sbdd4 = "../bdd.rs" 348 14 348 24
  
  let%span span5 = "../bdd.rs" 301 8 308 9
  
  use Bdd_Context_Type as Context'0
  
  use prelude.prelude.Borrow
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use map.Map
  
  use Bdd_Node_Type as Node'0
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use map.Map
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span5] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_context)
  
  constant o  : borrowed (Context'0.t_context)
  
  constant oo  : borrowed (Context'0.t_context)
  
  function grows_trans [#"../bdd.rs" 349 4 349 62] (self : borrowed (Context'0.t_context)) (o : borrowed (Context'0.t_context)) (oo : borrowed (Context'0.t_context)) : ()
    
  
  goal vc_grows_trans : ([%#sbdd3] self.current = oo.current /\ self.final = oo.final)
   -> ([%#sbdd2] self.final = o.current)
   -> ([%#sbdd1] grows'0 o)  -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd4] grows'0 oo)
end
module Bdd_Impl10_SetIrreleventVar_Impl
  let%span sbdd0 = "../bdd.rs" 352 15 352 24
  
  let%span sbdd1 = "../bdd.rs" 353 15 353 35
  
  let%span sbdd2 = "../bdd.rs" 354 15 354 32
  
  let%span sbdd3 = "../bdd.rs" 355 14 355 50
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 245 12 249 13
  
  let%span span7 = "../bdd.rs" 215 12 222 13
  
  let%span span8 = "../bdd.rs" 164 12 168 13
  
  let%span span9 = "../bdd.rs" 180 20 180 37
  
  let%span span10 = "../bdd.rs" 315 12 315 47
  
  let%span span11 = "../bdd.rs" 322 12 331 13
  
  let%span span12 = "../bdd.rs" 268 12 292 19
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span4] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span6] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span10] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span11] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span12] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Map
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant x  : uint64
  
  constant v  : Map.map uint64 bool
  
  constant b  : bool
  
  function set_irrelevent_var [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  
  goal vc_set_irrelevent_var : ([%#sbdd2] UInt64.to_int x < leastvar'0 a)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> match a with
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> (([%#sbdd2] UInt64.to_int x < leastvar'0 childt)
    && ([%#sbdd1] is_valid_bdd'0 self childt) && ([%#sbdd0] inv'0 self))
    /\ (([%#sbdd3] interp'0 childt v = interp'0 childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([%#sbdd2] UInt64.to_int x < leastvar'0 childf)
    && ([%#sbdd1] is_valid_bdd'0 self childf) && ([%#sbdd0] inv'0 self))
    /\ (([%#sbdd3] interp'0 childf v = interp'0 childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)))))
    | _ -> [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)
    end
end
module Bdd_Impl10_DiscrValuation_Impl
  let%span sbdd0 = "../bdd.rs" 369 15 369 24
  
  let%span sbdd1 = "../bdd.rs" 370 15 370 35
  
  let%span sbdd2 = "../bdd.rs" 371 15 371 35
  
  let%span sbdd3 = "../bdd.rs" 372 15 372 21
  
  let%span sbdd4 = "../bdd.rs" 373 14 373 50
  
  let%span sbdd5 = "../bdd.rs" 374 14 374 33
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 245 12 249 13
  
  let%span span9 = "../bdd.rs" 215 12 222 13
  
  let%span span10 = "../bdd.rs" 164 12 168 13
  
  let%span span11 = "../bdd.rs" 180 20 180 37
  
  let%span span12 = "../bdd.rs" 315 12 315 47
  
  let%span span13 = "../bdd.rs" 322 12 331 13
  
  let%span span14 = "../bdd.rs" 268 12 292 19
  
  let%span span15 = "../bdd.rs" 352 15 352 24
  
  let%span span16 = "../bdd.rs" 353 15 353 35
  
  let%span span17 = "../bdd.rs" 354 15 354 32
  
  let%span span18 = "../bdd.rs" 355 14 355 50
  
  let%span span19 = "../bdd.rs" 358 12 364 13
  
  let%span span20 = "../bdd.rs" 227 14 227 25
  
  let%span span21 = "../bdd.rs" 230 12 238 13
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span19] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span15] inv'0 self)
   -> ([%#span16] is_valid_bdd'0 self a)
   -> ([%#span17] UInt64.to_int x < leastvar'0 a)  -> ([%#span18] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_bdd) : int =
    [%#span21] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span20] size'0 self >= 0
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant b  : Bdd'0.t_bdd
  
  function discr_valuation [#"../bdd.rs" 376 4 376 82] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : Map.map uint64 bool
    
  
  goal vc_discr_valuation : ([%#sbdd3] a <> b)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> (let _ = set_irrelevent_var'0 in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> b then
        ((([%#sbdd3] childf <> b)
        && ([%#sbdd2] is_valid_bdd'0 self b) && ([%#sbdd1] is_valid_bdd'0 self childf) && ([%#sbdd0] inv'0 self))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childf + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childf (discr_valuation self childf b) <> interp'0 b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      else
        ((([%#sbdd3] childt <> b)
        && ([%#sbdd2] is_valid_bdd'0 self b) && ([%#sbdd1] is_valid_bdd'0 self childt) && ([%#sbdd0] inv'0 self))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childt + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childt (discr_valuation self childt b) <> interp'0 b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      
      | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> a then
          ((([%#sbdd3] a <> childf)
          && ([%#sbdd2] is_valid_bdd'0 self childf) && ([%#sbdd1] is_valid_bdd'0 self a) && ([%#sbdd0] inv'0 self))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childf) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childf) <> interp'0 childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        else
          ((([%#sbdd3] a <> childt)
          && ([%#sbdd2] is_valid_bdd'0 self childt) && ([%#sbdd1] is_valid_bdd'0 self a) && ([%#sbdd0] inv'0 self))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childt) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childt) <> interp'0 childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    else
      match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> if childfa <> childfb then
            ((([%#sbdd3] childfa <> childfb)
            && ([%#sbdd2] is_valid_bdd'0 self childfb)
            && ([%#sbdd1] is_valid_bdd'0 self childfa) && ([%#sbdd0] inv'0 self))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childfa + size'0 childfb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childfa (discr_valuation self childfa childfb)
            <> interp'0 childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          else
            ((([%#sbdd3] childta <> childtb)
            && ([%#sbdd2] is_valid_bdd'0 self childtb)
            && ([%#sbdd1] is_valid_bdd'0 self childta) && ([%#sbdd0] inv'0 self))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childta + size'0 childtb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childta (discr_valuation self childta childtb)
            <> interp'0 childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          
          | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
          end
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    
  )
end
module Bdd_Impl10_BddCanonical_Impl
  let%span sbdd0 = "../bdd.rs" 419 15 419 24
  
  let%span sbdd1 = "../bdd.rs" 420 15 420 35
  
  let%span sbdd2 = "../bdd.rs" 421 15 421 35
  
  let%span sbdd3 = "../bdd.rs" 422 4 422 56
  
  let%span sbdd4 = "../bdd.rs" 423 14 423 20
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../bdd.rs" 245 12 249 13
  
  let%span span8 = "../bdd.rs" 215 12 222 13
  
  let%span span9 = "../bdd.rs" 164 12 168 13
  
  let%span span10 = "../bdd.rs" 180 20 180 37
  
  let%span span11 = "../bdd.rs" 315 12 315 47
  
  let%span span12 = "../bdd.rs" 322 12 331 13
  
  let%span span13 = "../bdd.rs" 268 12 292 19
  
  let%span span14 = "../bdd.rs" 352 15 352 24
  
  let%span span15 = "../bdd.rs" 353 15 353 35
  
  let%span span16 = "../bdd.rs" 354 15 354 32
  
  let%span span17 = "../bdd.rs" 355 14 355 50
  
  let%span span18 = "../bdd.rs" 358 12 364 13
  
  let%span span19 = "../bdd.rs" 227 14 227 25
  
  let%span span20 = "../bdd.rs" 230 12 238 13
  
  let%span span21 = "../bdd.rs" 369 15 369 24
  
  let%span span22 = "../bdd.rs" 370 15 370 35
  
  let%span span23 = "../bdd.rs" 371 15 371 35
  
  let%span span24 = "../bdd.rs" 372 15 372 21
  
  let%span span25 = "../bdd.rs" 373 14 373 50
  
  let%span span26 = "../bdd.rs" 374 14 374 33
  
  let%span span27 = "../bdd.rs" 378 12 378 36
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span5] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span11] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span13] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span18] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span14] inv'0 self)
   -> ([%#span15] is_valid_bdd'0 self a)
   -> ([%#span16] UInt64.to_int x < leastvar'0 a)  -> ([%#span17] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_bdd) : int =
    [%#span20] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span19] size'0 self >= 0
  
  function discr_valuation'0 [#"../bdd.rs" 376 4 376 82] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : Map.map uint64 bool
    
  
  axiom discr_valuation'0_def : forall self : Context'0.t_context, a : Bdd'0.t_bdd, b : Bdd'0.t_bdd . discr_valuation'0 self a b
  = ([%#span27] let _ = () in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation'0 self childf b) v false
      else
        Map.set (discr_valuation'0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation'0 self a childf) v false
        else
          Map.set (discr_valuation'0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation'0 self childfa childfb) v false
          else
            Map.set (discr_valuation'0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  
  axiom discr_valuation'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, b : Bdd'0.t_bdd . ([%#span21] inv'0 self)
   -> ([%#span22] is_valid_bdd'0 self a)
   -> ([%#span23] is_valid_bdd'0 self b)
   -> ([%#span24] a <> b)
   -> ([%#span25] interp'0 a (discr_valuation'0 self a b) <> interp'0 b (discr_valuation'0 self a b))
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant b  : Bdd'0.t_bdd
  
  function bdd_canonical [#"../bdd.rs" 425 4 425 62] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : ()
    
  
  goal vc_bdd_canonical : ([%#sbdd3] forall v : Map.map uint64 bool . interp'0 a v = interp'0 b v)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)  -> ([%#sbdd0] inv'0 self)  -> (let _ = discr_valuation'0 in [%#sbdd4] a = b)
end
module Bdd_Impl11_New
  let%span sbdd0 = "../bdd.rs" 435 22 435 47
  
  let%span sbdd1 = "../bdd.rs" 436 28 436 57
  
  let%span sbdd2 = "../bdd.rs" 437 22 437 47
  
  let%span sbdd3 = "../bdd.rs" 438 22 438 47
  
  let%span sbdd4 = "../bdd.rs" 439 17 439 18
  
  let%span sbdd5 = "../bdd.rs" 431 48 431 52
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 245 12 249 13
  
  let%span span9 = "../bdd.rs" 215 12 222 13
  
  let%span span10 = "../bdd.rs" 164 12 168 13
  
  let%span span11 = "../bdd.rs" 180 20 180 37
  
  let%span span12 = "../bdd.rs" 315 12 315 47
  
  let%span span13 = "../bdd.rs" 322 12 331 13
  
  let%span span14 = "../bdd.rs" 268 12 292 19
  
  let%span span15 = "../bdd.rs" 71 18 71 47
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'2 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'4 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'3 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'4 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'3 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'3 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'2 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  use prelude.prelude.Intrinsic
  
  use map.Const
  
  let rec new'2 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'2 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use map.Const
  
  let rec new'1 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'1 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Const
  
  use map.Const
  
  let rec new'0 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'0 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Node'0.t_node))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Node'0.C_True ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Node'0.t_node = any_l () | & _1 : Node'0.t_node = any_l () ] 
    [ return' (result:Node'0.t_node)-> return' {result} ]
    
  
  let rec new (alloc:Bump'0.t_bump) (return'  (ret:Context'0.t_context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0 (fun (pr0:Node'0.t_node) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new'0 {[%#sbdd0] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd1] Snapshot.new (Const.const t) ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = new'1 {[%#sbdd2] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) ->  [ &_8 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = new'2 {[%#sbdd3] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &_0 <- Context'0.C_Context alloc _5 _6 _8 _9 ([%#sbdd4] (0 : uint64)) ] s1 | s1 = return' {_0} ]
       ]
    )
    [ & _0 : Context'0.t_context = any_l ()
    | & alloc : Bump'0.t_bump = alloc
    | & t : Node'0.t_node = any_l ()
    | & _5 : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd) = any_l ()
    | & _6 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) = any_l ()
    | & _8 : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd) = any_l ()
    | & _9 : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd) = any_l ()
    | & _10 : Node'0.t_node = any_l () ]
     [ return' (result:Context'0.t_context)-> {[@expl:postcondition] [%#sbdd5] inv'0 result} (! return' {result}) ] 
end
module Bdd_Impl11_Hashcons
  let%span sbdd0 = "../bdd.rs" 454 30 454 77
  
  let%span sbdd1 = "../bdd.rs" 455 22 455 30
  
  let%span sbdd2 = "../bdd.rs" 455 33 455 34
  
  let%span sbdd3 = "../bdd.rs" 461 20 461 21
  
  let%span sbdd4 = "../bdd.rs" 449 28 449 38
  
  let%span sbdd5 = "../bdd.rs" 443 15 443 36
  
  let%span sbdd6 = "../bdd.rs" 447 21 447 25
  
  let%span sbdd7 = "../bdd.rs" 444 14 444 28
  
  let%span sbdd8 = "../bdd.rs" 445 14 445 26
  
  let%span sbdd9 = "../bdd.rs" 446 14 446 42
  
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../bdd.rs" 245 12 249 13
  
  let%span span13 = "../bdd.rs" 215 12 222 13
  
  let%span span14 = "../bdd.rs" 164 12 168 13
  
  let%span span15 = "../bdd.rs" 180 20 180 37
  
  let%span span16 = "../bdd.rs" 315 12 315 47
  
  let%span span17 = "../bdd.rs" 322 12 331 13
  
  let%span span18 = "../bdd.rs" 268 12 292 19
  
  let%span span19 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span20 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span21 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span22 = "../bdd.rs" 301 8 308 9
  
  let%span span23 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span24 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span25 = "../bdd.rs" 58 30 58 33
  
  let%span span26 = "../bdd.rs" 58 38 58 41
  
  let%span span27 = "../bdd.rs" 56 8 56 128
  
  let%span span28 = "../bdd.rs" 22 31 22 34
  
  let%span span29 = "../bdd.rs" 21 18 21 32
  
  let%span span30 = "../bdd.rs" 22 42 22 48
  
  let%span span31 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span32 = "../bdd.rs" 67 37 67 40
  
  let%span span33 = "../bdd.rs" 62 18 65 9
  
  let%span span34 = "../bdd.rs" 67 52 67 65
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span10] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span11] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span14] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span15] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] shallow_model'1 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span16] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'0 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span17] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'6 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span18] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'0 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'6 (_x : Context'0.t_context)
  
  axiom inv'6 : forall x : Context'0.t_context . inv'6 x
  = (invariant'6 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'5 (self : Bdd'0.t_bdd) =
    [%#span19] true
  
  predicate inv'5 (_x : Bdd'0.t_bdd)
  
  axiom inv'5 : forall x : Bdd'0.t_bdd . inv'5 x = true
  
  predicate inv'3 (_x : Node'0.t_node)
  
  predicate invariant'4 (self : borrowed (Node'0.t_node)) =
    [%#span20] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_x : borrowed (Node'0.t_node))
  
  axiom inv'4 : forall x : borrowed (Node'0.t_node) . inv'4 x = true
  
  predicate invariant'3 (self : Node'0.t_node) =
    [%#span19] true
  
  axiom inv'3 : forall x : Node'0.t_node . inv'3 x = true
  
  predicate invariant'2 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span19] true
  
  predicate inv'2 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'2 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'2 x = true
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span21] inv'3 self
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span20] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = invariant'0 x
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span22] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_context)) =
    [%#span23] self.final = self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  function shallow_model'4 (self : borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span24] shallow_model'3 self.current
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) (key:Node'0.t_node) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span26] inv'5 val'}
    {[@expl:precondition] [%#span25] inv'3 key}
    any
    [ return' (result:())-> {[%#span27] forall i : NodeLog'0.t_nodelog . Map.get (shallow_model'3 self.final) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'4 self) i)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Node'0.t_node)) =
    [%#span23] self.final = self.current
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec alloc'0 (self:Bump'0.t_bump) (val':Node'0.t_node) (return'  (ret:borrowed (Node'0.t_node)))= {[@expl:precondition] [%#span28] inv'3 val'}
    any
    [ return' (result:borrowed (Node'0.t_node))-> {[%#span30] inv'4 result}
      {[%#span29] result.current = val'}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span31] deep_model'1 self
  
  function shallow_model'2 (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span10] shallow_model'3 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (key:Node'0.t_node) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span32] inv'1 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span34] inv'2 result}
      {[%#span33] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  let rec hashcons (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd6] inv'0 self}
    {[%#sbdd5] is_valid_node'0 self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n ] s1
      | s1 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rhashcons'0} {_11} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_8 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_8 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_8 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            alloc'0 {ralloc'0} {n} (fun (_ret':borrowed (Node'0.t_node)) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
             [ &r1 <- Bdd'0.C_Bdd (_19.current) rcnt'0 ] 
            s1)
      | s1 = -{resolve'0 _19}- s2
      | s2 = Context'0.t_context {self.current}
          (fun (ralloc'1:Bump'0.t_bump) (rhashcons'1:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'1:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'1:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'1:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'1:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)>
              {rhashcons'1}
              {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) ->
                 [ &_24 <- _ret' ] 
                Context'0.t_context {self.current}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 _24.final l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
                    
                    s3)))
      | s3 = add'0 {_24} {n} {r1} (fun (_ret':()) ->  [ &_23 <- _ret' ] s4)
      | s4 = bb6 ]
      
    | bb6 = s0
      [ s0 = 
        [ &_27 <- [%#sbdd0] Snapshot.new (Map.set (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self.current)) (Bdd_Bdd_Type.bdd_1 r1) (Bdd_Bdd_Type.bdd_0 r1)) ]
        
        s1
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
            
            [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 _27 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
            
            s1)
      | s1 = UInt64.sub {[%#sbdd1] (18446744073709551615 : uint64)} {[%#sbdd2] (1 : uint64)}
          (fun (_ret':uint64) ->  [ &_32 <- _ret' ] s2)
      | s2 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            UInt64.gt {rcnt'0} {_32} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s3))
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new self ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:loop invariant] (Snapshot.inner old_9_0).final = self.final}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = Context'0.t_context {self.current}
              (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
                Context'0.t_context {self.current}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 rcnt'0 ; } ]
                    
                    s1))
          | s1 = bb9 ]
           ]
         ]
      
    | bb11 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            UInt64.add {rcnt'0} {[%#sbdd3] (1 : uint64)}
              (fun (_ret':uint64) ->
                Context'0.t_context {self.current}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 _ret' ; } ]
                    
                    s1)))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 =  [ &_0 <- r1 ] s4
      | s4 = bb12 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_8} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 = {[@expl:assertion] [%#sbdd4] shallow_model'0 (Bdd_Bdd_Type.bdd_0 r) = shallow_model'1 n} s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb12 ]
      
    | bb12 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & n : Node'0.t_node = n
    | & _8 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _11 : Node'0.t_node = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _19 : borrowed (Node'0.t_node) = any_l ()
    | & _23 : () = any_l ()
    | & _24 : borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) = any_l ()
    | & _27 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : uint64 = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (Context'0.t_context)) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd9] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd8] grows'0 self}
      {[@expl:postcondition] [%#sbdd7] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Node
  let%span sbdd0 = "../bdd.rs" 465 15 465 40
  
  let%span sbdd1 = "../bdd.rs" 466 15 466 40
  
  let%span sbdd2 = "../bdd.rs" 467 15 467 63
  
  let%span sbdd3 = "../bdd.rs" 472 17 472 21
  
  let%span sbdd4 = "../bdd.rs" 468 14 468 26
  
  let%span sbdd5 = "../bdd.rs" 469 14 469 42
  
  let%span sbdd6 = "../bdd.rs" 470 4 470 106
  
  let%span sbdd7 = "../bdd.rs" 471 14 471 37
  
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "../bdd.rs" 245 12 249 13
  
  let%span span11 = "../bdd.rs" 215 12 222 13
  
  let%span span12 = "../bdd.rs" 164 12 168 13
  
  let%span span13 = "../bdd.rs" 180 20 180 37
  
  let%span span14 = "../bdd.rs" 315 12 315 47
  
  let%span span15 = "../bdd.rs" 322 12 331 13
  
  let%span span16 = "../bdd.rs" 268 12 292 19
  
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span18 = "../bdd.rs" 301 8 308 9
  
  let%span span19 = "../bdd.rs" 443 15 443 36
  
  let%span span20 = "../bdd.rs" 447 21 447 25
  
  let%span span21 = "../bdd.rs" 444 14 444 28
  
  let%span span22 = "../bdd.rs" 445 14 445 26
  
  let%span span23 = "../bdd.rs" 446 14 446 42
  
  let%span span24 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span25 = "../bdd.rs" 190 20 190 26
  
  let%span span26 = "../bdd.rs" 200 20 200 37
  
  let%span span27 = "../bdd.rs" 205 14 205 37
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span8] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span9] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span10] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span12] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'5 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span13] deep_model'1 self
  
  function shallow_model'2 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] shallow_model'5 self
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span14] Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) (shallow_model'2 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span15] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span16] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'2 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span17] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = invariant'0 x
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span18] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span20] inv'0 self}
    {[@expl:precondition] [%#span19] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span23] is_valid_bdd'0 self.final result}
      {[%#span22] grows'0 self}
      {[%#span21] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span24] self.final = self.current
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span25] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'4 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span26] deep_model'0 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span8] shallow_model'4 self
  
  let rec eq'0 (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span27] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  let rec node (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd3] inv'0 self}
    {[%#sbdd2] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[%#sbdd1] is_valid_bdd'0 self.current childf}
    {[%#sbdd0] is_valid_bdd'0 self.current childt}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {childt} {childf} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- childt ] s3
      | s3 = bb5 ]
      
    | bb3 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_17 <- _ret' ] 
             [ &self <- { self with current = _17.final ; } ] 
            s1)
      | s1 = -{inv'1 _17.final}- s2
      | s2 =  [ &_18 <- Node'0.C_If x childt childf ] s3
      | s3 = hashcons'0 {_17} {_18} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : uint64 = x
    | & childt : Bdd'0.t_bdd = childt
    | & childf : Bdd'0.t_bdd = childf
    | & _13 : bool = any_l ()
    | & _17 : borrowed (Context'0.t_context) = any_l ()
    | & _18 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd7] UInt64.to_int x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd6] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[@expl:postcondition] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd4] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_True
  let%span sbdd0 = "../bdd.rs" 483 22 483 26
  
  let%span sbdd1 = "../bdd.rs" 479 14 479 26
  
  let%span sbdd2 = "../bdd.rs" 480 14 480 42
  
  let%span sbdd3 = "../bdd.rs" 481 4 481 44
  
  let%span sbdd4 = "../bdd.rs" 482 14 482 46
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 245 12 249 13
  
  let%span span9 = "../bdd.rs" 215 12 222 13
  
  let%span span10 = "../bdd.rs" 164 12 168 13
  
  let%span span11 = "../bdd.rs" 180 20 180 37
  
  let%span span12 = "../bdd.rs" 315 12 315 47
  
  let%span span13 = "../bdd.rs" 322 12 331 13
  
  let%span span14 = "../bdd.rs" 268 12 292 19
  
  let%span span15 = "../bdd.rs" 301 8 308 9
  
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span17 = "../bdd.rs" 443 15 443 36
  
  let%span span18 = "../bdd.rs" 447 21 447 25
  
  let%span span19 = "../bdd.rs" 444 14 444 28
  
  let%span span20 = "../bdd.rs" 445 14 445 26
  
  let%span span21 = "../bdd.rs" 446 14 446 42
  
  use Bdd_Context_Type as Context'0
  
  predicate inv'0 (_x : Context'0.t_context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span5] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span15] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span16] self.final = self.current
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      {[%#span19] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  let rec true_ (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = _6.final ; } ] 
            s1)
      | s1 = -{inv'0 _6.final}- s2
      | s2 =  [ &_7 <- Node'0.C_True ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & _6 : borrowed (Context'0.t_context) = any_l ()
    | & _7 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_False
  let%span sbdd0 = "../bdd.rs" 491 23 491 27
  
  let%span sbdd1 = "../bdd.rs" 487 14 487 26
  
  let%span sbdd2 = "../bdd.rs" 488 14 488 42
  
  let%span sbdd3 = "../bdd.rs" 489 4 489 45
  
  let%span sbdd4 = "../bdd.rs" 490 14 490 46
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 245 12 249 13
  
  let%span span9 = "../bdd.rs" 215 12 222 13
  
  let%span span10 = "../bdd.rs" 164 12 168 13
  
  let%span span11 = "../bdd.rs" 180 20 180 37
  
  let%span span12 = "../bdd.rs" 315 12 315 47
  
  let%span span13 = "../bdd.rs" 322 12 331 13
  
  let%span span14 = "../bdd.rs" 268 12 292 19
  
  let%span span15 = "../bdd.rs" 301 8 308 9
  
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span17 = "../bdd.rs" 443 15 443 36
  
  let%span span18 = "../bdd.rs" 447 21 447 25
  
  let%span span19 = "../bdd.rs" 444 14 444 28
  
  let%span span20 = "../bdd.rs" 445 14 445 26
  
  let%span span21 = "../bdd.rs" 446 14 446 42
  
  use Bdd_Context_Type as Context'0
  
  predicate inv'0 (_x : Context'0.t_context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span5] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span15] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span16] self.final = self.current
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      {[%#span19] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  let rec false_ (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = _6.final ; } ] 
            s1)
      | s1 = -{inv'0 _6.final}- s2
      | s2 =  [ &_7 <- Node'0.C_False ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & _6 : borrowed (Context'0.t_context) = any_l ()
    | & _7 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . not interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_V
  let%span sbdd0 = "../bdd.rs" 498 18 498 22
  
  let%span sbdd1 = "../bdd.rs" 495 14 495 26
  
  let%span sbdd2 = "../bdd.rs" 496 14 496 42
  
  let%span sbdd3 = "../bdd.rs" 497 4 497 56
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../bdd.rs" 245 12 249 13
  
  let%span span8 = "../bdd.rs" 215 12 222 13
  
  let%span span9 = "../bdd.rs" 164 12 168 13
  
  let%span span10 = "../bdd.rs" 180 20 180 37
  
  let%span span11 = "../bdd.rs" 315 12 315 47
  
  let%span span12 = "../bdd.rs" 322 12 331 13
  
  let%span span13 = "../bdd.rs" 268 12 292 19
  
  let%span span14 = "../bdd.rs" 301 8 308 9
  
  let%span span15 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span16 = "../bdd.rs" 465 15 465 40
  
  let%span span17 = "../bdd.rs" 466 15 466 40
  
  let%span span18 = "../bdd.rs" 467 15 467 63
  
  let%span span19 = "../bdd.rs" 472 17 472 21
  
  let%span span20 = "../bdd.rs" 468 14 468 26
  
  let%span span21 = "../bdd.rs" 469 14 469 42
  
  let%span span22 = "../bdd.rs" 470 4 470 106
  
  let%span span23 = "../bdd.rs" 471 14 471 37
  
  let%span span24 = "../bdd.rs" 491 23 491 27
  
  let%span span25 = "../bdd.rs" 487 14 487 26
  
  let%span span26 = "../bdd.rs" 488 14 488 42
  
  let%span span27 = "../bdd.rs" 489 4 489 45
  
  let%span span28 = "../bdd.rs" 490 14 490 46
  
  let%span span29 = "../bdd.rs" 483 22 483 26
  
  let%span span30 = "../bdd.rs" 479 14 479 26
  
  let%span span31 = "../bdd.rs" 480 14 480 42
  
  let%span span32 = "../bdd.rs" 481 4 481 44
  
  let%span span33 = "../bdd.rs" 482 14 482 46
  
  use Bdd_Context_Type as Context'0
  
  predicate inv'0 (_x : Context'0.t_context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span5] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span11] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span13] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span14] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span15] self.final = self.current
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span19] inv'1 self}
    {[@expl:precondition] [%#span18] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span17] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span16] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span23] UInt64.to_int x <= leastvar'0 result}
      {[%#span22] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span24] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span28] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span27] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span26] is_valid_bdd'0 self.final result}
      {[%#span25] grows'0 self}
      (! return' {result}) ]
    
  
  let rec true'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span29] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span33] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span32] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span31] is_valid_bdd'0 self.final result}
      {[%#span30] grows'0 self}
      (! return' {result}) ]
    
  
  let rec v (self:borrowed (Context'0.t_context)) (x:uint64) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_7 <- _ret' ] 
             [ &self <- { self with current = _7.final ; } ] 
            s1)
      | s1 = -{inv'0 _7.final}- s2
      | s2 = true'0 {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &t <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_9 <- _ret' ] 
             [ &self <- { self with current = _9.final ; } ] 
            s1)
      | s1 = -{inv'0 _9.final}- s2
      | s2 = false'0 {_9} (fun (_ret':Bdd'0.t_bdd) ->  [ &f <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_10 <- _ret' ] 
             [ &self <- { self with current = _10.final ; } ] 
            s1)
      | s1 = -{inv'0 _10.final}- s2
      | s2 = node'0 {_10} {x} {t} {f} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : uint64 = x
    | & t : Bdd'0.t_bdd = any_l ()
    | & _7 : borrowed (Context'0.t_context) = any_l ()
    | & f : Bdd'0.t_bdd = any_l ()
    | & _9 : borrowed (Context'0.t_context) = any_l ()
    | & _10 : borrowed (Context'0.t_context) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v
      = Map.get v x}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Not
  let%span sbdd0 = "../bdd.rs" 504 15 504 35
  
  let%span sbdd1 = "../bdd.rs" 510 20 510 24
  
  let%span sbdd2 = "../bdd.rs" 505 14 505 26
  
  let%span sbdd3 = "../bdd.rs" 506 14 506 42
  
  let%span sbdd4 = "../bdd.rs" 507 4 507 60
  
  let%span sbdd5 = "../bdd.rs" 508 14 508 47
  
  let%span sbdd6 = "../bdd.rs" 509 14 509 22
  
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span8 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span9 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../bdd.rs" 245 12 249 13
  
  let%span span13 = "../bdd.rs" 215 12 222 13
  
  let%span span14 = "../bdd.rs" 164 12 168 13
  
  let%span span15 = "../bdd.rs" 180 20 180 37
  
  let%span span16 = "../bdd.rs" 315 12 315 47
  
  let%span span17 = "../bdd.rs" 322 12 331 13
  
  let%span span18 = "../bdd.rs" 268 12 292 19
  
  let%span span19 = "../bdd.rs" 227 14 227 25
  
  let%span span20 = "../bdd.rs" 230 12 238 13
  
  let%span span21 = "../bdd.rs" 301 8 308 9
  
  let%span span22 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span24 = "../bdd.rs" 190 20 190 26
  
  let%span span25 = "../bdd.rs" 58 30 58 33
  
  let%span span26 = "../bdd.rs" 58 38 58 41
  
  let%span span27 = "../bdd.rs" 56 8 56 128
  
  let%span span28 = "../bdd.rs" 483 22 483 26
  
  let%span span29 = "../bdd.rs" 479 14 479 26
  
  let%span span30 = "../bdd.rs" 480 14 480 42
  
  let%span span31 = "../bdd.rs" 481 4 481 44
  
  let%span span32 = "../bdd.rs" 482 14 482 46
  
  let%span span33 = "../bdd.rs" 491 23 491 27
  
  let%span span34 = "../bdd.rs" 487 14 487 26
  
  let%span span35 = "../bdd.rs" 488 14 488 42
  
  let%span span36 = "../bdd.rs" 489 4 489 45
  
  let%span span37 = "../bdd.rs" 490 14 490 46
  
  let%span span38 = "../bdd.rs" 465 15 465 40
  
  let%span span39 = "../bdd.rs" 466 15 466 40
  
  let%span span40 = "../bdd.rs" 467 15 467 63
  
  let%span span41 = "../bdd.rs" 472 17 472 21
  
  let%span span42 = "../bdd.rs" 468 14 468 26
  
  let%span span43 = "../bdd.rs" 469 14 469 42
  
  let%span span44 = "../bdd.rs" 470 4 470 106
  
  let%span span45 = "../bdd.rs" 471 14 471 37
  
  let%span span46 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span47 = "../bdd.rs" 67 37 67 40
  
  let%span span48 = "../bdd.rs" 62 18 65 9
  
  let%span span49 = "../bdd.rs" 67 52 67 65
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'4 (self : Bdd'0.t_bdd) =
    [%#span7] true
  
  predicate inv'4 (_x : Bdd'0.t_bdd)
  
  axiom inv'4 : forall x : Bdd'0.t_bdd . inv'4 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'3 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span7] true
  
  predicate inv'3 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'3 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Bdd'0.t_bdd) =
    [%#span8] inv'4 self
  
  predicate inv'2 (_x : Bdd'0.t_bdd)
  
  axiom inv'2 : forall x : Bdd'0.t_bdd . inv'2 x = true
  
  use Bdd_Context_Type as Context'0
  
  predicate inv'0 (_x : Context'0.t_context)
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span9] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span10] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span11] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'2 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span14] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span15] deep_model'2 self
  
  function shallow_model'4 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span16] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span17] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span18] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_bdd) : int =
    [%#span20] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span19] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span21] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span22] self.final = self.current
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span23] shallow_model'1 self.current
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span24] Bdd_Bdd_Type.bdd_1 self
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) (key:Bdd'0.t_bdd) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span26] inv'4 val'}
    {[@expl:precondition] [%#span25] inv'4 key}
    any
    [ return' (result:())-> {[%#span27] forall i : uint64 . Map.get (shallow_model'1 self.final) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec true'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span28] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span32] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span31] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span30] is_valid_bdd'0 self.final result}
      {[%#span29] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span33] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span37] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span36] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span35] is_valid_bdd'0 self.final result}
      {[%#span34] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span41] inv'1 self}
    {[@expl:precondition] [%#span40] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span39] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span38] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span45] UInt64.to_int x <= leastvar'0 result}
      {[%#span44] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span43] is_valid_bdd'0 self.final result}
      {[%#span42] grows'0 self}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span46] deep_model'1 self
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span10] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (key:Bdd'0.t_bdd) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span47] inv'2 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span49] inv'3 result}
      {[%#span48] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec not' (self:borrowed (Context'0.t_context)) (x:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd1] inv'1 self}
    {[%#sbdd0] is_valid_bdd'0 self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x ] s1
      | s1 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rnot_memo'0} {_13} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_10 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_10 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = Bdd'0.t_bdd {x}
        (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
          any
          [ br0 -> {r0'0 = Node'0.C_False } (! bb7)
          | br1 -> {r0'0 = Node'0.C_True } (! bb6)
          | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {r0'0 = Node'0.C_If a b c} (! bb8) ]
          )
    | bb8 = s0
      [ s0 = Bdd'0.t_bdd {x}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Node'0.if' {r0'0} (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v <- rv'0 ] s1))
      | s1 = Bdd'0.t_bdd {x}
          (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->
            Node'0.if' {r0'1}
              (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt <- rchildt'1 ] s2))
      | s2 = Bdd'0.t_bdd {x}
          (fun (r0'2:Node'0.t_node) (r1'2:uint64) ->
            Node'0.if' {r0'2}
              (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf <- rchildf'2 ] s3))
      | s3 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_25 <- _ret' ] 
             [ &self <- { self with current = _25.final ; } ] 
            s4)
      | s4 = -{inv'0 _25.final}- s5
      | s5 = not' {_25} {childt} (fun (_ret':Bdd'0.t_bdd) ->  [ &childt1 <- _ret' ] s6)
      | s6 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = _28.final ; } ] 
            s1)
      | s1 = -{inv'0 _28.final}- s2
      | s2 = not' {_28} {childf} (fun (_ret':Bdd'0.t_bdd) ->  [ &childf1 <- _ret' ] s3)
      | s3 = bb14 ]
      
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = _30.final ; } ] 
            s1)
      | s1 = -{inv'0 _30.final}- s2
      | s2 = node'0 {_30} {v} {childt1} {childf1} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb15 ]
      
    | bb15 = bb16
    | bb6 = bb9
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_19 <- _ret' ] 
             [ &self <- { self with current = _19.final ; } ] 
            s1)
      | s1 = -{inv'0 _19.final}- s2
      | s2 = false'0 {_19} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = bb16
    | bb7 = bb11
    | bb11 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_20 <- _ret' ] 
             [ &self <- { self with current = _20.final ; } ] 
            s1)
      | s1 = -{inv'0 _20.final}- s2
      | s2 = true'0 {_20} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = bb16
    | bb16 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)>
              {rnot_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 4}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) ->
                 [ &_35 <- _ret' ] 
                Context'0.t_context {self.current}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 _35.final l_and_memo'0 l_cnt'0 ; } ]
                    
                    s1)))
      | s1 = add'0 {_35} {x} {r1} (fun (_ret':()) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_10} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'1 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb18 ]
      
    | bb18 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : Bdd'0.t_bdd = x
    | & _10 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _13 : Bdd'0.t_bdd = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _19 : borrowed (Context'0.t_context) = any_l ()
    | & _20 : borrowed (Context'0.t_context) = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & childt1 : Bdd'0.t_bdd = any_l ()
    | & _25 : borrowed (Context'0.t_context) = any_l ()
    | & childf1 : Bdd'0.t_bdd = any_l ()
    | & _28 : borrowed (Context'0.t_context) = any_l ()
    | & _30 : borrowed (Context'0.t_context) = any_l ()
    | & _34 : () = any_l ()
    | & _35 : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd5] leastvar'0 x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd4] forall v : Map.map uint64 bool . interp'0 result v = (not interp'0 x v)}
      {[@expl:postcondition] [%#sbdd3] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd2] grows'0 self}
      (! return' {result}) ]
    
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function any_l (_ : 'b) : 'a
  
  let rec less (input:t_ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} {false} any ]
    
  
  let rec equal (input:t_ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} {false} any ]
    
  
  let rec greater (input:t_ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} {false} any ]
    
end
module Bdd_Impl11_And
  let%span sbdd0 = "../bdd.rs" 538 22 538 34
  
  let%span sbdd1 = "../bdd.rs" 527 15 527 35
  
  let%span sbdd2 = "../bdd.rs" 528 15 528 35
  
  let%span sbdd3 = "../bdd.rs" 534 20 534 24
  
  let%span sbdd4 = "../bdd.rs" 529 14 529 26
  
  let%span sbdd5 = "../bdd.rs" 530 14 530 42
  
  let%span sbdd6 = "../bdd.rs" 531 4 531 76
  
  let%span sbdd7 = "../bdd.rs" 532 14 532 84
  
  let%span sbdd8 = "../bdd.rs" 533 14 533 33
  
  let%span span9 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span10 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span11 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span12 = "" 0 0 0 0
  
  let%span span13 = "../bdd.rs" 245 12 249 13
  
  let%span span14 = "../bdd.rs" 215 12 222 13
  
  let%span span15 = "../bdd.rs" 164 12 168 13
  
  let%span span16 = "../bdd.rs" 180 20 180 37
  
  let%span span17 = "../bdd.rs" 315 12 315 47
  
  let%span span18 = "../bdd.rs" 322 12 331 13
  
  let%span span19 = "../bdd.rs" 268 12 292 19
  
  let%span span20 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span21 = "../bdd.rs" 227 14 227 25
  
  let%span span22 = "../bdd.rs" 230 12 238 13
  
  let%span span23 = "../bdd.rs" 301 8 308 9
  
  let%span span24 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span25 = "../bdd.rs" 190 20 190 26
  
  let%span span26 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span27 = "../bdd.rs" 58 30 58 33
  
  let%span span28 = "../bdd.rs" 58 38 58 41
  
  let%span span29 = "../bdd.rs" 56 8 56 128
  
  let%span span30 = "../bdd.rs" 491 23 491 27
  
  let%span span31 = "../bdd.rs" 487 14 487 26
  
  let%span span32 = "../bdd.rs" 488 14 488 42
  
  let%span span33 = "../bdd.rs" 489 4 489 45
  
  let%span span34 = "../bdd.rs" 490 14 490 46
  
  let%span span35 = "../bdd.rs" 465 15 465 40
  
  let%span span36 = "../bdd.rs" 466 15 466 40
  
  let%span span37 = "../bdd.rs" 467 15 467 63
  
  let%span span38 = "../bdd.rs" 472 17 472 21
  
  let%span span39 = "../bdd.rs" 468 14 468 26
  
  let%span span40 = "../bdd.rs" 469 14 469 42
  
  let%span span41 = "../bdd.rs" 470 4 470 106
  
  let%span span42 = "../bdd.rs" 471 14 471 37
  
  let%span span43 = "../../../../creusot-contracts/src/logic/ord.rs" 140 16 146 17
  
  let%span span44 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span45 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  
  let%span span46 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span47 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span48 = "../bdd.rs" 67 37 67 40
  
  let%span span49 = "../bdd.rs" 62 18 65 9
  
  let%span span50 = "../bdd.rs" 67 52 67 65
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'5 (self : Bdd'0.t_bdd) =
    [%#span9] true
  
  predicate inv'5 (_x : Bdd'0.t_bdd)
  
  axiom inv'5 : forall x : Bdd'0.t_bdd . inv'5 x = true
  
  predicate invariant'4 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) =
    [%#span9] true
  
  predicate inv'4 (_x : (Bdd'0.t_bdd, Bdd'0.t_bdd))
  
  axiom inv'4 : forall x : (Bdd'0.t_bdd, Bdd'0.t_bdd) . inv'4 x = true
  
  use prelude.prelude.Int
  
  function eq_cmp'0 (_1 : int) (_2 : int) : ()
  
  function antisym2'0 (_1 : int) (_2 : int) : ()
  
  function antisym1'0 (_1 : int) (_2 : int) : ()
  
  use Core_Cmp_Ordering_Type as Ordering'0
  
  function trans'0 (_1 : int) (_2 : int) (_3 : int) (_4 : Ordering'0.t_ordering) : ()
  
  function refl'0 (_1 : int) : ()
  
  function cmp_gt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_ge_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_lt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_le_log'0 (_1 : int) (_2 : int) : ()
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'3 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span9] true
  
  predicate inv'3 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'3 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) =
    [%#span10] inv'4 self
  
  predicate inv'2 (_x : (Bdd'0.t_bdd, Bdd'0.t_bdd))
  
  axiom inv'2 : forall x : (Bdd'0.t_bdd, Bdd'0.t_bdd) . inv'2 x = true
  
  use prelude.prelude.UInt64
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span11] UInt64.to_int self
  
  constant max'0 : uint64 = [%#span12] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_bdd) : int =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span14] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'4 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span15] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span16] deep_model'4 self
  
  function shallow_model'4 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span17] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span18] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_context) =
    [%#span19] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'7 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'1 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span20] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = invariant'0 x
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_bdd) : int =
    [%#span22] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span21] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_context)) =
    [%#span23] UInt64.to_int (Bdd_Context_Type.context_cnt self.current)
    <= UInt64.to_int (Bdd_Context_Type.context_cnt self.final)
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span24] shallow_model'1 self.current
  
  function deep_model'3 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span25] Bdd_Bdd_Type.bdd_1 self
  
  function deep_model'2 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) : (uint64, uint64) =
    [%#span26] (deep_model'3 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) (key:(Bdd'0.t_bdd, Bdd'0.t_bdd)) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span28] inv'5 val'}
    {[@expl:precondition] [%#span27] inv'4 key}
    any
    [ return' (result:())-> {[%#span29] forall i : (uint64, uint64) . Map.get (shallow_model'1 self.final) i
      = (if i = deep_model'2 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span30] inv'0 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span34] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span33] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span32] is_valid_bdd'0 self.final result}
      {[%#span31] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span38] inv'0 self}
    {[@expl:precondition] [%#span37] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span36] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span35] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span42] UInt64.to_int x <= leastvar'0 result}
      {[%#span41] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span40] is_valid_bdd'0 self.final result}
      {[%#span39] grows'0 self}
      (! return' {result}) ]
    
  
  function cmp_log'0 (self : int) (o : int) : Ordering'0.t_ordering =
    [%#span43] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  function deep_model'1 (self : uint64) : int =
    [%#span44] UInt64.to_int self
  
  let rec cmp'0 (self:uint64) (other:uint64) (return'  (ret:Ordering'0.t_ordering))= any
    [ return' (result:Ordering'0.t_ordering)-> {[%#span45] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span46] self.final = self.current
  
  function deep_model'0 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) : (uint64, uint64) =
    [%#span47] deep_model'2 self
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span11] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (key:(Bdd'0.t_bdd, Bdd'0.t_bdd)) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span48] inv'2 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span50] inv'3 result}
      {[%#span49] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec and (self:borrowed (Context'0.t_context)) (a:Bdd'0.t_bdd) (b:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd3] inv'0 self}
    {[%#sbdd2] is_valid_bdd'0 self.current b}
    {[%#sbdd1] is_valid_bdd'0 self.current a}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- (a, b) ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rand_memo'0} {_15} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_12 <- _ret' ] s3))
      | s3 = bb1 ]
      
    | bb1 = any [ br0 -> {_12 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_12 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = s0
      [ s0 = Bdd'0.t_bdd {a}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Bdd'0.t_bdd {b} (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->  [ &_23 <- (r0'0, r0'1) ] s1))
      | s1 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb5)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb6)
        | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb5) ]
         ]
      
    | bb5 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb7)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb8)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb7 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb9)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb9) ]
      
    | bb9 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb10)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb11) ]
      
    | bb11 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb10)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb10)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb12) ]
      
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {[%#sbdd0] false} any ]
      
    | bb12 = s0
      [ s0 = Node'0.if' {let (r'0, _) = _23 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &va <- rv'0 ] s1)
      | s1 = Node'0.if' {let (r'1, _) = _23 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childta <- rchildt'1 ] s2)
      | s2 = Node'0.if' {let (r'2, _) = _23 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childfa <- rchildf'2 ] s3)
      | s3 = Node'0.if' {let (_, r'3) = _23 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_bdd) (rchildf'3:Bdd'0.t_bdd) ->  [ &vb <- rv'3 ] s4)
      | s4 = Node'0.if' {let (_, r'4) = _23 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_bdd) (rchildf'4:Bdd'0.t_bdd) ->  [ &childtb <- rchildt'4 ] s5)
      | s5 = Node'0.if' {let (_, r'5) = _23 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_bdd) (rchildf'5:Bdd'0.t_bdd) ->  [ &childfb <- rchildf'5 ] s6)
      | s6 =  [ &_45 <- vb ] s7
      | s7 = cmp'0 {va} {_45} (fun (_ret':Ordering'0.t_ordering) ->  [ &_42 <- _ret' ] s8)
      | s8 = bb18 ]
      
    | bb18 = any
      [ br0 -> {_42 = Ordering'0.C_Less } (! bb21)
      | br1 -> {_42 = Ordering'0.C_Equal } (! bb22)
      | br2 -> {_42 = Ordering'0.C_Greater } (! bb20) ]
      
    | bb20 = bb23
    | bb23 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_49 <- _ret' ] 
             [ &self <- { self with current = _49.final ; } ] 
            s2)
      | s2 = -{inv'1 _49.final}- s3
      | s3 = and {_49} {a} {childtb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_48 <- _ret' ] s4)
      | s4 = bb24 ]
      
    | bb24 = s0
      [ s0 =  [ &childt <- _48 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_53 <- _ret' ] 
             [ &self <- { self with current = _53.final ; } ] 
            s2)
      | s2 = -{inv'1 _53.final}- s3
      | s3 = and {_53} {a} {childfb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_52 <- _ret' ] s4)
      | s4 = bb25 ]
      
    | bb25 = s0 [ s0 =  [ &childf <- _52 ] s1 | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_67 <- _ret' ] 
             [ &self <- { self with current = _67.final ; } ] 
            s2)
      | s2 = -{inv'1 _67.final}- s3
      | s3 = and {_67} {childta} {childtb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_66 <- _ret' ] s4)
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_71 <- _ret' ] 
             [ &self <- { self with current = _71.final ; } ] 
            s2)
      | s2 = -{inv'1 _71.final}- s3
      | s3 = and {_71} {childfa} {childfb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_70 <- _ret' ] s4)
      | s4 = bb30 ]
      
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] s1 | s1 = bb31 ] 
    | bb21 = bb26
    | bb26 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_58 <- _ret' ] 
             [ &self <- { self with current = _58.final ; } ] 
            s2)
      | s2 = -{inv'1 _58.final}- s3
      | s3 = and {_58} {childta} {b} (fun (_ret':Bdd'0.t_bdd) ->  [ &_57 <- _ret' ] s4)
      | s4 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_62 <- _ret' ] 
             [ &self <- { self with current = _62.final ; } ] 
            s2)
      | s2 = -{inv'1 _62.final}- s3
      | s3 = and {_62} {childfa} {b} (fun (_ret':Bdd'0.t_bdd) ->  [ &_61 <- _ret' ] s4)
      | s4 = bb28 ]
      
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] s1 | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_74 <- _ret' ] 
             [ &self <- { self with current = _74.final ; } ] 
            s1)
      | s1 = -{inv'1 _74.final}- s2
      | s2 = node'0 {_74} {v} {childt} {childf} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb32 ]
      
    | bb32 = bb33
    | bb13 = bb16
    | bb16 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> {self.current}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_31 <- _ret' ] 
             [ &self <- { self with current = _31.final ; } ] 
            s1)
      | s1 = -{inv'1 _31.final}- s2
      | s2 = false'0 {_31} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb17 ]
      
    | bb17 = bb33
    | bb8 = bb15
    | bb15 = s0 [ s0 =  [ &r1 <- a ] s1 | s1 = bb33 ] 
    | bb6 = bb14
    | bb14 = s0 [ s0 =  [ &r1 <- b ] s1 | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = Context'0.t_context {self.current}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)>
              {rand_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 5}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) ->
                 [ &_79 <- _ret' ] 
                Context'0.t_context {self.current}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 _79.final l_cnt'0 ; } ]
                    
                    s1)))
      | s1 =  [ &_80 <- (a, b) ] s2
      | s2 = add'0 {_79} {_80} {r1} (fun (_ret':()) ->  [ &_78 <- _ret' ] s3)
      | s3 = bb34 ]
      
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb35 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_12} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb35 ]
      
    | bb35 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & a : Bdd'0.t_bdd = a
    | & b : Bdd'0.t_bdd = b
    | & _12 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _15 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l ()
    | & _16 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _23 : (Node'0.t_node, Node'0.t_node) = any_l ()
    | & _31 : borrowed (Context'0.t_context) = any_l ()
    | & va : uint64 = any_l ()
    | & childta : Bdd'0.t_bdd = any_l ()
    | & childfa : Bdd'0.t_bdd = any_l ()
    | & vb : uint64 = any_l ()
    | & childtb : Bdd'0.t_bdd = any_l ()
    | & childfb : Bdd'0.t_bdd = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & _42 : Ordering'0.t_ordering = any_l ()
    | & _45 : uint64 = any_l ()
    | & _48 : Bdd'0.t_bdd = any_l ()
    | & _49 : borrowed (Context'0.t_context) = any_l ()
    | & _52 : Bdd'0.t_bdd = any_l ()
    | & _53 : borrowed (Context'0.t_context) = any_l ()
    | & _57 : Bdd'0.t_bdd = any_l ()
    | & _58 : borrowed (Context'0.t_context) = any_l ()
    | & _61 : Bdd'0.t_bdd = any_l ()
    | & _62 : borrowed (Context'0.t_context) = any_l ()
    | & _66 : Bdd'0.t_bdd = any_l ()
    | & _67 : borrowed (Context'0.t_context) = any_l ()
    | & _70 : Bdd'0.t_bdd = any_l ()
    | & _71 : borrowed (Context'0.t_context) = any_l ()
    | & _74 : borrowed (Context'0.t_context) = any_l ()
    | & _78 : () = any_l ()
    | & _79 : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) = any_l ()
    | & _80 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd7] leastvar'0 a <= leastvar'0 result
      \/ leastvar'0 b <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd6] forall v : Map.map uint64 bool . interp'0 result v
      = (interp'0 a v /\ interp'0 b v)}
      {[@expl:postcondition] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd4] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Hashmap_Impl0
  type k
  
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 80 8 80 29
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "" 0 0 0 0
  
  let%span span4 = "../bdd.rs" 87 24 87 84
  
  let%span span5 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  predicate invariant'1 (self : (u, v)) =
    [%#span1] true
  
  predicate inv'1 (_x : (u, v))
  
  axiom inv'1 : forall x : (u, v) . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : (u, v)) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : (u, v))
  
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span3] (18446744073709551615 : uint64)
  
  type deep_model_ty'1
  
  function hash_log'2 [#"../bdd.rs" 38 8 38 49] (_1 : deep_model_ty'1) : int
  
  type deep_model_ty'0
  
  function hash_log'1 [#"../bdd.rs" 38 8 38 49] (_1 : deep_model_ty'0) : int
  
  function hash_log'0 [#"../bdd.rs" 86 8 86 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [%#span4] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  
  function deep_model'3 (self : v) : deep_model_ty'1
  
  function deep_model'2 (self : u) : deep_model_ty'0
  
  function deep_model'1 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span5] (deep_model'2 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span6] deep_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : (u, v) . inv'0 self
   -> inv'0 self
  /\ (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl1
  let%span sbdd0 = "../bdd.rs" 120 4 120 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "../bdd.rs" 164 12 168 13
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 134 12 139 13
  
  let%span span7 = "../bdd.rs" 180 20 180 37
  
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span3] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 132 4 132 44] (x : NodeLog'0.t_nodelog) : int =
    [%#span6] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span7] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Node'0.t_node . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl2
  let%span sbdd0 = "../bdd.rs" 146 4 146 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "../bdd.rs" 190 20 190 26
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span5 = "../bdd.rs" 153 8 153 24
  
  let%span span6 = "../bdd.rs" 200 20 200 37
  
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'1 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'1 (_x : Bdd'0.t_bdd)
  
  axiom inv'1 : forall x : Bdd'0.t_bdd . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] Bdd_Bdd_Type.bdd_1 self
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span4] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 152 4 152 44] (x : uint64) : int =
    [%#span5] UInt64.to_int x
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span6] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span7] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl12
  let%span sbdd0 = "../bdd.rs" 94 9 94 11
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module Bdd_Impl17
  let%span sbdd0 = "../bdd.rs" 108 15 108 17
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module Bdd_Impl13
  let%span sbdd0 = "../bdd.rs" 94 13 94 22
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "../bdd.rs" 164 12 168 13
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span3] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] deep_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Node'0.t_node . forall other : Node'0.t_node . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl7
  let%span sbdd0 = "../bdd.rs" 206 4 206 34
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "../bdd.rs" 190 20 190 26
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span5 = "../bdd.rs" 200 20 200 37
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'1 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'1 (_x : Bdd'0.t_bdd)
  
  axiom inv'1 : forall x : Bdd'0.t_bdd . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] Bdd_Bdd_Type.bdd_1 self
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span4] deep_model'1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span5] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span6] shallow_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . forall other : Bdd'0.t_bdd . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (shallow_model'0 self = shallow_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl14
  let%span sbdd0 = "../bdd.rs" 94 24 94 29
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  goal clone'_refn : [%#sbdd0] forall self : Node'0.t_node . inv'0 self
   -> (forall result : Node'0.t_node . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl0
  let%span sbdd0 = "../bdd.rs" 113 4 113 27
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'1 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'1 (_x : Bdd'0.t_bdd)
  
  axiom inv'1 : forall x : Bdd'0.t_bdd . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  goal clone'_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . inv'0 self
   -> (forall result : Bdd'0.t_bdd . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl15
  
end
module Bdd_Impl16
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
module Bdd_Impl9
  
end
