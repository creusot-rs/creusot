
module Bdd_Bumpalo_Bump_Type
  type t_bump
end
module Bdd_Hashmap_MyHashMap_Type
  type t_myhashmap 'k 'v
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Bdd_Hashmap_Impl2_Hash
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 77 66 77 68
  
  let%span sbdd1 = "../bdd.rs" 76 17 76 21
  
  let%span sbdd2 = "../bdd.rs" 75 18 75 62
  
  let%span span3 = "" 0 0 0 0
  
  let%span span4 = "../bdd.rs" 83 24 83 84
  
  let%span span5 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "" 0 0 0 0
  
  let%span span9 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span17 = "../bdd.rs" 31 17 31 21
  
  let%span span18 = "../bdd.rs" 30 18 30 62
  
  predicate invariant'2 (self : v)
  
  predicate inv'2 (_x : v)
  
  axiom inv'2 : forall x : v . inv'2 x = true
  
  predicate invariant'1 (self : u)
  
  predicate inv'1 (_x : u)
  
  axiom inv'1 : forall x : u . inv'1 x = true
  
  predicate invariant'0 (self : (u, v))
  
  predicate inv'0 (_x : (u, v))
  
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span3] (18446744073709551615 : uint64)
  
  type deep_model_ty'1
  
  function hash_log'2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'1) : int
  
  type deep_model_ty'0
  
  function hash_log'1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'0) : int
  
  function hash_log'0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [%#span4] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  
  function deep_model'5 (self : v) : deep_model_ty'1
  
  function deep_model'4 (self : u) : deep_model_ty'0
  
  function deep_model'3 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span5] (deep_model'4 (let (a, _) = self in a), deep_model'5 (let (_, a) = self in a))
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span6] deep_model'3 self
  
  use prelude.prelude.Intrinsic
  
  constant min'0 : uint64 = [%#span7] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant bits'0 : uint32 = [%#span8] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span12] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span11] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span10] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span9] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span16] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span15] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span14] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span13] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  function deep_model'2 (self : v) : deep_model_ty'1 =
    [%#span6] deep_model'5 self
  
  let rec hash'1 (self:v) (return'  (ret:uint64))= {[@expl:precondition] [%#span17] inv'2 self}
    any
    [ return' (result:uint64)-> {[%#span18] UInt64.to_int result = hash_log'2 (deep_model'2 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : (u, v))
  
  function deep_model'1 (self : u) : deep_model_ty'0 =
    [%#span6] deep_model'4 self
  
  let rec hash'0 (self:u) (return'  (ret:uint64))= {[@expl:precondition] [%#span17] inv'1 self}
    any
    [ return' (result:uint64)-> {[%#span18] UInt64.to_int result = hash_log'1 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  let rec hash (self:(u, v)) (return'  (ret:uint64))= {[%#sbdd1] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {let (r'0, _) = self in r'0} (fun (_ret':uint64) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = hash'1 {let (_, r'0) = self in r'0} (fun (_ret':uint64) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = wrapping_mul'0 {_6} {[%#sbdd0] (17 : uint64)} (fun (_ret':uint64) ->  [ &_5 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = wrapping_add'0 {_3} {_5} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : (u, v) = self
    | & _3 : uint64 = any_l ()
    | & _5 : uint64 = any_l ()
    | & _6 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd2] UInt64.to_int result = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Bdd_Type
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  type t_bdd  =
    | C_Bdd (t_node) uint64
  with t_node  =
    | C_False
    | C_True
    | C_If uint64 (t_bdd) (t_bdd)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_bdd (input:t_bdd) (ret  (field_0:t_node) (field_1:uint64))= any
    [ good (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_node) (field_1:uint64)-> {C_Bdd field_0 field_1 <> input} {false} any ]
    
  
  let rec false' (input:t_node) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  
  let rec true' (input:t_node) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  
  let rec if' (input:t_node) (ret  (v:uint64) (childt:t_bdd) (childf:t_bdd))= any
    [ good (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:t_bdd) (childf:t_bdd)-> {C_If v childt childf <> input} {false} any ]
    
  
  function bdd_1 (self : t_bdd) : uint64 =
    match self with
      | C_Bdd _ a -> a
      end
  
  function bdd_0 (self : t_bdd) : t_node =
    match self with
      | C_Bdd a _ -> a
      end
end
module Bdd_Node_Type
  use export Bdd_Bdd_Type
end
module Bdd_Impl12_AssertReceiverIsTotalEq
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  let rec assert_receiver_is_total_eq (self:Node'0.t_node) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl7_Eq
  let%span sbdd0 = "../bdd.rs" 201 14 201 37
  
  let%span span1 = "../bdd.rs" 186 20 186 26
  
  let%span span2 = "../bdd.rs" 196 20 196 37
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span1] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Node_Type as Node'0
  
  let rec eq (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_bdd {self}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Bdd'0.t_bdd {o}
              (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->
                UInt64.eq {r1'0} {r1'1} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)))
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & self : Bdd'0.t_bdd = self | & o : Bdd'0.t_bdd = o ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
end
module Bdd_NodeLog_Type
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  type t_nodelog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec false' (input:t_nodelog) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} {false} any ]
    
  
  let rec true' (input:t_nodelog) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} {false} any ]
    
  
  let rec if' (input:t_nodelog) (ret  (v:uint64) (childt:uint64) (childf:uint64))= any
    [ good (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf <> input} {false} any ]
    
end
module Bdd_Impl13_Eq
  let%span sbdd0 = "../bdd.rs" 90 13 90 22
  
  let%span span1 = "../bdd.rs" 160 12 164 13
  
  let%span span2 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span3 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span4 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span5 = "../bdd.rs" 186 20 186 26
  
  let%span span6 = "../bdd.rs" 196 20 196 37
  
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span8 = "../bdd.rs" 201 14 201 37
  
  let%span span9 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span10 = "../../../../creusot-contracts/src/resolve.rs" 17 8 17 60
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  function deep_model'2 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span1] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span2] deep_model'2 self
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function deep_model'3 (self : uint64) : int =
    [%#span3] UInt64.to_int self
  
  function deep_model'1 (self : uint64) : int =
    [%#span2] deep_model'3 self
  
  let rec eq'1 (self:uint64) (other:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span4] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'4 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span5] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span6] deep_model'4 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span7] shallow_model'1 self
  
  let rec eq'0 (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span8] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  predicate resolve'1 (self : Node'0.t_node) =
    [%#span9] true
  
  predicate resolve'0 (self : (Node'0.t_node, Node'0.t_node)) =
    [%#span10] resolve'1 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  let rec eq (self:Node'0.t_node) (rhs:Node'0.t_node) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- (self, rhs) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_False } (! bb2)
        | br1 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_True } (! bb4)
        | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _4 in r'0) = Node'0.C_If a b c} (! bb6) ]
         ]
      
    | bb6 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb1)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb1)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb7 = bb10
    | bb10 = s0
      [ s0 = Node'0.if' {let (r'0, _) = _4 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.if' {let (r'1, _) = _4 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.if' {let (r'2, _) = _4 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 = Node'0.if' {let (_, r'3) = _4 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_bdd) (rchildf'3:Bdd'0.t_bdd) ->  [ &v_2 <- rv'3 ] s4)
      | s4 = Node'0.if' {let (_, r'4) = _4 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_bdd) (rchildf'4:Bdd'0.t_bdd) ->  [ &childt_2 <- rchildt'4 ] s5)
      | s5 = Node'0.if' {let (_, r'5) = _4 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_bdd) (rchildf'5:Bdd'0.t_bdd) ->  [ &childf_2 <- rchildf'5 ] s6)
      | s6 = -{resolve'0 _4}- s7
      | s7 = eq'0 {childf_1} {childf_2} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s8)
      | s8 = bb11 ]
      
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq'0 {childt_1} {childt_2} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0 [ s0 = eq'1 {v_1} {v_2} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ] 
    | bb16 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb21 ] 
    | bb17 = bb20
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb4 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb1)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb5)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb5 = bb9
    | bb9 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [%#sbdd0] true ] s2 | s2 = bb22 ] 
    | bb2 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb3)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb1)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb1 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [%#sbdd0] false ] s2 | s2 = bb22 ] 
    | bb3 = bb8
    | bb8 = s0 [ s0 = -{resolve'0 _4}- s1 | s1 =  [ &_0 <- [%#sbdd0] true ] s2 | s2 = bb22 ] 
    | bb22 = return' {_0} ]
    )
    [ & _0 : bool = any_l ()
    | & self : Node'0.t_node = self
    | & rhs : Node'0.t_node = rhs
    | & _4 : (Node'0.t_node, Node'0.t_node) = any_l ()
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_bdd = any_l ()
    | & childf_1 : Bdd'0.t_bdd = any_l ()
    | & v_2 : uint64 = any_l ()
    | & childt_2 : Bdd'0.t_bdd = any_l ()
    | & childf_2 : Bdd'0.t_bdd = any_l ()
    | & _17 : bool = any_l ()
    | & _20 : bool = any_l ()
    | & _23 : bool = any_l () ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (deep_model'0 self = deep_model'0 rhs)}
      (! return' {result}) ]
    
end
module Bdd_Impl0_Clone
  let%span sbdd0 = "../bdd.rs" 108 14 108 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec clone' (self:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : Bdd'0.t_bdd = any_l () | & self : Bdd'0.t_bdd = self ] 
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ]
    
end
module Bdd_Impl14_Clone
  let%span sbdd0 = "../bdd.rs" 90 24 90 29
  
  let%span span1 = "../bdd.rs" 108 14 108 29
  
  let%span span2 = "../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec clone'1 (self:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span1] result = self} (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  let rec clone'0 (self:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span2] result = self} (! return' {result}) ]
    
  
  use Bdd_Node_Type as Node'0
  
  let rec clone' (self:Node'0.t_node) (return'  (ret:Node'0.t_node))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb1 = {[%#sbdd0] false} any
    | bb4 = s0
      [ s0 = Node'0.if' {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone'0 {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1
      | s1 = clone'1 {_12} (fun (_ret':Bdd'0.t_bdd) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1
      | s1 = clone'1 {_15} (fun (_ret':Bdd'0.t_bdd) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 =  [ &_0 <- Node'0.C_If _7 _10 _13 ] 
        (any
        [ any_ (_any:uint64)-> (!  [ &_7 <- _any ] 
          (any
          [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_10 <- _any ] 
            (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_13 <- _any ] s1) ] )) ]
          )) ]
        )
      | s1 = bb10 ]
      
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- Node'0.C_True ] s1 | s1 = bb10 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- Node'0.C_False ] s1 | s1 = bb10 ] 
    | bb10 = return' {_0} ]
    )
    [ & _0 : Node'0.t_node = any_l ()
    | & self : Node'0.t_node = self
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_bdd = any_l ()
    | & childf_1 : Bdd'0.t_bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _10 : Bdd'0.t_bdd = any_l ()
    | & _12 : Bdd'0.t_bdd = any_l ()
    | & _13 : Bdd'0.t_bdd = any_l ()
    | & _15 : Bdd'0.t_bdd = any_l () ]
     [ return' (result:Node'0.t_node)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ] 
end
module Bdd_Impl17_AssertReceiverIsTotalEq
  use Bdd_Bdd_Type as Bdd'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  let rec assert_receiver_is_total_eq (self:Bdd'0.t_bdd) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Bdd_Impl1_Hash
  let%span sbdd0 = "../bdd.rs" 117 14 117 18
  
  let%span sbdd1 = "../bdd.rs" 121 53 121 54
  
  let%span sbdd2 = "../bdd.rs" 121 92 121 93
  
  let%span sbdd3 = "../bdd.rs" 119 20 119 21
  
  let%span sbdd4 = "../bdd.rs" 118 21 118 22
  
  let%span sbdd5 = "../bdd.rs" 115 14 115 46
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../bdd.rs" 130 12 135 13
  
  let%span span8 = "../bdd.rs" 160 12 164 13
  
  let%span span9 = "../bdd.rs" 176 20 176 37
  
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "" 0 0 0 0
  
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function hash_log'0 [#"../bdd.rs" 128 4 128 44] (x : NodeLog'0.t_nodelog) : int =
    [%#span7] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_Node_Type as Node'0
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  constant min'0 : uint64 = [%#span11] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant bits'0 : uint32 = [%#span12] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span16] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span15] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span14] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span13] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span20] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (max'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span19] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (min'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (max'0 : uint64) - UInt64.to_int (min'0 : uint64) + 1))}
      {[%#span18] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (min'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (max'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span17] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt64.to_int (min'0 : uint64)}
      (! return' {result}) ]
    
  
  use Bdd_Bdd_Type as Bdd'0
  
  let rec hash (self:Node'0.t_node) (return'  (ret:uint64))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb1 = {[%#sbdd0] false} any
    | bb4 = s0
      [ s0 = Node'0.if' {self} (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v <- rv'0 ] s1)
      | s1 = Node'0.if' {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt <- rchildt'1 ] s2)
      | s2 = Node'0.if' {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf <- rchildf'2 ] s3)
      | s3 = Bdd'0.t_bdd {childt}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd1] (5 : uint64)} (fun (_ret':uint64) ->  [ &_9 <- _ret' ] s4))
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 = wrapping_add'0 {v} {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = Bdd'0.t_bdd {childf}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd2] (7 : uint64)} (fun (_ret':uint64) ->  [ &_11 <- _ret' ] s1))
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = wrapping_add'0 {_7} {_11} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = bb11
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd3] (2 : uint64) ] s1 | s1 = bb11 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd4] (1 : uint64) ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : Node'0.t_node = self
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _11 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd5] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl2_Hash
  let%span sbdd0 = "../bdd.rs" 141 14 141 46
  
  let%span span1 = "../bdd.rs" 149 8 149 24
  
  let%span span2 = "../bdd.rs" 186 20 186 26
  
  let%span span3 = "../bdd.rs" 196 20 196 37
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [%#span1] UInt64.to_int x
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_Bdd_Type as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span4] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use Bdd_Node_Type as Node'0
  
  let rec hash (self:Bdd'0.t_bdd) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_bdd {self} (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->  [ &_0 <- r1'0 ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () | & self : Bdd'0.t_bdd = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd0] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module Bdd_Impl8_Size_Impl
  let%span sbdd0 = "../bdd.rs" 223 14 223 25
  
  use Bdd_Node_Type as Node'0
  
  use Bdd_Bdd_Type as Bdd'0
  
  use prelude.prelude.Int
  
  constant self  : Bdd'0.t_bdd
  
  function size [#"../bdd.rs" 224 4 224 24] (self : Bdd'0.t_bdd) : int
  
  goal vc_size : match self with
    | Bdd'0.C_Bdd (Node'0.C_True) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_False) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> ([%#sbdd0] size childt >= 0)
     -> (let ht = size childt in ([%#sbdd0] size childf >= 0)  -> (let hf = size childf in [%#sbdd0] 1 + ht + hf >= 0))
    end
end
module Bdd_Context_Type
  use Bdd_Bdd_Type as Bdd'0
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  use prelude.prelude.Borrow
  
  type t_context  =
    | C_Context (Bump'0.t_bump) (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec t_context (input:t_context) (ret  (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64))= any
    [ good (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      = input}
      (! ret {alloc} {hashcons} {hashcons_ghost} {not_memo} {and_memo} {cnt})
    | bad (alloc:Bump'0.t_bump) (hashcons:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (not_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (and_memo:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      <> input}
      {false}
      any ]
    
  
  function context_hashcons (self : t_context) : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ a _ _ _ _ -> a
      end
  
  function context_cnt (self : t_context) : uint64 =
    match self with
      | C_Context _ _ _ _ _ a -> a
      end
  
  function context_hashcons_ghost (self : t_context) : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) =
    match self with
      | C_Context _ _ a _ _ _ -> a
      end
  
  function context_not_memo (self : t_context) : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ _ _ a _ _ -> a
      end
  
  function context_and_memo (self : t_context) : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd) =
    match self with
      | C_Context _ _ _ _ a _ -> a
      end
end
module Bdd_Impl10_GrowsIsValidBdd_Impl
  let%span sbdd0 = "../bdd.rs" 333 15 333 27
  
  let%span sbdd1 = "../bdd.rs" 334 15 334 35
  
  let%span sbdd2 = "../bdd.rs" 336 35 336 39
  
  let%span sbdd3 = "../bdd.rs" 335 14 335 37
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 241 12 245 13
  
  let%span span7 = "../bdd.rs" 211 12 218 13
  
  let%span span8 = "../bdd.rs" 160 12 164 13
  
  let%span span9 = "../bdd.rs" 176 20 176 37
  
  let%span span10 = "../bdd.rs" 311 12 311 47
  
  let%span span11 = "../bdd.rs" 318 12 327 13
  
  let%span span12 = "../bdd.rs" 264 12 288 19
  
  let%span span13 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span14 = "../bdd.rs" 297 8 304 9
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span4] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span6] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span10] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span11] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span12] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'3 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'4 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span13] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span14] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_context)
  
  constant b  : Bdd'0.t_bdd
  
  function grows_is_valid_bdd [#"../bdd.rs" 336 4 336 56] (self : borrowed (Context'0.t_context)) (b : Bdd'0.t_bdd) : ()
  
  goal vc_grows_is_valid_bdd : ([%#sbdd2] inv'0 self)
   -> ([%#sbdd1] is_valid_bdd'0 ( * self) b)  -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd3] is_valid_bdd'0 ( ^ self) b)
end
module Bdd_Impl10_GrowsTrans_Impl
  let%span sbdd0 = "../bdd.rs" 340 15 340 27
  
  let%span sbdd1 = "../bdd.rs" 341 15 341 24
  
  let%span sbdd2 = "../bdd.rs" 342 15 342 26
  
  let%span sbdd3 = "../bdd.rs" 343 15 343 43
  
  let%span sbdd4 = "../bdd.rs" 345 28 345 32
  
  let%span sbdd5 = "../bdd.rs" 345 34 345 35
  
  let%span sbdd6 = "../bdd.rs" 345 48 345 50
  
  let%span sbdd7 = "../bdd.rs" 344 14 344 24
  
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "../bdd.rs" 241 12 245 13
  
  let%span span11 = "../bdd.rs" 211 12 218 13
  
  let%span span12 = "../bdd.rs" 160 12 164 13
  
  let%span span13 = "../bdd.rs" 176 20 176 37
  
  let%span span14 = "../bdd.rs" 311 12 311 47
  
  let%span span15 = "../bdd.rs" 318 12 327 13
  
  let%span span16 = "../bdd.rs" 264 12 288 19
  
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span18 = "../bdd.rs" 297 8 304 9
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'2 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span8] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span9] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span10] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span12] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'4 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span13] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] shallow_model'4 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span14] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span15] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span16] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'2 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'3 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span17] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span18] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_context)
  
  constant o  : borrowed (Context'0.t_context)
  
  constant oo  : borrowed (Context'0.t_context)
  
  function grows_trans [#"../bdd.rs" 345 4 345 62] (self : borrowed (Context'0.t_context)) (o : borrowed (Context'0.t_context)) (oo : borrowed (Context'0.t_context)) : ()
    
  
  goal vc_grows_trans : ([%#sbdd6] inv'0 oo)
   -> ([%#sbdd5] inv'0 o)
   -> ([%#sbdd4] inv'0 self)
   -> ([%#sbdd3]  * self =  * oo /\  ^ self =  ^ oo)
   -> ([%#sbdd2]  ^ self =  * o)  -> ([%#sbdd1] grows'0 o)  -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd7] grows'0 oo)
end
module Bdd_Impl10_SetIrreleventVar_Impl
  let%span sbdd0 = "../bdd.rs" 348 15 348 35
  
  let%span sbdd1 = "../bdd.rs" 349 15 349 32
  
  let%span sbdd2 = "../bdd.rs" 351 26 351 30
  
  let%span sbdd3 = "../bdd.rs" 350 14 350 50
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../bdd.rs" 241 12 245 13
  
  let%span span7 = "../bdd.rs" 211 12 218 13
  
  let%span span8 = "../bdd.rs" 160 12 164 13
  
  let%span span9 = "../bdd.rs" 176 20 176 37
  
  let%span span10 = "../bdd.rs" 311 12 311 47
  
  let%span span11 = "../bdd.rs" 318 12 327 13
  
  let%span span12 = "../bdd.rs" 264 12 288 19
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span4] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span6] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span4] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span10] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span11] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span12] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Map
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant x  : uint64
  
  constant v  : Map.map uint64 bool
  
  constant b  : bool
  
  function set_irrelevent_var [#"../bdd.rs" 351 4 351 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  
  goal vc_set_irrelevent_var : ([%#sbdd2] inv'0 self)
   -> ([%#sbdd1] UInt64.to_int x < leastvar'0 a)
   -> ([%#sbdd0] is_valid_bdd'0 self a)
   -> match a with
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> (([%#sbdd2] inv'0 self)
    && ([%#sbdd1] UInt64.to_int x < leastvar'0 childt) && ([%#sbdd0] is_valid_bdd'0 self childt))
    /\ (([%#sbdd3] interp'0 childt v = interp'0 childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([%#sbdd2] inv'0 self)
    && ([%#sbdd1] UInt64.to_int x < leastvar'0 childf) && ([%#sbdd0] is_valid_bdd'0 self childf))
    /\ (([%#sbdd3] interp'0 childf v = interp'0 childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)))))
    | _ -> [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)
    end
end
module Bdd_Impl10_DiscrValuation_Impl
  let%span sbdd0 = "../bdd.rs" 364 15 364 35
  
  let%span sbdd1 = "../bdd.rs" 365 15 365 35
  
  let%span sbdd2 = "../bdd.rs" 366 15 366 21
  
  let%span sbdd3 = "../bdd.rs" 370 23 370 27
  
  let%span sbdd4 = "../bdd.rs" 367 14 367 50
  
  let%span sbdd5 = "../bdd.rs" 368 14 368 33
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 241 12 245 13
  
  let%span span9 = "../bdd.rs" 211 12 218 13
  
  let%span span10 = "../bdd.rs" 160 12 164 13
  
  let%span span11 = "../bdd.rs" 176 20 176 37
  
  let%span span12 = "../bdd.rs" 311 12 311 47
  
  let%span span13 = "../bdd.rs" 318 12 327 13
  
  let%span span14 = "../bdd.rs" 264 12 288 19
  
  let%span span15 = "../bdd.rs" 348 15 348 35
  
  let%span span16 = "../bdd.rs" 349 15 349 32
  
  let%span span17 = "../bdd.rs" 351 26 351 30
  
  let%span span18 = "../bdd.rs" 350 14 350 50
  
  let%span span19 = "../bdd.rs" 353 12 359 13
  
  let%span span20 = "../bdd.rs" 223 14 223 25
  
  let%span span21 = "../bdd.rs" 226 12 234 13
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 351 4 351 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span19] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span15] is_valid_bdd'0 self a)
   -> ([%#span16] UInt64.to_int x < leastvar'0 a)
   -> ([%#span17] inv'0 self)  -> ([%#span18] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd'0.t_bdd) : int =
    [%#span21] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span20] size'0 self >= 0
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant b  : Bdd'0.t_bdd
  
  function discr_valuation [#"../bdd.rs" 370 4 370 82] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : Map.map uint64 bool
    
  
  goal vc_discr_valuation : ([%#sbdd3] inv'0 self)
   -> ([%#sbdd2] a <> b)
   -> ([%#sbdd1] is_valid_bdd'0 self b)
   -> ([%#sbdd0] is_valid_bdd'0 self a)
   -> (let _ = set_irrelevent_var'0 in match leastvar'0 a < leastvar'0 b with
    | True -> match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> match childf <> b with
        | True -> ((([%#sbdd3] inv'0 self)
        && ([%#sbdd2] childf <> b) && ([%#sbdd1] is_valid_bdd'0 self b) && ([%#sbdd0] is_valid_bdd'0 self childf))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childf + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childf (discr_valuation self childf b) <> interp'0 b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
        | False -> ((([%#sbdd3] inv'0 self)
        && ([%#sbdd2] childt <> b) && ([%#sbdd1] is_valid_bdd'0 self b) && ([%#sbdd0] is_valid_bdd'0 self childt))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childt + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childt (discr_valuation self childt b) <> interp'0 b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
        end
      | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
      end
    | False -> match leastvar'0 a > leastvar'0 b with
      | True -> match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> match childf <> a with
          | True -> ((([%#sbdd3] inv'0 self)
          && ([%#sbdd2] a <> childf) && ([%#sbdd1] is_valid_bdd'0 self childf) && ([%#sbdd0] is_valid_bdd'0 self a))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childf) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childf) <> interp'0 childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
          | False -> ((([%#sbdd3] inv'0 self)
          && ([%#sbdd2] a <> childt) && ([%#sbdd1] is_valid_bdd'0 self childt) && ([%#sbdd0] is_valid_bdd'0 self a))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childt) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childt) <> interp'0 childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
          end
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
      | False -> match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> match childfa <> childfb with
            | True -> ((([%#sbdd3] inv'0 self)
            && ([%#sbdd2] childfa <> childfb)
            && ([%#sbdd1] is_valid_bdd'0 self childfb) && ([%#sbdd0] is_valid_bdd'0 self childfa))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childfa + size'0 childfb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childfa (discr_valuation self childfa childfb)
            <> interp'0 childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
            | False -> ((([%#sbdd3] inv'0 self)
            && ([%#sbdd2] childta <> childtb)
            && ([%#sbdd1] is_valid_bdd'0 self childtb) && ([%#sbdd0] is_valid_bdd'0 self childta))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childta + size'0 childtb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childta (discr_valuation self childta childtb)
            <> interp'0 childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
            end
          | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
          end
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
      end
    end)
end
module Bdd_Impl10_BddCanonical_Impl
  let%span sbdd0 = "../bdd.rs" 413 15 413 35
  
  let%span sbdd1 = "../bdd.rs" 414 15 414 35
  
  let%span sbdd2 = "../bdd.rs" 415 4 415 56
  
  let%span sbdd3 = "../bdd.rs" 418 25 418 29
  
  let%span sbdd4 = "../bdd.rs" 416 14 416 20
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../bdd.rs" 241 12 245 13
  
  let%span span8 = "../bdd.rs" 211 12 218 13
  
  let%span span9 = "../bdd.rs" 160 12 164 13
  
  let%span span10 = "../bdd.rs" 176 20 176 37
  
  let%span span11 = "../bdd.rs" 311 12 311 47
  
  let%span span12 = "../bdd.rs" 318 12 327 13
  
  let%span span13 = "../bdd.rs" 264 12 288 19
  
  let%span span14 = "../bdd.rs" 348 15 348 35
  
  let%span span15 = "../bdd.rs" 349 15 349 32
  
  let%span span16 = "../bdd.rs" 351 26 351 30
  
  let%span span17 = "../bdd.rs" 350 14 350 50
  
  let%span span18 = "../bdd.rs" 353 12 359 13
  
  let%span span19 = "../bdd.rs" 223 14 223 25
  
  let%span span20 = "../bdd.rs" 226 12 234 13
  
  let%span span21 = "../bdd.rs" 364 15 364 35
  
  let%span span22 = "../bdd.rs" 365 15 365 35
  
  let%span span23 = "../bdd.rs" 366 15 366 21
  
  let%span span24 = "../bdd.rs" 370 23 370 27
  
  let%span span25 = "../bdd.rs" 367 14 367 50
  
  let%span span26 = "../bdd.rs" 368 14 368 33
  
  let%span span27 = "../bdd.rs" 372 12 372 36
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span5] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span11] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span13] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 351 4 351 87] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span18] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span14] is_valid_bdd'0 self a)
   -> ([%#span15] UInt64.to_int x < leastvar'0 a)
   -> ([%#span16] inv'0 self)  -> ([%#span17] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd'0.t_bdd) : int =
    [%#span20] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span19] size'0 self >= 0
  
  function discr_valuation'0 [#"../bdd.rs" 370 4 370 82] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : Map.map uint64 bool
    
  
  axiom discr_valuation'0_def : forall self : Context'0.t_context, a : Bdd'0.t_bdd, b : Bdd'0.t_bdd . discr_valuation'0 self a b
  = ([%#span27] let _ = () in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation'0 self childf b) v false
      else
        Map.set (discr_valuation'0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation'0 self a childf) v false
        else
          Map.set (discr_valuation'0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation'0 self childfa childfb) v false
          else
            Map.set (discr_valuation'0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  
  axiom discr_valuation'0_spec : forall self : Context'0.t_context, a : Bdd'0.t_bdd, b : Bdd'0.t_bdd . ([%#span21] is_valid_bdd'0 self a)
   -> ([%#span22] is_valid_bdd'0 self b)
   -> ([%#span23] a <> b)
   -> ([%#span24] inv'0 self)
   -> ([%#span25] interp'0 a (discr_valuation'0 self a b) <> interp'0 b (discr_valuation'0 self a b))
  
  constant self  : Context'0.t_context
  
  constant a  : Bdd'0.t_bdd
  
  constant b  : Bdd'0.t_bdd
  
  function bdd_canonical [#"../bdd.rs" 418 4 418 62] (self : Context'0.t_context) (a : Bdd'0.t_bdd) (b : Bdd'0.t_bdd) : ()
    
  
  goal vc_bdd_canonical : ([%#sbdd3] inv'0 self)
   -> ([%#sbdd2] forall v : Map.map uint64 bool . interp'0 a v = interp'0 b v)
   -> ([%#sbdd1] is_valid_bdd'0 self b)
   -> ([%#sbdd0] is_valid_bdd'0 self a)  -> (let _ = discr_valuation'0 in [%#sbdd4] a = b)
end
module Bdd_Impl11_New
  let%span sbdd0 = "../bdd.rs" 428 22 428 47
  
  let%span sbdd1 = "../bdd.rs" 429 28 429 57
  
  let%span sbdd2 = "../bdd.rs" 430 22 430 47
  
  let%span sbdd3 = "../bdd.rs" 431 22 431 47
  
  let%span sbdd4 = "../bdd.rs" 432 17 432 18
  
  let%span sbdd5 = "../bdd.rs" 424 48 424 52
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 241 12 245 13
  
  let%span span9 = "../bdd.rs" 211 12 218 13
  
  let%span span10 = "../bdd.rs" 160 12 164 13
  
  let%span span11 = "../bdd.rs" 176 20 176 37
  
  let%span span12 = "../bdd.rs" 311 12 311 47
  
  let%span span13 = "../bdd.rs" 318 12 327 13
  
  let%span span14 = "../bdd.rs" 264 12 288 19
  
  let%span span15 = "../bdd.rs" 67 18 67 47
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'2 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'4 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'3 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'4 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'3 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'3 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'2 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_x : Context'0.t_context)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use map.Const
  
  let rec new'2 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'2 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use map.Const
  
  let rec new'1 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'1 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Const
  
  use map.Const
  
  let rec new'0 (_1:()) (return'  (ret:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)))= any
    [ return' (result:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))-> {[%#span15] shallow_model'0 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Node'0.t_node))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Node'0.C_True ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Node'0.t_node = any_l () | & _1 : Node'0.t_node = any_l () ] 
    [ return' (result:Node'0.t_node)-> return' {result} ]
    
  
  let rec new (alloc:Bump'0.t_bump) (return'  (ret:Context'0.t_context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0 (fun (pr0:Node'0.t_node) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new'0 {[%#sbdd0] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd1] Snapshot.new (Const.const t) ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = new'1 {[%#sbdd2] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) ->  [ &_8 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = new'2 {[%#sbdd3] ()}
          (fun (_ret':MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &_0 <- Context'0.C_Context alloc _5 _6 _8 _9 ([%#sbdd4] (0 : uint64)) ] 
        (any
        [ any_ (_any:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))-> (!  [ &_5 <- _any ] 
          (any
          [ any_ (_any:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)))-> (!  [ &_6 <- _any ] 
            (any
            [ any_ (_any:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))-> (!  [ &_8 <- _any ] 
              (any
              [ any_ (_any:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))-> (!  [ &_9 <- _any ] s1) ]
              )) ]
            )) ]
          )) ]
        )
      | s1 = return' {_0} ]
       ]
    )
    [ & _0 : Context'0.t_context = any_l ()
    | & alloc : Bump'0.t_bump = alloc
    | & t : Node'0.t_node = any_l ()
    | & _5 : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd) = any_l ()
    | & _6 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) = any_l ()
    | & _8 : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd) = any_l ()
    | & _9 : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd) = any_l ()
    | & _10 : Node'0.t_node = any_l () ]
     [ return' (result:Context'0.t_context)-> {[@expl:postcondition] [%#sbdd5] inv'0 result} (! return' {result}) ] 
end
module Bdd_Impl11_Hashcons
  let%span sbdd0 = "../bdd.rs" 447 30 447 77
  
  let%span sbdd1 = "../bdd.rs" 448 22 448 30
  
  let%span sbdd2 = "../bdd.rs" 448 33 448 34
  
  let%span sbdd3 = "../bdd.rs" 454 20 454 21
  
  let%span sbdd4 = "../bdd.rs" 442 28 442 38
  
  let%span sbdd5 = "../bdd.rs" 436 15 436 36
  
  let%span sbdd6 = "../bdd.rs" 440 21 440 25
  
  let%span sbdd7 = "../bdd.rs" 437 14 437 28
  
  let%span sbdd8 = "../bdd.rs" 438 14 438 26
  
  let%span sbdd9 = "../bdd.rs" 439 14 439 42
  
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../bdd.rs" 241 12 245 13
  
  let%span span13 = "../bdd.rs" 211 12 218 13
  
  let%span span14 = "../bdd.rs" 160 12 164 13
  
  let%span span15 = "../bdd.rs" 176 20 176 37
  
  let%span span16 = "../bdd.rs" 311 12 311 47
  
  let%span span17 = "../bdd.rs" 318 12 327 13
  
  let%span span18 = "../bdd.rs" 264 12 288 19
  
  let%span span19 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span20 = "../bdd.rs" 297 8 304 9
  
  let%span span21 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span22 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span23 = "../bdd.rs" 54 30 54 33
  
  let%span span24 = "../bdd.rs" 54 38 54 41
  
  let%span span25 = "../bdd.rs" 52 8 52 128
  
  let%span span26 = "../bdd.rs" 18 31 18 34
  
  let%span span27 = "../bdd.rs" 17 18 17 32
  
  let%span span28 = "../bdd.rs" 18 42 18 48
  
  let%span span29 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span30 = "../bdd.rs" 63 37 63 40
  
  let%span span31 = "../bdd.rs" 58 18 61 9
  
  let%span span32 = "../bdd.rs" 63 52 63 65
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span10] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span11] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span14] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span15] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] shallow_model'1 self
  
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span16] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'0 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span17] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'7 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span18] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'0 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'7 (_x : Context'0.t_context)
  
  axiom inv'7 : forall x : Context'0.t_context . inv'7 x
  = (invariant'7 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'6 (self : NodeLog'0.t_nodelog) =
    [%#span19] true
  
  predicate inv'6 (_x : NodeLog'0.t_nodelog)
  
  axiom inv'6 : forall x : NodeLog'0.t_nodelog . inv'6 x = true
  
  predicate invariant'5 (self : Bdd'0.t_bdd) =
    [%#span19] true
  
  predicate inv'5 (_x : Bdd'0.t_bdd)
  
  axiom inv'5 : forall x : Bdd'0.t_bdd . inv'5 x = true
  
  predicate invariant'4 (self : borrowed (Node'0.t_node)) =
    [%#span19] true
  
  predicate inv'4 (_x : borrowed (Node'0.t_node))
  
  axiom inv'4 : forall x : borrowed (Node'0.t_node) . inv'4 x = true
  
  predicate invariant'3 (self : Node'0.t_node) =
    [%#span19] true
  
  predicate inv'3 (_x : Node'0.t_node)
  
  axiom inv'3 : forall x : Node'0.t_node . inv'3 x = true
  
  predicate invariant'2 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span19] true
  
  predicate inv'2 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'2 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'2 x = true
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span19] true
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span19] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'7 ( * x) /\ inv'7 ( ^ x))
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span20] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_context)) =
    [%#span21]  ^ self =  * self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  function shallow_model'4 (self : borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span22] shallow_model'3 ( * self)
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) (key:Node'0.t_node) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span24] inv'5 val'}
    {[@expl:precondition] [%#span23] inv'3 key}
    any
    [ return' (result:())-> {[%#span25] forall i : NodeLog'0.t_nodelog . inv'6 i
       -> Map.get (shallow_model'3 ( ^ self)) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'4 self) i)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Node'0.t_node)) =
    [%#span21]  ^ self =  * self
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec alloc'0 (self:Bump'0.t_bump) (val':Node'0.t_node) (return'  (ret:borrowed (Node'0.t_node)))= {[@expl:precondition] [%#span26] inv'3 val'}
    any
    [ return' (result:borrowed (Node'0.t_node))-> {[%#span28] inv'4 result}
      {[%#span27]  * result = val'}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span29] deep_model'1 self
  
  function shallow_model'2 (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span10] shallow_model'3 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (key:Node'0.t_node) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span30] inv'1 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span32] inv'2 result}
      {[%#span31] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  let rec hashcons (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd6] inv'0 self}
    {[%#sbdd5] is_valid_node'0 ( * self) n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n ] s1
      | s1 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rhashcons'0} {_11} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_8 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_8 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_8 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            alloc'0 {ralloc'0} {n} (fun (_ret':borrowed (Node'0.t_node)) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
             [ &r1 <- Bdd'0.C_Bdd ( * _19) rcnt'0 ] 
            s1)
      | s1 = -{resolve'0 _19}- s2
      | s2 = Context'0.t_context { * self}
          (fun (ralloc'1:Bump'0.t_bump) (rhashcons'1:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'1:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'1:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'1:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'1:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)>
              {rhashcons'1}
              {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd))) ->
                 [ &_24 <- _ret' ] 
                Context'0.t_context { * self}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 ( ^ _24) l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
                    
                    s3)))
      | s3 = add'0 {_24} {n} {r1} (fun (_ret':()) ->  [ &_23 <- _ret' ] s4)
      | s4 = bb6 ]
      
    | bb6 = s0
      [ s0 = 
        [ &_27 <- [%#sbdd0] Snapshot.new (Map.set (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost ( * self))) (Bdd_Bdd_Type.bdd_1 r1) (Bdd_Bdd_Type.bdd_0 r1)) ]
        
        s1
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
            
            [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 _27 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
            
            (any [ any_ (_any:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)))-> (!  [ &_27 <- _any ] s1) ] ))
      | s1 = UInt64.sub {[%#sbdd1] (18446744073709551615 : uint64)} {[%#sbdd2] (1 : uint64)}
          (fun (_ret':uint64) ->  [ &_32 <- _ret' ] s2)
      | s2 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            UInt64.gt {rcnt'0} {_32}
              (fun (_ret':bool) ->  [ &_30 <- _ret' ] (any [ any_ (_any:uint64)-> (!  [ &_32 <- _any ] s3) ] )))
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new self ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:loop invariant]  ^ Snapshot.inner old_9_0 =  ^ self}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = Context'0.t_context { * self}
              (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
                Context'0.t_context { * self}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 rcnt'0 ; } ]
                    
                    s1))
          | s1 = bb9 ]
           ]
         ]
      
    | bb11 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            UInt64.add {rcnt'0} {[%#sbdd3] (1 : uint64)}
              (fun (_ret':uint64) ->
                Context'0.t_context { * self}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 _ret' ; } ]
                    
                    s1)))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 =  [ &_0 <- r1 ] s4
      | s4 = bb12 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_8} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 = {[@expl:assertion] [%#sbdd4] shallow_model'0 (Bdd_Bdd_Type.bdd_0 r) = shallow_model'1 n} s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb12 ]
      
    | bb12 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & n : Node'0.t_node = n
    | & _8 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _11 : Node'0.t_node = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _19 : borrowed (Node'0.t_node) = any_l ()
    | & _23 : () = any_l ()
    | & _24 : borrowed (MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) = any_l ()
    | & _27 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_node)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : uint64 = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (Context'0.t_context)) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd9] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd8] grows'0 self}
      {[@expl:postcondition] [%#sbdd7] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Node
  let%span sbdd0 = "../bdd.rs" 458 15 458 40
  
  let%span sbdd1 = "../bdd.rs" 459 15 459 40
  
  let%span sbdd2 = "../bdd.rs" 460 15 460 63
  
  let%span sbdd3 = "../bdd.rs" 465 17 465 21
  
  let%span sbdd4 = "../bdd.rs" 461 14 461 26
  
  let%span sbdd5 = "../bdd.rs" 462 14 462 42
  
  let%span sbdd6 = "../bdd.rs" 463 4 463 106
  
  let%span sbdd7 = "../bdd.rs" 464 14 464 37
  
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "../bdd.rs" 241 12 245 13
  
  let%span span11 = "../bdd.rs" 211 12 218 13
  
  let%span span12 = "../bdd.rs" 160 12 164 13
  
  let%span span13 = "../bdd.rs" 176 20 176 37
  
  let%span span14 = "../bdd.rs" 311 12 311 47
  
  let%span span15 = "../bdd.rs" 318 12 327 13
  
  let%span span16 = "../bdd.rs" 264 12 288 19
  
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span18 = "../bdd.rs" 297 8 304 9
  
  let%span span19 = "../bdd.rs" 436 15 436 36
  
  let%span span20 = "../bdd.rs" 440 21 440 25
  
  let%span span21 = "../bdd.rs" 437 14 437 28
  
  let%span span22 = "../bdd.rs" 438 14 438 26
  
  let%span span23 = "../bdd.rs" 439 14 439 42
  
  let%span span24 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span25 = "../bdd.rs" 186 20 186 26
  
  let%span span26 = "../bdd.rs" 196 20 196 37
  
  let%span span27 = "../bdd.rs" 201 14 201 37
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span8] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span9] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span10] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span12] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'5 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span13] deep_model'1 self
  
  function shallow_model'2 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span8] shallow_model'5 self
  
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span14] Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) (shallow_model'2 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span15] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span16] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'2 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span17] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span18] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'1 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span20] inv'0 self}
    {[@expl:precondition] [%#span19] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span23] is_valid_bdd'0 ( ^ self) result}
      {[%#span22] grows'0 self}
      {[%#span21] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span24]  ^ self =  * self
  
  function deep_model'0 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span25] Bdd_Bdd_Type.bdd_1 self
  
  function shallow_model'4 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span26] deep_model'0 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span8] shallow_model'4 self
  
  let rec eq'0 (self:Bdd'0.t_bdd) (o:Bdd'0.t_bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span27] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  let rec node (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd3] inv'0 self}
    {[%#sbdd2] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[%#sbdd1] is_valid_bdd'0 ( * self) childf}
    {[%#sbdd0] is_valid_bdd'0 ( * self) childt}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {childt} {childf} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- childt ] s3
      | s3 = bb5 ]
      
    | bb3 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_17 <- _ret' ] 
             [ &self <- { self with current = ( ^ _17) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _17)}- s2
      | s2 =  [ &_18 <- Node'0.C_If x childt childf ] s3
      | s3 = hashcons'0 {_17} {_18} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : uint64 = x
    | & childt : Bdd'0.t_bdd = childt
    | & childf : Bdd'0.t_bdd = childf
    | & _13 : bool = any_l ()
    | & _17 : borrowed (Context'0.t_context) = any_l ()
    | & _18 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd7] UInt64.to_int x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd6] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[@expl:postcondition] [%#sbdd5] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd4] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_True
  let%span sbdd0 = "../bdd.rs" 476 22 476 26
  
  let%span sbdd1 = "../bdd.rs" 472 14 472 26
  
  let%span sbdd2 = "../bdd.rs" 473 14 473 42
  
  let%span sbdd3 = "../bdd.rs" 474 4 474 44
  
  let%span sbdd4 = "../bdd.rs" 475 14 475 46
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 241 12 245 13
  
  let%span span9 = "../bdd.rs" 211 12 218 13
  
  let%span span10 = "../bdd.rs" 160 12 164 13
  
  let%span span11 = "../bdd.rs" 176 20 176 37
  
  let%span span12 = "../bdd.rs" 311 12 311 47
  
  let%span span13 = "../bdd.rs" 318 12 327 13
  
  let%span span14 = "../bdd.rs" 264 12 288 19
  
  let%span span15 = "../bdd.rs" 297 8 304 9
  
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span17 = "../bdd.rs" 436 15 436 36
  
  let%span span18 = "../bdd.rs" 440 21 440 25
  
  let%span span19 = "../bdd.rs" 437 14 437 28
  
  let%span span20 = "../bdd.rs" 438 14 438 26
  
  let%span span21 = "../bdd.rs" 439 14 439 42
  
  use Bdd_Context_Type as Context'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span5] true
  
  predicate inv'0 (_x : Context'0.t_context)
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span15] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span16]  ^ self =  * self
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span21] is_valid_bdd'0 ( ^ self) result}
      {[%#span20] grows'0 self}
      {[%#span19] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  let rec true_ (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = ( ^ _6) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _6)}- s2
      | s2 =  [ &_7 <- Node'0.C_True ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & _6 : borrowed (Context'0.t_context) = any_l ()
    | & _7 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_False
  let%span sbdd0 = "../bdd.rs" 484 23 484 27
  
  let%span sbdd1 = "../bdd.rs" 480 14 480 26
  
  let%span sbdd2 = "../bdd.rs" 481 14 481 42
  
  let%span sbdd3 = "../bdd.rs" 482 4 482 45
  
  let%span sbdd4 = "../bdd.rs" 483 14 483 46
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span7 = "" 0 0 0 0
  
  let%span span8 = "../bdd.rs" 241 12 245 13
  
  let%span span9 = "../bdd.rs" 211 12 218 13
  
  let%span span10 = "../bdd.rs" 160 12 164 13
  
  let%span span11 = "../bdd.rs" 176 20 176 37
  
  let%span span12 = "../bdd.rs" 311 12 311 47
  
  let%span span13 = "../bdd.rs" 318 12 327 13
  
  let%span span14 = "../bdd.rs" 264 12 288 19
  
  let%span span15 = "../bdd.rs" 297 8 304 9
  
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span17 = "../bdd.rs" 436 15 436 36
  
  let%span span18 = "../bdd.rs" 440 21 440 25
  
  let%span span19 = "../bdd.rs" 437 14 437 28
  
  let%span span20 = "../bdd.rs" 438 14 438 26
  
  let%span span21 = "../bdd.rs" 439 14 439 42
  
  use Bdd_Context_Type as Context'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span5] true
  
  predicate inv'0 (_x : Context'0.t_context)
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span12] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span14] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span15] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span16]  ^ self =  * self
  
  let rec hashcons'0 (self:borrowed (Context'0.t_context)) (n:Node'0.t_node) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 ( * self) n}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span21] is_valid_bdd'0 ( ^ self) result}
      {[%#span20] grows'0 self}
      {[%#span19] Bdd_Bdd_Type.bdd_0 result = n}
      (! return' {result}) ]
    
  
  let rec false_ (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = ( ^ _6) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _6)}- s2
      | s2 =  [ &_7 <- Node'0.C_False ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & _6 : borrowed (Context'0.t_context) = any_l ()
    | & _7 : Node'0.t_node = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (max'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . not interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_V
  let%span sbdd0 = "../bdd.rs" 491 18 491 22
  
  let%span sbdd1 = "../bdd.rs" 488 14 488 26
  
  let%span sbdd2 = "../bdd.rs" 489 14 489 42
  
  let%span sbdd3 = "../bdd.rs" 490 4 490 56
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../bdd.rs" 241 12 245 13
  
  let%span span8 = "../bdd.rs" 211 12 218 13
  
  let%span span9 = "../bdd.rs" 160 12 164 13
  
  let%span span10 = "../bdd.rs" 176 20 176 37
  
  let%span span11 = "../bdd.rs" 311 12 311 47
  
  let%span span12 = "../bdd.rs" 318 12 327 13
  
  let%span span13 = "../bdd.rs" 264 12 288 19
  
  let%span span14 = "../bdd.rs" 297 8 304 9
  
  let%span span15 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span16 = "../bdd.rs" 458 15 458 40
  
  let%span span17 = "../bdd.rs" 459 15 459 40
  
  let%span span18 = "../bdd.rs" 460 15 460 63
  
  let%span span19 = "../bdd.rs" 465 17 465 21
  
  let%span span20 = "../bdd.rs" 461 14 461 26
  
  let%span span21 = "../bdd.rs" 462 14 462 42
  
  let%span span22 = "../bdd.rs" 463 4 463 106
  
  let%span span23 = "../bdd.rs" 464 14 464 37
  
  let%span span24 = "../bdd.rs" 484 23 484 27
  
  let%span span25 = "../bdd.rs" 480 14 480 26
  
  let%span span26 = "../bdd.rs" 481 14 481 42
  
  let%span span27 = "../bdd.rs" 482 4 482 45
  
  let%span span28 = "../bdd.rs" 483 14 483 46
  
  let%span span29 = "../bdd.rs" 476 22 476 26
  
  let%span span30 = "../bdd.rs" 472 14 472 26
  
  let%span span31 = "../bdd.rs" 473 14 473 42
  
  let%span span32 = "../bdd.rs" 474 4 474 44
  
  let%span span33 = "../bdd.rs" 475 14 475 46
  
  use Bdd_Context_Type as Context'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_context)) =
    [%#span4] true
  
  predicate inv'0 (_x : Context'0.t_context)
  
  predicate inv'1 (_x : borrowed (Context'0.t_context))
  
  axiom inv'1 : forall x : borrowed (Context'0.t_context) . inv'1 x = (inv'0 ( * x) /\ inv'0 ( ^ x))
  
  use prelude.prelude.UInt64
  
  use Bdd_Bdd_Type as Bdd'0
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'0 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span5] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span11] Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) (shallow_model'1 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span13] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 : forall x : Context'0.t_context . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span14] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span15]  ^ self =  * self
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span19] inv'1 self}
    {[@expl:precondition] [%#span18] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span17] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [%#span16] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span23] UInt64.to_int x <= leastvar'0 result}
      {[%#span22] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span21] is_valid_bdd'0 ( ^ self) result}
      {[%#span20] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span24] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span28] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span27] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span26] is_valid_bdd'0 ( ^ self) result}
      {[%#span25] grows'0 self}
      (! return' {result}) ]
    
  
  let rec true'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span29] inv'1 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span33] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span32] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span31] is_valid_bdd'0 ( ^ self) result}
      {[%#span30] grows'0 self}
      (! return' {result}) ]
    
  
  let rec v (self:borrowed (Context'0.t_context)) (x:uint64) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_7 <- _ret' ] 
             [ &self <- { self with current = ( ^ _7) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _7)}- s2
      | s2 = true'0 {_7} (fun (_ret':Bdd'0.t_bdd) ->  [ &t <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_9 <- _ret' ] 
             [ &self <- { self with current = ( ^ _9) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _9)}- s2
      | s2 = false'0 {_9} (fun (_ret':Bdd'0.t_bdd) ->  [ &f <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_context> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_10 <- _ret' ] 
             [ &self <- { self with current = ( ^ _10) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _10)}- s2
      | s2 = node'0 {_10} {x} {t} {f} (fun (_ret':Bdd'0.t_bdd) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : uint64 = x
    | & t : Bdd'0.t_bdd = any_l ()
    | & _7 : borrowed (Context'0.t_context) = any_l ()
    | & f : Bdd'0.t_bdd = any_l ()
    | & _9 : borrowed (Context'0.t_context) = any_l ()
    | & _10 : borrowed (Context'0.t_context) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v
      = Map.get v x}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Impl11_Not
  let%span sbdd0 = "../bdd.rs" 507 22 507 26
  
  let%span sbdd1 = "../bdd.rs" 497 15 497 35
  
  let%span sbdd2 = "../bdd.rs" 503 20 503 24
  
  let%span sbdd3 = "../bdd.rs" 498 14 498 26
  
  let%span sbdd4 = "../bdd.rs" 499 14 499 42
  
  let%span sbdd5 = "../bdd.rs" 500 4 500 60
  
  let%span sbdd6 = "../bdd.rs" 501 14 501 47
  
  let%span sbdd7 = "../bdd.rs" 502 14 502 22
  
  let%span span8 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span9 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span10 = "" 0 0 0 0
  
  let%span span11 = "../bdd.rs" 241 12 245 13
  
  let%span span12 = "../bdd.rs" 211 12 218 13
  
  let%span span13 = "../bdd.rs" 160 12 164 13
  
  let%span span14 = "../bdd.rs" 176 20 176 37
  
  let%span span15 = "../bdd.rs" 311 12 311 47
  
  let%span span16 = "../bdd.rs" 318 12 327 13
  
  let%span span17 = "../bdd.rs" 264 12 288 19
  
  let%span span18 = "../bdd.rs" 223 14 223 25
  
  let%span span19 = "../bdd.rs" 226 12 234 13
  
  let%span span20 = "../bdd.rs" 297 8 304 9
  
  let%span span21 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span22 = "../bdd.rs" 186 20 186 26
  
  let%span span23 = "../bdd.rs" 54 30 54 33
  
  let%span span24 = "../bdd.rs" 54 38 54 41
  
  let%span span25 = "../bdd.rs" 52 8 52 128
  
  let%span span26 = "../bdd.rs" 476 22 476 26
  
  let%span span27 = "../bdd.rs" 472 14 472 26
  
  let%span span28 = "../bdd.rs" 473 14 473 42
  
  let%span span29 = "../bdd.rs" 474 4 474 44
  
  let%span span30 = "../bdd.rs" 475 14 475 46
  
  let%span span31 = "../bdd.rs" 484 23 484 27
  
  let%span span32 = "../bdd.rs" 480 14 480 26
  
  let%span span33 = "../bdd.rs" 481 14 481 42
  
  let%span span34 = "../bdd.rs" 482 4 482 45
  
  let%span span35 = "../bdd.rs" 483 14 483 46
  
  let%span span36 = "../bdd.rs" 458 15 458 40
  
  let%span span37 = "../bdd.rs" 459 15 459 40
  
  let%span span38 = "../bdd.rs" 460 15 460 63
  
  let%span span39 = "../bdd.rs" 465 17 465 21
  
  let%span span40 = "../bdd.rs" 461 14 461 26
  
  let%span span41 = "../bdd.rs" 462 14 462 42
  
  let%span span42 = "../bdd.rs" 463 4 463 106
  
  let%span span43 = "../bdd.rs" 464 14 464 37
  
  let%span span44 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span45 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span46 = "../bdd.rs" 63 37 63 40
  
  let%span span47 = "../bdd.rs" 58 18 61 9
  
  let%span span48 = "../bdd.rs" 63 52 63 65
  
  use prelude.prelude.UInt64
  
  predicate invariant'5 (self : uint64) =
    [%#span8] true
  
  predicate inv'5 (_x : uint64)
  
  axiom inv'5 : forall x : uint64 . inv'5 x = true
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'4 (self : Bdd'0.t_bdd) =
    [%#span8] true
  
  predicate inv'4 (_x : Bdd'0.t_bdd)
  
  axiom inv'4 : forall x : Bdd'0.t_bdd . inv'4 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'3 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span8] true
  
  predicate inv'3 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'3 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'3 x = true
  
  predicate invariant'2 (self : Bdd'0.t_bdd) =
    [%#span8] true
  
  predicate inv'2 (_x : Bdd'0.t_bdd)
  
  axiom inv'2 : forall x : Bdd'0.t_bdd . inv'2 x = true
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span9] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span10] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'2 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span13] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span14] deep_model'2 self
  
  function shallow_model'4 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span9] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span15] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span16] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span17] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span8] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd'0.t_bdd) : int =
    [%#span19] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span18] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span20] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span21] shallow_model'1 ( * self)
  
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span22] Bdd_Bdd_Type.bdd_1 self
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) (key:Bdd'0.t_bdd) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span24] inv'4 val'}
    {[@expl:precondition] [%#span23] inv'4 key}
    any
    [ return' (result:())-> {[%#span25] forall i : uint64 . inv'5 i
       -> Map.get (shallow_model'1 ( ^ self)) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec true'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span26] inv'0 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span30] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span29] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span28] is_valid_bdd'0 ( ^ self) result}
      {[%#span27] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span31] inv'0 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span35] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span34] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span33] is_valid_bdd'0 ( ^ self) result}
      {[%#span32] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span39] inv'0 self}
    {[@expl:precondition] [%#span38] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span37] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [%#span36] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span43] UInt64.to_int x <= leastvar'0 result}
      {[%#span42] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span41] is_valid_bdd'0 ( ^ self) result}
      {[%#span40] grows'0 self}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (Context'0.t_context)) =
    [%#span44]  ^ self =  * self
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span45] deep_model'1 self
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span9] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (key:Bdd'0.t_bdd) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span46] inv'2 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span48] inv'3 result}
      {[%#span47] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec not' (self:borrowed (Context'0.t_context)) (x:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd2] inv'0 self}
    {[%#sbdd1] is_valid_bdd'0 ( * self) x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x ] s1
      | s1 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rnot_memo'0} {_13} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_10 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_10 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = Bdd'0.t_bdd {x}
        (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
          any
          [ br0 -> {r0'0 = Node'0.C_False } (! bb7)
          | br1 -> {r0'0 = Node'0.C_True } (! bb6)
          | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {r0'0 = Node'0.C_If a b c} (! bb8) ]
          )
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {[%#sbdd0] false} any ]
      
    | bb8 = s0
      [ s0 = Bdd'0.t_bdd {x}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Node'0.if' {r0'0} (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &v <- rv'0 ] s1))
      | s1 = Bdd'0.t_bdd {x}
          (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->
            Node'0.if' {r0'1}
              (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childt <- rchildt'1 ] s2))
      | s2 = Bdd'0.t_bdd {x}
          (fun (r0'2:Node'0.t_node) (r1'2:uint64) ->
            Node'0.if' {r0'2}
              (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childf <- rchildf'2 ] s3))
      | s3 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_25 <- _ret' ] 
             [ &self <- { self with current = ( ^ _25) ; } ] 
            s4)
      | s4 = -{inv'1 ( ^ _25)}- s5
      | s5 = not' {_25} {childt} (fun (_ret':Bdd'0.t_bdd) ->  [ &childt1 <- _ret' ] s6)
      | s6 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = ( ^ _28) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _28)}- s2
      | s2 = not' {_28} {childf} (fun (_ret':Bdd'0.t_bdd) ->  [ &childf1 <- _ret' ] s3)
      | s3 = bb14 ]
      
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = ( ^ _30) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _30)}- s2
      | s2 = node'0 {_30} {v} {childt1} {childf1} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb15 ]
      
    | bb15 = bb16
    | bb6 = bb9
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_19 <- _ret' ] 
             [ &self <- { self with current = ( ^ _19) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _19)}- s2
      | s2 = false'0 {_19} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = bb16
    | bb7 = bb11
    | bb11 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_20 <- _ret' ] 
             [ &self <- { self with current = ( ^ _20) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _20)}- s2
      | s2 = true'0 {_20} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = bb16
    | bb16 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)>
              {rnot_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 4}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd))) ->
                 [ &_35 <- _ret' ] 
                Context'0.t_context { * self}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 ( ^ _35) l_and_memo'0 l_cnt'0 ; } ]
                    
                    s1)))
      | s1 = add'0 {_35} {x} {r1} (fun (_ret':()) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_10} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb18 ]
      
    | bb18 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & x : Bdd'0.t_bdd = x
    | & _10 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _13 : Bdd'0.t_bdd = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _19 : borrowed (Context'0.t_context) = any_l ()
    | & _20 : borrowed (Context'0.t_context) = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & childt1 : Bdd'0.t_bdd = any_l ()
    | & _25 : borrowed (Context'0.t_context) = any_l ()
    | & childf1 : Bdd'0.t_bdd = any_l ()
    | & _28 : borrowed (Context'0.t_context) = any_l ()
    | & _30 : borrowed (Context'0.t_context) = any_l ()
    | & _34 : () = any_l ()
    | & _35 : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd6] leastvar'0 x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd5] forall v : Map.map uint64 bool . interp'0 result v = (not interp'0 x v)}
      {[@expl:postcondition] [%#sbdd4] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd3] grows'0 self}
      (! return' {result}) ]
    
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function any_l (_ : 'b) : 'a
  
  let rec less (input:t_ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} {false} any ]
    
  
  let rec equal (input:t_ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} {false} any ]
    
  
  let rec greater (input:t_ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} {false} any ]
    
end
module Bdd_Impl11_And
  let%span sbdd0 = "../bdd.rs" 531 22 531 34
  
  let%span sbdd1 = "../bdd.rs" 540 22 540 33
  
  let%span sbdd2 = "../bdd.rs" 520 15 520 35
  
  let%span sbdd3 = "../bdd.rs" 521 15 521 35
  
  let%span sbdd4 = "../bdd.rs" 527 20 527 24
  
  let%span sbdd5 = "../bdd.rs" 522 14 522 26
  
  let%span sbdd6 = "../bdd.rs" 523 14 523 42
  
  let%span sbdd7 = "../bdd.rs" 524 4 524 76
  
  let%span sbdd8 = "../bdd.rs" 525 14 525 84
  
  let%span sbdd9 = "../bdd.rs" 526 14 526 33
  
  let%span span10 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span11 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span12 = "" 0 0 0 0
  
  let%span span13 = "../bdd.rs" 241 12 245 13
  
  let%span span14 = "../bdd.rs" 211 12 218 13
  
  let%span span15 = "../bdd.rs" 160 12 164 13
  
  let%span span16 = "../bdd.rs" 176 20 176 37
  
  let%span span17 = "../bdd.rs" 311 12 311 47
  
  let%span span18 = "../bdd.rs" 318 12 327 13
  
  let%span span19 = "../bdd.rs" 264 12 288 19
  
  let%span span20 = "../bdd.rs" 223 14 223 25
  
  let%span span21 = "../bdd.rs" 226 12 234 13
  
  let%span span22 = "../bdd.rs" 297 8 304 9
  
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span24 = "../bdd.rs" 186 20 186 26
  
  let%span span25 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span26 = "../bdd.rs" 54 30 54 33
  
  let%span span27 = "../bdd.rs" 54 38 54 41
  
  let%span span28 = "../bdd.rs" 52 8 52 128
  
  let%span span29 = "../bdd.rs" 484 23 484 27
  
  let%span span30 = "../bdd.rs" 480 14 480 26
  
  let%span span31 = "../bdd.rs" 481 14 481 42
  
  let%span span32 = "../bdd.rs" 482 4 482 45
  
  let%span span33 = "../bdd.rs" 483 14 483 46
  
  let%span span34 = "../bdd.rs" 458 15 458 40
  
  let%span span35 = "../bdd.rs" 459 15 459 40
  
  let%span span36 = "../bdd.rs" 460 15 460 63
  
  let%span span37 = "../bdd.rs" 465 17 465 21
  
  let%span span38 = "../bdd.rs" 461 14 461 26
  
  let%span span39 = "../bdd.rs" 462 14 462 42
  
  let%span span40 = "../bdd.rs" 463 4 463 106
  
  let%span span41 = "../bdd.rs" 464 14 464 37
  
  let%span span42 = "../../../../creusot-contracts/src/logic/ord.rs" 140 16 146 17
  
  let%span span43 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span44 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  
  let%span span45 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span46 = "../../../../creusot-contracts/src/resolve.rs" 17 8 17 60
  
  let%span span47 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span48 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span49 = "../bdd.rs" 63 37 63 40
  
  let%span span50 = "../bdd.rs" 58 18 61 9
  
  let%span span51 = "../bdd.rs" 63 52 63 65
  
  use prelude.prelude.UInt64
  
  predicate invariant'6 (self : (uint64, uint64)) =
    [%#span10] true
  
  predicate inv'6 (_x : (uint64, uint64))
  
  axiom inv'6 : forall x : (uint64, uint64) . inv'6 x = true
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'5 (self : Bdd'0.t_bdd) =
    [%#span10] true
  
  predicate inv'5 (_x : Bdd'0.t_bdd)
  
  axiom inv'5 : forall x : Bdd'0.t_bdd . inv'5 x = true
  
  predicate invariant'4 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) =
    [%#span10] true
  
  predicate inv'4 (_x : (Bdd'0.t_bdd, Bdd'0.t_bdd))
  
  axiom inv'4 : forall x : (Bdd'0.t_bdd, Bdd'0.t_bdd) . inv'4 x = true
  
  use prelude.prelude.Int
  
  function eq_cmp'0 (_1 : int) (_2 : int) : ()
  
  function antisym2'0 (_1 : int) (_2 : int) : ()
  
  function antisym1'0 (_1 : int) (_2 : int) : ()
  
  use Core_Cmp_Ordering_Type as Ordering'0
  
  function trans'0 (_1 : int) (_2 : int) (_3 : int) (_4 : Ordering'0.t_ordering) : ()
  
  function refl'0 (_1 : int) : ()
  
  function cmp_gt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_ge_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_lt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_le_log'0 (_1 : int) (_2 : int) : ()
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'3 (self : Option'0.t_option (Bdd'0.t_bdd)) =
    [%#span10] true
  
  predicate inv'3 (_x : Option'0.t_option (Bdd'0.t_bdd))
  
  axiom inv'3 : forall x : Option'0.t_option (Bdd'0.t_bdd) . inv'3 x = true
  
  predicate invariant'2 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) =
    [%#span10] true
  
  predicate inv'2 (_x : (Bdd'0.t_bdd, Bdd'0.t_bdd))
  
  axiom inv'2 : forall x : (Bdd'0.t_bdd, Bdd'0.t_bdd) . inv'2 x = true
  
  use map.Map
  
  use Bdd_Hashmap_MyHashMap_Type as MyHashMap'0
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  use Bdd_Node_Type as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Bdd_Context_Type
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map uint64 (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span11] UInt64.to_int self
  
  constant max'0 : uint64 = [%#span12] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 239 4 239 28] (self : Bdd'0.t_bdd) : int =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (max'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 209 4 209 53] (self : Bdd'0.t_bdd) (vars : Map.map uint64 bool) : bool =
    [%#span14] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  function deep_model'4 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span15] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span16] deep_model'4 self
  
  function shallow_model'4 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span11] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 46 8 46 54] (self : MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) : Map.map (NodeLog'0.t_nodelog) (Option'0.t_option (Bdd'0.t_bdd))
    
  
  use Bdd_Context_Type as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 309 4 309 53] (self : Context'0.t_context) (b : Bdd'0.t_bdd) =
    [%#span17] Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) (shallow_model'4 (Bdd_Bdd_Type.bdd_0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 316 4 316 51] (self : Context'0.t_context) (n : Node'0.t_node) =
    [%#span18] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> Bdd_Bdd_Type.bdd_0 childt <> Bdd_Bdd_Type.bdd_0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 262 4 262 30] (self : Context'0.t_context) =
    [%#span19] (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (Bdd_Bdd_Type.bdd_0 b) = n
      /\ is_valid_node'0 self (Bdd_Bdd_Type.bdd_0 b)
      /\ Bdd_Bdd_Type.bdd_1 b < Bdd_Context_Type.context_cnt self
      /\ Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (Bdd_Bdd_Type.bdd_1 b)
      = Bdd_Bdd_Type.bdd_0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'7 (Bdd_Context_Type.context_not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'1 (Bdd_Context_Type.context_and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (Bdd_Context_Type.context_hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_x : Context'0.t_context)
  
  axiom inv'1 : forall x : Context'0.t_context . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_context)) =
    [%#span10] true
  
  predicate inv'0 (_x : borrowed (Context'0.t_context))
  
  axiom inv'0 : forall x : borrowed (Context'0.t_context) . inv'0 x = (inv'1 ( * x) /\ inv'1 ( ^ x))
  
  function size'0 [#"../bdd.rs" 224 4 224 24] (self : Bdd'0.t_bdd) : int =
    [%#span21] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_bdd . [%#span20] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 296 4 296 35] (self : borrowed (Context'0.t_context)) =
    [%#span22] UInt64.to_int (Bdd_Context_Type.context_cnt ( * self))
    <= UInt64.to_int (Bdd_Context_Type.context_cnt ( ^ self))
    /\ (forall n : NodeLog'0.t_nodelog . match Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( * self))) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (Bdd_Context_Type.context_hashcons ( ^ self))) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span23] shallow_model'1 ( * self)
  
  function deep_model'3 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span24] Bdd_Bdd_Type.bdd_1 self
  
  function deep_model'2 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) : (uint64, uint64) =
    [%#span25] (deep_model'3 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) (key:(Bdd'0.t_bdd, Bdd'0.t_bdd)) (val':Bdd'0.t_bdd) (return'  (ret:()))= {[@expl:precondition] [%#span27] inv'5 val'}
    {[@expl:precondition] [%#span26] inv'4 key}
    any
    [ return' (result:())-> {[%#span28] forall i : (uint64, uint64) . inv'6 i
       -> Map.get (shallow_model'1 ( ^ self)) i
      = (if i = deep_model'2 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec false'0 (self:borrowed (Context'0.t_context)) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span29] inv'0 self}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span33] UInt64.to_int (max'0 : uint64) + 1 = leastvar'0 result}
      {[%#span32] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span31] is_valid_bdd'0 ( ^ self) result}
      {[%#span30] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_context)) (x:uint64) (childt:Bdd'0.t_bdd) (childf:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[@expl:precondition] [%#span37] inv'0 self}
    {[@expl:precondition] [%#span36] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span35] is_valid_bdd'0 ( * self) childf}
    {[@expl:precondition] [%#span34] is_valid_bdd'0 ( * self) childt}
    any
    [ return' (result:Bdd'0.t_bdd)-> {[%#span41] UInt64.to_int x <= leastvar'0 result}
      {[%#span40] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span39] is_valid_bdd'0 ( ^ self) result}
      {[%#span38] grows'0 self}
      (! return' {result}) ]
    
  
  function cmp_log'0 (self : int) (o : int) : Ordering'0.t_ordering =
    [%#span42] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  function deep_model'1 (self : uint64) : int =
    [%#span43] UInt64.to_int self
  
  let rec cmp'0 (self:uint64) (other:uint64) (return'  (ret:Ordering'0.t_ordering))= any
    [ return' (result:Ordering'0.t_ordering)-> {[%#span44] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate resolve'4 (self : Node'0.t_node) =
    [%#span45] true
  
  predicate resolve'2 (self : (Node'0.t_node, Node'0.t_node)) =
    [%#span46] resolve'4 (let (a, _) = self in a) /\ resolve'4 (let (_, a) = self in a)
  
  predicate resolve'1 (self : borrowed (Context'0.t_context)) =
    [%#span47]  ^ self =  * self
  
  predicate resolve'3 (self : Bdd'0.t_bdd) =
    [%#span45] true
  
  predicate resolve'0 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) =
    [%#span46] resolve'3 (let (a, _) = self in a) /\ resolve'3 (let (_, a) = self in a)
  
  function deep_model'0 (self : (Bdd'0.t_bdd, Bdd'0.t_bdd)) : (uint64, uint64) =
    [%#span48] deep_model'2 self
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) : Map.map (uint64, uint64) (Option'0.t_option (Bdd'0.t_bdd))
    
   =
    [%#span11] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (key:(Bdd'0.t_bdd, Bdd'0.t_bdd)) (return'  (ret:Option'0.t_option (Bdd'0.t_bdd)))= {[@expl:precondition] [%#span49] inv'2 key}
    any
    [ return' (result:Option'0.t_option (Bdd'0.t_bdd))-> {[%#span51] inv'3 result}
      {[%#span50] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use Bdd_Bumpalo_Bump_Type as Bump'0
  
  let rec and (self:borrowed (Context'0.t_context)) (a:Bdd'0.t_bdd) (b:Bdd'0.t_bdd) (return'  (ret:Bdd'0.t_bdd))= {[%#sbdd4] inv'0 self}
    {[%#sbdd3] is_valid_bdd'0 ( * self) b}
    {[%#sbdd2] is_valid_bdd'0 ( * self) a}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- (a, b) ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            get'0 {rand_memo'0} {_15} (fun (_ret':Option'0.t_option (Bdd'0.t_bdd)) ->  [ &_12 <- _ret' ] s3))
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = any
        [ br0 -> {_12 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_bdd)-> {_12 = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb4 = s0
      [ s0 = Bdd'0.t_bdd {a}
          (fun (r0'0:Node'0.t_node) (r1'0:uint64) ->
            Bdd'0.t_bdd {b} (fun (r0'1:Node'0.t_node) (r1'1:uint64) ->  [ &_23 <- (r0'0, r0'1) ] s1))
      | s1 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb6)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb12)
        | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb6) ]
         ]
      
    | bb6 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb7)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb11)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb7 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb8)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb8) ]
      
    | bb8 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb5)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb9) ]
      
    | bb9 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb5)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb5)
      | br2 (a:uint64) (b:Bdd'0.t_bdd) (c:Bdd'0.t_bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb10) ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 = -{resolve'2 _23}- s3
      | s3 = {[%#sbdd0] false} any ]
      
    | bb10 = s0
      [ s0 = Node'0.if' {let (r'0, _) = _23 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_bdd) (rchildf'0:Bdd'0.t_bdd) ->  [ &va <- rv'0 ] s1)
      | s1 = Node'0.if' {let (r'1, _) = _23 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_bdd) (rchildf'1:Bdd'0.t_bdd) ->  [ &childta <- rchildt'1 ] s2)
      | s2 = Node'0.if' {let (r'2, _) = _23 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_bdd) (rchildf'2:Bdd'0.t_bdd) ->  [ &childfa <- rchildf'2 ] s3)
      | s3 = Node'0.if' {let (_, r'3) = _23 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_bdd) (rchildf'3:Bdd'0.t_bdd) ->  [ &vb <- rv'3 ] s4)
      | s4 = Node'0.if' {let (_, r'4) = _23 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_bdd) (rchildf'4:Bdd'0.t_bdd) ->  [ &childtb <- rchildt'4 ] s5)
      | s5 = Node'0.if' {let (_, r'5) = _23 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_bdd) (rchildf'5:Bdd'0.t_bdd) ->  [ &childfb <- rchildf'5 ] s6)
      | s6 = -{resolve'2 _23}- s7
      | s7 =  [ &_45 <- vb ] s8
      | s8 = cmp'0 {va} {_45} (fun (_ret':Ordering'0.t_ordering) ->  [ &_42 <- _ret' ] s9)
      | s9 = bb18 ]
      
    | bb18 = any
      [ br0 -> {_42 = Ordering'0.C_Less } (! bb21)
      | br1 -> {_42 = Ordering'0.C_Equal } (! bb22)
      | br2 -> {_42 = Ordering'0.C_Greater } (! bb20) ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = {[%#sbdd1] false} any ]
      
    | bb20 = bb23
    | bb23 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_49 <- _ret' ] 
             [ &self <- { self with current = ( ^ _49) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _49)}- s3
      | s3 = and {_49} {a} {childtb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_48 <- _ret' ] s4)
      | s4 = bb24 ]
      
    | bb24 = s0
      [ s0 =  [ &childt <- _48 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_48 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_53 <- _ret' ] 
             [ &self <- { self with current = ( ^ _53) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _53)}- s3
      | s3 = and {_53} {a} {childfb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_52 <- _ret' ] s4)
      | s4 = bb25 ]
      
    | bb25 = s0 [ s0 =  [ &childf <- _52 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_52 <- _any ] s1) ] ) | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_67 <- _ret' ] 
             [ &self <- { self with current = ( ^ _67) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _67)}- s3
      | s3 = and {_67} {childta} {childtb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_66 <- _ret' ] s4)
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_66 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_71 <- _ret' ] 
             [ &self <- { self with current = ( ^ _71) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _71)}- s3
      | s3 = and {_71} {childfa} {childfb} (fun (_ret':Bdd'0.t_bdd) ->  [ &_70 <- _ret' ] s4)
      | s4 = bb30 ]
      
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_70 <- _any ] s1) ] ) | s1 = bb31 ] 
    | bb21 = bb26
    | bb26 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_58 <- _ret' ] 
             [ &self <- { self with current = ( ^ _58) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _58)}- s3
      | s3 = and {_58} {childta} {b} (fun (_ret':Bdd'0.t_bdd) ->  [ &_57 <- _ret' ] s4)
      | s4 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_57 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_62 <- _ret' ] 
             [ &self <- { self with current = ( ^ _62) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _62)}- s3
      | s3 = and {_62} {childfa} {b} (fun (_ret':Bdd'0.t_bdd) ->  [ &_61 <- _ret' ] s4)
      | s4 = bb28 ]
      
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] (any [ any_ (_any:Bdd'0.t_bdd)-> (!  [ &_61 <- _any ] s1) ] ) | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_74 <- _ret' ] 
             [ &self <- { self with current = ( ^ _74) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _74)}- s2
      | s2 = node'0 {_74} {v} {childt} {childf} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb32 ]
      
    | bb32 = bb33
    | bb13 = bb16
    | bb16 = s0
      [ s0 = -{resolve'2 _23}- s1
      | s1 = Borrow.borrow_mut <Context'0.t_context> { * self}
          (fun (_ret':borrowed (Context'0.t_context)) ->
             [ &_31 <- _ret' ] 
             [ &self <- { self with current = ( ^ _31) ; } ] 
            s2)
      | s2 = -{inv'1 ( ^ _31)}- s3
      | s3 = false'0 {_31} (fun (_ret':Bdd'0.t_bdd) ->  [ &r1 <- _ret' ] s4)
      | s4 = bb17 ]
      
    | bb17 = bb33
    | bb11 = bb15
    | bb15 = s0 [ s0 = -{resolve'2 _23}- s1 | s1 =  [ &r1 <- a ] s2 | s2 = bb33 ] 
    | bb12 = bb14
    | bb14 = s0 [ s0 = -{resolve'2 _23}- s1 | s1 =  [ &r1 <- b ] s2 | s2 = bb33 ] 
    | bb33 = s0
      [ s0 = Context'0.t_context { * self}
          (fun (ralloc'0:Bump'0.t_bump) (rhashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (rnot_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rand_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)>
              {rand_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 5}
              (fun (_ret':borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd))) ->
                 [ &_79 <- _ret' ] 
                Context'0.t_context { * self}
                  (fun (l_alloc'0:Bump'0.t_bump) (l_hashcons'0:MyHashMap'0.t_myhashmap (Node'0.t_node) (Bdd'0.t_bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_node))) (l_not_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_and_memo'0:MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 ( ^ _79) l_cnt'0 ; } ]
                    
                    s1)))
      | s1 =  [ &_80 <- (a, b) ] s2
      | s2 = add'0 {_79} {_80} {r1} (fun (_ret':()) ->  [ &_78 <- _ret' ] s3)
      | s3 = bb34 ]
      
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'1 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb35 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.some <Bdd'0.t_bdd> {_12} (fun (r0'0:Bdd'0.t_bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb35 ]
      
    | bb35 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_bdd = any_l ()
    | & self : borrowed (Context'0.t_context) = self
    | & a : Bdd'0.t_bdd = a
    | & b : Bdd'0.t_bdd = b
    | & _12 : Option'0.t_option (Bdd'0.t_bdd) = any_l ()
    | & _15 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l ()
    | & _16 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l ()
    | & r : Bdd'0.t_bdd = any_l ()
    | & r1 : Bdd'0.t_bdd = any_l ()
    | & _23 : (Node'0.t_node, Node'0.t_node) = any_l ()
    | & _31 : borrowed (Context'0.t_context) = any_l ()
    | & va : uint64 = any_l ()
    | & childta : Bdd'0.t_bdd = any_l ()
    | & childfa : Bdd'0.t_bdd = any_l ()
    | & vb : uint64 = any_l ()
    | & childtb : Bdd'0.t_bdd = any_l ()
    | & childfb : Bdd'0.t_bdd = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_bdd = any_l ()
    | & childf : Bdd'0.t_bdd = any_l ()
    | & _42 : Ordering'0.t_ordering = any_l ()
    | & _45 : uint64 = any_l ()
    | & _48 : Bdd'0.t_bdd = any_l ()
    | & _49 : borrowed (Context'0.t_context) = any_l ()
    | & _52 : Bdd'0.t_bdd = any_l ()
    | & _53 : borrowed (Context'0.t_context) = any_l ()
    | & _57 : Bdd'0.t_bdd = any_l ()
    | & _58 : borrowed (Context'0.t_context) = any_l ()
    | & _61 : Bdd'0.t_bdd = any_l ()
    | & _62 : borrowed (Context'0.t_context) = any_l ()
    | & _66 : Bdd'0.t_bdd = any_l ()
    | & _67 : borrowed (Context'0.t_context) = any_l ()
    | & _70 : Bdd'0.t_bdd = any_l ()
    | & _71 : borrowed (Context'0.t_context) = any_l ()
    | & _74 : borrowed (Context'0.t_context) = any_l ()
    | & _78 : () = any_l ()
    | & _79 : borrowed (MyHashMap'0.t_myhashmap (Bdd'0.t_bdd, Bdd'0.t_bdd) (Bdd'0.t_bdd)) = any_l ()
    | & _80 : (Bdd'0.t_bdd, Bdd'0.t_bdd) = any_l () ]
    
    [ return' (result:Bdd'0.t_bdd)-> {[@expl:postcondition] [%#sbdd8] leastvar'0 a <= leastvar'0 result
      \/ leastvar'0 b <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd7] forall v : Map.map uint64 bool . interp'0 result v
      = (interp'0 a v /\ interp'0 b v)}
      {[@expl:postcondition] [%#sbdd6] is_valid_bdd'0 ( ^ self) result}
      {[@expl:postcondition] [%#sbdd5] grows'0 self}
      (! return' {result}) ]
    
end
module Bdd_Hashmap_Impl0
  type k
  
  type v
end
module Bdd_Impl4
  
end
module Bdd_Impl6
  
end
module Bdd_Hashmap_Impl2
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 76 8 76 29
  
  let%span span1 = "" 0 0 0 0
  
  let%span span2 = "../bdd.rs" 83 24 83 84
  
  let%span span3 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  predicate invariant'0 (self : (u, v))
  
  predicate inv'0 (_x : (u, v))
  
  axiom inv'0 : forall x : (u, v) . inv'0 x = true
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span1] (18446744073709551615 : uint64)
  
  type deep_model_ty'1
  
  function hash_log'2 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'1) : int
  
  type deep_model_ty'0
  
  function hash_log'1 [#"../bdd.rs" 34 8 34 49] (_1 : deep_model_ty'0) : int
  
  function hash_log'0 [#"../bdd.rs" 82 8 82 48] (x : (deep_model_ty'0, deep_model_ty'1)) : int =
    [%#span2] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (max'0 : uint64) + 1)
  
  function deep_model'3 (self : v) : deep_model_ty'1
  
  function deep_model'2 (self : u) : deep_model_ty'0
  
  function deep_model'1 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span3] (deep_model'2 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : (u, v)) : (deep_model_ty'0, deep_model_ty'1) =
    [%#span4] deep_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : (u, v) . inv'0 self
   -> inv'0 self
  /\ (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl1
  let%span sbdd0 = "../bdd.rs" 116 4 116 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../bdd.rs" 160 12 164 13
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span4 = "" 0 0 0 0
  
  let%span span5 = "../bdd.rs" 130 12 135 13
  
  let%span span6 = "../bdd.rs" 176 20 176 37
  
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span2] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant max'0 : uint64 = [%#span4] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 128 4 128 44] (x : NodeLog'0.t_nodelog) : int =
    [%#span5] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (max'0 : uint64) + 1)
      end
  
  function shallow_model'1 [#"../bdd.rs" 175 4 175 50] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span6] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span7] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Node'0.t_node . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl2
  let%span sbdd0 = "../bdd.rs" 142 4 142 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../bdd.rs" 186 20 186 26
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span4 = "../bdd.rs" 149 8 149 24
  
  let%span span5 = "../bdd.rs" 196 20 196 37
  
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] Bdd_Bdd_Type.bdd_1 self
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 148 4 148 44] (x : uint64) : int =
    [%#span4] UInt64.to_int x
  
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span5] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span6] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Bdd_Impl12
  let%span sbdd0 = "../bdd.rs" 90 9 90 11
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module Bdd_Impl17
  let%span sbdd0 = "../bdd.rs" 104 15 104 17
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module Bdd_Impl13
  let%span sbdd0 = "../bdd.rs" 90 13 90 22
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../bdd.rs" 160 12 164 13
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use Bdd_NodeLog_Type as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 158 4 158 44] (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span2] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (Bdd_Bdd_Type.bdd_1 childt) (Bdd_Bdd_Type.bdd_1 childf)
      end
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Node'0.t_node) : NodeLog'0.t_nodelog =
    [%#span3] deep_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Node'0.t_node . forall other : Node'0.t_node . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl7
  let%span sbdd0 = "../bdd.rs" 202 4 202 34
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../bdd.rs" 186 20 186 26
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span4 = "../bdd.rs" 196 20 196 37
  
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  use Bdd_Bdd_Type as Bdd_Bdd_Type
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 185 4 185 44] (self : Bdd'0.t_bdd) : uint64 =
    [%#span2] Bdd_Bdd_Type.bdd_1 self
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span3] deep_model'1 self
  
  function shallow_model'1 [#"../bdd.rs" 195 4 195 50] (self : Bdd'0.t_bdd) : uint64 =
    [%#span4] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_bdd) : uint64 =
    [%#span5] shallow_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . forall other : Bdd'0.t_bdd . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (shallow_model'0 self = shallow_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module Bdd_Impl14
  let%span sbdd0 = "../bdd.rs" 90 24 90 29
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  use Bdd_Node_Type as Node'0
  
  predicate invariant'1 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'1 (_x : Node'0.t_node)
  
  axiom inv'1 : forall x : Node'0.t_node . inv'1 x = true
  
  predicate invariant'0 (self : Node'0.t_node) =
    [%#span1] true
  
  predicate inv'0 (_x : Node'0.t_node)
  
  axiom inv'0 : forall x : Node'0.t_node . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  goal clone'_refn : [%#sbdd0] forall self : Node'0.t_node . inv'0 self
   -> (forall result : Node'0.t_node . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl0
  let%span sbdd0 = "../bdd.rs" 109 4 109 27
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  use Bdd_Bdd_Type as Bdd'0
  
  predicate invariant'1 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'1 (_x : Bdd'0.t_bdd)
  
  axiom inv'1 : forall x : Bdd'0.t_bdd . inv'1 x = true
  
  predicate invariant'0 (self : Bdd'0.t_bdd) =
    [%#span1] true
  
  predicate inv'0 (_x : Bdd'0.t_bdd)
  
  axiom inv'0 : forall x : Bdd'0.t_bdd . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  goal clone'_refn : [%#sbdd0] forall self : Bdd'0.t_bdd . inv'0 self
   -> (forall result : Bdd'0.t_bdd . result = self  -> inv'1 result /\ result = self)
end
module Bdd_Impl15
  
end
module Bdd_Impl16
  
end
module Bdd_Impl3
  
end
module Bdd_Impl5
  
end
module Bdd_Impl9
  
end
