
module T_bdd__bumpalo__Bump [#"../bdd.rs" 17 4 17 19]
  type t_Bump
end
module T_bdd__hashmap__MyHashMap [#"../bdd.rs" 42 4 42 30]
  type t_MyHashMap 'k 'v
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_bdd__hashmap__qyi11648407051195780326__hash [#"../bdd.rs" 80 8 80 29] (* <(U, V) as hashmap::Hash> *)
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 81 66 81 68
  let%span sbdd1 = "../bdd.rs" 80 17 80 21
  let%span sbdd2 = "../bdd.rs" 79 18 79 62
  let%span span3 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span4 = "" 0 0 0 0
  let%span span5 = "../bdd.rs" 87 24 87 84
  let%span span6 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span8 = "" 0 0 0 0
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span18 = "../bdd.rs" 35 17 35 21
  let%span span19 = "../bdd.rs" 34 18 34 62
  
  predicate invariant'4 (self : v)
  
  predicate inv'5 (_1 : v)
  
  axiom inv'5 : forall x : v [inv'5 x] . inv'5 x  -> invariant'4 x
  
  predicate invariant'3 (self : u)
  
  predicate inv'4 (_1 : u)
  
  axiom inv'4 : forall x : u [inv'4 x] . inv'4 x  -> invariant'3 x
  
  predicate inv'3 (_1 : (u, v))
  
  axiom inv'3 [@rewrite] : forall x : (u, v) [inv'3 x] . inv'3 x = (let (a, b) = x in inv'4 a /\ inv'5 b)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : v) =
    [%#span3] inv'5 self
  
  predicate inv'2 (_1 : v)
  
  axiom inv'2 [@rewrite] : forall x : v [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : u) =
    [%#span3] inv'4 self
  
  predicate inv'1 (_1 : u)
  
  axiom inv'1 [@rewrite] : forall x : u [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 (self : (u, v)) =
    [%#span3] inv'3 self
  
  predicate inv'0 (_1 : (u, v))
  
  axiom inv'0 [@rewrite] : forall x : (u, v) [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span4] (18446744073709551615 : uint64)
  
  type t_DeepModelTy'1
  
  function hash_log'2 [#"../bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'1) : int
  
  type t_DeepModelTy'0
  
  function hash_log'1 [#"../bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'0) : int
  
  function hash_log'0 [#"../bdd.rs" 86 8 86 48] (x : (t_DeepModelTy'0, t_DeepModelTy'1)) : int =
    [%#span5] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (v_MAX'0 : uint64) + 1)
  
  function deep_model'5 (self : v) : t_DeepModelTy'1
  
  function deep_model'4 (self : u) : t_DeepModelTy'0
  
  function deep_model'3 (self : (u, v)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#span6] (deep_model'4 (let (a, _) = self in a), deep_model'5 (let (_, a) = self in a))
  
  function deep_model'0 (self : (u, v)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#span7] deep_model'3 self
  
  use prelude.prelude.Intrinsic
  
  constant v_MIN'0 : uint64 = [%#span8] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span13] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (v_MAX'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span12] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (v_MIN'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span11] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (v_MIN'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (v_MAX'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span10] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self
      + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt64.to_int (v_MIN'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span17] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (v_MAX'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span16] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (v_MIN'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span15] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (v_MIN'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (v_MAX'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span14] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self
      * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt64.to_int (v_MIN'0 : uint64)}
      (! return' {result}) ]
    
  
  function deep_model'2 (self : v) : t_DeepModelTy'1 =
    [%#span7] deep_model'5 self
  
  let rec hash'1 (self:v) (return'  (ret:uint64))= {[@expl:precondition] [%#span18] inv'2 self}
    any
    [ return' (result:uint64)-> {[%#span19] UInt64.to_int result = hash_log'2 (deep_model'2 self)}
      (! return' {result}) ]
    
  
  function deep_model'1 (self : u) : t_DeepModelTy'0 =
    [%#span7] deep_model'4 self
  
  let rec hash'0 (self:u) (return'  (ret:uint64))= {[@expl:precondition] [%#span18] inv'1 self}
    any
    [ return' (result:uint64)-> {[%#span19] UInt64.to_int result = hash_log'1 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec hash (self:(u, v)) (return'  (ret:uint64))= {[%#sbdd1] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {let (r'0, _) = self in r'0} (fun (_ret':uint64) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = hash'1 {let (_, r'0) = self in r'0} (fun (_ret':uint64) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = wrapping_mul'0 {_6} {[%#sbdd0] (17 : uint64)} (fun (_ret':uint64) ->  [ &_5 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = wrapping_add'0 {_3} {_5} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : (u, v) = self
    | & _3 : uint64 = any_l ()
    | & _5 : uint64 = any_l ()
    | & _6 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd2] UInt64.to_int result = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module T_bdd__Bdd [#"../bdd.rs" 109 0 109 22]
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  type t_Bdd  =
    | C_Bdd (t_Node) uint64
  with t_Node  =
    | C_False
    | C_True
    | C_If uint64 (t_Bdd) (t_Bdd)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Bdd (input:t_Bdd) (ret  (field_0:t_Node) (field_1:uint64))= any
    [ good (field_0:t_Node) (field_1:uint64)-> {C_Bdd field_0 field_1 = input} (! ret {field_0} {field_1}) ]
    
  
  let rec v_False (input:t_Node) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} (! {false} any) ]
    
  
  let rec v_True (input:t_Node) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} (! {false} any) ]
    
  
  let rec v_If (input:t_Node) (ret  (v:uint64) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:uint64) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : uint64, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
    
  
  function t_Bdd__1 (self : t_Bdd) : uint64 =
    match self with
      | C_Bdd _ a -> a
      end
  
  function t_Bdd__0 (self : t_Bdd) : t_Node =
    match self with
      | C_Bdd a _ -> a
      end
end
module T_bdd__Node [#"../bdd.rs" 95 0 95 17]
  use export T_bdd__Bdd
end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq [#"../bdd.rs" 94 9 94 11] (* <Node<'arena> as std::cmp::Eq> *)
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq (self:Node'0.t_Node) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi2581120635339165136__eq [#"../bdd.rs" 206 4 206 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "../bdd.rs" 205 14 205 37
  let%span span1 = "../bdd.rs" 190 20 190 26
  let%span span2 = "../bdd.rs" 200 20 200 37
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_bdd__Bdd as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span1] T_bdd__Bdd.t_Bdd__1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span2] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span3] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use T_bdd__Node as Node'0
  
  meta "compute_max_steps" 1000000
  
  let rec eq (self:Bdd'0.t_Bdd) (o:Bdd'0.t_Bdd) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_Bdd {self}
          (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
            Bdd'0.t_Bdd {o}
              (fun (r0'1:Node'0.t_Node) (r1'1:uint64) ->
                UInt64.eq {r1'0} {r1'1} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)))
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & self : Bdd'0.t_Bdd = self | & o : Bdd'0.t_Bdd = o ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (shallow_model'0 self = shallow_model'0 o)}
      (! return' {result}) ]
    
end
module T_bdd__NodeLog [#"../bdd.rs" 102 0 102 12]
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  type t_NodeLog  =
    | C_False
    | C_True
    | C_If uint64 uint64 uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec v_False (input:t_NodeLog) (ret  )= any
    [ good -> {C_False  = input} (! ret) | bad -> {C_False  <> input} (! {false} any) ]
    
  
  let rec v_True (input:t_NodeLog) (ret  )= any
    [ good -> {C_True  = input} (! ret) | bad -> {C_True  <> input} (! {false} any) ]
    
  
  let rec v_If (input:t_NodeLog) (ret  (v:uint64) (childt:uint64) (childf:uint64))= any
    [ good (v:uint64) (childt:uint64) (childf:uint64)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : uint64, childt : uint64, childf : uint64 [C_If v childt childf : t_NodeLog] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
    
end
module M_bdd__qyi4854841669736991510__eq [#"../bdd.rs" 94 13 94 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "../bdd.rs" 94 13 94 22
  let%span span1 = "../bdd.rs" 164 12 168 13
  let%span span2 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span3 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span span4 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span span5 = "../bdd.rs" 190 20 190 26
  let%span span6 = "../bdd.rs" 200 20 200 37
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span8 = "../bdd.rs" 205 14 205 37
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  function deep_model'2 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span1] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span2] deep_model'2 self
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function deep_model'3 (self : uint64) : int =
    [%#span3] UInt64.to_int self
  
  function deep_model'1 (self : uint64) : int =
    [%#span2] deep_model'3 self
  
  let rec eq'1 (self:uint64) (other:uint64) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span4] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
    
  
  use T_bdd__Bdd as Bdd'0
  
  function deep_model'4 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span5] T_bdd__Bdd.t_Bdd__1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span6] deep_model'4 self
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span7] shallow_model'1 self
  
  let rec eq'0 (self:Bdd'0.t_Bdd) (o:Bdd'0.t_Bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span8] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec eq (self:Node'0.t_Node) (rhs:Node'0.t_Node) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- (self, rhs) ] s1
      | s1 = any
        [ br0 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_False } (! bb2)
        | br1 -> {(let (r'0, _) = _4 in r'0) = Node'0.C_True } (! bb4)
        | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (r'0, _) = _4 in r'0) = Node'0.C_If a b c} (! bb6) ]
         ]
      
    | bb6 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb25)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb25)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb25 = bb1
    | bb7 = bb10
    | bb10 = s0
      [ s0 = Node'0.v_If {let (r'0, _) = _4 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_Bdd) (rchildf'0:Bdd'0.t_Bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.v_If {let (r'1, _) = _4 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_Bdd) (rchildf'1:Bdd'0.t_Bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.v_If {let (r'2, _) = _4 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_Bdd) (rchildf'2:Bdd'0.t_Bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 = Node'0.v_If {let (_, r'3) = _4 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_Bdd) (rchildf'3:Bdd'0.t_Bdd) ->  [ &v_2 <- rv'3 ] s4)
      | s4 = Node'0.v_If {let (_, r'4) = _4 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_Bdd) (rchildf'4:Bdd'0.t_Bdd) ->  [ &childt_2 <- rchildt'4 ] s5)
      | s5 = Node'0.v_If {let (_, r'5) = _4 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_Bdd) (rchildf'5:Bdd'0.t_Bdd) ->  [ &childf_2 <- rchildf'5 ] s6)
      | s6 = eq'0 {childf_1} {childf_2} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s7)
      | s7 = bb11 ]
      
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq'0 {childt_1} {childt_2} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0 [ s0 = eq'1 {v_1} {v_2} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ] 
    | bb16 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb21 ] 
    | bb17 = bb20
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb4 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb1)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb5)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb5 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb2 = any
      [ br0 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_False } (! bb3)
      | br1 -> {(let (_, r'0) = _4 in r'0) = Node'0.C_True } (! bb1)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (_, r'0) = _4 in r'0) = Node'0.C_If a b c} (! bb1) ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sbdd0] false ] s1 | s1 = bb22 ] 
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- [%#sbdd0] true ] s1 | s1 = bb22 ] 
    | bb22 = return' {_0} ]
    )
    [ & _0 : bool = any_l ()
    | & self : Node'0.t_Node = self
    | & rhs : Node'0.t_Node = rhs
    | & _4 : (Node'0.t_Node, Node'0.t_Node) = any_l ()
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_Bdd = any_l ()
    | & childf_1 : Bdd'0.t_Bdd = any_l ()
    | & v_2 : uint64 = any_l ()
    | & childt_2 : Bdd'0.t_Bdd = any_l ()
    | & childf_2 : Bdd'0.t_Bdd = any_l ()
    | & _17 : bool = any_l ()
    | & _20 : bool = any_l ()
    | & _23 : bool = any_l () ]
    
    [ return' (result:bool)-> {[@expl:postcondition] [%#sbdd0] result = (deep_model'0 self = deep_model'0 rhs)}
      (! return' {result}) ]
    
end
module M_bdd__qyi2820858787824331484__clone [#"../bdd.rs" 113 4 113 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "../bdd.rs" 112 14 112 29
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use T_bdd__Bdd as Bdd'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : Bdd'0.t_Bdd = any_l () | & self : Bdd'0.t_Bdd = self ] 
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ]
    
end
module M_bdd__qyi17981791245757283426__clone [#"../bdd.rs" 94 24 94 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "../bdd.rs" 94 24 94 29
  let%span span1 = "../bdd.rs" 112 14 112 29
  let%span span2 = "../../../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use T_bdd__Bdd as Bdd'0
  
  let rec clone'1 (self:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span1] result = self} (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  let rec clone'0 (self:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span2] result = self} (! return' {result}) ]
    
  
  use T_bdd__Node as Node'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:Node'0.t_Node) (return'  (ret:Node'0.t_Node))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb4 = s0
      [ s0 = Node'0.v_If {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_Bdd) (rchildf'0:Bdd'0.t_Bdd) ->  [ &v_1 <- rv'0 ] s1)
      | s1 = Node'0.v_If {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_Bdd) (rchildf'1:Bdd'0.t_Bdd) ->  [ &childt_1 <- rchildt'1 ] s2)
      | s2 = Node'0.v_If {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_Bdd) (rchildf'2:Bdd'0.t_Bdd) ->  [ &childf_1 <- rchildf'2 ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone'0 {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1
      | s1 = clone'1 {_12} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1
      | s1 = clone'1 {_15} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- Node'0.C_If _7 _10 _13 ] s1 | s1 = bb10 ] 
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- Node'0.C_True ] s1 | s1 = bb10 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- Node'0.C_False ] s1 | s1 = bb10 ] 
    | bb10 = return' {_0} ]
    )
    [ & _0 : Node'0.t_Node = any_l ()
    | & self : Node'0.t_Node = self
    | & v_1 : uint64 = any_l ()
    | & childt_1 : Bdd'0.t_Bdd = any_l ()
    | & childf_1 : Bdd'0.t_Bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _10 : Bdd'0.t_Bdd = any_l ()
    | & _12 : Bdd'0.t_Bdd = any_l ()
    | & _13 : Bdd'0.t_Bdd = any_l ()
    | & _15 : Bdd'0.t_Bdd = any_l () ]
     [ return' (result:Node'0.t_Node)-> {[@expl:postcondition] [%#sbdd0] result = self} (! return' {result}) ] 
end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq [#"../bdd.rs" 108 15 108 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  use T_bdd__Bdd as Bdd'0
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq (self:Bdd'0.t_Bdd) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi699402059438633899__hash [#"../bdd.rs" 120 4 120 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "../bdd.rs" 125 53 125 54
  let%span sbdd1 = "../bdd.rs" 125 92 125 93
  let%span sbdd2 = "../bdd.rs" 123 20 123 21
  let%span sbdd3 = "../bdd.rs" 122 21 122 22
  let%span sbdd4 = "../bdd.rs" 119 14 119 46
  let%span span5 = "" 0 0 0 0
  let%span span6 = "../bdd.rs" 134 12 139 13
  let%span span7 = "../bdd.rs" 164 12 168 13
  let%span span8 = "../bdd.rs" 180 20 180 37
  let%span span9 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span10 = "" 0 0 0 0
  let%span span11 = "" 0 0 0 0
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  use T_bdd__NodeLog as NodeLog'0
  
  function hash_log'0 [#"../bdd.rs" 132 4 132 44] (x : NodeLog'0.t_NodeLog) : int =
    [%#span6] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (v_MAX'0 : uint64) + 1)
      end
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use T_bdd__Node as Node'0
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span7] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span8] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span9] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  constant v_MIN'0 : uint64 = [%#span10] (0 : uint64)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span11] (64 : uint32)
  
  let rec wrapping_add'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span15] UInt64.to_int self + UInt64.to_int rhs > UInt64.to_int (v_MAX'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      - k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span14] UInt64.to_int self + UInt64.to_int rhs < UInt64.to_int (v_MIN'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self + UInt64.to_int rhs
      + k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span13] UInt64.to_int self + UInt64.to_int rhs >= UInt64.to_int (v_MIN'0 : uint64)
      /\ UInt64.to_int self + UInt64.to_int rhs <= UInt64.to_int (v_MAX'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self + UInt64.to_int rhs}
      {[%#span12] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self
      + UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt64.to_int (v_MIN'0 : uint64)}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint64) (rhs:uint64) (return'  (ret:uint64))= any
    [ return' (result:uint64)-> {[%#span19] UInt64.to_int self * UInt64.to_int rhs > UInt64.to_int (v_MAX'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      - k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span18] UInt64.to_int self * UInt64.to_int rhs < UInt64.to_int (v_MIN'0 : uint64)
       -> (exists k : int . k > 0
      /\ UInt64.to_int result
      = UInt64.to_int self * UInt64.to_int rhs
      + k * (UInt64.to_int (v_MAX'0 : uint64) - UInt64.to_int (v_MIN'0 : uint64) + 1))}
      {[%#span17] UInt64.to_int self * UInt64.to_int rhs >= UInt64.to_int (v_MIN'0 : uint64)
      /\ UInt64.to_int self * UInt64.to_int rhs <= UInt64.to_int (v_MAX'0 : uint64)
       -> UInt64.to_int result = UInt64.to_int self * UInt64.to_int rhs}
      {[%#span16] UInt64.to_int result
      = EuclideanDivision.mod (UInt64.to_int self
      * UInt64.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt64.to_int (v_MIN'0 : uint64)}
      (! return' {result}) ]
    
  
  use T_bdd__Bdd as Bdd'0
  
  meta "compute_max_steps" 1000000
  
  let rec hash (self:Node'0.t_Node) (return'  (ret:uint64))= (! bb0
    [ bb0 = any
      [ br0 -> {self = Node'0.C_False } (! bb2)
      | br1 -> {self = Node'0.C_True } (! bb3)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {self = Node'0.C_If a b c} (! bb4) ]
      
    | bb4 = s0
      [ s0 = Node'0.v_If {self}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_Bdd) (rchildf'0:Bdd'0.t_Bdd) ->  [ &v <- rv'0 ] s1)
      | s1 = Node'0.v_If {self}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_Bdd) (rchildf'1:Bdd'0.t_Bdd) ->  [ &childt <- rchildt'1 ] s2)
      | s2 = Node'0.v_If {self}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_Bdd) (rchildf'2:Bdd'0.t_Bdd) ->  [ &childf <- rchildf'2 ] s3)
      | s3 = Bdd'0.t_Bdd {childt}
          (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd0] (5 : uint64)} (fun (_ret':uint64) ->  [ &_9 <- _ret' ] s4))
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 = wrapping_add'0 {v} {_9} (fun (_ret':uint64) ->  [ &_7 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = Bdd'0.t_Bdd {childf}
          (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
            wrapping_mul'0 {r1'0} {[%#sbdd1] (7 : uint64)} (fun (_ret':uint64) ->  [ &_11 <- _ret' ] s1))
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = wrapping_add'0 {_7} {_11} (fun (_ret':uint64) ->  [ &_0 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = bb11
    | bb3 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd2] (2 : uint64) ] s1 | s1 = bb11 ] 
    | bb2 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd3] (1 : uint64) ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : uint64 = any_l ()
    | & self : Node'0.t_Node = self
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_Bdd = any_l ()
    | & childf : Bdd'0.t_Bdd = any_l ()
    | & _7 : uint64 = any_l ()
    | & _9 : uint64 = any_l ()
    | & _11 : uint64 = any_l () ]
    
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module M_bdd__qyi14323183011761258016__hash [#"../bdd.rs" 146 4 146 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "../bdd.rs" 145 14 145 46
  let%span span1 = "../bdd.rs" 153 8 153 24
  let%span span2 = "../bdd.rs" 190 20 190 26
  let%span span3 = "../bdd.rs" 200 20 200 37
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../bdd.rs" 152 4 152 44] (x : uint64) : int =
    [%#span1] UInt64.to_int x
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use T_bdd__Bdd as Bdd'0
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span2] T_bdd__Bdd.t_Bdd__1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span3] deep_model'0 self
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span4] shallow_model'1 self
  
  use prelude.prelude.Intrinsic
  
  use T_bdd__Node as Node'0
  
  meta "compute_max_steps" 1000000
  
  let rec hash (self:Bdd'0.t_Bdd) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = Bdd'0.t_Bdd {self} (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->  [ &_0 <- r1'0 ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () | & self : Bdd'0.t_Bdd = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [%#sbdd0] UInt64.to_int result
      = hash_log'0 (shallow_model'0 self)}
      (! return' {result}) ]
    
end
module M_bdd__qyi13535665294507397779__size__Impl [#"../bdd.rs" 228 4 228 24] (* Bdd<'arena> *)
  let%span sbdd0 = "../bdd.rs" 227 14 227 25
  
  use T_bdd__Node as Node'0
  
  use T_bdd__Bdd as Bdd'0
  
  use prelude.prelude.Int
  
  constant self  : Bdd'0.t_Bdd
  
  function size [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_Bdd) : int
  
  goal vc_size : match self with
    | Bdd'0.C_Bdd (Node'0.C_True) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_False) _ -> [%#sbdd0] 0 >= 0
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> ([%#sbdd0] size childt >= 0)
     -> (let ht = size childt in ([%#sbdd0] size childf >= 0)  -> (let hf = size childf in [%#sbdd0] 1 + ht + hf >= 0))
    end
end
module T_bdd__Context [#"../bdd.rs" 254 0 254 26]
  use T_bdd__Bdd as Bdd'0
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  use T_bdd__bumpalo__Bump as Bump'0
  
  use prelude.prelude.Borrow
  
  type t_Context  =
    | C_Context (Bump'0.t_Bump) (MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) uint64
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Context (input:t_Context) (ret  (alloc:Bump'0.t_Bump) (hashcons:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (not_memo:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (and_memo:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (cnt:uint64))= any
    [ good (alloc:Bump'0.t_Bump) (hashcons:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (hashcons_ghost:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (not_memo:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (and_memo:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (cnt:uint64)-> {C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt
      = input}
      (! ret {alloc} {hashcons} {hashcons_ghost} {not_memo} {and_memo} {cnt}) ]
    
  
  function t_Context__hashcons (self : t_Context) : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd) =
    match self with
      | C_Context _ a _ _ _ _ -> a
      end
  
  function t_Context__cnt (self : t_Context) : uint64 =
    match self with
      | C_Context _ _ _ _ _ a -> a
      end
  
  function t_Context__hashcons_ghost (self : t_Context) : Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node)) =
    match self with
      | C_Context _ _ a _ _ _ -> a
      end
  
  function t_Context__not_memo (self : t_Context) : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd) =
    match self with
      | C_Context _ _ _ a _ _ -> a
      end
  
  function t_Context__and_memo (self : t_Context) : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd) =
    match self with
      | C_Context _ _ _ _ a _ -> a
      end
end
module M_bdd__qyi11078426090797403070__grows_is_valid_bdd__Impl [#"../bdd.rs" 340 4 340 56] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 337 15 337 27
  let%span sbdd1 = "../bdd.rs" 338 15 338 35
  let%span sbdd2 = "../bdd.rs" 339 14 339 37
  let%span span3 = "../bdd.rs" 164 12 168 13
  let%span span4 = "../bdd.rs" 180 20 180 37
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span6 = "../bdd.rs" 315 12 315 47
  let%span span7 = "../bdd.rs" 301 8 308 9
  
  use T_bdd__Bdd as Bdd'0
  
  use T_bdd__Context as Context'0
  
  use prelude.prelude.Borrow
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__Node as Node'0
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span3] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span4] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span5] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span6] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span7] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_Context)
  
  constant b  : Bdd'0.t_Bdd
  
  function grows_is_valid_bdd [#"../bdd.rs" 340 4 340 56] (self : borrowed (Context'0.t_Context)) (b : Bdd'0.t_Bdd) : ()
  
  goal vc_grows_is_valid_bdd : ([%#sbdd1] is_valid_bdd'0 self.current b)
   -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd2] is_valid_bdd'0 self.final b)
end
module M_bdd__qyi11078426090797403070__grows_trans__Impl [#"../bdd.rs" 349 4 349 62] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 344 15 344 27
  let%span sbdd1 = "../bdd.rs" 345 15 345 24
  let%span sbdd2 = "../bdd.rs" 346 15 346 26
  let%span sbdd3 = "../bdd.rs" 347 15 347 43
  let%span sbdd4 = "../bdd.rs" 348 14 348 24
  let%span span5 = "../bdd.rs" 301 8 308 9
  
  use T_bdd__Context as Context'0
  
  use prelude.prelude.Borrow
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use map.Map
  
  use T_bdd__Node as Node'0
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use map.Map
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span5] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  constant self  : borrowed (Context'0.t_Context)
  
  constant o  : borrowed (Context'0.t_Context)
  
  constant oo  : borrowed (Context'0.t_Context)
  
  function grows_trans [#"../bdd.rs" 349 4 349 62] (self : borrowed (Context'0.t_Context)) (o : borrowed (Context'0.t_Context)) (oo : borrowed (Context'0.t_Context)) : ()
    
  
  goal vc_grows_trans : ([%#sbdd3] self.current = oo.current /\ self.final = oo.final)
   -> ([%#sbdd2] self.final = o.current)
   -> ([%#sbdd1] grows'0 o)  -> ([%#sbdd0] grows'0 self)  -> ([%#sbdd4] grows'0 oo)
end
module M_bdd__qyi11078426090797403070__set_irrelevent_var__Impl [#"../bdd.rs" 356 4 356 87] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 352 15 352 24
  let%span sbdd1 = "../bdd.rs" 353 15 353 35
  let%span sbdd2 = "../bdd.rs" 354 15 354 32
  let%span sbdd3 = "../bdd.rs" 355 14 355 50
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span5 = "" 0 0 0 0
  let%span span6 = "../bdd.rs" 245 12 249 13
  let%span span7 = "../bdd.rs" 215 12 222 13
  let%span span8 = "../bdd.rs" 164 12 168 13
  let%span span9 = "../bdd.rs" 180 20 180 37
  let%span span10 = "../bdd.rs" 315 12 315 47
  let%span span11 = "../bdd.rs" 322 12 331 13
  let%span span12 = "../bdd.rs" 268 12 292 19
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span4] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span5] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span6] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span8] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span9] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span4] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span10] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span11] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span12] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Map
  
  constant self  : Context'0.t_Context
  
  constant a  : Bdd'0.t_Bdd
  
  constant x  : uint64
  
  constant v  : Map.map uint64 bool
  
  constant b  : bool
  
  function set_irrelevent_var [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
  
  goal vc_set_irrelevent_var : ([%#sbdd2] UInt64.to_int x < leastvar'0 a)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> match a with
    | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> (([%#sbdd2] UInt64.to_int x < leastvar'0 childt)
    && ([%#sbdd1] is_valid_bdd'0 self childt) && ([%#sbdd0] inv'0 self))
    /\ (([%#sbdd3] interp'0 childt v = interp'0 childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([%#sbdd2] UInt64.to_int x < leastvar'0 childf)
    && ([%#sbdd1] is_valid_bdd'0 self childf) && ([%#sbdd0] inv'0 self))
    /\ (([%#sbdd3] interp'0 childf v = interp'0 childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)))))
    | _ -> [%#sbdd3] interp'0 a v = interp'0 a (Map.set v x b)
    end
end
module M_bdd__qyi11078426090797403070__discr_valuation__Impl [#"../bdd.rs" 376 4 376 82] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 369 15 369 24
  let%span sbdd1 = "../bdd.rs" 370 15 370 35
  let%span sbdd2 = "../bdd.rs" 371 15 371 35
  let%span sbdd3 = "../bdd.rs" 372 15 372 21
  let%span sbdd4 = "../bdd.rs" 373 14 373 50
  let%span sbdd5 = "../bdd.rs" 374 14 374 33
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span7 = "" 0 0 0 0
  let%span span8 = "../bdd.rs" 245 12 249 13
  let%span span9 = "../bdd.rs" 215 12 222 13
  let%span span10 = "../bdd.rs" 164 12 168 13
  let%span span11 = "../bdd.rs" 180 20 180 37
  let%span span12 = "../bdd.rs" 315 12 315 47
  let%span span13 = "../bdd.rs" 322 12 331 13
  let%span span14 = "../bdd.rs" 268 12 292 19
  let%span span15 = "../bdd.rs" 352 15 352 24
  let%span span16 = "../bdd.rs" 353 15 353 35
  let%span span17 = "../bdd.rs" 354 15 354 32
  let%span span18 = "../bdd.rs" 355 14 355 50
  let%span span19 = "../bdd.rs" 358 12 364 13
  let%span span20 = "../bdd.rs" 227 14 227 25
  let%span span21 = "../bdd.rs" 230 12 238 13
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span12] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span14] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span19] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_Context, a : Bdd'0.t_Bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span15] inv'0 self)
   -> ([%#span16] is_valid_bdd'0 self a)
   -> ([%#span17] UInt64.to_int x < leastvar'0 a)  -> ([%#span18] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_Bdd) : int =
    [%#span21] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_Bdd . [%#span20] size'0 self >= 0
  
  constant self  : Context'0.t_Context
  
  constant a  : Bdd'0.t_Bdd
  
  constant b  : Bdd'0.t_Bdd
  
  function discr_valuation [#"../bdd.rs" 376 4 376 82] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (b : Bdd'0.t_Bdd) : Map.map uint64 bool
    
  
  goal vc_discr_valuation : ([%#sbdd3] a <> b)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)
   -> ([%#sbdd0] inv'0 self)
   -> (let _ = set_irrelevent_var'0 in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> b then
        ((([%#sbdd3] childf <> b)
        && ([%#sbdd2] is_valid_bdd'0 self b) && ([%#sbdd1] is_valid_bdd'0 self childf) && ([%#sbdd0] inv'0 self))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childf + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childf (discr_valuation self childf b) <> interp'0 b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      else
        ((([%#sbdd3] childt <> b)
        && ([%#sbdd2] is_valid_bdd'0 self b) && ([%#sbdd1] is_valid_bdd'0 self childt) && ([%#sbdd0] inv'0 self))
        /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
        /\ ([%#sbdd5] size'0 childt + size'0 b) < ([%#sbdd5] size'0 a + size'0 b))
        /\ (([%#sbdd4] interp'0 childt (discr_valuation self childt b) <> interp'0 b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [%#sbdd4] interp'0 a result
        <> interp'0 b result))
      
      | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> a then
          ((([%#sbdd3] a <> childf)
          && ([%#sbdd2] is_valid_bdd'0 self childf) && ([%#sbdd1] is_valid_bdd'0 self a) && ([%#sbdd0] inv'0 self))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childf) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childf) <> interp'0 childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        else
          ((([%#sbdd3] a <> childt)
          && ([%#sbdd2] is_valid_bdd'0 self childt) && ([%#sbdd1] is_valid_bdd'0 self a) && ([%#sbdd0] inv'0 self))
          /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
          /\ ([%#sbdd5] size'0 a + size'0 childt) < ([%#sbdd5] size'0 a + size'0 b))
          /\ (([%#sbdd4] interp'0 a (discr_valuation self a childt) <> interp'0 childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [%#sbdd4] interp'0 a result
          <> interp'0 b result))
        
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    else
      match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> if childfa <> childfb then
            ((([%#sbdd3] childfa <> childfb)
            && ([%#sbdd2] is_valid_bdd'0 self childfb)
            && ([%#sbdd1] is_valid_bdd'0 self childfa) && ([%#sbdd0] inv'0 self))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childfa + size'0 childfb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childfa (discr_valuation self childfa childfb)
            <> interp'0 childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          else
            ((([%#sbdd3] childta <> childtb)
            && ([%#sbdd2] is_valid_bdd'0 self childtb)
            && ([%#sbdd1] is_valid_bdd'0 self childta) && ([%#sbdd0] inv'0 self))
            /\ 0 <= ([%#sbdd5] size'0 a + size'0 b)
            /\ ([%#sbdd5] size'0 childta + size'0 childtb) < ([%#sbdd5] size'0 a + size'0 b))
            /\ (([%#sbdd4] interp'0 childta (discr_valuation self childta childtb)
            <> interp'0 childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [%#sbdd4] interp'0 a result
            <> interp'0 b result))
          
          | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
          end
        | _ -> let result = Const.const true in [%#sbdd4] interp'0 a result <> interp'0 b result
        end
    
  )
end
module M_bdd__qyi11078426090797403070__bdd_canonical__Impl [#"../bdd.rs" 425 4 425 62] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 419 15 419 24
  let%span sbdd1 = "../bdd.rs" 420 15 420 35
  let%span sbdd2 = "../bdd.rs" 421 15 421 35
  let%span sbdd3 = "../bdd.rs" 422 4 422 56
  let%span sbdd4 = "../bdd.rs" 423 14 423 20
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../bdd.rs" 245 12 249 13
  let%span span8 = "../bdd.rs" 215 12 222 13
  let%span span9 = "../bdd.rs" 164 12 168 13
  let%span span10 = "../bdd.rs" 180 20 180 37
  let%span span11 = "../bdd.rs" 315 12 315 47
  let%span span12 = "../bdd.rs" 322 12 331 13
  let%span span13 = "../bdd.rs" 268 12 292 19
  let%span span14 = "../bdd.rs" 352 15 352 24
  let%span span15 = "../bdd.rs" 353 15 353 35
  let%span span16 = "../bdd.rs" 354 15 354 32
  let%span span17 = "../bdd.rs" 355 14 355 50
  let%span span18 = "../bdd.rs" 358 12 364 13
  let%span span19 = "../bdd.rs" 227 14 227 25
  let%span span20 = "../bdd.rs" 230 12 238 13
  let%span span21 = "../bdd.rs" 369 15 369 24
  let%span span22 = "../bdd.rs" 370 15 370 35
  let%span span23 = "../bdd.rs" 371 15 371 35
  let%span span24 = "../bdd.rs" 372 15 372 21
  let%span span25 = "../bdd.rs" 373 14 373 50
  let%span span26 = "../bdd.rs" 374 14 374 33
  let%span span27 = "../bdd.rs" 378 12 378 36
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'2 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span5] shallow_model'2 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span11] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span13] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use map.Const
  
  use map.Map
  
  function set_irrelevent_var'0 [#"../bdd.rs" 356 4 356 87] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (x : uint64) (v : Map.map uint64 bool) (b : bool) : ()
    
   =
    [%#span18] match a with
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let _ = set_irrelevent_var'0 self childt x v b in let _ = set_irrelevent_var'0 self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var'0_spec : forall self : Context'0.t_Context, a : Bdd'0.t_Bdd, x : uint64, v : Map.map uint64 bool, b : bool . ([%#span14] inv'0 self)
   -> ([%#span15] is_valid_bdd'0 self a)
   -> ([%#span16] UInt64.to_int x < leastvar'0 a)  -> ([%#span17] interp'0 a v = interp'0 a (Map.set v x b))
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_Bdd) : int =
    [%#span20] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_Bdd . [%#span19] size'0 self >= 0
  
  function discr_valuation'0 [#"../bdd.rs" 376 4 376 82] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (b : Bdd'0.t_Bdd) : Map.map uint64 bool
    
  
  axiom discr_valuation'0_def : forall self : Context'0.t_Context, a : Bdd'0.t_Bdd, b : Bdd'0.t_Bdd . discr_valuation'0 self a b
  = ([%#span27] let _ = () in if leastvar'0 a < leastvar'0 b then
    match a with
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> b then
        Map.set (discr_valuation'0 self childf b) v false
      else
        Map.set (discr_valuation'0 self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar'0 a > leastvar'0 b then
      match b with
        | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if childf <> a then
          Map.set (discr_valuation'0 self a childf) v false
        else
          Map.set (discr_valuation'0 self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | Bdd'0.C_Bdd (Node'0.C_If v childta childfa) _ -> match b with
          | Bdd'0.C_Bdd (Node'0.C_If _ childtb childfb) _ -> if childfa <> childfb then
            Map.set (discr_valuation'0 self childfa childfb) v false
          else
            Map.set (discr_valuation'0 self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
    
  )
  
  axiom discr_valuation'0_spec : forall self : Context'0.t_Context, a : Bdd'0.t_Bdd, b : Bdd'0.t_Bdd . ([%#span21] inv'0 self)
   -> ([%#span22] is_valid_bdd'0 self a)
   -> ([%#span23] is_valid_bdd'0 self b)
   -> ([%#span24] a <> b)
   -> ([%#span25] interp'0 a (discr_valuation'0 self a b) <> interp'0 b (discr_valuation'0 self a b))
  
  constant self  : Context'0.t_Context
  
  constant a  : Bdd'0.t_Bdd
  
  constant b  : Bdd'0.t_Bdd
  
  function bdd_canonical [#"../bdd.rs" 425 4 425 62] (self : Context'0.t_Context) (a : Bdd'0.t_Bdd) (b : Bdd'0.t_Bdd) : ()
    
  
  goal vc_bdd_canonical : ([%#sbdd3] forall v : Map.map uint64 bool . interp'0 a v = interp'0 b v)
   -> ([%#sbdd2] is_valid_bdd'0 self b)
   -> ([%#sbdd1] is_valid_bdd'0 self a)  -> ([%#sbdd0] inv'0 self)  -> (let _ = discr_valuation'0 in [%#sbdd4] a = b)
end
module M_bdd__qyi11078426090797403070__new [#"../bdd.rs" 431 4 431 52] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 435 22 435 47
  let%span sbdd1 = "../bdd.rs" 436 28 436 57
  let%span sbdd2 = "../bdd.rs" 437 22 437 47
  let%span sbdd3 = "../bdd.rs" 438 22 438 47
  let%span sbdd4 = "../bdd.rs" 439 17 439 18
  let%span sbdd5 = "../bdd.rs" 431 48 431 52
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span7 = "" 0 0 0 0
  let%span span8 = "../bdd.rs" 245 12 249 13
  let%span span9 = "../bdd.rs" 215 12 222 13
  let%span span10 = "../bdd.rs" 164 12 168 13
  let%span span11 = "../bdd.rs" 180 20 180 37
  let%span span12 = "../bdd.rs" 315 12 315 47
  let%span span13 = "../bdd.rs" 322 12 331 13
  let%span span14 = "../bdd.rs" 268 12 292 19
  let%span span15 = "../bdd.rs" 71 18 71 47
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'2 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'4 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span11] deep_model'0 self
  
  function shallow_model'3 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span6] shallow_model'4 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span12] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'3 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span14] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'3 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'2 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  use prelude.prelude.Snapshot
  
  use T_bdd__bumpalo__Bump as Bump'0
  
  use prelude.prelude.Intrinsic
  
  use map.Const
  
  let rec new'2 (_1:()) (return'  (ret:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)))= any
    [ return' (result:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd))-> {[%#span15] shallow_model'2 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use map.Const
  
  let rec new'1 (_1:()) (return'  (ret:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)))= any
    [ return' (result:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd))-> {[%#span15] shallow_model'1 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Const
  
  use map.Const
  
  let rec new'0 (_1:()) (return'  (ret:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)))= any
    [ return' (result:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd))-> {[%#span15] shallow_model'0 result
      = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
  
  let rec promoted0 (return'  (ret:Node'0.t_Node))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- Node'0.C_True ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : Node'0.t_Node = any_l () | & _1 : Node'0.t_Node = any_l () ] 
    [ return' (result:Node'0.t_Node)-> return' {result} ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec new (alloc:Bump'0.t_Bump) (return'  (ret:Context'0.t_Context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0 (fun (pr0:Node'0.t_Node) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new'0 {[%#sbdd0] ()}
          (fun (_ret':MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd1] Snapshot.new (Const.const t) ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = new'1 {[%#sbdd2] ()}
          (fun (_ret':MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) ->  [ &_8 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = new'2 {[%#sbdd3] ()}
          (fun (_ret':MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &_0 <- Context'0.C_Context alloc _5 _6 _8 _9 ([%#sbdd4] (0 : uint64)) ] s1 | s1 = return' {_0} ]
       ]
    )
    [ & _0 : Context'0.t_Context = any_l ()
    | & alloc : Bump'0.t_Bump = alloc
    | & t : Node'0.t_Node = any_l ()
    | & _5 : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd) = any_l ()
    | & _6 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node)) = any_l ()
    | & _8 : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd) = any_l ()
    | & _9 : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd) = any_l ()
    | & _10 : Node'0.t_Node = any_l () ]
     [ return' (result:Context'0.t_Context)-> {[@expl:postcondition] [%#sbdd5] inv'0 result} (! return' {result}) ] 
end
module M_bdd__qyi11078426090797403070__hashcons [#"../bdd.rs" 447 4 447 58] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 454 30 454 77
  let%span sbdd1 = "../bdd.rs" 455 22 455 30
  let%span sbdd2 = "../bdd.rs" 455 33 455 34
  let%span sbdd3 = "../bdd.rs" 461 20 461 21
  let%span sbdd4 = "../bdd.rs" 449 28 449 38
  let%span sbdd5 = "../bdd.rs" 443 15 443 36
  let%span sbdd6 = "../bdd.rs" 447 21 447 25
  let%span sbdd7 = "../bdd.rs" 444 14 444 28
  let%span sbdd8 = "../bdd.rs" 445 14 445 26
  let%span sbdd9 = "../bdd.rs" 446 14 446 42
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span11 = "" 0 0 0 0
  let%span span12 = "../bdd.rs" 245 12 249 13
  let%span span13 = "../bdd.rs" 215 12 222 13
  let%span span14 = "../bdd.rs" 164 12 168 13
  let%span span15 = "../bdd.rs" 180 20 180 37
  let%span span16 = "../bdd.rs" 315 12 315 47
  let%span span17 = "../bdd.rs" 322 12 331 13
  let%span span18 = "../bdd.rs" 268 12 292 19
  let%span span19 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span20 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span21 = "../bdd.rs" 301 8 308 9
  let%span span22 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span24 = "../bdd.rs" 58 30 58 33
  let%span span25 = "../bdd.rs" 58 38 58 41
  let%span span26 = "../bdd.rs" 56 8 56 128
  let%span span27 = "../bdd.rs" 22 31 22 34
  let%span span28 = "../bdd.rs" 21 18 21 32
  let%span span29 = "../bdd.rs" 22 42 22 48
  let%span span30 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span31 = "../bdd.rs" 67 37 67 40
  let%span span32 = "../bdd.rs" 62 18 65 9
  let%span span33 = "../bdd.rs" 67 52 67 65
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span10] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span11] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span14] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span15] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] shallow_model'1 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span16] Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'0 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span17] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'6 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span18] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'0 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'6 (_1 : Context'0.t_Context)
  
  axiom inv'6 [@rewrite] : forall x : Context'0.t_Context [inv'6 x] . inv'6 x
  = (invariant'6 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate inv'5 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'5 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'5 x] . inv'5 x = true
  
  predicate inv'3 (_1 : Node'0.t_Node)
  
  predicate invariant'4 (self : borrowed (Node'0.t_Node)) =
    [%#span19] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node))
  
  axiom inv'4 [@rewrite] : forall x : borrowed (Node'0.t_Node) [inv'4 x] . inv'4 x = true
  
  axiom inv'3 [@rewrite] : forall x : Node'0.t_Node [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : Option'0.t_Option (Bdd'0.t_Bdd))
  
  axiom inv'2 [@rewrite] : forall x : Option'0.t_Option (Bdd'0.t_Bdd) [inv'2 x] . inv'2 x = true
  
  predicate invariant'1 (self : Node'0.t_Node) =
    [%#span20] inv'3 self
  
  predicate inv'1 (_1 : Node'0.t_Node)
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node [inv'1 x] . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (Context'0.t_Context)) =
    [%#span19] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'0 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'0 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span21] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (Context'0.t_Context)) =
    [%#span22] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Context'0.t_Context)) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  function shallow_model'4 (self : borrowed (MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd))) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span23] shallow_model'3 self.current
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd))) (key:Node'0.t_Node) (val':Bdd'0.t_Bdd) (return'  (ret:()))= {[@expl:precondition] [%#span25] inv'5 val'}
    {[@expl:precondition] [%#span24] inv'3 key}
    any
    [ return' (result:())-> {[%#span26] forall i : NodeLog'0.t_NodeLog . Map.get (shallow_model'3 self.final) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'4 self) i)}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node)) =
    [%#span22] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node)) =
    resolve'2 _1
  
  use T_bdd__bumpalo__Bump as Bump'0
  
  let rec alloc'0 (self:Bump'0.t_Bump) (val':Node'0.t_Node) (return'  (ret:borrowed (Node'0.t_Node)))= {[@expl:precondition] [%#span27] inv'3 val'}
    any
    [ return' (result:borrowed (Node'0.t_Node))-> {[%#span29] inv'4 result}
      {[%#span28] result.current = val'}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span30] deep_model'1 self
  
  function shallow_model'2 (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span10] shallow_model'3 self
  
  let rec get'0 (self:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (key:Node'0.t_Node) (return'  (ret:Option'0.t_Option (Bdd'0.t_Bdd)))= {[@expl:precondition] [%#span31] inv'1 key}
    any
    [ return' (result:Option'0.t_Option (Bdd'0.t_Bdd))-> {[%#span33] inv'2 result}
      {[%#span32] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'2 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec hashcons (self:borrowed (Context'0.t_Context)) (n:Node'0.t_Node) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd6] inv'0 self}
    {[%#sbdd5] is_valid_node'0 self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n ] s1
      | s1 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            get'0 {rhashcons'0} {_11} (fun (_ret':Option'0.t_Option (Bdd'0.t_Bdd)) ->  [ &_8 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_8 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_Bdd)-> {_8 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            alloc'0 {ralloc'0} {n} (fun (_ret':borrowed (Node'0.t_Node)) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
             [ &r1 <- Bdd'0.C_Bdd (_19.current) rcnt'0 ] 
            s1)
      | s1 = -{resolve'0 _19}- s2
      | s2 = Context'0.t_Context {self.current}
          (fun (ralloc'1:Bump'0.t_Bump) (rhashcons'1:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'1:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'1:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'1:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'1:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)>
              {rhashcons'1}
              {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd))) ->
                 [ &_24 <- _ret' ] 
                Context'0.t_Context {self.current}
                  (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 _24.final l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
                    
                    s3)))
      | s3 = add'0 {_24} {n} {r1} (fun (_ret':()) ->  [ &_23 <- _ret' ] s4)
      | s4 = bb6 ]
      
    | bb6 = s0
      [ s0 = 
        [ &_27 <- [%#sbdd0] Snapshot.new (Map.set (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self.current)) (T_bdd__Bdd.t_Bdd__1 r1) (T_bdd__Bdd.t_Bdd__0 r1)) ]
        
        s1
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
            
            [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 _27 l_not_memo'0 l_and_memo'0 l_cnt'0 ; } ]
            
            s1)
      | s1 = UInt64.sub {[%#sbdd1] (18446744073709551615 : uint64)} {[%#sbdd2] (1 : uint64)}
          (fun (_ret':uint64) ->  [ &_32 <- _ret' ] s2)
      | s2 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            UInt64.gt {rcnt'0} {_32} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s3))
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new self ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:loop invariant] (Snapshot.inner old_9_0).final = self.final}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = Context'0.t_Context {self.current}
              (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
                Context'0.t_Context {self.current}
                  (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 rcnt'0 ; } ]
                    
                    s1))
          | s1 = bb9 ]
           ]
         ]
      
    | bb11 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            UInt64.add {rcnt'0} {[%#sbdd3] (1 : uint64)}
              (fun (_ret':uint64) ->
                Context'0.t_Context {self.current}
                  (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 l_and_memo'0 _ret' ; } ]
                    
                    s1)))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 =  [ &_0 <- r1 ] s4
      | s4 = bb12 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Bdd'0.t_Bdd> {_8} (fun (r0'0:Bdd'0.t_Bdd) ->  [ &r <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'1 self}- s3
      | s3 = {[@expl:assertion] [%#sbdd4] shallow_model'0 (T_bdd__Bdd.t_Bdd__0 r) = shallow_model'1 n} s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb12 ]
      
    | bb12 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & n : Node'0.t_Node = n
    | & _8 : Option'0.t_Option (Bdd'0.t_Bdd) = any_l ()
    | & _11 : Node'0.t_Node = any_l ()
    | & r : Bdd'0.t_Bdd = any_l ()
    | & r1 : Bdd'0.t_Bdd = any_l ()
    | & _19 : borrowed (Node'0.t_Node) = any_l ()
    | & _23 : () = any_l ()
    | & _24 : borrowed (MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) = any_l ()
    | & _27 : Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : uint64 = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (Context'0.t_Context)) = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd9] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd8] grows'0 self}
      {[@expl:postcondition] [%#sbdd7] T_bdd__Bdd.t_Bdd__0 result = n}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__node [#"../bdd.rs" 472 4 472 87] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 465 15 465 40
  let%span sbdd1 = "../bdd.rs" 466 15 466 40
  let%span sbdd2 = "../bdd.rs" 467 15 467 63
  let%span sbdd3 = "../bdd.rs" 472 17 472 21
  let%span sbdd4 = "../bdd.rs" 468 14 468 26
  let%span sbdd5 = "../bdd.rs" 469 14 469 42
  let%span sbdd6 = "../bdd.rs" 470 4 470 106
  let%span sbdd7 = "../bdd.rs" 471 14 471 37
  let%span span8 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../bdd.rs" 245 12 249 13
  let%span span11 = "../bdd.rs" 215 12 222 13
  let%span span12 = "../bdd.rs" 164 12 168 13
  let%span span13 = "../bdd.rs" 180 20 180 37
  let%span span14 = "../bdd.rs" 315 12 315 47
  let%span span15 = "../bdd.rs" 322 12 331 13
  let%span span16 = "../bdd.rs" 268 12 292 19
  let%span span17 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span18 = "../bdd.rs" 301 8 308 9
  let%span span19 = "../bdd.rs" 443 15 443 36
  let%span span20 = "../bdd.rs" 447 21 447 25
  let%span span21 = "../bdd.rs" 444 14 444 28
  let%span span22 = "../bdd.rs" 445 14 445 26
  let%span span23 = "../bdd.rs" 446 14 446 42
  let%span span24 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span25 = "../bdd.rs" 190 20 190 26
  let%span span26 = "../bdd.rs" 200 20 200 37
  let%span span27 = "../bdd.rs" 205 14 205 37
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use prelude.prelude.Borrow
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'6 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'3 (self : uint64) : int =
    [%#span8] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span9] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span10] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'3 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span12] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'5 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span13] deep_model'1 self
  
  function shallow_model'2 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span8] shallow_model'5 self
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span14] Map.get (shallow_model'1 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'2 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span15] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span16] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'1 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'2 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'6 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_1 : Context'0.t_Context)
  
  axiom inv'1 [@rewrite] : forall x : Context'0.t_Context [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_Context)) =
    [%#span17] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'0 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span18] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'1 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'1 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  let rec hashcons'0 (self:borrowed (Context'0.t_Context)) (n:Node'0.t_Node) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span20] inv'0 self}
    {[@expl:precondition] [%#span19] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span23] is_valid_bdd'0 self.final result}
      {[%#span22] grows'0 self}
      {[%#span21] T_bdd__Bdd.t_Bdd__0 result = n}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span24] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  function deep_model'0 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span25] T_bdd__Bdd.t_Bdd__1 self
  
  function shallow_model'4 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span26] deep_model'0 self
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span8] shallow_model'4 self
  
  let rec eq'0 (self:Bdd'0.t_Bdd) (o:Bdd'0.t_Bdd) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#span27] result = (shallow_model'0 self = shallow_model'0 o)} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec node (self:borrowed (Context'0.t_Context)) (x:uint64) (childt:Bdd'0.t_Bdd) (childf:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd3] inv'0 self}
    {[%#sbdd2] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[%#sbdd1] is_valid_bdd'0 self.current childf}
    {[%#sbdd0] is_valid_bdd'0 self.current childt}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {childt} {childf} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- childt ] s3
      | s3 = bb5 ]
      
    | bb3 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_Context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_17 <- _ret' ] 
             [ &self <- { self with current = _17.final ; } ] 
            s1)
      | s1 = -{inv'1 _17.final}- s2
      | s2 =  [ &_18 <- Node'0.C_If x childt childf ] s3
      | s3 = hashcons'0 {_17} {_18} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & x : uint64 = x
    | & childt : Bdd'0.t_Bdd = childt
    | & childf : Bdd'0.t_Bdd = childf
    | & _13 : bool = any_l ()
    | & _17 : borrowed (Context'0.t_Context) = any_l ()
    | & _18 : Node'0.t_Node = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd7] UInt64.to_int x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd6] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[@expl:postcondition] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd4] grows'0 self}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__trueqy95z [#"../bdd.rs" 483 4 483 42] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 483 22 483 26
  let%span sbdd1 = "../bdd.rs" 479 14 479 26
  let%span sbdd2 = "../bdd.rs" 480 14 480 42
  let%span sbdd3 = "../bdd.rs" 481 4 481 44
  let%span sbdd4 = "../bdd.rs" 482 14 482 46
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span7 = "" 0 0 0 0
  let%span span8 = "../bdd.rs" 245 12 249 13
  let%span span9 = "../bdd.rs" 215 12 222 13
  let%span span10 = "../bdd.rs" 164 12 168 13
  let%span span11 = "../bdd.rs" 180 20 180 37
  let%span span12 = "../bdd.rs" 315 12 315 47
  let%span span13 = "../bdd.rs" 322 12 331 13
  let%span span14 = "../bdd.rs" 268 12 292 19
  let%span span15 = "../bdd.rs" 301 8 308 9
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span17 = "../bdd.rs" 443 15 443 36
  let%span span18 = "../bdd.rs" 447 21 447 25
  let%span span19 = "../bdd.rs" 444 14 444 28
  let%span span20 = "../bdd.rs" 445 14 445 26
  let%span span21 = "../bdd.rs" 446 14 446 42
  
  use T_bdd__Context as Context'0
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_Context)) =
    [%#span5] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span12] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span14] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span15] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span16] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  let rec hashcons'0 (self:borrowed (Context'0.t_Context)) (n:Node'0.t_Node) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      {[%#span19] T_bdd__Bdd.t_Bdd__0 result = n}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec trueqy95z (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_Context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = _6.final ; } ] 
            s1)
      | s1 = -{inv'0 _6.final}- s2
      | s2 =  [ &_7 <- Node'0.C_True ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & _6 : borrowed (Context'0.t_Context) = any_l ()
    | & _7 : Node'0.t_Node = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (v_MAX'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__falseqy95z [#"../bdd.rs" 491 4 491 43] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 491 23 491 27
  let%span sbdd1 = "../bdd.rs" 487 14 487 26
  let%span sbdd2 = "../bdd.rs" 488 14 488 42
  let%span sbdd3 = "../bdd.rs" 489 4 489 45
  let%span sbdd4 = "../bdd.rs" 490 14 490 46
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span7 = "" 0 0 0 0
  let%span span8 = "../bdd.rs" 245 12 249 13
  let%span span9 = "../bdd.rs" 215 12 222 13
  let%span span10 = "../bdd.rs" 164 12 168 13
  let%span span11 = "../bdd.rs" 180 20 180 37
  let%span span12 = "../bdd.rs" 315 12 315 47
  let%span span13 = "../bdd.rs" 322 12 331 13
  let%span span14 = "../bdd.rs" 268 12 292 19
  let%span span15 = "../bdd.rs" 301 8 308 9
  let%span span16 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span17 = "../bdd.rs" 443 15 443 36
  let%span span18 = "../bdd.rs" 447 21 447 25
  let%span span19 = "../bdd.rs" 444 14 444 28
  let%span span20 = "../bdd.rs" 445 14 445 26
  let%span span21 = "../bdd.rs" 446 14 446 42
  
  use T_bdd__Context as Context'0
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_Context)) =
    [%#span5] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span6] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span7] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span9] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span11] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span6] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span12] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span13] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span14] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span15] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span16] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  let rec hashcons'0 (self:borrowed (Context'0.t_Context)) (n:Node'0.t_Node) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span18] inv'1 self}
    {[@expl:precondition] [%#span17] is_valid_node'0 self.current n}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      {[%#span19] T_bdd__Bdd.t_Bdd__0 result = n}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec falseqy95z (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_Context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_6 <- _ret' ] 
             [ &self <- { self with current = _6.final ; } ] 
            s1)
      | s1 = -{inv'0 _6.final}- s2
      | s2 =  [ &_7 <- Node'0.C_False ] s3
      | s3 = hashcons'0 {_6} {_7} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_0 <- _ret' ] s4)
      | s4 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & _6 : borrowed (Context'0.t_Context) = any_l ()
    | & _7 : Node'0.t_Node = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd4] UInt64.to_int (v_MAX'0 : uint64) + 1
      = leastvar'0 result}
      {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . not interp'0 result v}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__v [#"../bdd.rs" 498 4 498 46] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 498 18 498 22
  let%span sbdd1 = "../bdd.rs" 495 14 495 26
  let%span sbdd2 = "../bdd.rs" 496 14 496 42
  let%span sbdd3 = "../bdd.rs" 497 4 497 56
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../bdd.rs" 245 12 249 13
  let%span span8 = "../bdd.rs" 215 12 222 13
  let%span span9 = "../bdd.rs" 164 12 168 13
  let%span span10 = "../bdd.rs" 180 20 180 37
  let%span span11 = "../bdd.rs" 315 12 315 47
  let%span span12 = "../bdd.rs" 322 12 331 13
  let%span span13 = "../bdd.rs" 268 12 292 19
  let%span span14 = "../bdd.rs" 301 8 308 9
  let%span span15 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span16 = "../bdd.rs" 465 15 465 40
  let%span span17 = "../bdd.rs" 466 15 466 40
  let%span span18 = "../bdd.rs" 467 15 467 63
  let%span span19 = "../bdd.rs" 472 17 472 21
  let%span span20 = "../bdd.rs" 468 14 468 26
  let%span span21 = "../bdd.rs" 469 14 469 42
  let%span span22 = "../bdd.rs" 470 4 470 106
  let%span span23 = "../bdd.rs" 471 14 471 37
  let%span span24 = "../bdd.rs" 491 23 491 27
  let%span span25 = "../bdd.rs" 487 14 487 26
  let%span span26 = "../bdd.rs" 488 14 488 42
  let%span span27 = "../bdd.rs" 489 4 489 45
  let%span span28 = "../bdd.rs" 490 14 490 46
  let%span span29 = "../bdd.rs" 483 22 483 26
  let%span span30 = "../bdd.rs" 479 14 479 26
  let%span span31 = "../bdd.rs" 480 14 480 42
  let%span span32 = "../bdd.rs" 481 4 481 44
  let%span span33 = "../bdd.rs" 482 14 482 46
  
  use T_bdd__Context as Context'0
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Context'0.t_Context)) =
    [%#span4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use T_bdd__Bdd as Bdd'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  function shallow_model'5 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'4 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'2 (self : uint64) : int =
    [%#span5] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span6] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span7] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'2 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span8] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'0 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span9] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'3 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] deep_model'0 self
  
  function shallow_model'1 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span5] shallow_model'3 self
  
  function shallow_model'0 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span11] Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span12] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span13] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'1 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'4 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'5 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span14] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'0 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span15] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  let rec node'0 (self:borrowed (Context'0.t_Context)) (x:uint64) (childt:Bdd'0.t_Bdd) (childf:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span19] inv'1 self}
    {[@expl:precondition] [%#span18] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span17] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span16] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span23] UInt64.to_int x <= leastvar'0 result}
      {[%#span22] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span21] is_valid_bdd'0 self.final result}
      {[%#span20] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false_'0 (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span24] inv'1 self}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span28] UInt64.to_int (v_MAX'0 : uint64) + 1 = leastvar'0 result}
      {[%#span27] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span26] is_valid_bdd'0 self.final result}
      {[%#span25] grows'0 self}
      (! return' {result}) ]
    
  
  let rec true_'0 (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span29] inv'1 self}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span33] UInt64.to_int (v_MAX'0 : uint64) + 1 = leastvar'0 result}
      {[%#span32] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span31] is_valid_bdd'0 self.final result}
      {[%#span30] grows'0 self}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec v (self:borrowed (Context'0.t_Context)) (x:uint64) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd0] inv'1 self}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_7 <- _ret' ] 
             [ &self <- { self with current = _7.final ; } ] 
            s1)
      | s1 = -{inv'0 _7.final}- s2
      | s2 = true_'0 {_7} (fun (_ret':Bdd'0.t_Bdd) ->  [ &t <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_9 <- _ret' ] 
             [ &self <- { self with current = _9.final ; } ] 
            s1)
      | s1 = -{inv'0 _9.final}- s2
      | s2 = false_'0 {_9} (fun (_ret':Bdd'0.t_Bdd) ->  [ &f <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <Context'0.t_Context> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_10 <- _ret' ] 
             [ &self <- { self with current = _10.final ; } ] 
            s1)
      | s1 = -{inv'0 _10.final}- s2
      | s2 = node'0 {_10} {x} {t} {f} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & x : uint64 = x
    | & t : Bdd'0.t_Bdd = any_l ()
    | & _7 : borrowed (Context'0.t_Context) = any_l ()
    | & f : Bdd'0.t_Bdd = any_l ()
    | & _9 : borrowed (Context'0.t_Context) = any_l ()
    | & _10 : borrowed (Context'0.t_Context) = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd3] forall v : Map.map uint64 bool . interp'0 result v
      = Map.get v x}
      {[@expl:postcondition] [%#sbdd2] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd1] grows'0 self}
      (! return' {result}) ]
    
end
module M_bdd__qyi11078426090797403070__not [#"../bdd.rs" 510 4 510 56] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 504 15 504 35
  let%span sbdd1 = "../bdd.rs" 510 20 510 24
  let%span sbdd2 = "../bdd.rs" 505 14 505 26
  let%span sbdd3 = "../bdd.rs" 506 14 506 42
  let%span sbdd4 = "../bdd.rs" 507 4 507 60
  let%span sbdd5 = "../bdd.rs" 508 14 508 47
  let%span sbdd6 = "../bdd.rs" 509 14 509 22
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span8 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span9 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span10 = "" 0 0 0 0
  let%span span11 = "../bdd.rs" 245 12 249 13
  let%span span12 = "../bdd.rs" 215 12 222 13
  let%span span13 = "../bdd.rs" 164 12 168 13
  let%span span14 = "../bdd.rs" 180 20 180 37
  let%span span15 = "../bdd.rs" 315 12 315 47
  let%span span16 = "../bdd.rs" 322 12 331 13
  let%span span17 = "../bdd.rs" 268 12 292 19
  let%span span18 = "../bdd.rs" 227 14 227 25
  let%span span19 = "../bdd.rs" 230 12 238 13
  let%span span20 = "../bdd.rs" 301 8 308 9
  let%span span21 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span22 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span23 = "../bdd.rs" 190 20 190 26
  let%span span24 = "../bdd.rs" 58 30 58 33
  let%span span25 = "../bdd.rs" 58 38 58 41
  let%span span26 = "../bdd.rs" 56 8 56 128
  let%span span27 = "../bdd.rs" 483 22 483 26
  let%span span28 = "../bdd.rs" 479 14 479 26
  let%span span29 = "../bdd.rs" 480 14 480 42
  let%span span30 = "../bdd.rs" 481 4 481 44
  let%span span31 = "../bdd.rs" 482 14 482 46
  let%span span32 = "../bdd.rs" 491 23 491 27
  let%span span33 = "../bdd.rs" 487 14 487 26
  let%span span34 = "../bdd.rs" 488 14 488 42
  let%span span35 = "../bdd.rs" 489 4 489 45
  let%span span36 = "../bdd.rs" 490 14 490 46
  let%span span37 = "../bdd.rs" 465 15 465 40
  let%span span38 = "../bdd.rs" 466 15 466 40
  let%span span39 = "../bdd.rs" 467 15 467 63
  let%span span40 = "../bdd.rs" 472 17 472 21
  let%span span41 = "../bdd.rs" 468 14 468 26
  let%span span42 = "../bdd.rs" 469 14 469 42
  let%span span43 = "../bdd.rs" 470 4 470 106
  let%span span44 = "../bdd.rs" 471 14 471 37
  let%span span45 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span46 = "../bdd.rs" 67 37 67 40
  let%span span47 = "../bdd.rs" 62 18 65 9
  let%span span48 = "../bdd.rs" 67 52 67 65
  
  use T_bdd__Bdd as Bdd'0
  
  predicate inv'4 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'4 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'4 x] . inv'4 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (Bdd'0.t_Bdd))
  
  axiom inv'3 [@rewrite] : forall x : Option'0.t_Option (Bdd'0.t_Bdd) [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Bdd'0.t_Bdd) =
    [%#span7] inv'4 self
  
  predicate inv'2 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'2 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'2 x] . inv'2 x = true
  
  use T_bdd__Context as Context'0
  
  predicate inv'0 (_1 : Context'0.t_Context)
  
  predicate invariant'1 (self : borrowed (Context'0.t_Context)) =
    [%#span8] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'1 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'1 x] . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt64
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span9] UInt64.to_int self
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span10] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span11] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'2 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span13] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span14] deep_model'2 self
  
  function shallow_model'4 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span9] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span15] Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'4 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span16] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'0 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span17] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'1 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'7 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  axiom inv'0 [@rewrite] : forall x : Context'0.t_Context [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_Bdd) : int =
    [%#span19] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_Bdd . [%#span18] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span20] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span21] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span22] shallow_model'1 self.current
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span23] T_bdd__Bdd.t_Bdd__1 self
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) (key:Bdd'0.t_Bdd) (val':Bdd'0.t_Bdd) (return'  (ret:()))= {[@expl:precondition] [%#span25] inv'4 val'}
    {[@expl:precondition] [%#span24] inv'4 key}
    any
    [ return' (result:())-> {[%#span26] forall i : uint64 . Map.get (shallow_model'1 self.final) i
      = (if i = deep_model'1 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec true_'0 (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span27] inv'1 self}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span31] UInt64.to_int (v_MAX'0 : uint64) + 1 = leastvar'0 result}
      {[%#span30] forall v : Map.map uint64 bool . interp'0 result v}
      {[%#span29] is_valid_bdd'0 self.final result}
      {[%#span28] grows'0 self}
      (! return' {result}) ]
    
  
  let rec false_'0 (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span32] inv'1 self}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span36] UInt64.to_int (v_MAX'0 : uint64) + 1 = leastvar'0 result}
      {[%#span35] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span34] is_valid_bdd'0 self.final result}
      {[%#span33] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_Context)) (x:uint64) (childt:Bdd'0.t_Bdd) (childf:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span40] inv'1 self}
    {[@expl:precondition] [%#span39] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span38] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span37] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span44] UInt64.to_int x <= leastvar'0 result}
      {[%#span43] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span42] is_valid_bdd'0 self.final result}
      {[%#span41] grows'0 self}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span45] deep_model'1 self
  
  function shallow_model'0 (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span9] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (key:Bdd'0.t_Bdd) (return'  (ret:Option'0.t_Option (Bdd'0.t_Bdd)))= {[@expl:precondition] [%#span46] inv'2 key}
    any
    [ return' (result:Option'0.t_Option (Bdd'0.t_Bdd))-> {[%#span48] inv'3 result}
      {[%#span47] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use T_bdd__bumpalo__Bump as Bump'0
  
  meta "compute_max_steps" 1000000
  
  let rec not' (self:borrowed (Context'0.t_Context)) (x:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd1] inv'1 self}
    {[%#sbdd0] is_valid_bdd'0 self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x ] s1
      | s1 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            get'0 {rnot_memo'0} {_13} (fun (_ret':Option'0.t_Option (Bdd'0.t_Bdd)) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb1 ]
      
    | bb1 = any [ br0 -> {_10 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_Bdd)-> {_10 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = Bdd'0.t_Bdd {x}
        (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
          any
          [ br0 -> {r0'0 = Node'0.C_False } (! bb7)
          | br1 -> {r0'0 = Node'0.C_True } (! bb6)
          | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {r0'0 = Node'0.C_If a b c} (! bb8) ]
          )
    | bb8 = s0
      [ s0 = Bdd'0.t_Bdd {x}
          (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
            Node'0.v_If {r0'0}
              (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_Bdd) (rchildf'0:Bdd'0.t_Bdd) ->  [ &v <- rv'0 ] s1))
      | s1 = Bdd'0.t_Bdd {x}
          (fun (r0'1:Node'0.t_Node) (r1'1:uint64) ->
            Node'0.v_If {r0'1}
              (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_Bdd) (rchildf'1:Bdd'0.t_Bdd) ->  [ &childt <- rchildt'1 ] s2))
      | s2 = Bdd'0.t_Bdd {x}
          (fun (r0'2:Node'0.t_Node) (r1'2:uint64) ->
            Node'0.v_If {r0'2}
              (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_Bdd) (rchildf'2:Bdd'0.t_Bdd) ->  [ &childf <- rchildf'2 ] s3))
      | s3 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_25 <- _ret' ] 
             [ &self <- { self with current = _25.final ; } ] 
            s4)
      | s4 = -{inv'0 _25.final}- s5
      | s5 = not' {_25} {childt} (fun (_ret':Bdd'0.t_Bdd) ->  [ &childt1 <- _ret' ] s6)
      | s6 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = _28.final ; } ] 
            s1)
      | s1 = -{inv'0 _28.final}- s2
      | s2 = not' {_28} {childf} (fun (_ret':Bdd'0.t_Bdd) ->  [ &childf1 <- _ret' ] s3)
      | s3 = bb14 ]
      
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = _30.final ; } ] 
            s1)
      | s1 = -{inv'0 _30.final}- s2
      | s2 = node'0 {_30} {v} {childt1} {childf1} (fun (_ret':Bdd'0.t_Bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb15 ]
      
    | bb15 = bb16
    | bb6 = bb9
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_19 <- _ret' ] 
             [ &self <- { self with current = _19.final ; } ] 
            s1)
      | s1 = -{inv'0 _19.final}- s2
      | s2 = false_'0 {_19} (fun (_ret':Bdd'0.t_Bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = bb16
    | bb7 = bb11
    | bb11 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_20 <- _ret' ] 
             [ &self <- { self with current = _20.final ; } ] 
            s1)
      | s1 = -{inv'0 _20.final}- s2
      | s2 = true_'0 {_20} (fun (_ret':Bdd'0.t_Bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = bb16
    | bb16 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)>
              {rnot_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 4}
              (fun (_ret':borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) ->
                 [ &_35 <- _ret' ] 
                Context'0.t_Context {self.current}
                  (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 _35.final l_and_memo'0 l_cnt'0 ; } ]
                    
                    s1)))
      | s1 = add'0 {_35} {x} {r1} (fun (_ret':()) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb17 ]
      
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Bdd'0.t_Bdd> {_10} (fun (r0'0:Bdd'0.t_Bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'1 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb18 ]
      
    | bb18 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & x : Bdd'0.t_Bdd = x
    | & _10 : Option'0.t_Option (Bdd'0.t_Bdd) = any_l ()
    | & _13 : Bdd'0.t_Bdd = any_l ()
    | & r : Bdd'0.t_Bdd = any_l ()
    | & r1 : Bdd'0.t_Bdd = any_l ()
    | & _19 : borrowed (Context'0.t_Context) = any_l ()
    | & _20 : borrowed (Context'0.t_Context) = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_Bdd = any_l ()
    | & childf : Bdd'0.t_Bdd = any_l ()
    | & childt1 : Bdd'0.t_Bdd = any_l ()
    | & _25 : borrowed (Context'0.t_Context) = any_l ()
    | & childf1 : Bdd'0.t_Bdd = any_l ()
    | & _28 : borrowed (Context'0.t_Context) = any_l ()
    | & _30 : borrowed (Context'0.t_Context) = any_l ()
    | & _34 : () = any_l ()
    | & _35 : borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd5] leastvar'0 x <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd4] forall v : Map.map uint64 bool . interp'0 result v = (not interp'0 x v)}
      {[@expl:postcondition] [%#sbdd3] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd2] grows'0 self}
      (! return' {result}) ]
    
end
module T_core__cmp__Ordering
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function any_l (_ : 'b) : 'a
  
  let rec v_Less (input:t_Ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} (! {false} any) ]
    
  
  let rec v_Equal (input:t_Ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} (! {false} any) ]
    
  
  let rec v_Greater (input:t_Ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} (! {false} any) ]
    
end
module M_bdd__qyi11078426090797403070__and [#"../bdd.rs" 534 4 534 72] (* Context<'arena> *)
  let%span sbdd0 = "../bdd.rs" 538 22 538 34
  let%span sbdd1 = "../bdd.rs" 527 15 527 35
  let%span sbdd2 = "../bdd.rs" 528 15 528 35
  let%span sbdd3 = "../bdd.rs" 534 20 534 24
  let%span sbdd4 = "../bdd.rs" 529 14 529 26
  let%span sbdd5 = "../bdd.rs" 530 14 530 42
  let%span sbdd6 = "../bdd.rs" 531 4 531 76
  let%span sbdd7 = "../bdd.rs" 532 14 532 84
  let%span sbdd8 = "../bdd.rs" 533 14 533 33
  let%span span9 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span10 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  let%span span11 = "" 0 0 0 0
  let%span span12 = "../bdd.rs" 245 12 249 13
  let%span span13 = "../bdd.rs" 215 12 222 13
  let%span span14 = "../bdd.rs" 164 12 168 13
  let%span span15 = "../bdd.rs" 180 20 180 37
  let%span span16 = "../bdd.rs" 315 12 315 47
  let%span span17 = "../bdd.rs" 322 12 331 13
  let%span span18 = "../bdd.rs" 268 12 292 19
  let%span span19 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span20 = "../bdd.rs" 227 14 227 25
  let%span span21 = "../bdd.rs" 230 12 238 13
  let%span span22 = "../bdd.rs" 301 8 308 9
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  let%span span24 = "../bdd.rs" 190 20 190 26
  let%span span25 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span span26 = "../bdd.rs" 58 30 58 33
  let%span span27 = "../bdd.rs" 58 38 58 41
  let%span span28 = "../bdd.rs" 56 8 56 128
  let%span span29 = "../bdd.rs" 491 23 491 27
  let%span span30 = "../bdd.rs" 487 14 487 26
  let%span span31 = "../bdd.rs" 488 14 488 42
  let%span span32 = "../bdd.rs" 489 4 489 45
  let%span span33 = "../bdd.rs" 490 14 490 46
  let%span span34 = "../bdd.rs" 465 15 465 40
  let%span span35 = "../bdd.rs" 466 15 466 40
  let%span span36 = "../bdd.rs" 467 15 467 63
  let%span span37 = "../bdd.rs" 472 17 472 21
  let%span span38 = "../bdd.rs" 468 14 468 26
  let%span span39 = "../bdd.rs" 469 14 469 42
  let%span span40 = "../bdd.rs" 470 4 470 106
  let%span span41 = "../bdd.rs" 471 14 471 37
  let%span span42 = "../../../../creusot-contracts/src/logic/ord.rs" 140 16 146 17
  let%span span43 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span span44 = "../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span span45 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span46 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span47 = "../bdd.rs" 67 37 67 40
  let%span span48 = "../bdd.rs" 62 18 65 9
  let%span span49 = "../bdd.rs" 67 52 67 65
  
  use T_bdd__Bdd as Bdd'0
  
  predicate inv'5 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'5 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'5 x] . inv'5 x = true
  
  predicate inv'4 (_1 : (Bdd'0.t_Bdd, Bdd'0.t_Bdd))
  
  axiom inv'4 [@rewrite] : forall x : (Bdd'0.t_Bdd, Bdd'0.t_Bdd) [inv'4 x] . inv'4 x = true
  
  use prelude.prelude.Int
  
  function eq_cmp'0 (_1 : int) (_2 : int) : ()
  
  function antisym2'0 (_1 : int) (_2 : int) : ()
  
  function antisym1'0 (_1 : int) (_2 : int) : ()
  
  use T_core__cmp__Ordering as Ordering'0
  
  function trans'0 (_1 : int) (_2 : int) (_3 : int) (_4 : Ordering'0.t_Ordering) : ()
  
  function refl'0 (_1 : int) : ()
  
  function cmp_gt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_ge_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_lt_log'0 (_1 : int) (_2 : int) : ()
  
  function cmp_le_log'0 (_1 : int) (_2 : int) : ()
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (Bdd'0.t_Bdd))
  
  axiom inv'3 [@rewrite] : forall x : Option'0.t_Option (Bdd'0.t_Bdd) [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : (Bdd'0.t_Bdd, Bdd'0.t_Bdd)) =
    [%#span9] inv'4 self
  
  predicate inv'2 (_1 : (Bdd'0.t_Bdd, Bdd'0.t_Bdd))
  
  axiom inv'2 [@rewrite] : forall x : (Bdd'0.t_Bdd, Bdd'0.t_Bdd) [inv'2 x] . inv'2 x = true
  
  use prelude.prelude.UInt64
  
  use map.Map
  
  use T_bdd__hashmap__MyHashMap as MyHashMap'0
  
  use T_bdd__NodeLog as NodeLog'0
  
  use T_bdd__Node as Node'0
  
  use map.Map
  
  function shallow_model'1 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as T_bdd__Context
  
  use map.Map
  
  function shallow_model'7 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map uint64 (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  function shallow_model'5 (self : uint64) : int =
    [%#span10] UInt64.to_int self
  
  constant v_MAX'0 : uint64 = [%#span11] (18446744073709551615 : uint64)
  
  function leastvar'0 [#"../bdd.rs" 243 4 243 28] (self : Bdd'0.t_Bdd) : int =
    [%#span12] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> UInt64.to_int (v_MAX'0 : uint64) + 1
      | Bdd'0.C_Bdd (Node'0.C_If v _ _) _ -> shallow_model'5 v
      end
  
  use map.Map
  
  function interp'0 [#"../bdd.rs" 213 4 213 53] (self : Bdd'0.t_Bdd) (vars : Map.map uint64 bool) : bool =
    [%#span13] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> true
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> false
      | Bdd'0.C_Bdd (Node'0.C_If v childt childf) _ -> if Map.get vars v then
        interp'0 childt vars
      else
        interp'0 childf vars
      
      end
  
  use map.Map
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  function deep_model'4 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span14] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function shallow_model'6 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span15] deep_model'4 self
  
  function shallow_model'4 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span10] shallow_model'6 self
  
  function shallow_model'3 [#"../bdd.rs" 50 8 50 54] (self : MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) : Map.map (NodeLog'0.t_NodeLog) (Option'0.t_Option (Bdd'0.t_Bdd))
    
  
  use T_bdd__Context as Context'0
  
  predicate is_valid_bdd'0 [#"../bdd.rs" 313 4 313 53] (self : Context'0.t_Context) (b : Bdd'0.t_Bdd) =
    [%#span16] Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) (shallow_model'4 (T_bdd__Bdd.t_Bdd__0 b))
    = Option'0.C_Some b
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  predicate is_valid_node'0 [#"../bdd.rs" 320 4 320 51] (self : Context'0.t_Context) (n : Node'0.t_Node) =
    [%#span17] match n with
      | Node'0.C_True -> true
      | Node'0.C_False -> true
      | Node'0.C_If v childt childf -> T_bdd__Bdd.t_Bdd__0 childt <> T_bdd__Bdd.t_Bdd__0 childf
      /\ is_valid_bdd'0 self childt
      /\ is_valid_bdd'0 self childf /\ UInt64.to_int v < leastvar'0 childt /\ UInt64.to_int v < leastvar'0 childf
      end
  
  predicate invariant'1 [#"../bdd.rs" 266 4 266 30] (self : Context'0.t_Context) =
    [%#span18] (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self)) n with
      | Option'0.C_Some b -> shallow_model'4 (T_bdd__Bdd.t_Bdd__0 b) = n
      /\ is_valid_node'0 self (T_bdd__Bdd.t_Bdd__0 b)
      /\ T_bdd__Bdd.t_Bdd__1 b < T_bdd__Context.t_Context__cnt self
      /\ Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (T_bdd__Bdd.t_Bdd__1 b)
      = T_bdd__Bdd.t_Bdd__0 b
      | Option'0.C_None -> true
      end)
    /\ (forall bm : uint64 . match Map.get (shallow_model'7 (T_bdd__Context.t_Context__not_memo self)) bm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) bm) bm in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (not interp'0 b v)) /\ leastvar'0 b <= leastvar'0 n
      end)
    /\ (forall abm : (uint64, uint64) . match Map.get (shallow_model'1 (T_bdd__Context.t_Context__and_memo self)) abm with
      | Option'0.C_None -> true
      | Option'0.C_Some n -> let a = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (a, _) = abm in a)) (let (a, _) = abm in a) in let b = Bdd'0.C_Bdd (Map.get (Snapshot.inner (T_bdd__Context.t_Context__hashcons_ghost self)) (let (_, a) = abm in a)) (let (_, a) = abm in a) in is_valid_bdd'0 self n
      /\ is_valid_bdd'0 self a
      /\ is_valid_bdd'0 self b
      /\ (forall v : Map.map uint64 bool . interp'0 n v = (interp'0 a v /\ interp'0 b v))
      /\ (leastvar'0 a <= leastvar'0 n \/ leastvar'0 b <= leastvar'0 n)
      end)
  
  predicate inv'1 (_1 : Context'0.t_Context)
  
  axiom inv'1 [@rewrite] : forall x : Context'0.t_Context [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Context'0.C_Context alloc hashcons hashcons_ghost not_memo and_memo cnt -> true
    end)
  
  predicate invariant'0 (self : borrowed (Context'0.t_Context)) =
    [%#span19] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'0 (_1 : borrowed (Context'0.t_Context))
  
  axiom inv'0 [@rewrite] : forall x : borrowed (Context'0.t_Context) [inv'0 x] . inv'0 x = invariant'0 x
  
  function size'0 [#"../bdd.rs" 228 4 228 24] (self : Bdd'0.t_Bdd) : int =
    [%#span21] match self with
      | Bdd'0.C_Bdd (Node'0.C_True) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_False) _ -> 0
      | Bdd'0.C_Bdd (Node'0.C_If _ childt childf) _ -> let ht = size'0 childt in let hf = size'0 childf in 1 + ht + hf
      end
  
  axiom size'0_spec : forall self : Bdd'0.t_Bdd . [%#span20] size'0 self >= 0
  
  predicate grows'0 [#"../bdd.rs" 300 4 300 35] (self : borrowed (Context'0.t_Context)) =
    [%#span22] UInt64.to_int (T_bdd__Context.t_Context__cnt self.current)
    <= UInt64.to_int (T_bdd__Context.t_Context__cnt self.final)
    /\ (forall n : NodeLog'0.t_NodeLog . match Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.current)) n with
      | Option'0.C_Some b -> Map.get (shallow_model'3 (T_bdd__Context.t_Context__hashcons self.final)) n
      = Option'0.C_Some b
      | Option'0.C_None -> true
      end)
  
  use prelude.prelude.Intrinsic
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span23] shallow_model'1 self.current
  
  function deep_model'3 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span24] T_bdd__Bdd.t_Bdd__1 self
  
  function deep_model'2 (self : (Bdd'0.t_Bdd, Bdd'0.t_Bdd)) : (uint64, uint64) =
    [%#span25] (deep_model'3 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) (key:(Bdd'0.t_Bdd, Bdd'0.t_Bdd)) (val':Bdd'0.t_Bdd) (return'  (ret:()))= {[@expl:precondition] [%#span27] inv'5 val'}
    {[@expl:precondition] [%#span26] inv'4 key}
    any
    [ return' (result:())-> {[%#span28] forall i : (uint64, uint64) . Map.get (shallow_model'1 self.final) i
      = (if i = deep_model'2 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      (! return' {result}) ]
    
  
  let rec false_'0 (self:borrowed (Context'0.t_Context)) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span29] inv'0 self}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span33] UInt64.to_int (v_MAX'0 : uint64) + 1 = leastvar'0 result}
      {[%#span32] forall v : Map.map uint64 bool . not interp'0 result v}
      {[%#span31] is_valid_bdd'0 self.final result}
      {[%#span30] grows'0 self}
      (! return' {result}) ]
    
  
  let rec node'0 (self:borrowed (Context'0.t_Context)) (x:uint64) (childt:Bdd'0.t_Bdd) (childf:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[@expl:precondition] [%#span37] inv'0 self}
    {[@expl:precondition] [%#span36] UInt64.to_int x < leastvar'0 childt /\ UInt64.to_int x < leastvar'0 childf}
    {[@expl:precondition] [%#span35] is_valid_bdd'0 self.current childf}
    {[@expl:precondition] [%#span34] is_valid_bdd'0 self.current childt}
    any
    [ return' (result:Bdd'0.t_Bdd)-> {[%#span41] UInt64.to_int x <= leastvar'0 result}
      {[%#span40] forall v : Map.map uint64 bool . interp'0 result v
      = (if Map.get v x then interp'0 childt v else interp'0 childf v)}
      {[%#span39] is_valid_bdd'0 self.final result}
      {[%#span38] grows'0 self}
      (! return' {result}) ]
    
  
  function cmp_log'0 (self : int) (o : int) : Ordering'0.t_Ordering =
    [%#span42] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  function deep_model'1 (self : uint64) : int =
    [%#span43] UInt64.to_int self
  
  let rec cmp'0 (self:uint64) (other:uint64) (return'  (ret:Ordering'0.t_Ordering))= any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#span44] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (Context'0.t_Context)) =
    [%#span45] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Context'0.t_Context)) =
    resolve'1 _1
  
  function deep_model'0 (self : (Bdd'0.t_Bdd, Bdd'0.t_Bdd)) : (uint64, uint64) =
    [%#span46] deep_model'2 self
  
  function shallow_model'0 (self : MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) : Map.map (uint64, uint64) (Option'0.t_Option (Bdd'0.t_Bdd))
    
   =
    [%#span10] shallow_model'1 self
  
  let rec get'0 (self:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (key:(Bdd'0.t_Bdd, Bdd'0.t_Bdd)) (return'  (ret:Option'0.t_Option (Bdd'0.t_Bdd)))= {[@expl:precondition] [%#span47] inv'2 key}
    any
    [ return' (result:Option'0.t_Option (Bdd'0.t_Bdd))-> {[%#span49] inv'3 result}
      {[%#span48] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use T_bdd__bumpalo__Bump as Bump'0
  
  meta "compute_max_steps" 1000000
  
  let rec and (self:borrowed (Context'0.t_Context)) (a:Bdd'0.t_Bdd) (b:Bdd'0.t_Bdd) (return'  (ret:Bdd'0.t_Bdd))= {[%#sbdd3] inv'0 self}
    {[%#sbdd2] is_valid_bdd'0 self.current b}
    {[%#sbdd1] is_valid_bdd'0 self.current a}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- (a, b) ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            get'0 {rand_memo'0} {_15} (fun (_ret':Option'0.t_Option (Bdd'0.t_Bdd)) ->  [ &_12 <- _ret' ] s3))
      | s3 = bb1 ]
      
    | bb1 = any [ br0 -> {_12 = Option'0.C_None } (! bb4) | br1 (a:Bdd'0.t_Bdd)-> {_12 = Option'0.C_Some a} (! bb2) ] 
    | bb4 = s0
      [ s0 = Bdd'0.t_Bdd {a}
          (fun (r0'0:Node'0.t_Node) (r1'0:uint64) ->
            Bdd'0.t_Bdd {b} (fun (r0'1:Node'0.t_Node) (r1'1:uint64) ->  [ &_23 <- (r0'0, r0'1) ] s1))
      | s1 = any
        [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb5)
        | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb6)
        | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb5) ]
         ]
      
    | bb5 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb7)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb8)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb7) ]
      
    | bb7 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb9)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb9) ]
      
    | bb9 = any
      [ br0 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_False } (! bb13)
      | br1 -> {(let (_, r'0) = _23 in r'0) = Node'0.C_True } (! bb10)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (_, r'0) = _23 in r'0) = Node'0.C_If a b c} (! bb11) ]
      
    | bb11 = any
      [ br0 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_False } (! bb10)
      | br1 -> {(let (r'0, _) = _23 in r'0) = Node'0.C_True } (! bb10)
      | br2 (a:uint64) (b:Bdd'0.t_Bdd) (c:Bdd'0.t_Bdd)-> {(let (r'0, _) = _23 in r'0) = Node'0.C_If a b c} (! bb12) ]
      
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {[%#sbdd0] false} any ]
      
    | bb12 = s0
      [ s0 = Node'0.v_If {let (r'0, _) = _23 in r'0}
          (fun (rv'0:uint64) (rchildt'0:Bdd'0.t_Bdd) (rchildf'0:Bdd'0.t_Bdd) ->  [ &va <- rv'0 ] s1)
      | s1 = Node'0.v_If {let (r'1, _) = _23 in r'1}
          (fun (rv'1:uint64) (rchildt'1:Bdd'0.t_Bdd) (rchildf'1:Bdd'0.t_Bdd) ->  [ &childta <- rchildt'1 ] s2)
      | s2 = Node'0.v_If {let (r'2, _) = _23 in r'2}
          (fun (rv'2:uint64) (rchildt'2:Bdd'0.t_Bdd) (rchildf'2:Bdd'0.t_Bdd) ->  [ &childfa <- rchildf'2 ] s3)
      | s3 = Node'0.v_If {let (_, r'3) = _23 in r'3}
          (fun (rv'3:uint64) (rchildt'3:Bdd'0.t_Bdd) (rchildf'3:Bdd'0.t_Bdd) ->  [ &vb <- rv'3 ] s4)
      | s4 = Node'0.v_If {let (_, r'4) = _23 in r'4}
          (fun (rv'4:uint64) (rchildt'4:Bdd'0.t_Bdd) (rchildf'4:Bdd'0.t_Bdd) ->  [ &childtb <- rchildt'4 ] s5)
      | s5 = Node'0.v_If {let (_, r'5) = _23 in r'5}
          (fun (rv'5:uint64) (rchildt'5:Bdd'0.t_Bdd) (rchildf'5:Bdd'0.t_Bdd) ->  [ &childfb <- rchildf'5 ] s6)
      | s6 =  [ &_45 <- vb ] s7
      | s7 = cmp'0 {va} {_45} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_42 <- _ret' ] s8)
      | s8 = bb18 ]
      
    | bb18 = any
      [ br0 -> {_42 = Ordering'0.C_Less } (! bb21)
      | br1 -> {_42 = Ordering'0.C_Equal } (! bb22)
      | br2 -> {_42 = Ordering'0.C_Greater } (! bb20) ]
      
    | bb20 = bb23
    | bb23 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_49 <- _ret' ] 
             [ &self <- { self with current = _49.final ; } ] 
            s2)
      | s2 = -{inv'1 _49.final}- s3
      | s3 = and {_49} {a} {childtb} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_48 <- _ret' ] s4)
      | s4 = bb24 ]
      
    | bb24 = s0
      [ s0 =  [ &childt <- _48 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_53 <- _ret' ] 
             [ &self <- { self with current = _53.final ; } ] 
            s2)
      | s2 = -{inv'1 _53.final}- s3
      | s3 = and {_53} {a} {childfb} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_52 <- _ret' ] s4)
      | s4 = bb25 ]
      
    | bb25 = s0 [ s0 =  [ &childf <- _52 ] s1 | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_67 <- _ret' ] 
             [ &self <- { self with current = _67.final ; } ] 
            s2)
      | s2 = -{inv'1 _67.final}- s3
      | s3 = and {_67} {childta} {childtb} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_66 <- _ret' ] s4)
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_71 <- _ret' ] 
             [ &self <- { self with current = _71.final ; } ] 
            s2)
      | s2 = -{inv'1 _71.final}- s3
      | s3 = and {_71} {childfa} {childfb} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_70 <- _ret' ] s4)
      | s4 = bb30 ]
      
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] s1 | s1 = bb31 ] 
    | bb21 = bb26
    | bb26 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_58 <- _ret' ] 
             [ &self <- { self with current = _58.final ; } ] 
            s2)
      | s2 = -{inv'1 _58.final}- s3
      | s3 = and {_58} {childta} {b} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_57 <- _ret' ] s4)
      | s4 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] s1
      | s1 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_62 <- _ret' ] 
             [ &self <- { self with current = _62.final ; } ] 
            s2)
      | s2 = -{inv'1 _62.final}- s3
      | s3 = and {_62} {childfa} {b} (fun (_ret':Bdd'0.t_Bdd) ->  [ &_61 <- _ret' ] s4)
      | s4 = bb28 ]
      
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] s1 | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_74 <- _ret' ] 
             [ &self <- { self with current = _74.final ; } ] 
            s1)
      | s1 = -{inv'1 _74.final}- s2
      | s2 = node'0 {_74} {v} {childt} {childf} (fun (_ret':Bdd'0.t_Bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb32 ]
      
    | bb32 = bb33
    | bb13 = bb16
    | bb16 = s0
      [ s0 = Borrow.borrow_mut <Context'0.t_Context> {self.current}
          (fun (_ret':borrowed (Context'0.t_Context)) ->
             [ &_31 <- _ret' ] 
             [ &self <- { self with current = _31.final ; } ] 
            s1)
      | s1 = -{inv'1 _31.final}- s2
      | s2 = false_'0 {_31} (fun (_ret':Bdd'0.t_Bdd) ->  [ &r1 <- _ret' ] s3)
      | s3 = bb17 ]
      
    | bb17 = bb33
    | bb8 = bb15
    | bb15 = s0 [ s0 =  [ &r1 <- a ] s1 | s1 = bb33 ] 
    | bb6 = bb14
    | bb14 = s0 [ s0 =  [ &r1 <- b ] s1 | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = Context'0.t_Context {self.current}
          (fun (ralloc'0:Bump'0.t_Bump) (rhashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (rhashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (rnot_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rand_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (rcnt'0:uint64) ->
            Borrow.borrow_final
              <MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)>
              {rand_memo'0}
              {Borrow.inherit_id (Borrow.get_id self) 5}
              (fun (_ret':borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd))) ->
                 [ &_79 <- _ret' ] 
                Context'0.t_Context {self.current}
                  (fun (l_alloc'0:Bump'0.t_Bump) (l_hashcons'0:MyHashMap'0.t_MyHashMap (Node'0.t_Node) (Bdd'0.t_Bdd)) (l_hashcons_ghost'0:Snapshot.snap_ty (Map.map uint64 (Node'0.t_Node))) (l_not_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_and_memo'0:MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) (l_cnt'0:uint64) ->
                    
                    [ &self <- { self with current = Context'0.C_Context l_alloc'0 l_hashcons'0 l_hashcons_ghost'0 l_not_memo'0 _79.final l_cnt'0 ; } ]
                    
                    s1)))
      | s1 =  [ &_80 <- (a, b) ] s2
      | s2 = add'0 {_79} {_80} {r1} (fun (_ret':()) ->  [ &_78 <- _ret' ] s3)
      | s3 = bb34 ]
      
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- r1 ] s3 | s3 = bb35 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Bdd'0.t_Bdd> {_12} (fun (r0'0:Bdd'0.t_Bdd) ->  [ &r <- r0'0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = bb35 ]
      
    | bb35 = return' {_0} ]
    )
    [ & _0 : Bdd'0.t_Bdd = any_l ()
    | & self : borrowed (Context'0.t_Context) = self
    | & a : Bdd'0.t_Bdd = a
    | & b : Bdd'0.t_Bdd = b
    | & _12 : Option'0.t_Option (Bdd'0.t_Bdd) = any_l ()
    | & _15 : (Bdd'0.t_Bdd, Bdd'0.t_Bdd) = any_l ()
    | & _16 : (Bdd'0.t_Bdd, Bdd'0.t_Bdd) = any_l ()
    | & r : Bdd'0.t_Bdd = any_l ()
    | & r1 : Bdd'0.t_Bdd = any_l ()
    | & _23 : (Node'0.t_Node, Node'0.t_Node) = any_l ()
    | & _31 : borrowed (Context'0.t_Context) = any_l ()
    | & va : uint64 = any_l ()
    | & childta : Bdd'0.t_Bdd = any_l ()
    | & childfa : Bdd'0.t_Bdd = any_l ()
    | & vb : uint64 = any_l ()
    | & childtb : Bdd'0.t_Bdd = any_l ()
    | & childfb : Bdd'0.t_Bdd = any_l ()
    | & v : uint64 = any_l ()
    | & childt : Bdd'0.t_Bdd = any_l ()
    | & childf : Bdd'0.t_Bdd = any_l ()
    | & _42 : Ordering'0.t_Ordering = any_l ()
    | & _45 : uint64 = any_l ()
    | & _48 : Bdd'0.t_Bdd = any_l ()
    | & _49 : borrowed (Context'0.t_Context) = any_l ()
    | & _52 : Bdd'0.t_Bdd = any_l ()
    | & _53 : borrowed (Context'0.t_Context) = any_l ()
    | & _57 : Bdd'0.t_Bdd = any_l ()
    | & _58 : borrowed (Context'0.t_Context) = any_l ()
    | & _61 : Bdd'0.t_Bdd = any_l ()
    | & _62 : borrowed (Context'0.t_Context) = any_l ()
    | & _66 : Bdd'0.t_Bdd = any_l ()
    | & _67 : borrowed (Context'0.t_Context) = any_l ()
    | & _70 : Bdd'0.t_Bdd = any_l ()
    | & _71 : borrowed (Context'0.t_Context) = any_l ()
    | & _74 : borrowed (Context'0.t_Context) = any_l ()
    | & _78 : () = any_l ()
    | & _79 : borrowed (MyHashMap'0.t_MyHashMap (Bdd'0.t_Bdd, Bdd'0.t_Bdd) (Bdd'0.t_Bdd)) = any_l ()
    | & _80 : (Bdd'0.t_Bdd, Bdd'0.t_Bdd) = any_l () ]
    
    [ return' (result:Bdd'0.t_Bdd)-> {[@expl:postcondition] [%#sbdd7] leastvar'0 a <= leastvar'0 result
      \/ leastvar'0 b <= leastvar'0 result}
      {[@expl:postcondition] [%#sbdd6] forall v : Map.map uint64 bool . interp'0 result v
      = (interp'0 a v /\ interp'0 b v)}
      {[@expl:postcondition] [%#sbdd5] is_valid_bdd'0 self.final result}
      {[@expl:postcondition] [%#sbdd4] grows'0 self}
      (! return' {result}) ]
    
end
module M_bdd__hashmap__qyi3654902689778462160 [#"../bdd.rs" 44 4 44 53] (* <hashmap::MyHashMap<K, V> as creusot_contracts::ShallowModel> *)
  type k
  
  type v
end
module M_bdd__qyi7772446835577928499 [#"../bdd.rs" 174 0 174 42] (* <Node<'arena> as creusot_contracts::ShallowModel> *)
  
end
module M_bdd__qyi3703834414764219159 [#"../bdd.rs" 194 0 194 41] (* <Bdd<'arena> as creusot_contracts::ShallowModel> *)
  
end
module M_bdd__hashmap__qyi11648407051195780326 [#"../bdd.rs" 78 4 78 42] (* <(U, V) as hashmap::Hash> *)
  type u
  
  type v
  
  let%span sbdd0 = "../bdd.rs" 80 8 80 29
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "" 0 0 0 0
  let%span span3 = "../bdd.rs" 87 24 87 84
  let%span span4 = "../../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  predicate invariant'2 (self : v)
  
  predicate inv'3 (_1 : v)
  
  axiom inv'3 : forall x : v [inv'3 x] . inv'3 x  -> invariant'2 x
  
  predicate invariant'1 (self : u)
  
  predicate inv'2 (_1 : u)
  
  axiom inv'2 : forall x : u [inv'2 x] . inv'2 x  -> invariant'1 x
  
  predicate inv'1 (_1 : (u, v))
  
  axiom inv'1 [@rewrite] : forall x : (u, v) [inv'1 x] . inv'1 x = (let (a, b) = x in inv'2 a /\ inv'3 b)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : (u, v)) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : (u, v))
  
  axiom inv'0 [@rewrite] : forall x : (u, v) [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span2] (18446744073709551615 : uint64)
  
  type t_DeepModelTy'1
  
  function hash_log'2 [#"../bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'1) : int
  
  type t_DeepModelTy'0
  
  function hash_log'1 [#"../bdd.rs" 38 8 38 49] (_1 : t_DeepModelTy'0) : int
  
  function hash_log'0 [#"../bdd.rs" 86 8 86 48] (x : (t_DeepModelTy'0, t_DeepModelTy'1)) : int =
    [%#span3] mod (hash_log'1 (let (a, _) = x in a)
    + hash_log'2 (let (_, a) = x in a) * 17) (UInt64.to_int (v_MAX'0 : uint64) + 1)
  
  function deep_model'3 (self : v) : t_DeepModelTy'1
  
  function deep_model'2 (self : u) : t_DeepModelTy'0
  
  function deep_model'1 (self : (u, v)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#span4] (deep_model'2 (let (a, _) = self in a), deep_model'3 (let (_, a) = self in a))
  
  function deep_model'0 (self : (u, v)) : (t_DeepModelTy'0, t_DeepModelTy'1) =
    [%#span5] deep_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : (u, v) . inv'0 self
   -> inv'0 self
  /\ (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi699402059438633899 [#"../bdd.rs" 118 0 118 43] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "../bdd.rs" 120 4 120 25
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "../bdd.rs" 164 12 168 13
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span4 = "" 0 0 0 0
  let%span span5 = "../bdd.rs" 134 12 139 13
  let%span span6 = "../bdd.rs" 180 20 180 37
  let%span span7 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use T_bdd__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node)
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_Node) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Node'0.t_Node)
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node [inv'0 x] . inv'0 x = true
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use T_bdd__NodeLog as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span2] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function deep_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint64 = [%#span4] (18446744073709551615 : uint64)
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 132 4 132 44] (x : NodeLog'0.t_NodeLog) : int =
    [%#span5] match x with
      | NodeLog'0.C_False -> 1
      | NodeLog'0.C_True -> 2
      | NodeLog'0.C_If v childt childf -> mod (UInt64.to_int v + UInt64.to_int childt * 5
      + UInt64.to_int childf * 7) (UInt64.to_int (v_MAX'0 : uint64) + 1)
      end
  
  function shallow_model'1 [#"../bdd.rs" 179 4 179 50] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span6] deep_model'1 self
  
  function shallow_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span7] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Node'0.t_Node . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi14323183011761258016 [#"../bdd.rs" 144 0 144 42] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd0 = "../bdd.rs" 146 4 146 25
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "../bdd.rs" 190 20 190 26
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span4 = "../bdd.rs" 153 8 153 24
  let%span span5 = "../bdd.rs" 200 20 200 37
  let%span span6 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use T_bdd__Bdd as Bdd'0
  
  predicate inv'1 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'1 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_Bdd) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'0 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'0 x] . inv'0 x = true
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span2] T_bdd__Bdd.t_Bdd__1 self
  
  function deep_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  function hash_log'0 [#"../bdd.rs" 152 4 152 44] (x : uint64) : int =
    [%#span4] UInt64.to_int x
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span5] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span6] shallow_model'1 self
  
  goal hash_refn : [%#sbdd0] forall self : Bdd'0.t_Bdd . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (shallow_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module M_bdd__qyi2024536649982164874 [#"../bdd.rs" 94 9 94 11] (* <Node<'arena> as std::cmp::Eq> *)
  let%span sbdd0 = "../bdd.rs" 94 9 94 11
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module M_bdd__qyi1284786238026687571 [#"../bdd.rs" 108 15 108 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  let%span sbdd0 = "../bdd.rs" 108 15 108 17
  
  goal assert_receiver_is_total_eq_refn : [%#sbdd0] true
end
module M_bdd__qyi4854841669736991510 [#"../bdd.rs" 94 13 94 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "../bdd.rs" 94 13 94 22
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "../bdd.rs" 164 12 168 13
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use T_bdd__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node)
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_Node) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Node'0.t_Node)
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node [inv'0 x] . inv'0 x = true
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use T_bdd__NodeLog as NodeLog'0
  
  function deep_model'1 [#"../bdd.rs" 162 4 162 44] (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span2] match self with
      | Node'0.C_False -> NodeLog'0.C_False
      | Node'0.C_True -> NodeLog'0.C_True
      | Node'0.C_If v childt childf -> NodeLog'0.C_If v (T_bdd__Bdd.t_Bdd__1 childt) (T_bdd__Bdd.t_Bdd__1 childf)
      end
  
  function deep_model'0 (self : Node'0.t_Node) : NodeLog'0.t_NodeLog =
    [%#span3] deep_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Node'0.t_Node . forall other : Node'0.t_Node . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_bdd__qyi2581120635339165136 [#"../bdd.rs" 204 0 204 38] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd0 = "../bdd.rs" 206 4 206 34
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "../bdd.rs" 190 20 190 26
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span4 = "../bdd.rs" 200 20 200 37
  let%span span5 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  use T_bdd__Bdd as Bdd'0
  
  predicate inv'1 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'1 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_Bdd) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'0 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'0 x] . inv'0 x = true
  
  use T_bdd__Bdd as T_bdd__Bdd
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Int
  
  function deep_model'1 [#"../bdd.rs" 189 4 189 44] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span2] T_bdd__Bdd.t_Bdd__1 self
  
  function deep_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span3] deep_model'1 self
  
  function shallow_model'1 [#"../bdd.rs" 199 4 199 50] (self : Bdd'0.t_Bdd) : uint64 =
    [%#span4] deep_model'1 self
  
  function shallow_model'0 (self : Bdd'0.t_Bdd) : uint64 =
    [%#span5] shallow_model'1 self
  
  goal eq_refn : [%#sbdd0] forall self : Bdd'0.t_Bdd . forall other : Bdd'0.t_Bdd . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (shallow_model'0 self = shallow_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_bdd__qyi17981791245757283426 [#"../bdd.rs" 94 24 94 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "../bdd.rs" 94 24 94 29
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use T_bdd__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node)
  
  axiom inv'1 [@rewrite] : forall x : Node'0.t_Node [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_Node) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Node'0.t_Node)
  
  axiom inv'0 [@rewrite] : forall x : Node'0.t_Node [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#sbdd0] forall self : Node'0.t_Node . inv'0 self
   -> (forall result : Node'0.t_Node . result = self  -> inv'1 result /\ result = self)
end
module M_bdd__qyi2820858787824331484 [#"../bdd.rs" 111 0 111 34] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd0 = "../bdd.rs" 113 4 113 27
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use T_bdd__Bdd as Bdd'0
  
  predicate inv'1 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'1 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Bdd'0.t_Bdd) =
    [%#span1] inv'1 self
  
  predicate inv'0 (_1 : Bdd'0.t_Bdd)
  
  axiom inv'0 [@rewrite] : forall x : Bdd'0.t_Bdd [inv'0 x] . inv'0 x = true
  
  goal clone'_refn : [%#sbdd0] forall self : Bdd'0.t_Bdd . inv'0 self
   -> (forall result : Bdd'0.t_Bdd . result = self  -> inv'1 result /\ result = self)
end
module M_bdd__qyi14756181302899806199 [#"../bdd.rs" 94 31 94 35] (* <Node<'arena> as std::marker::Copy> *)
  
end
module M_bdd__qyi5472335391960264585 [#"../bdd.rs" 108 9 108 13] (* <Bdd<'arena> as std::marker::Copy> *)
  
end
module M_bdd__qyi8139533306702407225 [#"../bdd.rs" 157 0 157 39] (* <Node<'arena> as creusot_contracts::DeepModel> *)
  
end
module M_bdd__qyi16182607467161522489 [#"../bdd.rs" 184 0 184 38] (* <Bdd<'arena> as creusot_contracts::DeepModel> *)
  
end
module M_bdd__qyi1768470595944209046 [#"../bdd.rs" 263 0 263 42] (* <Context<'arena> as creusot_contracts::Invariant> *)
  
end
