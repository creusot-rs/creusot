module T_core__ptr__non_null__NonNull
  use prelude.prelude.Opaque
  
  type t_NonNull 't =
    | C_NonNull opaque_ptr
  
  let rec t_NonNull < 't > (input:t_NonNull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer}) ]
    
end
module T_core__marker__PhantomData
  type t_PhantomData 't =
    | C_PhantomData
  
  let rec t_PhantomData < 't > (input:t_PhantomData 't) (ret  )= any [ good -> {C_PhantomData  = input} (! ret) ] 
end
module T_core__slice__iter__Iter
  use prelude.prelude.Borrow
  
  use T_core__marker__PhantomData as PhantomData'0
  
  use prelude.prelude.Opaque
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Iter 't =
    | C_Iter (NonNull'0.t_NonNull 't) opaque_ptr (PhantomData'0.t_PhantomData 't)
  
  let rec t_Iter < 't > (input:t_Iter 't) (ret  (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData 't))= any
    [ good (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Iter ptr end_or_len _marker
      = input}
      (! ret {ptr} {end_or_len} {_marker}) ]
    
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_03_std_iterators__slice_iter [#"03_std_iterators.rs" 6 0 6 42]
  type t
  
  let%span s03_std_iterators0 = "03_std_iterators.rs" 7 16 7 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 8 4 8 38
  let%span s03_std_iterators2 = "03_std_iterators.rs" 8 4 8 38
  let%span s03_std_iterators3 = "03_std_iterators.rs" 8 4 8 38
  let%span s03_std_iterators4 = "03_std_iterators.rs" 8 16 8 36
  let%span s03_std_iterators5 = "03_std_iterators.rs" 8 4 8 38
  let%span s03_std_iterators6 = "03_std_iterators.rs" 10 13 10 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 4 11 4 30
  let%span s03_std_iterators8 = "03_std_iterators.rs" 6 21 6 26
  let%span s03_std_iterators9 = "03_std_iterators.rs" 5 10 5 33
  let%span sslice10 = "../../../../creusot-contracts/src/std/slice.rs" 249 0 358 1
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span sslice12 = "../../../../creusot-contracts/src/std/slice.rs" 410 12 410 66
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span smodel14 = "../../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span siter15 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter16 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 45
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 416 4 416 10
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 425 15 425 32
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 426 15 426 32
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 427 14 427 42
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 423 4 423 10
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 101 4 101 82
  let%span sslice25 = "../../../../creusot-contracts/src/std/slice.rs" 403 20 403 61
  let%span sresolve26 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sslice27 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice28 = "../../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sseq29 = "../../../../creusot-contracts/src/logic/seq.rs" 198 8 198 97
  let%span sops30 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span smodel31 = "../../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sinvariant32 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  
  predicate inv'7 (_1 : t)
  
  predicate invariant'6 (self : t) =
    [%#sboxed33] inv'7 self
  
  predicate inv'9 (_1 : t)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t [inv'9 x] . inv'9 x = invariant'6 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'5 (self : Seq.seq t) =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t [inv'8 x] . inv'8 x = invariant'5 x
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function view'2 (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice28] view'2 self = Slice.id self)
  && ([%#sslice27] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'4 (self : slice t) =
    [%#sslice34] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : slice t)
  
  axiom inv_axiom'6 [@rewrite] : forall x : slice t [inv'6 x] . inv'6 x = invariant'4 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : t) =
    [%#sinvariant32] inv'7 self
  
  predicate inv'5 (_1 : t)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate invariant'1 (self : slice t) =
    [%#sinvariant32] inv'6 self
  
  predicate inv'2 (_1 : slice t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice t [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use T_core__slice__iter__Iter as Iter'0
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : slice t) (ix : int) : t =
    [%#sops30] Seq.get (view'2 self) ix
  
  use seq.Seq
  
  function view'0 (self : slice t) : Seq.seq t =
    [%#smodel14] view'2 self
  
  use seq.Seq
  
  function to_ref_seq'0 (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice24] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice23] Seq.length (to_ref_seq'0 self) = Seq.length (view'0 self))
  
  function view'1 (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t) =
    [%#sslice12] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : Iter'0.t_Iter t) (ab : Seq.seq t) (b : Iter'0.t_Iter t) (bc : Seq.seq t) (c : Iter'0.t_Iter t) : ()
    
   =
    [%#sslice22] ()
  
  axiom produces_trans'0_spec : forall a : Iter'0.t_Iter t, ab : Seq.seq t, b : Iter'0.t_Iter t, bc : Seq.seq t, c : Iter'0.t_Iter t . ([%#sslice19] produces'0 a ab b)
   -> ([%#sslice20] produces'0 b bc c)  -> ([%#sslice21] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : Iter'0.t_Iter t) : () =
    [%#sslice18] ()
  
  axiom produces_refl'0_spec : forall self : Iter'0.t_Iter t . [%#sslice17] produces'0 self (Seq.empty  : Seq.seq t) self
  
  predicate inv'1 (_1 : Iter'0.t_Iter t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Iter'0.t_Iter t [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq t) =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'0 (_1 : Seq.seq t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t [inv'0 x] . inv'0 x = invariant'0 x
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate resolve'1 (self : borrowed (Iter'0.t_Iter t)) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Iter'0.t_Iter t)) =
    resolve'1 _1
  
  use seq.Seq
  
  function view'3 (self : borrowed (Iter'0.t_Iter t)) : slice t =
    [%#smodel31] view'1 self.current
  
  predicate completed'0 (self : borrowed (Iter'0.t_Iter t)) =
    [%#sslice25] resolve'1 self /\ view'2 (view'3 self) = (Seq.empty  : Seq.seq t)
  
  let rec next'0 (self:borrowed (Iter'0.t_Iter t)) (return'  (ret:Option'0.t_Option t))= any
    [ return' (result:Option'0.t_Option t)-> {inv'3 result}
      {[%#siter13] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate into_iter_post'0 (self : Iter'0.t_Iter t) (res : Iter'0.t_Iter t) =
    [%#siter16] self = res
  
  predicate into_iter_pre'0 (self : Iter'0.t_Iter t) =
    [%#siter15] true
  
  let rec into_iter'0 (self:Iter'0.t_Iter t) (return'  (ret:Iter'0.t_Iter t))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#siter11] into_iter_pre'0 self}
    any
    [ return' (result:Iter'0.t_Iter t)-> {inv'1 result}
      {[%#siter11] into_iter_post'0 self result}
      (! return' {result}) ]
    
  
  let rec iter'0 (self:slice t) (return'  (ret:Iter'0.t_Iter t))= {[@expl:precondition] inv'2 self}
    any [ return' (result:Iter'0.t_Iter t)-> {[%#sslice10] view'1 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec slice_iter (slice:slice t) (return'  (ret:usize))= {[%#s03_std_iterators8] inv'2 slice}
    {[%#s03_std_iterators7] Seq.length (view'0 slice) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = iter'0 {slice} (fun (_ret':Iter'0.t_Iter t) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = into_iter'0 {_7} (fun (_ret':Iter'0.t_Iter t) ->  [ &iter <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] Snapshot.new iter ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators2] Snapshot.new (Seq.empty  : Seq.seq t) ] s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:loop invariant] [%#s03_std_iterators4] UIntSize.to_int i = Seq.length (Snapshot.inner produced)}
        {[@expl:loop invariant] [%#s03_std_iterators3] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = Borrow.borrow_mut <Iter'0.t_Iter t> {iter}
              (fun (_ret':borrowed (Iter'0.t_Iter t)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <Iter'0.t_Iter t> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (Iter'0.t_Iter t)) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':Option'0.t_Option t) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = Option'0.C_None } (! bb10) | br1 (a:t)-> {_18 = Option'0.C_Some a} (! bb9) ]  ]
          
        | bb9 = bb11
        | bb11 = s0
          [ s0 = Option'0.v_Some <t> {_18} (fun (r0'0:t) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators5] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb12 ]
          
        | bb12 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 = UIntSize.add {i} {[%#s03_std_iterators6] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s2)
          | s2 = bb5 ]
           ]
         ]
      
    | bb10 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & slice : slice t = slice
    | & i : usize = any_l ()
    | & iter : Iter'0.t_Iter t = any_l ()
    | & _7 : Iter'0.t_Iter t = any_l ()
    | & iter_old : Snapshot.snap_ty (Iter'0.t_Iter t) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t) = any_l ()
    | & _18 : Option'0.t_Option t = any_l ()
    | & _19 : borrowed (Iter'0.t_Iter t) = any_l ()
    | & _20 : borrowed (Iter'0.t_Iter t) = any_l ()
    | & __creusot_proc_iter_elem : t = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq t) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#s03_std_iterators9] UIntSize.to_int result
      = Seq.length (view'0 slice)}
      (! return' {result}) ]
    
end
module T_core__ptr__unique__Unique
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Unique 't =
    | C_Unique (NonNull'0.t_NonNull 't) (PhantomData'0.t_PhantomData 't)
  
  let rec t_Unique < 't > (input:t_Unique 't) (ret  (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't))= any
    [ good (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker}) ]
    
end
module T_alloc__raw_vec__Cap
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Cap  =
    | C_Cap usize
  
  let rec t_Cap (input:t_Cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0}) ]
    
end
module T_alloc__raw_vec__RawVec
  use T_alloc__raw_vec__Cap as Cap'0
  
  use T_core__ptr__unique__Unique as Unique'0
  
  type t_RawVec 't 'a =
    | C_RawVec (Unique'0.t_Unique 't) (Cap'0.t_Cap) 'a
  
  let rec t_RawVec < 't > < 'a > (input:t_RawVec 't 'a) (ret  (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc}) ]
    
end
module T_alloc__vec__Vec
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  type t_Vec 't 'a =
    | C_Vec (RawVec'0.t_RawVec 't 'a) usize
  
  let rec t_Vec < 't > < 'a > (input:t_Vec 't 'a) (ret  (buf:RawVec'0.t_RawVec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_RawVec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len}) ]
    
end
module T_alloc__alloc__Global
  type t_Global  =
    | C_Global
  
  let rec t_Global (input:t_Global) (ret  )= any [ good -> {C_Global  = input} (! ret) ] 
end
module M_03_std_iterators__vec_iter [#"03_std_iterators.rs" 17 0 17 41]
  type t
  
  let%span s03_std_iterators0 = "03_std_iterators.rs" 18 16 18 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 19 4 19 38
  let%span s03_std_iterators2 = "03_std_iterators.rs" 19 4 19 38
  let%span s03_std_iterators3 = "03_std_iterators.rs" 19 4 19 38
  let%span s03_std_iterators4 = "03_std_iterators.rs" 19 16 19 36
  let%span s03_std_iterators5 = "03_std_iterators.rs" 19 4 19 38
  let%span s03_std_iterators6 = "03_std_iterators.rs" 21 13 21 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 15 11 15 28
  let%span s03_std_iterators8 = "03_std_iterators.rs" 17 19 17 22
  let%span s03_std_iterators9 = "03_std_iterators.rs" 16 10 16 31
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span sslice11 = "../../../../creusot-contracts/src/std/slice.rs" 410 12 410 66
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span smodel13 = "../../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span svec14 = "../../../../creusot-contracts/src/std/vec.rs" 208 20 208 24
  let%span svec15 = "../../../../creusot-contracts/src/std/vec.rs" 214 20 214 34
  let%span sslice16 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 45
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 416 4 416 10
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 425 15 425 32
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 426 15 426 32
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 427 14 427 42
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 423 4 423 10
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 101 4 101 82
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 403 20 403 61
  let%span sresolve25 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span svec26 = "../../../../creusot-contracts/src/std/vec.rs" 19 14 19 41
  let%span sseq27 = "../../../../creusot-contracts/src/logic/seq.rs" 198 8 198 97
  let%span sops28 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span smodel29 = "../../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sinvariant32 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span svec34 = "../../../../creusot-contracts/src/std/vec.rs" 68 20 68 41
  
  predicate inv'7 (_1 : t)
  
  predicate invariant'6 (self : t) =
    [%#sboxed33] inv'7 self
  
  predicate inv'9 (_1 : t)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t [inv'9 x] . inv'9 x = invariant'6 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'5 (self : Seq.seq t) =
    [%#sseq27] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t [inv'8 x] . inv'8 x = invariant'5 x
  
  use T_alloc__alloc__Global as Global'0
  
  use T_alloc__vec__Vec as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function view'2 (self : Vec'0.t_Vec t (Global'0.t_Global)) : Seq.seq t
  
  axiom view'2_spec : forall self : Vec'0.t_Vec t (Global'0.t_Global) . [%#svec26] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'4 (self : Vec'0.t_Vec t (Global'0.t_Global)) =
    [%#svec34] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : Vec'0.t_Vec t (Global'0.t_Global))
  
  axiom inv_axiom'6 [@rewrite] : forall x : Vec'0.t_Vec t (Global'0.t_Global) [inv'6 x] . inv'6 x = invariant'4 x
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : t) =
    [%#sinvariant32] inv'7 self
  
  predicate inv'5 (_1 : t)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t [inv'4 x] . inv'4 x = invariant'2 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option t)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate invariant'1 (self : Vec'0.t_Vec t (Global'0.t_Global)) =
    [%#sinvariant32] inv'6 self
  
  predicate inv'2 (_1 : Vec'0.t_Vec t (Global'0.t_Global))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Vec'0.t_Vec t (Global'0.t_Global) [inv'2 x] . inv'2 x = invariant'1 x
  
  use seq.Seq
  
  use T_core__slice__iter__Iter as Iter'0
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  function view'5 (self : slice t) : Seq.seq t
  
  axiom view'5_spec : forall self : slice t . ([%#sslice31] view'5 self = Slice.id self)
  && ([%#sslice30] Seq.length (view'5 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] (self : slice t) (ix : int) : t =
    [%#sops28] Seq.get (view'5 self) ix
  
  use seq.Seq
  
  function view'3 (self : slice t) : Seq.seq t =
    [%#smodel13] view'5 self
  
  use seq.Seq
  
  function to_ref_seq'0 (self : slice t) : Seq.seq t
  
  axiom to_ref_seq'0_spec : forall self : slice t . ([%#sslice23] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice22] Seq.length (to_ref_seq'0 self) = Seq.length (view'3 self))
  
  function view'1 (self : Iter'0.t_Iter t) : slice t
  
  predicate produces'0 (self : Iter'0.t_Iter t) (visited : Seq.seq t) (tl : Iter'0.t_Iter t) =
    [%#sslice11] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : Iter'0.t_Iter t) (ab : Seq.seq t) (b : Iter'0.t_Iter t) (bc : Seq.seq t) (c : Iter'0.t_Iter t) : ()
    
   =
    [%#sslice21] ()
  
  axiom produces_trans'0_spec : forall a : Iter'0.t_Iter t, ab : Seq.seq t, b : Iter'0.t_Iter t, bc : Seq.seq t, c : Iter'0.t_Iter t . ([%#sslice18] produces'0 a ab b)
   -> ([%#sslice19] produces'0 b bc c)  -> ([%#sslice20] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : Iter'0.t_Iter t) : () =
    [%#sslice17] ()
  
  axiom produces_refl'0_spec : forall self : Iter'0.t_Iter t . [%#sslice16] produces'0 self (Seq.empty  : Seq.seq t) self
  
  predicate inv'1 (_1 : Iter'0.t_Iter t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Iter'0.t_Iter t [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq t) =
    [%#sseq27] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'0 (_1 : Seq.seq t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t [inv'0 x] . inv'0 x = invariant'0 x
  
  function view'0 (self : Vec'0.t_Vec t (Global'0.t_Global)) : Seq.seq t =
    [%#smodel13] view'2 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate resolve'1 (self : borrowed (Iter'0.t_Iter t)) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Iter'0.t_Iter t)) =
    resolve'1 _1
  
  use seq.Seq
  
  function view'4 (self : borrowed (Iter'0.t_Iter t)) : slice t =
    [%#smodel29] view'1 self.current
  
  predicate completed'0 (self : borrowed (Iter'0.t_Iter t)) =
    [%#sslice24] resolve'1 self /\ view'5 (view'4 self) = (Seq.empty  : Seq.seq t)
  
  let rec next'0 (self:borrowed (Iter'0.t_Iter t)) (return'  (ret:Option'0.t_Option t))= any
    [ return' (result:Option'0.t_Option t)-> {inv'3 result}
      {[%#siter12] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate into_iter_post'0 (self : Vec'0.t_Vec t (Global'0.t_Global)) (res : Iter'0.t_Iter t) =
    [%#svec15] view'0 self = view'3 (view'1 res)
  
  predicate into_iter_pre'0 (self : Vec'0.t_Vec t (Global'0.t_Global)) =
    [%#svec14] true
  
  let rec into_iter'0 (self:Vec'0.t_Vec t (Global'0.t_Global)) (return'  (ret:Iter'0.t_Iter t))= {[@expl:precondition] inv'2 self}
    {[@expl:precondition] [%#siter10] into_iter_pre'0 self}
    any [ return' (result:Iter'0.t_Iter t)-> {[%#siter10] into_iter_post'0 self result} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec vec_iter (vec:Vec'0.t_Vec t (Global'0.t_Global)) (return'  (ret:usize))= {[%#s03_std_iterators8] inv'2 vec}
    {[%#s03_std_iterators7] Seq.length (view'0 vec) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = into_iter'0 {vec} (fun (_ret':Iter'0.t_Iter t) ->  [ &iter <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] Snapshot.new iter ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators2] Snapshot.new (Seq.empty  : Seq.seq t) ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:loop invariant] [%#s03_std_iterators4] UIntSize.to_int i = Seq.length (Snapshot.inner produced)}
        {[@expl:loop invariant] [%#s03_std_iterators3] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = Borrow.borrow_mut <Iter'0.t_Iter t> {iter}
              (fun (_ret':borrowed (Iter'0.t_Iter t)) ->  [ &_19 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <Iter'0.t_Iter t> {_19.current} {Borrow.get_id _19}
              (fun (_ret':borrowed (Iter'0.t_Iter t)) ->
                 [ &_18 <- _ret' ] 
                 [ &_19 <- { _19 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_18} (fun (_ret':Option'0.t_Option t) ->  [ &_17 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _19}- s1
          | s1 = any [ br0 -> {_17 = Option'0.C_None } (! bb9) | br1 (a:t)-> {_17 = Option'0.C_Some a} (! bb8) ]  ]
          
        | bb8 = bb10
        | bb10 = s0
          [ s0 = Option'0.v_Some <t> {_17} (fun (r0'0:t) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_22 <- [%#s03_std_iterators5] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb11 ]
          
        | bb11 = s0
          [ s0 =  [ &produced <- _22 ] s1
          | s1 = UIntSize.add {i} {[%#s03_std_iterators6] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
           ]
         ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & vec : Vec'0.t_Vec t (Global'0.t_Global) = vec
    | & i : usize = any_l ()
    | & iter : Iter'0.t_Iter t = any_l ()
    | & iter_old : Snapshot.snap_ty (Iter'0.t_Iter t) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t) = any_l ()
    | & _17 : Option'0.t_Option t = any_l ()
    | & _18 : borrowed (Iter'0.t_Iter t) = any_l ()
    | & _19 : borrowed (Iter'0.t_Iter t) = any_l ()
    | & __creusot_proc_iter_elem : t = any_l ()
    | & _22 : Snapshot.snap_ty (Seq.seq t) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#s03_std_iterators9] UIntSize.to_int result
      = Seq.length (view'0 vec)}
      (! return' {result}) ]
    
end
module T_core__slice__iter__IterMut
  use prelude.prelude.Borrow
  
  use T_core__marker__PhantomData as PhantomData'0
  
  use prelude.prelude.Opaque
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_IterMut 't =
    | C_IterMut (NonNull'0.t_NonNull 't) opaque_ptr (PhantomData'0.t_PhantomData (borrowed 't))
  
  let rec t_IterMut < 't > (input:t_IterMut 't) (ret  (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData (borrowed 't)))= any
    [ good (ptr:NonNull'0.t_NonNull 't) (end_or_len:opaque_ptr) (_marker:PhantomData'0.t_PhantomData (borrowed 't))-> {C_IterMut ptr end_or_len _marker
      = input}
      (! ret {ptr} {end_or_len} {_marker}) ]
    
end
module M_03_std_iterators__all_zero [#"03_std_iterators.rs" 28 0 28 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 29 4 29 87
  let%span s03_std_iterators1 = "03_std_iterators.rs" 29 4 29 87
  let%span s03_std_iterators2 = "03_std_iterators.rs" 29 4 29 87
  let%span s03_std_iterators3 = "03_std_iterators.rs" 29 4 29 87
  let%span s03_std_iterators4 = "03_std_iterators.rs" 31 13 31 14
  let%span s03_std_iterators5 = "03_std_iterators.rs" 26 10 26 33
  let%span s03_std_iterators6 = "03_std_iterators.rs" 27 0 27 66
  let%span svec7 = "../../../../creusot-contracts/src/std/vec.rs" 178 26 178 42
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 179 26 179 48
  let%span sslice9 = "../../../../creusot-contracts/src/std/slice.rs" 249 0 358 1
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span sslice11 = "../../../../creusot-contracts/src/std/slice.rs" 469 12 469 66
  let%span sops12 = "../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span svec14 = "../../../../creusot-contracts/src/std/vec.rs" 19 14 19 41
  let%span smodel15 = "../../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sops16 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 437 14 437 50
  let%span siter20 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter21 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sresolve22 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 475 15 475 24
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 476 14 476 45
  let%span sslice25 = "../../../../creusot-contracts/src/std/slice.rs" 473 4 473 10
  let%span sslice26 = "../../../../creusot-contracts/src/std/slice.rs" 481 15 481 21
  let%span sslice27 = "../../../../creusot-contracts/src/std/slice.rs" 482 15 482 21
  let%span sslice28 = "../../../../creusot-contracts/src/std/slice.rs" 483 15 483 21
  let%span sslice29 = "../../../../creusot-contracts/src/std/slice.rs" 484 15 484 32
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 485 15 485 32
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 486 14 486 42
  let%span sslice32 = "../../../../creusot-contracts/src/std/slice.rs" 479 4 479 10
  let%span sslice33 = "../../../../creusot-contracts/src/std/slice.rs" 90 14 90 41
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 91 4 91 86
  let%span sslice35 = "../../../../creusot-contracts/src/std/slice.rs" 462 20 462 61
  let%span sslice36 = "../../../../creusot-contracts/src/std/slice.rs" 447 20 447 36
  let%span sops37 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : Option'0.t_Option (borrowed usize))
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option (borrowed usize) [inv'4 x] . inv'4 x = true
  
  use prelude.prelude.Slice
  
  predicate inv'3 (_1 : borrowed (slice usize))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (slice usize) [inv'3 x] . inv'3 x = true
  
  use T_alloc__alloc__Global as Global'0
  
  use T_alloc__vec__Vec as Vec'0
  
  predicate inv'2 (_1 : borrowed (Vec'0.t_Vec usize (Global'0.t_Global)))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Vec'0.t_Vec usize (Global'0.t_Global)) [inv'2 x] . inv'2 x = true
  
  use seq.Seq
  
  use T_core__slice__iter__IterMut as IterMut'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  function view'3 (self : slice usize) : Seq.seq usize
  
  axiom view'3_spec : forall self : slice usize . ([%#sslice18] view'3 self = Slice.id self)
  && ([%#sslice17] Seq.length (view'3 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'2 [@inline:trivial] (self : slice usize) (ix : int) : usize =
    [%#sops37] Seq.get (view'3 self) ix
  
  use seq.Seq
  
  function view'2 (self : borrowed (slice usize)) : Seq.seq usize =
    [%#smodel15] view'3 self.current
  
  use seq.Seq
  
  function to_mut_seq'0 (self : borrowed (slice usize)) : Seq.seq (borrowed usize)
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice usize) . ([%#sslice34] forall i : int . 0 <= i
  /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'2 self.current i) (index_logic'2 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  && ([%#sslice33] Seq.length (to_mut_seq'0 self) = Seq.length (view'2 self))
  
  function view'4 (self : IterMut'0.t_IterMut usize) : borrowed (slice usize)
  
  axiom view'4_spec : forall self : IterMut'0.t_IterMut usize . [%#sslice19] Seq.length (view'3 (view'4 self).final)
  = Seq.length (view'3 (view'4 self).current)
  
  predicate produces'0 (self : IterMut'0.t_IterMut usize) (visited : Seq.seq (borrowed usize)) (tl : IterMut'0.t_IterMut usize)
    
   =
    [%#sslice11] to_mut_seq'0 (view'4 self) = Seq.(++) visited (to_mut_seq'0 (view'4 tl))
  
  predicate inv'1 (_1 : IterMut'0.t_IterMut usize)
  
  function produces_trans'0 (a : IterMut'0.t_IterMut usize) (ab : Seq.seq (borrowed usize)) (b : IterMut'0.t_IterMut usize) (bc : Seq.seq (borrowed usize)) (c : IterMut'0.t_IterMut usize) : ()
    
   =
    [%#sslice32] ()
  
  axiom produces_trans'0_spec : forall a : IterMut'0.t_IterMut usize, ab : Seq.seq (borrowed usize), b : IterMut'0.t_IterMut usize, bc : Seq.seq (borrowed usize), c : IterMut'0.t_IterMut usize . ([%#sslice26] inv'1 a)
   -> ([%#sslice27] inv'1 b)
   -> ([%#sslice28] inv'1 c)
   -> ([%#sslice29] produces'0 a ab b)
   -> ([%#sslice30] produces'0 b bc c)  -> ([%#sslice31] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : IterMut'0.t_IterMut usize) : () =
    [%#sslice25] ()
  
  axiom produces_refl'0_spec : forall self : IterMut'0.t_IterMut usize . ([%#sslice23] inv'1 self)
   -> ([%#sslice24] produces'0 self (Seq.empty  : Seq.seq (borrowed usize)) self)
  
  axiom inv_axiom'1 [@rewrite] : forall x : IterMut'0.t_IterMut usize [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Seq.seq (borrowed usize))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq (borrowed usize) [inv'0 x] . inv'0 x = true
  
  function view'0 (self : Vec'0.t_Vec usize (Global'0.t_Global)) : Seq.seq usize
  
  axiom view'0_spec : forall self : Vec'0.t_Vec usize (Global'0.t_Global) . [%#svec14] Seq.length (view'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  function index_logic'1 [@inline:trivial] (self : Vec'0.t_Vec usize (Global'0.t_Global)) (ix : int) : usize =
    [%#sops16] Seq.get (view'0 self) ix
  
  function view'1 (self : borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) : Seq.seq usize =
    [%#smodel15] view'0 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'9 (self : borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'4 (_1 : borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) =
    resolve'9 _1
  
  predicate resolve'8 (self : IterMut'0.t_IterMut usize) =
    [%#sslice36] (view'4 self).current = (view'4 self).final
  
  predicate resolve'3 (_1 : IterMut'0.t_IterMut usize) =
    resolve'8 _1
  
  predicate resolve'7 (self : borrowed usize) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed usize) =
    resolve'7 _1
  
  use seq.Seq
  
  predicate resolve'6 (self : borrowed (IterMut'0.t_IterMut usize)) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (IterMut'0.t_IterMut usize)) =
    resolve'6 _1
  
  use seq.Seq
  
  function view'5 (self : borrowed (IterMut'0.t_IterMut usize)) : borrowed (slice usize) =
    [%#smodel15] view'4 self.current
  
  predicate completed'0 (self : borrowed (IterMut'0.t_IterMut usize)) =
    [%#sslice35] resolve'6 self /\ view'3 (view'5 self).current = (Seq.empty  : Seq.seq usize)
  
  let rec next'0 (self:borrowed (IterMut'0.t_IterMut usize)) (return'  (ret:Option'0.t_Option (borrowed usize)))= any
    [ return' (result:Option'0.t_Option (borrowed usize))-> {inv'4 result}
      {[%#siter13] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq (borrowed usize))) (ix : int) : borrowed usize
    
   =
    [%#sops12] Seq.get (Snapshot.inner self) ix
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate resolve'5 (self : borrowed (slice usize)) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (slice usize)) =
    resolve'5 _1
  
  predicate into_iter_post'0 (self : IterMut'0.t_IterMut usize) (res : IterMut'0.t_IterMut usize) =
    [%#siter21] self = res
  
  predicate into_iter_pre'0 (self : IterMut'0.t_IterMut usize) =
    [%#siter20] true
  
  let rec into_iter'0 (self:IterMut'0.t_IterMut usize) (return'  (ret:IterMut'0.t_IterMut usize))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#siter10] into_iter_pre'0 self}
    any
    [ return' (result:IterMut'0.t_IterMut usize)-> {inv'1 result}
      {[%#siter10] into_iter_post'0 self result}
      (! return' {result}) ]
    
  
  let rec iter_mut'0 (self:borrowed (slice usize)) (return'  (ret:IterMut'0.t_IterMut usize))= {[@expl:precondition] inv'3 self}
    any [ return' (result:IterMut'0.t_IterMut usize)-> {[%#sslice9] view'4 result = self} (! return' {result}) ] 
  
  let rec deref_mut'0 (self:borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) (return'  (ret:borrowed (slice usize)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (slice usize))-> {inv'3 result}
      {[%#svec8] view'3 result.final = view'0 self.final}
      {[%#svec7] view'2 result = view'1 self}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec all_zero (v:borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <Vec'0.t_Vec usize (Global'0.t_Global)> {v.current} {Borrow.get_id v}
          (fun (_ret':borrowed (Vec'0.t_Vec usize (Global'0.t_Global))) ->
             [ &_8 <- _ret' ] 
             [ &v <- { v with current = _ret'.final ; } ] 
            s1)
      | s1 = deref_mut'0 {_8} (fun (_ret':borrowed (slice usize)) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <slice usize> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed (slice usize)) ->  [ &_6 <- _ret' ]  [ &_7 <- { _7 with current = _ret'.final ; } ] s1)
      | s1 = iter_mut'0 {_6} (fun (_ret':IterMut'0.t_IterMut usize) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 = into_iter'0 {_5} (fun (_ret':IterMut'0.t_IterMut usize) ->  [ &iter <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = -{resolve'0 _7}- s1 | s1 =  [ &iter_old <- [%#s03_std_iterators0] Snapshot.new iter ] s2 | s2 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators1] Snapshot.new (Seq.empty  : Seq.seq (borrowed usize)) ] s1
      | s1 = bb5 ]
      
    | bb5 = bb6
    | bb6 = bb6
      [ bb6 = {[@expl:loop invariant] [%#s03_std_iterators2] forall i : int . 0 <= i
        /\ i < Seq.length (Snapshot.inner produced)  -> UIntSize.to_int (index_logic'0 produced i).final = 0}
        {[@expl:loop invariant] [%#s03_std_iterators2] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators2] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators2] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = Borrow.borrow_mut <IterMut'0.t_IterMut usize> {iter}
              (fun (_ret':borrowed (IterMut'0.t_IterMut usize)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <IterMut'0.t_IterMut usize> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (IterMut'0.t_IterMut usize)) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':Option'0.t_Option (borrowed usize)) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb8 ]
          
        | bb8 = s0
          [ s0 = -{resolve'1 _20}- s1
          | s1 = any
            [ br0 -> {_18 = Option'0.C_None } (! bb11) | br1 (a:borrowed usize)-> {_18 = Option'0.C_Some a} (! bb10) ]
             ]
          
        | bb10 = bb12
        | bb12 = s0
          [ s0 = Option'0.v_Some <borrowed usize> {_18}
              (fun (r0'0:borrowed usize) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators3] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb13 ]
          
        | bb13 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 =  [ &x <- __creusot_proc_iter_elem ] s2
          | s2 =  [ &x <- { x with current = ([%#s03_std_iterators4] (0 : usize)) ; } ] s3
          | s3 = -{resolve'2 x}- s4
          | s4 = bb6 ]
           ]
         ]
      
    | bb11 = s0 [ s0 = -{resolve'3 iter}- s1 | s1 = -{resolve'4 v}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l ()
    | & v : borrowed (Vec'0.t_Vec usize (Global'0.t_Global)) = v
    | & iter : IterMut'0.t_IterMut usize = any_l ()
    | & _5 : IterMut'0.t_IterMut usize = any_l ()
    | & _6 : borrowed (slice usize) = any_l ()
    | & _7 : borrowed (slice usize) = any_l ()
    | & _8 : borrowed (Vec'0.t_Vec usize (Global'0.t_Global)) = any_l ()
    | & iter_old : Snapshot.snap_ty (IterMut'0.t_IterMut usize) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (borrowed usize)) = any_l ()
    | & _18 : Option'0.t_Option (borrowed usize) = any_l ()
    | & _19 : borrowed (IterMut'0.t_IterMut usize) = any_l ()
    | & _20 : borrowed (IterMut'0.t_IterMut usize) = any_l ()
    | & __creusot_proc_iter_elem : borrowed usize = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq (borrowed usize)) = any_l ()
    | & x : borrowed usize = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#s03_std_iterators6] forall i : int . 0 <= i
      /\ i < Seq.length (view'1 v)  -> UIntSize.to_int (index_logic'1 v.final i) = 0}
      {[@expl:postcondition] [%#s03_std_iterators5] Seq.length (view'0 v.final) = Seq.length (view'1 v)}
      (! return' {result}) ]
    
end
module T_core__iter__adapters__take__Take
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Take 'i =
    | C_Take 'i usize
  
  let rec t_Take < 'i > (input:t_Take 'i) (ret  (iter:'i) (n:usize))= any
    [ good (iter:'i) (n:usize)-> {C_Take iter n = input} (! ret {iter} {n}) ]
    
end
module T_core__iter__adapters__skip__Skip
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Skip 'i =
    | C_Skip 'i usize
  
  let rec t_Skip < 'i > (input:t_Skip 'i) (ret  (iter:'i) (n:usize))= any
    [ good (iter:'i) (n:usize)-> {C_Skip iter n = input} (! ret {iter} {n}) ]
    
end
module M_03_std_iterators__skip_take [#"03_std_iterators.rs" 35 0 35 48]
  type i
  
  let%span s03_std_iterators0 = "03_std_iterators.rs" 38 20 38 31
  let%span s03_std_iterators1 = "03_std_iterators.rs" 35 30 35 34
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span siter3 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span stake4 = "../../../../creusot-contracts/src/std/iter/take.rs" 18 4 18 41
  let%span stake5 = "../../../../creusot-contracts/src/std/iter/take.rs" 34 14 34 50
  let%span sskip6 = "../../../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 41
  let%span sskip7 = "../../../../creusot-contracts/src/std/iter/skip.rs" 23 14 23 50
  let%span sskip8 = "../../../../creusot-contracts/src/std/iter/skip.rs" 50 8 58 9
  let%span sskip9 = "../../../../creusot-contracts/src/std/iter/skip.rs" 64 8 71 9
  let%span sskip10 = "../../../../creusot-contracts/src/std/iter/skip.rs" 34 12 34 33
  let%span sresolve11 = "../../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sskip12 = "../../../../creusot-contracts/src/std/iter/skip.rs" 76 15 76 24
  let%span sskip13 = "../../../../creusot-contracts/src/std/iter/skip.rs" 77 14 77 45
  let%span sskip14 = "../../../../creusot-contracts/src/std/iter/skip.rs" 84 15 84 21
  let%span sskip15 = "../../../../creusot-contracts/src/std/iter/skip.rs" 85 15 85 21
  let%span sskip16 = "../../../../creusot-contracts/src/std/iter/skip.rs" 86 15 86 21
  let%span sskip17 = "../../../../creusot-contracts/src/std/iter/skip.rs" 87 15 87 32
  let%span sskip18 = "../../../../creusot-contracts/src/std/iter/skip.rs" 88 15 88 32
  let%span sskip19 = "../../../../creusot-contracts/src/std/iter/skip.rs" 89 14 89 42
  let%span stake20 = "../../../../creusot-contracts/src/std/iter/take.rs" 69 12 69 88
  let%span stake21 = "../../../../creusot-contracts/src/std/iter/take.rs" 60 12 61 92
  let%span sinvariant22 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span stake23 = "../../../../creusot-contracts/src/std/iter/take.rs" 75 15 75 24
  let%span stake24 = "../../../../creusot-contracts/src/std/iter/take.rs" 76 14 76 45
  let%span stake25 = "../../../../creusot-contracts/src/std/iter/take.rs" 81 15 81 21
  let%span stake26 = "../../../../creusot-contracts/src/std/iter/take.rs" 82 15 82 21
  let%span stake27 = "../../../../creusot-contracts/src/std/iter/take.rs" 83 15 83 21
  let%span stake28 = "../../../../creusot-contracts/src/std/iter/take.rs" 84 15 84 32
  let%span stake29 = "../../../../creusot-contracts/src/std/iter/take.rs" 85 15 85 32
  let%span stake30 = "../../../../creusot-contracts/src/std/iter/take.rs" 86 14 86 42
  let%span stake31 = "../../../../creusot-contracts/src/std/iter/take.rs" 26 14 26 68
  let%span stake32 = "../../../../creusot-contracts/src/std/iter/take.rs" 44 8 44 29
  let%span sseq33 = "../../../../creusot-contracts/src/logic/seq.rs" 198 8 198 97
  let%span siter34 = "../../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter35 = "../../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter36 = "../../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter37 = "../../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter38 = "../../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter39 = "../../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter40 = "../../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter41 = "../../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sresolve42 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sboxed43 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_Item'0
  
  predicate inv'7 (_1 : t_Item'0)
  
  predicate invariant'3 (self : t_Item'0) =
    [%#sboxed43] inv'7 self
  
  predicate inv'8 (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'8 x] . inv'8 x = invariant'3 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 (self : i) (visited : Seq.seq t_Item'0) (o : i)
  
  predicate inv'2 (_1 : i)
  
  function produces_trans'2 (a : i) (ab : Seq.seq t_Item'0) (b : i) (bc : Seq.seq t_Item'0) (c : i) : ()
  
  axiom produces_trans'2_spec : forall a : i, ab : Seq.seq t_Item'0, b : i, bc : Seq.seq t_Item'0, c : i . ([%#siter36] inv'2 a)
   -> ([%#siter37] inv'2 b)
   -> ([%#siter38] inv'2 c)
   -> ([%#siter39] produces'2 a ab b)
   -> ([%#siter40] produces'2 b bc c)  -> ([%#siter41] produces'2 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'2 (self : i) : ()
  
  axiom produces_refl'2_spec : forall self : i . ([%#siter34] inv'2 self)
   -> ([%#siter35] produces'2 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use T_core__iter__adapters__take__Take as Take'0
  
  predicate inv'3 (_1 : Take'0.t_Take i)
  
  function iter'0 (self : Take'0.t_Take i) : i
  
  axiom iter'0_spec : forall self : Take'0.t_Take i . [%#stake4] inv'3 self  -> inv'2 (iter'0 self)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function n'0 (self : Take'0.t_Take i) : int
  
  axiom n'0_spec : forall self : Take'0.t_Take i . [%#stake5] n'0 self >= 0
  /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'1 (self : Take'0.t_Take i) (visited : Seq.seq t_Item'0) (o : Take'0.t_Take i) =
    [%#stake20] n'0 self = n'0 o + Seq.length visited /\ produces'2 (iter'0 self) visited (iter'0 o)
  
  function produces_trans'1 (a : Take'0.t_Take i) (ab : Seq.seq t_Item'0) (b : Take'0.t_Take i) (bc : Seq.seq t_Item'0) (c : Take'0.t_Take i) : ()
    
  
  axiom produces_trans'1_spec : forall a : Take'0.t_Take i, ab : Seq.seq t_Item'0, b : Take'0.t_Take i, bc : Seq.seq t_Item'0, c : Take'0.t_Take i . ([%#stake25] inv'3 a)
   -> ([%#stake26] inv'3 b)
   -> ([%#stake27] inv'3 c)
   -> ([%#stake28] produces'1 a ab b)
   -> ([%#stake29] produces'1 b bc c)  -> ([%#stake30] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : Take'0.t_Take i) : ()
  
  axiom produces_refl'1_spec : forall self : Take'0.t_Take i . ([%#stake23] inv'3 self)
   -> ([%#stake24] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : borrowed (Take'0.t_Take i)) =
    [%#sinvariant22] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'6 (_1 : borrowed (Take'0.t_Take i))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Take'0.t_Take i) [inv'6 x] . inv'6 x = invariant'2 x
  
  use seq.Seq
  
  predicate invariant'1 (self : Seq.seq t_Item'0) =
    [%#sseq33] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'8 (Seq.get self i)
  
  predicate inv'5 (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'5 x] . inv'5 x = invariant'1 x
  
  use T_core__iter__adapters__skip__Skip as Skip'0
  
  predicate resolve'4 (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate inv'0 (_1 : Skip'0.t_Skip (Take'0.t_Take i))
  
  function iter'1 (self : Skip'0.t_Skip (Take'0.t_Take i)) : Take'0.t_Take i
  
  axiom iter'1_spec : forall self : Skip'0.t_Skip (Take'0.t_Take i) . [%#sskip6] inv'0 self  -> inv'3 (iter'1 self)
  
  function n'1 (self : Skip'0.t_Skip (Take'0.t_Take i)) : int
  
  axiom n'1_spec : forall self : Skip'0.t_Skip (Take'0.t_Take i) . [%#sskip7] n'1 self >= 0
  /\ n'1 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate produces'0 (self : Skip'0.t_Skip (Take'0.t_Take i)) (visited : Seq.seq t_Item'0) (o : Skip'0.t_Skip (Take'0.t_Take i))
    
   =
    [%#sskip9] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'1 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'5 s
    /\ Seq.length s = n'1 self
    /\ produces'1 (iter'1 self) (Seq.(++) s visited) (iter'1 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i)))
  
  function produces_trans'0 (a : Skip'0.t_Skip (Take'0.t_Take i)) (ab : Seq.seq t_Item'0) (b : Skip'0.t_Skip (Take'0.t_Take i)) (bc : Seq.seq t_Item'0) (c : Skip'0.t_Skip (Take'0.t_Take i)) : ()
    
  
  axiom produces_trans'0_spec : forall a : Skip'0.t_Skip (Take'0.t_Take i), ab : Seq.seq t_Item'0, b : Skip'0.t_Skip (Take'0.t_Take i), bc : Seq.seq t_Item'0, c : Skip'0.t_Skip (Take'0.t_Take i) . ([%#sskip14] inv'0 a)
   -> ([%#sskip15] inv'0 b)
   -> ([%#sskip16] inv'0 c)
   -> ([%#sskip17] produces'0 a ab b)
   -> ([%#sskip18] produces'0 b bc c)  -> ([%#sskip19] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : Skip'0.t_Skip (Take'0.t_Take i)) : ()
  
  axiom produces_refl'0_spec : forall self : Skip'0.t_Skip (Take'0.t_Take i) . ([%#sskip12] inv'0 self)
   -> ([%#sskip13] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate invariant'0 (self : borrowed (Skip'0.t_Skip (Take'0.t_Take i))) =
    [%#sinvariant22] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 (_1 : borrowed (Skip'0.t_Skip (Take'0.t_Take i)))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Skip'0.t_Skip (Take'0.t_Take i)) [inv'4 x] . inv'4 x
  = invariant'0 x
  
  axiom inv_axiom'2 [@rewrite] : forall x : Take'0.t_Take i [inv'3 x] . inv'3 x
  = match x with
    | Take'0.C_Take iter n -> inv'2 iter
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option t_Item'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option t_Item'0 [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'7 a_0
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : Skip'0.t_Skip (Take'0.t_Take i) [inv'0 x] . inv'0 x
  = match x with
    | Skip'0.C_Skip iter n -> inv'3 iter
    end
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : Option'0.t_Option t_Item'0) =
    [%#sresolve11] match self with
      | Option'0.C_Some x -> resolve'4 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option t_Item'0) =
    resolve'3 _1
  
  predicate resolve'9 (_1 : i)
  
  predicate resolve'7 (self : Take'0.t_Take i) =
    [%#stake32] resolve'9 (iter'0 self)
  
  predicate resolve'5 (_1 : Take'0.t_Take i) =
    resolve'7 _1
  
  predicate resolve'2 (self : Skip'0.t_Skip (Take'0.t_Take i)) =
    [%#sskip10] resolve'5 (iter'1 self)
  
  predicate resolve'0 (_1 : Skip'0.t_Skip (Take'0.t_Take i)) =
    resolve'2 _1
  
  use seq.Seq
  
  predicate completed'2 (self : borrowed i)
  
  function iter_mut'0 (self : borrowed (Take'0.t_Take i)) : borrowed i
  
  axiom iter_mut'0_spec : forall self : borrowed (Take'0.t_Take i) . [%#stake31] iter'0 self.current
  = (iter_mut'0 self).current
  /\ iter'0 self.final = (iter_mut'0 self).final
  
  predicate resolve'8 (self : borrowed (Take'0.t_Take i)) =
    [%#sresolve42] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed (Take'0.t_Take i)) =
    resolve'8 _1
  
  predicate completed'1 (self : borrowed (Take'0.t_Take i)) =
    [%#stake21] n'0 self.current = 0 /\ resolve'6 self
    \/ n'0 self.current > 0 /\ n'0 self.current = n'0 self.final + 1 /\ completed'2 (iter_mut'0 self)
  
  predicate completed'0 (self : borrowed (Skip'0.t_Skip (Take'0.t_Take i))) =
    [%#sskip8] n'1 self.final = 0
    /\ (exists s : Seq.seq t_Item'0, i : borrowed (Take'0.t_Take i) . inv'5 s
    /\ inv'6 i
    /\ Seq.length s <= n'1 self.current
    /\ produces'1 (iter'1 self.current) s i.current
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i))
    /\ completed'1 i /\ i.final = iter'1 self.final)
  
  let rec next'0 (self:borrowed (Skip'0.t_Skip (Take'0.t_Take i))) (return'  (ret:Option'0.t_Option t_Item'0))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option t_Item'0)-> {inv'1 result}
      {[%#siter3] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  let rec skip'0 (self:Take'0.t_Take i) (n:usize) (return'  (ret:Skip'0.t_Skip (Take'0.t_Take i)))= {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Skip'0.t_Skip (Take'0.t_Take i))-> {inv'0 result}
      {[%#siter2] iter'1 result = self /\ n'1 result = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  let rec take'0 (self:i) (n:usize) (return'  (ret:Take'0.t_Take i))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:Take'0.t_Take i)-> {inv'3 result}
      {[%#siter2] iter'0 result = self /\ n'0 result = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec skip_take (iter:i) (n:usize) (return'  (ret:()))= {[%#s03_std_iterators1] inv'2 iter}
    (! bb0
    [ bb0 = s0 [ s0 = take'0 {iter} {n} (fun (_ret':Take'0.t_Take i) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = skip'0 {_6} {n} (fun (_ret':Skip'0.t_Skip (Take'0.t_Take i)) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = {inv'0 _5}
        Borrow.borrow_mut <Skip'0.t_Skip (Take'0.t_Take i)> {_5}
          (fun (_ret':borrowed (Skip'0.t_Skip (Take'0.t_Take i))) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- _ret'.final ] 
            s1)
      | s1 = next'0 {_4} (fun (_ret':Option'0.t_Option t_Item'0) ->  [ &res <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'1 res} s3
      | s3 = -{resolve'1 res}- s4
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators0] res = Option'0.C_None} s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & iter : i = iter
    | & n : usize = n
    | & res : Option'0.t_Option t_Item'0 = any_l ()
    | & _4 : borrowed (Skip'0.t_Skip (Take'0.t_Take i)) = any_l ()
    | & _5 : Skip'0.t_Skip (Take'0.t_Take i) = any_l ()
    | & _6 : Take'0.t_Take i = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv [#"../../../../creusot-contracts/src/std/iter/map_inv.rs" 3 0 3 26]
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  type t_MapInv 'i 'b 'f =
    | C_MapInv 'i 'f (Snapshot.snap_ty (Seq.seq 'b))
  
  let rec t_MapInv < 'i > < 'b > < 'f > (input:t_MapInv 'i 'b 'f) (ret  (iter:'i) (func:'f) (produced:Snapshot.snap_ty (Seq.seq 'b)))= any
    [ good (iter:'i) (func:'f) (produced:Snapshot.snap_ty (Seq.seq 'b))-> {C_MapInv iter func produced = input}
      (! ret {iter} {func} {produced}) ]
    
  
  function t_MapInv__produced (self : t_MapInv 'i 'b 'f) : Snapshot.snap_ty (Seq.seq 'b) =
    match self with
      | C_MapInv _ _ a -> a
      end
  
  function t_MapInv__iter (self : t_MapInv 'i 'b 'f) : 'i =
    match self with
      | C_MapInv a _ _ -> a
      end
  
  function t_MapInv__func (self : t_MapInv 'i 'b 'f) : 'f =
    match self with
      | C_MapInv _ a _ -> a
      end
end
module T_03_std_iterators__counter__qyClosure0 [#"03_std_iterators.rs" 48 12 48 91]
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  type m_03_std_iterators__counter__qyClosure0  =
    | M_03_std_iterators__counter__qyClosure0 (borrowed usize)
  
  let rec m_03_std_iterators__counter__qyClosure0 (input:m_03_std_iterators__counter__qyClosure0) (ret  (cnt:borrowed usize))= any
    [ good (cnt:borrowed usize)-> {M_03_std_iterators__counter__qyClosure0 cnt = input} (! ret {cnt}) ]
    
end
module M_03_std_iterators__counter__qyClosure0 [#"03_std_iterators.rs" 48 12 48 91]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 50 23 50 24
  let%span s03_std_iterators1 = "03_std_iterators.rs" 47 23 47 65
  let%span s03_std_iterators2 = "03_std_iterators.rs" 48 22 48 89
  let%span sresolve3 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  use T_03_std_iterators__counter__qyClosure0 as Closure'0
  
  function field_0'0 [#"03_std_iterators.rs" 48 12 48 91] (self : Closure'0.m_03_std_iterators__counter__qyClosure0) : borrowed usize
    
   =
    let Closure'0.M_03_std_iterators__counter__qyClosure0 a = self in a
  
  predicate unnest'0 [#"03_std_iterators.rs" 48 12 48 91] (self : Closure'0.m_03_std_iterators__counter__qyClosure0) (_2 : Closure'0.m_03_std_iterators__counter__qyClosure0)
    
   =
    (field_0'0 _2).final = (field_0'0 self).final
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt32
  
  predicate resolve'1 (self : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec m_03_std_iterators__counter__qyClosure0 (_1:borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) (x:uint32) (_prod:Snapshot.snap_ty (Seq.seq uint32)) (return'  (ret:uint32))= {[%#s03_std_iterators1] UIntSize.to_int (field_0'0 _1.current).current
    = Seq.length (Snapshot.inner _prod)
    /\ (field_0'0 _1.current).current < (v_MAX'0 : usize)}
    (! bb0
    [ bb0 = s0
      [ s0 = Closure'0.m_03_std_iterators__counter__qyClosure0 {_1.current}
          (fun (r'0:borrowed usize) ->
            UIntSize.add {r'0.current} {[%#s03_std_iterators0] (1 : usize)}
              (fun (_ret':usize) ->
                Closure'0.m_03_std_iterators__counter__qyClosure0 {_1.current}
                  (fun (r'1:borrowed usize) ->
                    
                    [ &_1 <- { _1 with current = Closure'0.M_03_std_iterators__counter__qyClosure0 ({ r'1 with current = _ret' ; }) ; } ]
                    
                    s1)))
      | s1 = -{resolve'0 _1}- s2
      | s2 =  [ &res1 <- x ] s3
      | s3 =  [ &res <- res1 ] s4
      | s4 =  [ &_0 <- res ] s5
      | s5 = return' {_0} ]
       ]
    )
    [ & _0 : uint32 = any_l ()
    | & _1 : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0 = _1
    | & x : uint32 = x
    | & res : uint32 = any_l ()
    | & res1 : uint32 = any_l () ]
    
    [ return' (result:uint32)-> {[@expl:postcondition] unnest'0 _1.current _1.final}
      {[@expl:postcondition] [%#s03_std_iterators2] UIntSize.to_int (field_0'0 _1.final).current
      = UIntSize.to_int (field_0'0 _1.current).current + 1
      /\ UIntSize.to_int (field_0'0 _1.final).current = Seq.length (Snapshot.inner _prod) + 1 /\ result = x}
      (! return' {result}) ]
    
end
module M_03_std_iterators__counter [#"03_std_iterators.rs" 41 0 41 27]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 42 18 42 19
  let%span s03_std_iterators1 = "03_std_iterators.rs" 56 20 56 40
  let%span s03_std_iterators2 = "03_std_iterators.rs" 57 4 57 35
  let%span s03_std_iterators3 = "03_std_iterators.rs" 58 20 58 36
  let%span svec4 = "../../../../creusot-contracts/src/std/vec.rs" 172 26 172 42
  let%span sslice5 = "../../../../creusot-contracts/src/std/slice.rs" 249 0 358 1
  let%span siter6 = "../../../../creusot-contracts/src/std/iter.rs" 53 4 55 71
  let%span siter7 = "../../../../creusot-contracts/src/std/iter.rs" 56 15 56 51
  let%span siter8 = "../../../../creusot-contracts/src/std/iter.rs" 57 15 57 70
  let%span siter9 = "../../../../creusot-contracts/src/std/iter.rs" 59 21 59 25
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 59 27 59 31
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 58 14 58 88
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 59 4 62 61
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 173 16 175 83
  let%span svec14 = "../../../../creusot-contracts/src/std/vec.rs" 19 14 19 41
  let%span smodel15 = "../../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sslice16 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 45
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 416 4 416 10
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 425 15 425 32
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 426 15 426 32
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 427 14 427 42
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 423 4 423 10
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 410 12 410 66
  let%span s03_std_iterators23 = "03_std_iterators.rs" 47 23 47 65
  let%span smap_inv24 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 165 8 171 9
  let%span smap_inv25 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 152 8 159 9
  let%span smap_inv26 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv27 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 45 8 58 9
  let%span svec28 = "../../../../creusot-contracts/src/std/vec.rs" 292 20 292 32
  let%span sslice29 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 100 14 100 41
  let%span sslice32 = "../../../../creusot-contracts/src/std/slice.rs" 101 4 101 82
  let%span sslice33 = "../../../../creusot-contracts/src/std/slice.rs" 403 20 403 61
  let%span smap_inv34 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 127 8 131 9
  let%span smap_inv35 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 66 8 66 50
  let%span smap_inv36 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 25 15 25 24
  let%span smap_inv37 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 26 14 26 45
  let%span smap_inv38 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 21
  let%span smap_inv39 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 34 15 34 21
  let%span smap_inv40 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 35 15 35 21
  let%span smap_inv41 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 36 15 36 32
  let%span smap_inv42 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 37 15 37 32
  let%span smap_inv43 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 38 14 38 42
  let%span sops44 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sresolve45 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span smodel46 = "../../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sinvariant47 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use T_03_std_iterators__counter__qyClosure0 as Closure'0
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  predicate inv'13 (_1 : Seq.seq (borrowed Closure'0.m_03_std_iterators__counter__qyClosure0))
  
  axiom inv_axiom'13 [@rewrite] : forall x : Seq.seq (borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) [inv'13 x] . inv'13 x
  = true
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  predicate inv'12 (_1 : uint32)
  
  axiom inv_axiom'12 [@rewrite] : forall x : uint32 [inv'12 x] . inv'12 x = true
  
  predicate inv'11 (_1 : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0 [inv'11 x] . inv'11 x
  = true
  
  use seq.Seq
  
  predicate inv'10 (_1 : Seq.seq uint32)
  
  axiom inv_axiom'10 [@rewrite] : forall x : Seq.seq uint32 [inv'10 x] . inv'10 x = true
  
  use T_core__slice__iter__Iter as Iter'0
  
  predicate inv'9 (_1 : borrowed (Iter'0.t_Iter uint32))
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed (Iter'0.t_Iter uint32) [inv'9 x] . inv'9 x = true
  
  use T_alloc__alloc__Global as Global'0
  
  use T_alloc__vec__Vec as Vec'0
  
  predicate inv'8 (_1 : Vec'0.t_Vec uint32 (Global'0.t_Global))
  
  axiom inv_axiom'8 [@rewrite] : forall x : Vec'0.t_Vec uint32 (Global'0.t_Global) [inv'8 x] . inv'8 x = true
  
  use seq.Seq
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as MapInv'0
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  function field_0'0 [#"03_std_iterators.rs" 48 12 48 91] (self : Closure'0.m_03_std_iterators__counter__qyClosure0) : borrowed usize
    
   =
    let Closure'0.M_03_std_iterators__counter__qyClosure0 a = self in a
  
  predicate unnest'0 [#"03_std_iterators.rs" 48 12 48 91] (self : Closure'0.m_03_std_iterators__counter__qyClosure0) (_2 : Closure'0.m_03_std_iterators__counter__qyClosure0)
    
   =
    (field_0'0 _2).final = (field_0'0 self).final
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Snapshot
  
  predicate postcondition_mut'0 [#"03_std_iterators.rs" 48 12 48 91] (self : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) (result : uint32)
    
   =
    (let (x, _prod) = args in UIntSize.to_int (field_0'0 self.final).current
    = UIntSize.to_int (field_0'0 self.current).current + 1
    /\ UIntSize.to_int (field_0'0 self.final).current = Seq.length (Snapshot.inner _prod) + 1 /\ result = x)
    /\ unnest'0 self.current self.final
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  predicate precondition'0 [#"03_std_iterators.rs" 48 12 48 91] (self : Closure'0.m_03_std_iterators__counter__qyClosure0) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32)))
    
   =
    [%#s03_std_iterators23] let (x, _prod) = args in UIntSize.to_int (field_0'0 self).current
    = Seq.length (Snapshot.inner _prod)
    /\ (field_0'0 self).current < (v_MAX'0 : usize)
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  function view'4 (self : slice uint32) : Seq.seq uint32
  
  axiom view'4_spec : forall self : slice uint32 . ([%#sslice30] view'4 self = Slice.id self)
  && ([%#sslice29] Seq.length (view'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  function index_logic'0 [@inline:trivial] (self : slice uint32) (ix : int) : uint32 =
    [%#sops44] Seq.get (view'4 self) ix
  
  function view'1 (self : slice uint32) : Seq.seq uint32 =
    [%#smodel15] view'4 self
  
  function to_ref_seq'0 (self : slice uint32) : Seq.seq uint32
  
  axiom to_ref_seq'0_spec : forall self : slice uint32 . ([%#sslice32] forall i : int . 0 <= i
  /\ i < Seq.length (to_ref_seq'0 self)  -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  && ([%#sslice31] Seq.length (to_ref_seq'0 self) = Seq.length (view'1 self))
  
  function view'3 (self : Iter'0.t_Iter uint32) : slice uint32
  
  predicate produces'0 (self : Iter'0.t_Iter uint32) (visited : Seq.seq uint32) (tl : Iter'0.t_Iter uint32) =
    [%#sslice22] to_ref_seq'0 (view'3 self) = Seq.(++) visited (to_ref_seq'0 (view'3 tl))
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  use seq.Seq
  
  use T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv as T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv
  
  predicate produces'1 [@inline:trivial] (self : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) (visited : Seq.seq uint32) (succ : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)
    
   =
    [%#smap_inv27] unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ)
    /\ (exists fs : Seq.seq (borrowed Closure'0.m_03_std_iterators__counter__qyClosure0) . inv'13 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq uint32 . inv'10 s
    /\ Seq.length s = Seq.length visited
    /\ produces'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self) s (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter succ)
    /\ Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced succ)
    = Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    else
      (Seq.get fs 0).current = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self
      /\ (Seq.get fs (Seq.length visited - 1)).final
      = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i) (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self)) (Seq.([..]) s 0 i))) (Seq.get visited i))))
  
  predicate inv'5 (_1 : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)
    
  
  function produces_trans'3 (a : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) (ab : Seq.seq uint32) (b : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) (bc : Seq.seq uint32) (c : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) : ()
    
  
  axiom produces_trans'3_spec : forall a : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0, ab : Seq.seq uint32, b : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0, bc : Seq.seq uint32, c : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0 . ([%#smap_inv38] inv'5 a)
   -> ([%#smap_inv39] inv'5 b)
   -> ([%#smap_inv40] inv'5 c)
   -> ([%#smap_inv41] produces'1 a ab b)
   -> ([%#smap_inv42] produces'1 b bc c)  -> ([%#smap_inv43] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'3 (self : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) : ()
    
  
  axiom produces_refl'3_spec : forall self : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0 . ([%#smap_inv36] inv'5 self)
   -> ([%#smap_inv37] produces'1 self (Seq.empty  : Seq.seq uint32) self)
  
  predicate inv'7 (_1 : Seq.seq uint32)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq uint32 [inv'7 x] . inv'7 x = true
  
  predicate invariant'1 (self : borrowed (MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0))
    
   =
    [%#sinvariant47] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0))
    
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) [inv'6 x] . inv'6 x
  = invariant'1 x
  
  predicate invariant'0 (self : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)
    
  
  axiom inv_axiom'5 [@rewrite] : forall x : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0 [inv'5 x] . inv'5 x
  = (invariant'0 x
  /\ match x with
    | MapInv'0.C_MapInv iter func produced -> true
    end)
  
  predicate inv'4 (_1 : Closure'0.m_03_std_iterators__counter__qyClosure0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Closure'0.m_03_std_iterators__counter__qyClosure0 [inv'4 x] . inv'4 x = true
  
  function produces_trans'2 (a : Iter'0.t_Iter uint32) (ab : Seq.seq uint32) (b : Iter'0.t_Iter uint32) (bc : Seq.seq uint32) (c : Iter'0.t_Iter uint32) : ()
    
   =
    [%#sslice21] ()
  
  axiom produces_trans'2_spec : forall a : Iter'0.t_Iter uint32, ab : Seq.seq uint32, b : Iter'0.t_Iter uint32, bc : Seq.seq uint32, c : Iter'0.t_Iter uint32 . ([%#sslice18] produces'0 a ab b)
   -> ([%#sslice19] produces'0 b bc c)  -> ([%#sslice20] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'2 (self : Iter'0.t_Iter uint32) : () =
    [%#sslice17] ()
  
  axiom produces_refl'2_spec : forall self : Iter'0.t_Iter uint32 . [%#sslice16] produces'0 self (Seq.empty  : Seq.seq uint32) self
  
  predicate inv'3 (_1 : Iter'0.t_Iter uint32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Iter'0.t_Iter uint32 [inv'3 x] . inv'3 x = true
  
  predicate inv'2 (_1 : uint32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : uint32 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : slice uint32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : slice uint32 [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Vec'0.t_Vec uint32 (Global'0.t_Global))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Vec'0.t_Vec uint32 (Global'0.t_Global) [inv'0 x] . inv'0 x = true
  
  function produces_trans'1 (a : Iter'0.t_Iter uint32) (ab : Seq.seq uint32) (b : Iter'0.t_Iter uint32) (bc : Seq.seq uint32) (c : Iter'0.t_Iter uint32) : ()
    
   =
    [%#sslice21] ()
  
  axiom produces_trans'1_spec : forall a : Iter'0.t_Iter uint32, ab : Seq.seq uint32, b : Iter'0.t_Iter uint32, bc : Seq.seq uint32, c : Iter'0.t_Iter uint32 . ([%#sslice18] produces'0 a ab b)
   -> ([%#sslice19] produces'0 b bc c)  -> ([%#sslice20] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : Iter'0.t_Iter uint32) : () =
    [%#sslice17] ()
  
  axiom produces_refl'1_spec : forall self : Iter'0.t_Iter uint32 . [%#sslice16] produces'0 self (Seq.empty  : Seq.seq uint32) self
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  function view'0 (self : Vec'0.t_Vec uint32 (Global'0.t_Global)) : Seq.seq uint32
  
  axiom view'0_spec : forall self : Vec'0.t_Vec uint32 (Global'0.t_Global) . [%#svec14] Seq.length (view'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate from_iter_post'0 (prod : Seq.seq uint32) (res : Vec'0.t_Vec uint32 (Global'0.t_Global)) =
    [%#svec28] prod = view'0 res
  
  function view'5 (self : borrowed (Iter'0.t_Iter uint32)) : slice uint32 =
    [%#smodel46] view'3 self.current
  
  predicate resolve'2 (self : borrowed (Iter'0.t_Iter uint32)) =
    [%#sresolve45] self.final = self.current
  
  predicate completed'1 (self : borrowed (Iter'0.t_Iter uint32)) =
    [%#sslice33] resolve'2 self /\ view'4 (view'5 self) = (Seq.empty  : Seq.seq uint32)
  
  predicate completed'0 (self : borrowed (MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0))
    
   =
    [%#smap_inv26] Snapshot.inner (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__produced self.final)
    = (Seq.empty  : Seq.seq uint32)
    /\ completed'1 (Borrow.borrow_logic (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.current) (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self.final) (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.current
    = T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self.final
  
  predicate resolve'7 (self : borrowed usize) =
    [%#sresolve45] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed usize) =
    resolve'7 _1
  
  predicate resolve'5 [#"03_std_iterators.rs" 48 12 48 91] (_1 : Closure'0.m_03_std_iterators__counter__qyClosure0) =
    resolve'6 (field_0'0 _1)
  
  predicate resolve'4 (_1 : Closure'0.m_03_std_iterators__counter__qyClosure0) =
    resolve'5 _1
  
  predicate resolve'3 (_1 : Iter'0.t_Iter uint32) =
    true
  
  predicate resolve'1 (self : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)
    
   =
    [%#smap_inv35] resolve'3 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__iter self)
    /\ resolve'4 (T_creusot_contracts__stdqy35z1__iter__map_inv__MapInv.t_MapInv__func self)
  
  predicate resolve'0 (_1 : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)
    
   =
    resolve'1 _1
  
  let rec collect'0 (self:MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) (return'  (ret:Vec'0.t_Vec uint32 (Global'0.t_Global)))= {[@expl:precondition] inv'5 self}
    any
    [ return' (result:Vec'0.t_Vec uint32 (Global'0.t_Global))-> {inv'8 result}
      {[%#siter13] exists done' : borrowed (MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0), prod : Seq.seq uint32 . inv'6 done'
      /\ inv'7 prod
      /\ resolve'0 done'.final
      /\ completed'0 done' /\ produces'1 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
    
  
  use seq.Seq
  
  predicate preservation'0 (iter : Iter'0.t_Iter uint32) (func : Closure'0.m_03_std_iterators__counter__qyClosure0) =
    [%#smap_inv25] forall s : Seq.seq uint32, e1 : uint32, e2 : uint32, f : borrowed Closure'0.m_03_std_iterators__counter__qyClosure0, b : uint32, i : Iter'0.t_Iter uint32 . inv'10 s
    /\ inv'2 e1 /\ inv'2 e2 /\ inv'11 f /\ inv'12 b /\ inv'3 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f (e1, Snapshot.new s) b  -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  use seq.Seq
  
  predicate next_precondition'0 (iter : Iter'0.t_Iter uint32) (func : Closure'0.m_03_std_iterators__counter__qyClosure0) (produced : Seq.seq uint32)
    
   =
    [%#smap_inv34] forall e : uint32, i : Iter'0.t_Iter uint32 . inv'2 e
    /\ inv'3 i /\ produces'0 iter (Seq.singleton e) i  -> precondition'0 func (e, Snapshot.new produced)
  
  predicate reinitialize'0 (_1 : ()) =
    [%#smap_inv24] forall iter : borrowed (Iter'0.t_Iter uint32), func : Closure'0.m_03_std_iterators__counter__qyClosure0 . inv'9 iter
    /\ inv'4 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq uint32) /\ preservation'0 iter.final func
  
  let rec map_inv'0 (self:Iter'0.t_Iter uint32) (func:Closure'0.m_03_std_iterators__counter__qyClosure0) (return'  (ret:MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0))= {[@expl:precondition] [%#siter10] inv'4 func}
    {[@expl:precondition] [%#siter9] inv'3 self}
    {[@expl:precondition] [%#siter8] preservation'0 self func}
    {[@expl:precondition] [%#siter7] reinitialize'0 ()}
    {[@expl:precondition] [%#siter6] forall e : uint32, i2 : Iter'0.t_Iter uint32 . inv'2 e /\ inv'3 i2
     -> produces'0 self (Seq.singleton e) i2  -> precondition'0 func (e, Snapshot.new (Seq.empty  : Seq.seq uint32))}
    any
    [ return' (result:MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0)-> {[%#siter12] inv'5 result}
      {[%#siter11] result = MapInv'0.C_MapInv self func (Snapshot.new (Seq.empty  : Seq.seq uint32))}
      (! return' {result}) ]
    
  
  let rec iter'0 (self:slice uint32) (return'  (ret:Iter'0.t_Iter uint32))= {[@expl:precondition] inv'1 self}
    any [ return' (result:Iter'0.t_Iter uint32)-> {[%#sslice5] view'3 result = self} (! return' {result}) ] 
  
  function view'2 (self : Vec'0.t_Vec uint32 (Global'0.t_Global)) : Seq.seq uint32 =
    [%#smodel15] view'0 self
  
  let rec deref'0 (self:Vec'0.t_Vec uint32 (Global'0.t_Global)) (return'  (ret:slice uint32))= {[@expl:precondition] inv'0 self}
    any [ return' (result:slice uint32)-> {inv'1 result} {[%#svec4] view'1 result = view'2 self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec counter (v:Vec'0.t_Vec uint32 (Global'0.t_Global)) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &cnt <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = deref'0 {v} (fun (_ret':slice uint32) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = iter'0 {_7} (fun (_ret':Iter'0.t_Iter uint32) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Borrow.borrow_mut <usize> {cnt}
          (fun (_ret':borrowed usize) ->  [ &_10 <- _ret' ]  [ &cnt <- _ret'.final ] s1)
      | s1 =  [ &_9 <- Closure'0.M_03_std_iterators__counter__qyClosure0 _10 ] s2
      | s2 = map_inv'0 {_5} {_9}
          (fun (_ret':MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0) ->
             [ &_4 <- _ret' ] 
            s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = collect'0 {_4} (fun (_ret':Vec'0.t_Vec uint32 (Global'0.t_Global)) ->  [ &x <- _ret' ] s1) | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators1] Seq.length (view'0 x) = Seq.length (view'0 v)} s1 | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators2] Seq.(==) (view'0 x) (view'0 v)} s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators3] UIntSize.to_int cnt = Seq.length (view'0 x)} s1 | s1 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & v : Vec'0.t_Vec uint32 (Global'0.t_Global) = v
    | & cnt : usize = any_l ()
    | & x : Vec'0.t_Vec uint32 (Global'0.t_Global) = any_l ()
    | & _4 : MapInv'0.t_MapInv (Iter'0.t_Iter uint32) uint32 Closure'0.m_03_std_iterators__counter__qyClosure0 = any_l ()
    | & _5 : Iter'0.t_Iter uint32 = any_l ()
    | & _7 : slice uint32 = any_l ()
    | & _9 : Closure'0.m_03_std_iterators__counter__qyClosure0 = any_l ()
    | & _10 : borrowed usize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__ops__range__Range
  type t_Range 'idx =
    | C_Range 'idx 'idx
  
  let rec t_Range < 'idx > (input:t_Range 'idx) (ret  (start:'idx) (end':'idx))= any
    [ good (start:'idx) (end':'idx)-> {C_Range start end' = input} (! ret {start} {end'}) ]
    
  
  function t_Range__end (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range _ a -> a
      end
  
  function t_Range__start (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range a _ -> a
      end
end
module M_03_std_iterators__sum_range [#"03_std_iterators.rs" 63 0 63 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 64 16 64 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 66 13 66 14
  let%span s03_std_iterators2 = "03_std_iterators.rs" 65 4 65 48
  let%span s03_std_iterators3 = "03_std_iterators.rs" 65 4 65 48
  let%span s03_std_iterators4 = "03_std_iterators.rs" 65 4 65 48
  let%span s03_std_iterators5 = "03_std_iterators.rs" 65 16 65 46
  let%span s03_std_iterators6 = "03_std_iterators.rs" 65 4 65 48
  let%span s03_std_iterators7 = "03_std_iterators.rs" 67 13 67 14
  let%span s03_std_iterators8 = "03_std_iterators.rs" 61 11 61 18
  let%span s03_std_iterators9 = "03_std_iterators.rs" 62 10 62 21
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span srange11 = "../../../../creusot-contracts/src/std/iter/range.rs" 22 8 28 9
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter14 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span srange15 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange16 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange17 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange18 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange19 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange20 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange21 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange22 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum23 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span srange24 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span sresolve25 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option isize)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option isize [inv'3 x] . inv'3 x = true
  
  use T_core__ops__range__Range as Range'0
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : borrowed (Range'0.t_Range isize))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Range'0.t_Range isize) [inv'2 x] . inv'2 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.IntSize
  
  function deep_model'0 (self : isize) : int =
    [%#snum23] IntSize.to_int self
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  predicate produces'0 (self : Range'0.t_Range isize) (visited : Seq.seq isize) (o : Range'0.t_Range isize) =
    [%#srange11] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  predicate inv'1 (_1 : Range'0.t_Range isize)
  
  function produces_trans'0 (a : Range'0.t_Range isize) (ab : Seq.seq isize) (b : Range'0.t_Range isize) (bc : Seq.seq isize) (c : Range'0.t_Range isize) : ()
    
  
  axiom produces_trans'0_spec : forall a : Range'0.t_Range isize, ab : Seq.seq isize, b : Range'0.t_Range isize, bc : Seq.seq isize, c : Range'0.t_Range isize . ([%#srange17] inv'1 a)
   -> ([%#srange18] inv'1 b)
   -> ([%#srange19] inv'1 c)
   -> ([%#srange20] produces'0 a ab b)
   -> ([%#srange21] produces'0 b bc c)  -> ([%#srange22] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : Range'0.t_Range isize) : ()
  
  axiom produces_refl'0_spec : forall self : Range'0.t_Range isize . ([%#srange15] inv'1 self)
   -> ([%#srange16] produces'0 self (Seq.empty  : Seq.seq isize) self)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Range'0.t_Range isize [inv'1 x] . inv'1 x = true
  
  predicate inv'0 (_1 : Seq.seq isize)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq isize [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate resolve'1 (self : borrowed (Range'0.t_Range isize)) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Range'0.t_Range isize)) =
    resolve'1 _1
  
  predicate completed'0 (self : borrowed (Range'0.t_Range isize)) =
    [%#srange24] resolve'1 self
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self.current)
    >= deep_model'0 (T_core__ops__range__Range.t_Range__end self.current)
  
  let rec next'0 (self:borrowed (Range'0.t_Range isize)) (return'  (ret:Option'0.t_Option isize))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:Option'0.t_Option isize)-> {inv'3 result}
      {[%#siter12] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate into_iter_post'0 (self : Range'0.t_Range isize) (res : Range'0.t_Range isize) =
    [%#siter14] self = res
  
  predicate into_iter_pre'0 (self : Range'0.t_Range isize) =
    [%#siter13] true
  
  let rec into_iter'0 (self:Range'0.t_Range isize) (return'  (ret:Range'0.t_Range isize))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#siter10] into_iter_pre'0 self}
    any
    [ return' (result:Range'0.t_Range isize)-> {inv'1 result}
      {[%#siter10] into_iter_post'0 self result}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec sum_range (n:isize) (return'  (ret:isize))= {[%#s03_std_iterators8] IntSize.to_int n >= 0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : isize) ] s1
      | s1 =  [ &_7 <- Range'0.C_Range ([%#s03_std_iterators1] (0 : isize)) n ] s2
      | s2 = into_iter'0 {_7} (fun (_ret':Range'0.t_Range isize) ->  [ &iter <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] Snapshot.new iter ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators3] Snapshot.new (Seq.empty  : Seq.seq isize) ] s1 | s1 = bb3 ]
      
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:loop invariant] [%#s03_std_iterators5] IntSize.to_int i = Seq.length (Snapshot.inner produced)
        /\ i <= n}
        {[@expl:loop invariant] [%#s03_std_iterators4] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = Borrow.borrow_mut <Range'0.t_Range isize> {iter}
              (fun (_ret':borrowed (Range'0.t_Range isize)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <Range'0.t_Range isize> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (Range'0.t_Range isize)) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':Option'0.t_Option isize) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = Option'0.C_None } (! bb9) | br1 (a:isize)-> {_18 = Option'0.C_Some a} (! bb8) ]  ]
          
        | bb8 = bb10
        | bb10 = s0
          [ s0 = Option'0.v_Some <isize> {_18} (fun (r0'0:isize) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators6] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb11 ]
          
        | bb11 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 = IntSize.add {i} {[%#s03_std_iterators7] (1 : isize)} (fun (_ret':isize) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
           ]
         ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : isize = any_l ()
    | & n : isize = n
    | & i : isize = any_l ()
    | & iter : Range'0.t_Range isize = any_l ()
    | & _7 : Range'0.t_Range isize = any_l ()
    | & iter_old : Snapshot.snap_ty (Range'0.t_Range isize) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq isize) = any_l ()
    | & _18 : Option'0.t_Option isize = any_l ()
    | & _19 : borrowed (Range'0.t_Range isize) = any_l ()
    | & _20 : borrowed (Range'0.t_Range isize) = any_l ()
    | & __creusot_proc_iter_elem : isize = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq isize) = any_l () ]
     [ return' (result:isize)-> {[@expl:postcondition] [%#s03_std_iterators9] result = n} (! return' {result}) ] 
end
module T_core__iter__adapters__enumerate__Enumerate
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Enumerate 'i =
    | C_Enumerate 'i usize
  
  let rec t_Enumerate < 'i > (input:t_Enumerate 'i) (ret  (iter:'i) (count:usize))= any
    [ good (iter:'i) (count:usize)-> {C_Enumerate iter count = input} (! ret {iter} {count}) ]
    
end
module M_03_std_iterators__enumerate_range [#"03_std_iterators.rs" 72 0 72 24]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 74 20 74 21
  let%span s03_std_iterators1 = "03_std_iterators.rs" 74 23 74 25
  let%span s03_std_iterators2 = "03_std_iterators.rs" 73 4 73 96
  let%span s03_std_iterators3 = "03_std_iterators.rs" 73 4 73 96
  let%span s03_std_iterators4 = "03_std_iterators.rs" 73 4 73 96
  let%span s03_std_iterators5 = "03_std_iterators.rs" 73 4 73 96
  let%span siter6 = "../../../../creusot-contracts/src/std/iter.rs" 155 16 155 105
  let%span siter7 = "../../../../creusot-contracts/src/std/iter.rs" 156 16 158 56
  let%span siter8 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span senumerate9 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 76 8 82 9
  let%span sops10 = "../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span srange12 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span srange13 = "../../../../creusot-contracts/src/std/iter/range.rs" 22 8 28 9
  let%span senumerate14 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 41
  let%span siter15 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter16 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span senumerate17 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 24
  let%span senumerate18 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 88 14 88 45
  let%span senumerate19 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 93 15 93 21
  let%span senumerate20 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 94 15 94 21
  let%span senumerate21 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 95 15 95 21
  let%span senumerate22 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 96 15 96 32
  let%span senumerate23 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 97 15 97 32
  let%span senumerate24 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 98 14 98 42
  let%span senumerate25 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 64 8 70 9
  let%span sresolve26 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span srange27 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange28 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange29 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange30 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange31 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange32 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange33 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange34 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum35 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span sinvariant36 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_core__option__Option as Option'0
  
  predicate inv'6 (_1 : Option'0.t_Option (usize, usize))
  
  axiom inv_axiom'6 [@rewrite] : forall x : Option'0.t_Option (usize, usize) [inv'6 x] . inv'6 x = true
  
  use T_core__ops__range__Range as Range'0
  
  predicate inv'5 (_1 : Range'0.t_Range usize)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Range'0.t_Range usize [inv'5 x] . inv'5 x = true
  
  use seq.Seq
  
  predicate inv'4 (_1 : Seq.seq usize)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Seq.seq usize [inv'4 x] . inv'4 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  function deep_model'0 (self : usize) : int =
    [%#snum35] UIntSize.to_int self
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  predicate produces'1 (self : Range'0.t_Range usize) (visited : Seq.seq usize) (o : Range'0.t_Range usize) =
    [%#srange13] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  function produces_trans'1 (a : Range'0.t_Range usize) (ab : Seq.seq usize) (b : Range'0.t_Range usize) (bc : Seq.seq usize) (c : Range'0.t_Range usize) : ()
    
  
  axiom produces_trans'1_spec : forall a : Range'0.t_Range usize, ab : Seq.seq usize, b : Range'0.t_Range usize, bc : Seq.seq usize, c : Range'0.t_Range usize . ([%#srange29] inv'5 a)
   -> ([%#srange30] inv'5 b)
   -> ([%#srange31] inv'5 c)
   -> ([%#srange32] produces'1 a ab b)
   -> ([%#srange33] produces'1 b bc c)  -> ([%#srange34] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'1 (self : Range'0.t_Range usize) : ()
  
  axiom produces_refl'1_spec : forall self : Range'0.t_Range usize . ([%#srange27] inv'5 self)
   -> ([%#srange28] produces'1 self (Seq.empty  : Seq.seq usize) self)
  
  use prelude.prelude.Borrow
  
  predicate inv'3 (_1 : borrowed (Range'0.t_Range usize))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Range'0.t_Range usize) [inv'3 x] . inv'3 x = true
  
  use T_core__iter__adapters__enumerate__Enumerate as Enumerate'0
  
  predicate inv'1 (_1 : Enumerate'0.t_Enumerate (Range'0.t_Range usize))
  
  predicate invariant'1 (self : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) =
    [%#sinvariant36] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 (_1 : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize)))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize)) [inv'2 x] . inv'2 x
  = invariant'1 x
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function iter'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) : Range'0.t_Range usize
  
  axiom iter'0_spec : forall self : Enumerate'0.t_Enumerate (Range'0.t_Range usize) . [%#senumerate14] inv'1 self
   -> inv'5 (iter'0 self)
  
  function n'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) : int
  
  use seq.Seq
  
  predicate produces'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) (visited : Seq.seq (usize, usize)) (o : Enumerate'0.t_Enumerate (Range'0.t_Range usize))
    
   =
    [%#senumerate9] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq usize . inv'4 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  function produces_trans'0 (a : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) (ab : Seq.seq (usize, usize)) (b : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) (bc : Seq.seq (usize, usize)) (c : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) : ()
    
  
  axiom produces_trans'0_spec : forall a : Enumerate'0.t_Enumerate (Range'0.t_Range usize), ab : Seq.seq (usize, usize), b : Enumerate'0.t_Enumerate (Range'0.t_Range usize), bc : Seq.seq (usize, usize), c : Enumerate'0.t_Enumerate (Range'0.t_Range usize) . ([%#senumerate19] inv'1 a)
   -> ([%#senumerate20] inv'1 b)
   -> ([%#senumerate21] inv'1 c)
   -> ([%#senumerate22] produces'0 a ab b)
   -> ([%#senumerate23] produces'0 b bc c)  -> ([%#senumerate24] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) : ()
  
  axiom produces_refl'0_spec : forall self : Enumerate'0.t_Enumerate (Range'0.t_Range usize) . ([%#senumerate17] inv'1 self)
   -> ([%#senumerate18] produces'0 self (Seq.empty  : Seq.seq (usize, usize)) self)
  
  predicate invariant'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Enumerate'0.t_Enumerate (Range'0.t_Range usize) [inv'1 x] . inv'1 x
  = (invariant'0 x
  /\ match x with
    | Enumerate'0.C_Enumerate iter count -> true
    end)
  
  predicate inv'0 (_1 : Seq.seq (usize, usize))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq (usize, usize) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate resolve'1 (self : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) =
    resolve'1 _1
  
  predicate resolve'2 (self : borrowed (Range'0.t_Range usize)) =
    [%#sresolve26] self.final = self.current
  
  predicate completed'0 (self : borrowed (Range'0.t_Range usize)) =
    [%#srange12] resolve'2 self
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self.current)
    >= deep_model'0 (T_core__ops__range__Range.t_Range__end self.current)
  
  predicate completed'1 (self : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) =
    [%#senumerate25] exists inner : borrowed (Range'0.t_Range usize) . inv'3 inner
    /\ inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'0 inner /\ n'0 self.current = n'0 self.final
  
  let rec next'0 (self:borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) (return'  (ret:Option'0.t_Option (usize, usize)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:Option'0.t_Option (usize, usize))-> {inv'6 result}
      {[%#siter11] match result with
        | Option'0.C_None -> completed'1 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq (usize, usize))) (ix : int) : (usize, usize)
    
   =
    [%#sops10] Seq.get (Snapshot.inner self) ix
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate into_iter_post'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) (res : Enumerate'0.t_Enumerate (Range'0.t_Range usize))
    
   =
    [%#siter16] self = res
  
  predicate into_iter_pre'0 (self : Enumerate'0.t_Enumerate (Range'0.t_Range usize)) =
    [%#siter15] true
  
  let rec into_iter'0 (self:Enumerate'0.t_Enumerate (Range'0.t_Range usize)) (return'  (ret:Enumerate'0.t_Enumerate (Range'0.t_Range usize)))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#siter8] into_iter_pre'0 self}
    any
    [ return' (result:Enumerate'0.t_Enumerate (Range'0.t_Range usize))-> {inv'1 result}
      {[%#siter8] into_iter_post'0 self result}
      (! return' {result}) ]
    
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  let rec enumerate'0 (self:Range'0.t_Range usize) (return'  (ret:Enumerate'0.t_Enumerate (Range'0.t_Range usize)))= {[@expl:precondition] inv'5 self}
    {[@expl:precondition] [%#siter7] forall s : Seq.seq usize, i : Range'0.t_Range usize . inv'4 s
    /\ inv'5 i /\ produces'1 self s i  -> Seq.length s < UIntSize.to_int v_MAX'0}
    {[@expl:precondition] [%#siter6] forall i : borrowed (Range'0.t_Range usize) . inv'3 i /\ completed'0 i
     -> produces'1 i.current (Seq.empty  : Seq.seq usize) i.final}
    any
    [ return' (result:Enumerate'0.t_Enumerate (Range'0.t_Range usize))-> {inv'1 result}
      {[%#siter8] iter'0 result = self /\ n'0 result = 0}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec enumerate_range (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_3 <- Range'0.C_Range ([%#s03_std_iterators0] (0 : usize)) ([%#s03_std_iterators1] (10 : usize)) ] s1
      | s1 = enumerate'0 {_3} (fun (_ret':Enumerate'0.t_Enumerate (Range'0.t_Range usize)) ->  [ &_2 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = into_iter'0 {_2} (fun (_ret':Enumerate'0.t_Enumerate (Range'0.t_Range usize)) ->  [ &iter <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] Snapshot.new iter ] s1 | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators3] Snapshot.new (Seq.empty  : Seq.seq (usize, usize)) ] s1 | s1 = bb4 ]
      
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:loop invariant] [%#s03_std_iterators4] forall i : int . 0 <= i
        /\ i < Seq.length (Snapshot.inner produced)
         -> (let (a, _) = index_logic'0 produced i in a) = (let (_, a) = index_logic'0 produced i in a)}
        {[@expl:loop invariant] [%#s03_std_iterators4] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = {inv'1 iter}
            Borrow.borrow_mut <Enumerate'0.t_Enumerate (Range'0.t_Range usize)> {iter}
              (fun (_ret':borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) ->
                 [ &_15 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &iter <- _ret'.final ] 
                s1)
          | s1 = {inv'1 _15.current}
            Borrow.borrow_final <Enumerate'0.t_Enumerate (Range'0.t_Range usize)> {_15.current} {Borrow.get_id _15}
              (fun (_ret':borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize))) ->
                 [ &_14 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &_15 <- { _15 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_14} (fun (_ret':Option'0.t_Option (usize, usize)) ->  [ &_13 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = s0
          [ s0 = {[@expl:type invariant] inv'2 _15} s1
          | s1 = -{resolve'0 _15}- s2
          | s2 = any
            [ br0 -> {_13 = Option'0.C_None } (! bb10) | br1 (a:(usize, usize))-> {_13 = Option'0.C_Some a} (! bb9) ]
             ]
          
        | bb9 = bb11
        | bb11 = s0
          [ s0 = Option'0.v_Some <(usize, usize)> {_13}
              (fun (r0'0:(usize, usize)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_18 <- [%#s03_std_iterators5] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb12 ]
          
        | bb12 = s0
          [ s0 =  [ &produced <- _18 ] s1
          | s1 =  [ &ix <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &x <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = bb5 ]
           ]
         ]
      
    | bb10 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & iter : Enumerate'0.t_Enumerate (Range'0.t_Range usize) = any_l ()
    | & _2 : Enumerate'0.t_Enumerate (Range'0.t_Range usize) = any_l ()
    | & _3 : Range'0.t_Range usize = any_l ()
    | & iter_old : Snapshot.snap_ty (Enumerate'0.t_Enumerate (Range'0.t_Range usize)) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & _13 : Option'0.t_Option (usize, usize) = any_l ()
    | & _14 : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize)) = any_l ()
    | & _15 : borrowed (Enumerate'0.t_Enumerate (Range'0.t_Range usize)) = any_l ()
    | & __creusot_proc_iter_elem : (usize, usize) = any_l ()
    | & _18 : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & ix : usize = any_l ()
    | & x : usize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__iter__adapters__zip__Zip
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Zip 'a 'b =
    | C_Zip 'a 'b usize usize usize
  
  let rec t_Zip < 'a > < 'b > (input:t_Zip 'a 'b) (ret  (a:'a) (b:'b) (index:usize) (len:usize) (a_len:usize))= any
    [ good (a:'a) (b:'b) (index:usize) (len:usize) (a_len:usize)-> {C_Zip a b index len a_len = input}
      (! ret {a} {b} {index} {len} {a_len}) ]
    
end
module M_03_std_iterators__my_reverse [#"03_std_iterators.rs" 94 0 94 37]
  type t
  
  let%span s03_std_iterators0 = "03_std_iterators.rs" 96 36 96 55
  let%span s03_std_iterators1 = "03_std_iterators.rs" 101 26 101 27
  let%span s03_std_iterators2 = "03_std_iterators.rs" 101 22 101 27
  let%span s03_std_iterators3 = "03_std_iterators.rs" 101 19 101 20
  let%span s03_std_iterators4 = "03_std_iterators.rs" 101 40 101 41
  let%span s03_std_iterators5 = "03_std_iterators.rs" 101 36 101 41
  let%span s03_std_iterators6 = "03_std_iterators.rs" 101 33 101 34
  let%span s03_std_iterators7 = "03_std_iterators.rs" 97 4 97 36
  let%span s03_std_iterators8 = "03_std_iterators.rs" 97 4 97 36
  let%span s03_std_iterators9 = "03_std_iterators.rs" 97 4 97 36
  let%span s03_std_iterators10 = "03_std_iterators.rs" 97 16 97 34
  let%span s03_std_iterators11 = "03_std_iterators.rs" 98 16 98 78
  let%span s03_std_iterators12 = "03_std_iterators.rs" 99 16 99 76
  let%span s03_std_iterators13 = "03_std_iterators.rs" 100 16 100 80
  let%span s03_std_iterators14 = "03_std_iterators.rs" 97 4 97 36
  let%span s03_std_iterators15 = "03_std_iterators.rs" 102 30 102 31
  let%span s03_std_iterators16 = "03_std_iterators.rs" 103 22 103 52
  let%span s03_std_iterators17 = "03_std_iterators.rs" 94 21 94 26
  let%span s03_std_iterators18 = "03_std_iterators.rs" 93 0 93 46
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 249 0 358 1
  let%span siter20 = "../../../../creusot-contracts/src/std/iter.rs" 166 27 166 48
  let%span siter21 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 214 1
  let%span siter22 = "../../../../creusot-contracts/src/std/iter.rs" 168 26 168 62
  let%span szip23 = "../../../../creusot-contracts/src/std/iter/zip.rs" 46 8 52 9
  let%span smodel24 = "../../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span ssnapshot25 = "../../../../creusot-contracts/src/snapshot.rs" 27 20 27 39
  let%span s03_std_iterators26 = "03_std_iterators.rs" 81 4 83 5
  let%span s03_std_iterators27 = "03_std_iterators.rs" 88 4 90 5
  let%span siter28 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span sslice29 = "../../../../creusot-contracts/src/std/slice.rs" 261 19 261 35
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 262 19 262 35
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 263 8 263 52
  let%span sops32 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sops33 = "../../../../creusot-contracts/src/logic/ops.rs" 53 8 53 32
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 41
  let%span sslice35 = "../../../../creusot-contracts/src/std/slice.rs" 30 14 30 42
  let%span smodel36 = "../../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span siter37 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span szip38 = "../../../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 41
  let%span szip39 = "../../../../creusot-contracts/src/std/iter/zip.rs" 23 4 23 41
  let%span siter40 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span szip41 = "../../../../creusot-contracts/src/std/iter/zip.rs" 57 15 57 24
  let%span szip42 = "../../../../creusot-contracts/src/std/iter/zip.rs" 58 14 58 45
  let%span szip43 = "../../../../creusot-contracts/src/std/iter/zip.rs" 65 15 65 21
  let%span szip44 = "../../../../creusot-contracts/src/std/iter/zip.rs" 66 15 66 21
  let%span szip45 = "../../../../creusot-contracts/src/std/iter/zip.rs" 67 15 67 21
  let%span szip46 = "../../../../creusot-contracts/src/std/iter/zip.rs" 68 15 68 32
  let%span szip47 = "../../../../creusot-contracts/src/std/iter/zip.rs" 69 15 69 32
  let%span szip48 = "../../../../creusot-contracts/src/std/iter/zip.rs" 70 14 70 42
  let%span srange49 = "../../../../creusot-contracts/src/std/iter/range.rs" 22 8 28 9
  let%span szip50 = "../../../../creusot-contracts/src/std/iter/zip.rs" 33 8 40 9
  let%span sresolve51 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span srange52 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange53 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange54 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange55 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange56 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange57 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange58 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange59 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum60 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span srange61 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span sslice62 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span sinvariant63 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sinvariant64 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sseq65 = "../../../../creusot-contracts/src/logic/seq.rs" 198 8 198 97
  let%span sboxed66 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  predicate inv'13 (_1 : t)
  
  predicate invariant'4 (self : t) =
    [%#sboxed66] inv'13 self
  
  predicate inv'12 (_1 : t)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t [inv'12 x] . inv'12 x = invariant'4 x
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'3 (self : Seq.seq t) =
    [%#sseq65] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'12 (Seq.get self i)
  
  predicate inv'11 (_1 : Seq.seq t)
  
  axiom inv_axiom'11 [@rewrite] : forall x : Seq.seq t [inv'11 x] . inv'11 x = invariant'3 x
  
  use prelude.prelude.UIntSize
  
  predicate inv'10 (_1 : usize)
  
  axiom inv_axiom'10 [@rewrite] : forall x : usize [inv'10 x] . inv'10 x = true
  
  use T_core__ops__range__Range as Range'0
  
  use prelude.prelude.Borrow
  
  predicate inv'9 (_1 : borrowed (Range'0.t_Range usize))
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed (Range'0.t_Range usize) [inv'9 x] . inv'9 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option (usize, usize))
  
  axiom inv_axiom'8 [@rewrite] : forall x : Option'0.t_Option (usize, usize) [inv'8 x] . inv'8 x = true
  
  use T_core__iter__adapters__zip__Zip as Zip'0
  
  predicate inv'7 (_1 : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) [inv'7 x] . inv'7 x
  = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  function deep_model'0 (self : usize) : int =
    [%#snum60] UIntSize.to_int self
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  predicate produces'1 (self : Range'0.t_Range usize) (visited : Seq.seq usize) (o : Range'0.t_Range usize) =
    [%#srange49] T_core__ops__range__Range.t_Range__end self = T_core__ops__range__Range.t_Range__end o
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    /\ (Seq.length visited > 0
     -> deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    <= deep_model'0 (T_core__ops__range__Range.t_Range__end o))
    /\ Seq.length visited
    = deep_model'0 (T_core__ops__range__Range.t_Range__start o)
    - deep_model'0 (T_core__ops__range__Range.t_Range__start self)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (T_core__ops__range__Range.t_Range__start self) + i)
  
  predicate inv'5 (_1 : Range'0.t_Range usize)
  
  function produces_trans'1 (a : Range'0.t_Range usize) (ab : Seq.seq usize) (b : Range'0.t_Range usize) (bc : Seq.seq usize) (c : Range'0.t_Range usize) : ()
    
  
  axiom produces_trans'1_spec : forall a : Range'0.t_Range usize, ab : Seq.seq usize, b : Range'0.t_Range usize, bc : Seq.seq usize, c : Range'0.t_Range usize . ([%#srange54] inv'5 a)
   -> ([%#srange55] inv'5 b)
   -> ([%#srange56] inv'5 c)
   -> ([%#srange57] produces'1 a ab b)
   -> ([%#srange58] produces'1 b bc c)  -> ([%#srange59] produces'1 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'1 (self : Range'0.t_Range usize) : ()
  
  axiom produces_refl'1_spec : forall self : Range'0.t_Range usize . ([%#srange52] inv'5 self)
   -> ([%#srange53] produces'1 self (Seq.empty  : Seq.seq usize) self)
  
  predicate inv'6 (_1 : Seq.seq usize)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Seq.seq usize [inv'6 x] . inv'6 x = true
  
  axiom inv_axiom'5 [@rewrite] : forall x : Range'0.t_Range usize [inv'5 x] . inv'5 x = true
  
  use prelude.prelude.Slice
  
  predicate inv'2 (_1 : slice t)
  
  predicate invariant'2 (self : slice t) =
    [%#sinvariant64] inv'2 self
  
  predicate inv'4 (_1 : slice t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : slice t [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (slice t)) =
    [%#sinvariant63] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (slice t))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (slice t) [inv'3 x] . inv'3 x = invariant'1 x
  
  use prelude.prelude.Slice
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  function view'2 (self : slice t) : Seq.seq t
  
  axiom view'2_spec : forall self : slice t . ([%#sslice35] view'2 self = Slice.id self)
  && ([%#sslice34] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'0 (self : slice t) =
    [%#sslice62] inv'11 (view'2 self)
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice t [inv'2 x] . inv'2 x = invariant'0 x
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'1 (_1 : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))
  
  function iterb'0 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) : Range'0.t_Range usize
  
  axiom iterb'0_spec : forall self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) . [%#szip39] inv'1 self
   -> inv'5 (iterb'0 self)
  
  function itera'0 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) : Range'0.t_Range usize
  
  axiom itera'0_spec : forall self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) . [%#szip38] inv'1 self
   -> inv'5 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) (visited : Seq.seq (usize, usize)) (o : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))
    
   =
    [%#szip23] exists p1 : Seq.seq usize, p2 : Seq.seq usize . inv'6 p1
    /\ inv'6 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'1 (iterb'0 self) p2 (iterb'0 o)
  
  function produces_trans'0 (a : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) (ab : Seq.seq (usize, usize)) (b : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) (bc : Seq.seq (usize, usize)) (c : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) : ()
    
  
  axiom produces_trans'0_spec : forall a : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize), ab : Seq.seq (usize, usize), b : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize), bc : Seq.seq (usize, usize), c : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) . ([%#szip43] inv'1 a)
   -> ([%#szip44] inv'1 b)
   -> ([%#szip45] inv'1 c)
   -> ([%#szip46] produces'0 a ab b)  -> ([%#szip47] produces'0 b bc c)  -> ([%#szip48] produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  function produces_refl'0 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) : ()
  
  axiom produces_refl'0_spec : forall self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) . ([%#szip41] inv'1 self)
   -> ([%#szip42] produces'0 self (Seq.empty  : Seq.seq (usize, usize)) self)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) [inv'1 x] . inv'1 x
  = true
  
  predicate inv'0 (_1 : Seq.seq (usize, usize))
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq (usize, usize) [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Reverse
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (slice t)) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (slice t)) =
    resolve'3 _1
  
  use seq.Seq
  
  function index_logic'1 [@inline:trivial] (self : slice t) (ix : usize) : t =
    [%#sops33] Seq.get (view'2 self) (UIntSize.to_int ix)
  
  function index_logic'0 [@inline:trivial] (self : slice t) (ix : int) : t =
    [%#sops32] Seq.get (view'2 self) ix
  
  use seq.Permut
  
  function view'0 (self : borrowed (slice t)) : Seq.seq t =
    [%#smodel24] view'2 self.current
  
  let rec swap'0 (self:borrowed (slice t)) (a:usize) (b:usize) (return'  (ret:()))= {[@expl:precondition] inv'3 self}
    {[@expl:precondition] [%#sslice30] UIntSize.to_int b < Seq.length (view'0 self)}
    {[@expl:precondition] [%#sslice29] UIntSize.to_int a < Seq.length (view'0 self)}
    any
    [ return' (result:())-> {[%#sslice31] Permut.exchange (view'2 self.final) (view'0 self) (UIntSize.to_int a) (UIntSize.to_int b)}
      (! return' {result}) ]
    
  
  use seq.Seq
  
  predicate resolve'2 (self : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) =
    resolve'2 _1
  
  predicate resolve'5 (_1 : usize) =
    true
  
  use seq.Seq
  
  predicate resolve'6 (self : borrowed (Range'0.t_Range usize)) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'4 (_1 : borrowed (Range'0.t_Range usize)) =
    resolve'6 _1
  
  predicate completed'1 (self : borrowed (Range'0.t_Range usize)) =
    [%#srange61] resolve'6 self
    /\ deep_model'0 (T_core__ops__range__Range.t_Range__start self.current)
    >= deep_model'0 (T_core__ops__range__Range.t_Range__end self.current)
  
  predicate completed'0 (self : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) =
    [%#szip50] exists a : borrowed (Range'0.t_Range usize), b : borrowed (Range'0.t_Range usize) . inv'9 a
    /\ inv'9 b
    /\ a.current = itera'0 self.current
    /\ b.current = iterb'0 self.current
    /\ a.final = itera'0 self.final
    /\ b.final = iterb'0 self.final
    /\ (completed'1 a /\ resolve'4 b
    \/ (exists x : usize . inv'10 x /\ produces'1 a.current (Seq.singleton x) a.final /\ resolve'5 x /\ completed'1 b))
  
  let rec next'0 (self:borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) (return'  (ret:Option'0.t_Option (usize, usize)))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (usize, usize))-> {inv'8 result}
      {[%#siter28] match result with
        | Option'0.C_None -> completed'0 self
        | Option'0.C_Some v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  predicate equiv_reverse_range'0 [#"03_std_iterators.rs" 87 0 87 81] (s1 : Seq.seq t) (s2 : Seq.seq t) (l : int) (u : int) (n : int)
    
   =
    [%#s03_std_iterators27] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 (n - i)
  
  predicate equiv_range'0 [#"03_std_iterators.rs" 80 0 80 65] (s1 : Seq.seq t) (s2 : Seq.seq t) (l : int) (u : int) =
    [%#s03_std_iterators26] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 i
  
  function view'4 (self : borrowed (slice t)) : Seq.seq t =
    [%#smodel36] view'0 self
  
  function view'1 (self : Snapshot.snap_ty (borrowed (slice t))) : Seq.seq t =
    [%#ssnapshot25] view'4 (Snapshot.inner self)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate into_iter_post'1 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) (res : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))
    
   =
    [%#siter40] self = res
  
  predicate into_iter_pre'1 (self : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) =
    [%#siter37] true
  
  let rec into_iter'0 (self:Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) (return'  (ret:Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [%#siter21] into_iter_pre'1 self}
    any
    [ return' (result:Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))-> {inv'1 result}
      {[%#siter21] into_iter_post'1 self result}
      (! return' {result}) ]
    
  
  predicate into_iter_post'0 (self : Range'0.t_Range usize) (res : Range'0.t_Range usize) =
    [%#siter40] self = res
  
  predicate into_iter_pre'0 (self : Range'0.t_Range usize) =
    [%#siter37] true
  
  let rec zip'0 (self:Range'0.t_Range usize) (other:Range'0.t_Range usize) (return'  (ret:Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)))= {[@expl:precondition] inv'5 other}
    {[@expl:precondition] inv'5 self}
    {[@expl:precondition] [%#siter20] into_iter_pre'0 other}
    any
    [ return' (result:Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))-> {inv'1 result}
      {[%#siter22] into_iter_post'0 other (iterb'0 result)}
      {[%#siter21] itera'0 result = self}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  function view'3 (self : slice t) : Seq.seq t =
    [%#smodel36] view'2 self
  
  let rec len'0 (self:slice t) (return'  (ret:usize))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:usize)-> {[%#sslice19] Seq.length (view'3 self) = UIntSize.to_int result} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec my_reverse (slice:borrowed (slice t)) (return'  (ret:()))= {[%#s03_std_iterators17] inv'3 slice}
    (! bb0
    [ bb0 = s0 [ s0 = len'0 {slice.current} (fun (_ret':usize) ->  [ &n <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &old_v <- [%#s03_std_iterators0] Snapshot.new slice ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UIntSize.eq {[%#s03_std_iterators1] (2 : usize)} {[%#s03_std_iterators2] (0 : usize)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = {[@expl:division by zero] [%#s03_std_iterators2] not _12} s2
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = UIntSize.div {n} {[%#s03_std_iterators1] (2 : usize)} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s1)
      | s1 =  [ &_9 <- Range'0.C_Range ([%#s03_std_iterators3] (0 : usize)) _10 ] s2
      | s2 = UIntSize.eq {[%#s03_std_iterators4] (2 : usize)} {[%#s03_std_iterators5] (0 : usize)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#s03_std_iterators5] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = UIntSize.div {n} {[%#s03_std_iterators4] (2 : usize)} (fun (_ret':usize) ->  [ &_14 <- _ret' ] s1)
      | s1 =  [ &_13 <- Range'0.C_Range ([%#s03_std_iterators6] (0 : usize)) _14 ] s2
      | s2 = zip'0 {_9} {_13}
          (fun (_ret':Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) ->  [ &_8 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0
      [ s0 = into_iter'0 {_8}
          (fun (_ret':Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) ->  [ &iter <- _ret' ] s1)
      | s1 = bb6 ]
      
    | bb6 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators7] Snapshot.new iter ] s1 | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators8] Snapshot.new (Seq.empty  : Seq.seq (usize, usize)) ] s1 | s1 = bb8 ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new slice ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:loop invariant] (Snapshot.inner old_9_0).final = slice.final}
        {[@expl:loop invariant] [%#s03_std_iterators13] equiv_reverse_range'0 (view'0 slice) (view'1 old_v) (UIntSize.to_int n
        - Seq.length (Snapshot.inner produced)) (UIntSize.to_int n) (UIntSize.to_int n - 1)}
        {[@expl:loop invariant] [%#s03_std_iterators12] equiv_reverse_range'0 (view'0 slice) (view'1 old_v) 0 (Seq.length (Snapshot.inner produced)) (UIntSize.to_int n
        - 1)}
        {[@expl:loop invariant] [%#s03_std_iterators11] equiv_range'0 (view'0 slice) (view'1 old_v) (Seq.length (Snapshot.inner produced)) (UIntSize.to_int n
        - Seq.length (Snapshot.inner produced))}
        {[@expl:loop invariant] [%#s03_std_iterators10] UIntSize.to_int n = Seq.length (view'0 slice)}
        {[@expl:loop invariant] [%#s03_std_iterators9] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators9] inv'1 iter}
        {[@expl:loop invariant] [%#s03_std_iterators9] inv'0 (Snapshot.inner produced)}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = Borrow.borrow_mut <Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)> {iter}
              (fun (_ret':borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) ->
                 [ &_31 <- _ret' ] 
                 [ &iter <- _ret'.final ] 
                s1)
          | s1 = Borrow.borrow_final
              <Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)>
              {_31.current}
              {Borrow.get_id _31}
              (fun (_ret':borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize))) ->
                 [ &_30 <- _ret' ] 
                 [ &_31 <- { _31 with current = _ret'.final ; } ] 
                s2)
          | s2 = next'0 {_30} (fun (_ret':Option'0.t_Option (usize, usize)) ->  [ &_29 <- _ret' ] s3)
          | s3 = bb11 ]
          
        | bb11 = s0
          [ s0 = -{resolve'0 _31}- s1
          | s1 = any
            [ br0 -> {_29 = Option'0.C_None } (! bb14) | br1 (a:(usize, usize))-> {_29 = Option'0.C_Some a} (! bb13) ]
             ]
          
        | bb13 = bb15
        | bb15 = s0
          [ s0 = Option'0.v_Some <(usize, usize)> {_29}
              (fun (r0'0:(usize, usize)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_34 <- [%#s03_std_iterators14] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb16 ]
          
        | bb16 = s0
          [ s0 =  [ &produced <- _34 ] s1
          | s1 =  [ &i <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &j <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = {inv'2 slice.current}
            Borrow.borrow_mut <slice t> {slice.current}
              (fun (_ret':borrowed (slice t)) ->
                 [ &_39 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &slice <- { slice with current = _ret'.final ; } ] 
                s4)
          | s4 = UIntSize.sub {n} {j} (fun (_ret':usize) ->  [ &_42 <- _ret' ] s5)
          | s5 = UIntSize.sub {_42} {[%#s03_std_iterators15] (1 : usize)} (fun (_ret':usize) ->  [ &_41 <- _ret' ] s6)
          | s6 = swap'0 {_39} {i} {_41} (fun (_ret':()) ->  [ &_38 <- _ret' ] s7)
          | s7 = bb17 ]
          
        | bb17 = s0
          [ s0 = {[@expl:assertion] [%#s03_std_iterators16] index_logic'0 (Snapshot.inner old_v).current (UIntSize.to_int n
            - UIntSize.to_int j
            - 1)
            = index_logic'1 slice.current i}
            s1
          | s1 = bb9 ]
           ]
         ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'3 slice} s1 | s1 = -{resolve'1 slice}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l ()
    | & slice : borrowed (slice t) = slice
    | & n : usize = any_l ()
    | & old_v : Snapshot.snap_ty (borrowed (slice t)) = any_l ()
    | & iter : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) = any_l ()
    | & _8 : Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize) = any_l ()
    | & _9 : Range'0.t_Range usize = any_l ()
    | & _10 : usize = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : Range'0.t_Range usize = any_l ()
    | & _14 : usize = any_l ()
    | & _16 : bool = any_l ()
    | & iter_old : Snapshot.snap_ty (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & _29 : Option'0.t_Option (usize, usize) = any_l ()
    | & _30 : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) = any_l ()
    | & _31 : borrowed (Zip'0.t_Zip (Range'0.t_Range usize) (Range'0.t_Range usize)) = any_l ()
    | & __creusot_proc_iter_elem : (usize, usize) = any_l ()
    | & _34 : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & i : usize = any_l ()
    | & j : usize = any_l ()
    | & _38 : () = any_l ()
    | & _39 : borrowed (slice t) = any_l ()
    | & _41 : usize = any_l ()
    | & _42 : usize = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (slice t)) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#s03_std_iterators18] Seq.(==) (view'2 slice.final) (Reverse.reverse (view'0 slice))}
      (! return' {result}) ]
    
end
