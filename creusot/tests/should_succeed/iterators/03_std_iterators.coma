module M_03_std_iterators__slice_iter [#"03_std_iterators.rs" 6 0 6 42]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 7 16 7 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 9 4 9 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 9 4 9 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 8 16 8 36
  let%span s03_std_iterators4 = "03_std_iterators.rs" 9 4 9 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 9 4 9 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 10 13 10 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 6 21 6 26
  let%span s03_std_iterators8 = "03_std_iterators.rs" 4 11 4 30
  let%span s03_std_iterators9 = "03_std_iterators.rs" 5 10 5 33
  let%span sslice10 = "../../../../creusot-contracts/src/std/slice.rs" 245 0 354 1
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span sslice12 = "../../../../creusot-contracts/src/std/slice.rs" 405 12 405 66
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span smodel14 = "../../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span siter15 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter16 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 411 14 411 45
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 409 4 409 10
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 416 15 416 32
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 417 15 417 32
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 42
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 414 4 414 10
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 96 14 96 41
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 97 14 97 80
  let%span sslice25 = "../../../../creusot-contracts/src/std/slice.rs" 398 20 398 61
  let%span sresolve26 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sslice27 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice28 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sops29 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sseq30 = "../../../../creusot-contracts/src/logic/seq.rs" 444 20 444 95
  let%span smodel31 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sinvariant32 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Slice
  
  type t_T'0
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  function view'2 (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice27] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice28] view'2 self = Slice.id self)
  
  use seq.Seq
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed33] inv'7 self
  
  predicate inv'9 (_1 : t_T'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_T'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq30] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_T'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : slice t_T'0) =
    [%#sslice34] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : slice t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : slice t_T'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'1 (self : slice t_T'0) =
    [%#sinvariant32] inv'6 self
  
  predicate inv'2 (_1 : slice t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  function view'1 (self : t_Iter'0) : slice t_T'0
  
  let rec iter'0 (self:slice t_T'0) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'2 self}
    any [ return' (result:t_Iter'0)-> {[%#sslice10] view'1 result = self} (! return' {result}) ] 
  
  predicate inv'0 (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Iter'0) =
    [%#siter15] true
  
  predicate into_iter_post'0 (self : t_Iter'0) (res : t_Iter'0) =
    [%#siter16] self = res
  
  let rec into_iter'0 (self:t_Iter'0) (return'  (ret:t_Iter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter11] into_iter_pre'0 self}
    any [ return' (result:t_Iter'0)-> {inv'0 result} {[%#siter11] into_iter_post'0 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function view'0 (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel14] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : slice t_T'0) (ix : int) : t_T'0 =
    [%#sops29] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice23] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'0 self))
  && ([%#sslice24] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0) =
    [%#sslice12] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#sslice22] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#sslice19] produces'0 a ab b)
   -> ([%#sslice20] produces'0 b bc c)  -> ([%#sslice21] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice18] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice17] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
  
  use seq.Seq
  
  predicate invariant'3 (self : t_T'0) =
    [%#sinvariant32] inv'7 self
  
  predicate inv'5 (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_T'0) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'0 (self : Seq.seq t_T'0) =
    [%#sseq30] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'1 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate resolve'1 (self : borrowed (t_Iter'0)) =
    [%#sresolve26] self.final = self.current
  
  function view'3 (self : borrowed (t_Iter'0)) : slice t_T'0 =
    [%#smodel31] view'1 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : borrowed (t_Iter'0)) =
    [%#sslice25] resolve'1 self /\ view'2 (view'3 self) = (Seq.empty  : Seq.seq t_T'0)
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Iter'0)) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter13] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : borrowed (t_Iter'0)) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec slice_iter'0 (slice:slice t_T'0) (return'  (ret:usize))= {[@expl:slice_iter 'slice' type invariant] [%#s03_std_iterators7] inv'2 slice}
    {[@expl:slice_iter requires] [%#s03_std_iterators8] Seq.length (view'0 slice) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = iter'0 {slice} (fun (_ret':t_Iter'0) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = into_iter'0 {_7} (fun (_ret':t_Iter'0) ->  [ &iter <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] Snapshot.new iter ] s1 | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators2] Snapshot.new (Seq.empty  : Seq.seq t_T'0) ] s1 | s1 = bb4 ]
      
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] [%#s03_std_iterators4] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators4] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators4] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] UIntSize.to_int i = Seq.length (Snapshot.inner produced)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = Borrow.borrow_mut <t_Iter'0> {iter}
              (fun (_ret':borrowed (t_Iter'0)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <t_Iter'0> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (t_Iter'0)) ->  [ &_19 <- _ret' ]  [ &_20 <- { _20 with current = _ret'.final } ] s2)
          | s2 = next'0 {_19} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = C_None'0 } (! bb10) | br1 (x0:t_T'0)-> {_18 = C_Some'0 x0} (! bb9) ]  ]
          
        | bb9 = bb11
        | bb11 = s0
          [ s0 = v_Some'0 {_18} (fun (r0'0:t_T'0) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators5] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb12 ]
          
        | bb12 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 = UIntSize.add {i} {[%#s03_std_iterators6] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s2)
          | s2 = bb5 ]
           ]
         ]
      
    | bb10 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & slice : slice t_T'0 = slice
    | & i : usize = any_l ()
    | & iter : t_Iter'0 = any_l ()
    | & _7 : t_Iter'0 = any_l ()
    | & iter_old : Snapshot.snap_ty (t_Iter'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_T'0) = any_l ()
    | & _18 : t_Option'0 = any_l ()
    | & _19 : borrowed (t_Iter'0) = any_l ()
    | & _20 : borrowed (t_Iter'0) = any_l ()
    | & __creusot_proc_iter_elem : t_T'0 = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq t_T'0) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:slice_iter ensures] [%#s03_std_iterators9] UIntSize.to_int result
      = Seq.length (view'0 slice)}
      (! return' {result}) ]
    
end
module M_03_std_iterators__vec_iter [#"03_std_iterators.rs" 17 0 17 41]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 18 16 18 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 20 4 20 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 20 4 20 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 19 16 19 36
  let%span s03_std_iterators4 = "03_std_iterators.rs" 20 4 20 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 20 4 20 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 21 13 21 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 17 19 17 22
  let%span s03_std_iterators8 = "03_std_iterators.rs" 15 11 15 28
  let%span s03_std_iterators9 = "03_std_iterators.rs" 16 10 16 31
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span sslice11 = "../../../../creusot-contracts/src/std/slice.rs" 405 12 405 66
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span smodel13 = "../../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span svec14 = "../../../../creusot-contracts/src/std/vec.rs" 205 20 205 24
  let%span svec15 = "../../../../creusot-contracts/src/std/vec.rs" 211 20 211 34
  let%span sslice16 = "../../../../creusot-contracts/src/std/slice.rs" 411 14 411 45
  let%span sslice17 = "../../../../creusot-contracts/src/std/slice.rs" 409 4 409 10
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 416 15 416 32
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 417 15 417 32
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 42
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 414 4 414 10
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 96 14 96 41
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 97 14 97 80
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 398 20 398 61
  let%span sresolve25 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span svec26 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sops27 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sseq28 = "../../../../creusot-contracts/src/logic/seq.rs" 444 20 444 95
  let%span smodel29 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sinvariant32 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed33 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span svec34 = "../../../../creusot-contracts/src/std/vec.rs" 65 20 65 41
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_T'0
  
  use seq.Seq
  
  function view'2 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : t_Vec'0 . [%#svec26] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  use seq.Seq
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed33] inv'7 self
  
  predicate inv'9 (_1 : t_T'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_T'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq28] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_T'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : t_Vec'0) =
    [%#svec34] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : t_Vec'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Vec'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#sinvariant32] inv'6 self
  
  predicate inv'2 (_1 : t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate into_iter_pre'0 (self : t_Vec'0) =
    [%#svec14] true
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  function view'0 (self : t_Vec'0) : Seq.seq t_T'0 =
    [%#smodel13] view'2 self
  
  use prelude.prelude.Slice
  
  function view'1 (self : t_Iter'0) : slice t_T'0
  
  use prelude.prelude.Slice
  
  function view'5 (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'5_spec : forall self : slice t_T'0 . ([%#sslice30] Seq.length (view'5 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice31] view'5 self = Slice.id self)
  
  function view'3 (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel13] view'5 self
  
  predicate into_iter_post'0 (self : t_Vec'0) (res : t_Iter'0) =
    [%#svec15] view'0 self = view'3 (view'1 res)
  
  let rec into_iter'0 (self:t_Vec'0) (return'  (ret:t_Iter'0))= {[@expl:into_iter 'self' type invariant] inv'2 self}
    {[@expl:into_iter requires] [%#siter10] into_iter_pre'0 self}
    any [ return' (result:t_Iter'0)-> {[%#siter10] into_iter_post'0 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : slice t_T'0) (ix : int) : t_T'0 =
    [%#sops27] Seq.get (view'5 self) ix
  
  function to_ref_seq'0 (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom to_ref_seq'0_spec : forall self : slice t_T'0 . ([%#sslice22] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'3 self))
  && ([%#sslice23] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0) =
    [%#sslice11] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#sslice21] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#sslice18] produces'0 a ab b)
   -> ([%#sslice19] produces'0 b bc c)  -> ([%#sslice20] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice17] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice16] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
  
  predicate inv'0 (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  predicate invariant'3 (self : t_T'0) =
    [%#sinvariant32] inv'7 self
  
  predicate inv'5 (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_T'0) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'0 (self : Seq.seq t_T'0) =
    [%#sseq28] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'1 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate resolve'1 (self : borrowed (t_Iter'0)) =
    [%#sresolve25] self.final = self.current
  
  function view'4 (self : borrowed (t_Iter'0)) : slice t_T'0 =
    [%#smodel29] view'1 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : borrowed (t_Iter'0)) =
    [%#sslice24] resolve'1 self /\ view'5 (view'4 self) = (Seq.empty  : Seq.seq t_T'0)
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Iter'0)) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter12] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : borrowed (t_Iter'0)) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec vec_iter'0 (vec:t_Vec'0) (return'  (ret:usize))= {[@expl:vec_iter 'vec' type invariant] [%#s03_std_iterators7] inv'2 vec}
    {[@expl:vec_iter requires] [%#s03_std_iterators8] Seq.length (view'0 vec) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = into_iter'0 {vec} (fun (_ret':t_Iter'0) ->  [ &iter <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] Snapshot.new iter ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators2] Snapshot.new (Seq.empty  : Seq.seq t_T'0) ] s1 | s1 = bb3 ]
      
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] [%#s03_std_iterators4] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators4] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators4] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] UIntSize.to_int i = Seq.length (Snapshot.inner produced)}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = Borrow.borrow_mut <t_Iter'0> {iter}
              (fun (_ret':borrowed (t_Iter'0)) ->  [ &_19 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <t_Iter'0> {_19.current} {Borrow.get_id _19}
              (fun (_ret':borrowed (t_Iter'0)) ->  [ &_18 <- _ret' ]  [ &_19 <- { _19 with current = _ret'.final } ] s2)
          | s2 = next'0 {_18} (fun (_ret':t_Option'0) ->  [ &_17 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _19}- s1
          | s1 = any [ br0 -> {_17 = C_None'0 } (! bb9) | br1 (x0:t_T'0)-> {_17 = C_Some'0 x0} (! bb8) ]  ]
          
        | bb8 = bb10
        | bb10 = s0
          [ s0 = v_Some'0 {_17} (fun (r0'0:t_T'0) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_22 <- [%#s03_std_iterators5] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb11 ]
          
        | bb11 = s0
          [ s0 =  [ &produced <- _22 ] s1
          | s1 = UIntSize.add {i} {[%#s03_std_iterators6] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
           ]
         ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & vec : t_Vec'0 = vec
    | & i : usize = any_l ()
    | & iter : t_Iter'0 = any_l ()
    | & iter_old : Snapshot.snap_ty (t_Iter'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_T'0) = any_l ()
    | & _17 : t_Option'0 = any_l ()
    | & _18 : borrowed (t_Iter'0) = any_l ()
    | & _19 : borrowed (t_Iter'0) = any_l ()
    | & __creusot_proc_iter_elem : t_T'0 = any_l ()
    | & _22 : Snapshot.snap_ty (Seq.seq t_T'0) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:vec_iter ensures] [%#s03_std_iterators9] UIntSize.to_int result
      = Seq.length (view'0 vec)}
      (! return' {result}) ]
    
end
module M_03_std_iterators__all_zero [#"03_std_iterators.rs" 28 0 28 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 30 4 30 7
  let%span s03_std_iterators1 = "03_std_iterators.rs" 30 4 30 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 29 16 29 85
  let%span s03_std_iterators3 = "03_std_iterators.rs" 30 4 30 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 30 4 30 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 31 13 31 14
  let%span s03_std_iterators6 = "03_std_iterators.rs" 26 10 26 33
  let%span s03_std_iterators7 = "03_std_iterators.rs" 27 10 27 64
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 175 26 175 42
  let%span svec9 = "../../../../creusot-contracts/src/std/vec.rs" 176 26 176 48
  let%span sslice10 = "../../../../creusot-contracts/src/std/slice.rs" 245 0 354 1
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span sops12 = "../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33
  let%span sslice13 = "../../../../creusot-contracts/src/std/slice.rs" 459 12 459 66
  let%span siter14 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span svec15 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span smodel16 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sops17 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  let%span sslice18 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 427 14 427 50
  let%span siter21 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter22 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sresolve23 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 465 15 465 24
  let%span sslice25 = "../../../../creusot-contracts/src/std/slice.rs" 466 14 466 45
  let%span sslice26 = "../../../../creusot-contracts/src/std/slice.rs" 463 4 463 10
  let%span sslice27 = "../../../../creusot-contracts/src/std/slice.rs" 471 15 471 21
  let%span sslice28 = "../../../../creusot-contracts/src/std/slice.rs" 472 15 472 21
  let%span sslice29 = "../../../../creusot-contracts/src/std/slice.rs" 473 15 473 21
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 474 15 474 32
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 475 15 475 32
  let%span sslice32 = "../../../../creusot-contracts/src/std/slice.rs" 476 14 476 42
  let%span sslice33 = "../../../../creusot-contracts/src/std/slice.rs" 469 4 469 10
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 87 14 87 41
  let%span sslice35 = "../../../../creusot-contracts/src/std/slice.rs" 88 14 88 84
  let%span sslice36 = "../../../../creusot-contracts/src/std/slice.rs" 452 20 452 61
  let%span sslice37 = "../../../../creusot-contracts/src/std/slice.rs" 437 20 437 36
  let%span sops38 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  predicate inv'2 (_1 : borrowed (t_Vec'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Vec'0) [inv'2 x] . inv'2 x = true
  
  use prelude.prelude.Slice
  
  predicate inv'3 (_1 : borrowed (slice usize))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (slice usize) [inv'3 x] . inv'3 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  function view'3 (self : slice usize) : Seq.seq usize
  
  axiom view'3_spec : forall self : slice usize . ([%#sslice18] Seq.length (view'3 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice19] view'3 self = Slice.id self)
  
  function view'2 (self : borrowed (slice usize)) : Seq.seq usize =
    [%#smodel16] view'3 self.current
  
  function view'0 (self : t_Vec'0) : Seq.seq usize
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec15] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  function view'1 (self : borrowed (t_Vec'0)) : Seq.seq usize =
    [%#smodel16] view'0 self.current
  
  let rec deref_mut'0 (self:borrowed (t_Vec'0)) (return'  (ret:borrowed (slice usize)))= {[@expl:deref_mut 'self' type invariant] inv'2 self}
    any
    [ return' (result:borrowed (slice usize))-> {inv'3 result}
      {[%#svec8] view'2 result = view'1 self}
      {[%#svec9] view'3 result.final = view'0 self.final}
      (! return' {result}) ]
    
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: opaque_ptr; t_IterMut__qy95zmarker'0: () }
  
  function view'4 (self : t_IterMut'0) : borrowed (slice usize)
  
  axiom view'4_spec : forall self : t_IterMut'0 . [%#sslice20] Seq.length (view'3 (view'4 self).final)
  = Seq.length (view'3 (view'4 self).current)
  
  let rec iter_mut'0 (self:borrowed (slice usize)) (return'  (ret:t_IterMut'0))= {[@expl:iter_mut 'self' type invariant] inv'3 self}
    any [ return' (result:t_IterMut'0)-> {[%#sslice10] view'4 result = self} (! return' {result}) ] 
  
  predicate inv'0 (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_IterMut'0) =
    [%#siter21] true
  
  predicate into_iter_post'0 (self : t_IterMut'0) (res : t_IterMut'0) =
    [%#siter22] self = res
  
  let rec into_iter'0 (self:t_IterMut'0) (return'  (ret:t_IterMut'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter11] into_iter_pre'0 self}
    any
    [ return' (result:t_IterMut'0)-> {inv'0 result} {[%#siter11] into_iter_post'0 self result} (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (slice usize)) =
    [%#sresolve23] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (slice usize)) =
    resolve'5 _1
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq (borrowed usize))) (ix : int) : borrowed usize
    
   =
    [%#sops12] Seq.get (Snapshot.inner self) ix
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'2 [@inline:trivial] (self : slice usize) (ix : int) : usize =
    [%#sops38] Seq.get (view'3 self) ix
  
  function to_mut_seq'0 (self : borrowed (slice usize)) : Seq.seq (borrowed usize)
  
  axiom to_mut_seq'0_spec : forall self : borrowed (slice usize) . ([%#sslice34] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice35] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = Borrow.borrow_logic (index_logic'2 self.current i) (index_logic'2 self.final i) (Borrow.inherit_id (Borrow.get_id self) i))
  
  predicate produces'0 (self : t_IterMut'0) (visited : Seq.seq (borrowed usize)) (tl : t_IterMut'0) =
    [%#sslice13] to_mut_seq'0 (view'4 self) = Seq.(++) visited (to_mut_seq'0 (view'4 tl))
  
  function produces_trans'0 (a : t_IterMut'0) (ab : Seq.seq (borrowed usize)) (b : t_IterMut'0) (bc : Seq.seq (borrowed usize)) (c : t_IterMut'0) : ()
    
   =
    [%#sslice33] ()
  
  axiom produces_trans'0_spec : forall a : t_IterMut'0, ab : Seq.seq (borrowed usize), b : t_IterMut'0, bc : Seq.seq (borrowed usize), c : t_IterMut'0 . ([%#sslice27] inv'0 a)
   -> ([%#sslice28] inv'0 b)
   -> ([%#sslice29] inv'0 c)
   -> ([%#sslice30] produces'0 a ab b)
   -> ([%#sslice31] produces'0 b bc c)  -> ([%#sslice32] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IterMut'0) : () =
    [%#sslice26] ()
  
  axiom produces_refl'0_spec : forall self : t_IterMut'0 . ([%#sslice24] inv'0 self)
   -> ([%#sslice25] produces'0 self (Seq.empty  : Seq.seq (borrowed usize)) self)
  
  predicate inv'1 (_1 : Seq.seq (borrowed usize))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (borrowed usize) [inv'1 x] . inv'1 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed usize)
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x = true
  
  predicate resolve'6 (self : borrowed (t_IterMut'0)) =
    [%#sresolve23] self.final = self.current
  
  function view'5 (self : borrowed (t_IterMut'0)) : borrowed (slice usize) =
    [%#smodel16] view'4 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : borrowed (t_IterMut'0)) =
    [%#sslice36] resolve'6 self /\ view'3 (view'5 self).current = (Seq.empty  : Seq.seq usize)
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_IterMut'0)) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'4 result}
      {[%#siter14] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'1 (_1 : borrowed (t_IterMut'0)) =
    resolve'6 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:borrowed usize))= any
    [ good (field_0:borrowed usize)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : borrowed usize [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
    
  
  predicate resolve'7 (self : borrowed usize) =
    [%#sresolve23] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed usize) =
    resolve'7 _1
  
  predicate resolve'8 (self : t_IterMut'0) =
    [%#sslice37] (view'4 self).current = (view'4 self).final
  
  predicate resolve'3 (_1 : t_IterMut'0) =
    resolve'8 _1
  
  predicate resolve'9 (self : borrowed (t_Vec'0)) =
    [%#sresolve23] self.final = self.current
  
  predicate resolve'4 (_1 : borrowed (t_Vec'0)) =
    resolve'9 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'0) (ix : int) : usize =
    [%#sops17] Seq.get (view'0 self) ix
  
  meta "compute_max_steps" 1000000
  
  let rec all_zero'0 (v:borrowed (t_Vec'0)) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <t_Vec'0> {v.current} {Borrow.get_id v}
          (fun (_ret':borrowed (t_Vec'0)) ->  [ &_8 <- _ret' ]  [ &v <- { v with current = _ret'.final } ] s1)
      | s1 = deref_mut'0 {_8} (fun (_ret':borrowed (slice usize)) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <slice usize> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed (slice usize)) ->  [ &_6 <- _ret' ]  [ &_7 <- { _7 with current = _ret'.final } ] s1)
      | s1 = iter_mut'0 {_6} (fun (_ret':t_IterMut'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 = into_iter'0 {_5} (fun (_ret':t_IterMut'0) ->  [ &iter <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = -{resolve'0 _7}- s1 | s1 =  [ &iter_old <- [%#s03_std_iterators0] Snapshot.new iter ] s2 | s2 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators1] Snapshot.new (Seq.empty  : Seq.seq (borrowed usize)) ] s1
      | s1 = bb5 ]
      
    | bb5 = bb6
    | bb6 = bb6
      [ bb6 = {[@expl:for invariant] [%#s03_std_iterators3] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators3] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators3] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators2] forall i : int . 0 <= i
        /\ i < Seq.length (Snapshot.inner produced)  -> UIntSize.to_int (index_logic'0 produced i).final = 0}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = Borrow.borrow_mut <t_IterMut'0> {iter}
              (fun (_ret':borrowed (t_IterMut'0)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <t_IterMut'0> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (t_IterMut'0)) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb8 ]
          
        | bb8 = s0
          [ s0 = -{resolve'1 _20}- s1
          | s1 = any [ br0 -> {_18 = C_None'0 } (! bb11) | br1 (x0:borrowed usize)-> {_18 = C_Some'0 x0} (! bb10) ]  ]
          
        | bb10 = bb12
        | bb12 = s0
          [ s0 = v_Some'0 {_18} (fun (r0'0:borrowed usize) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators4] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb13 ]
          
        | bb13 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 =  [ &x <- __creusot_proc_iter_elem ] s2
          | s2 =  [ &x <- { x with current = ([%#s03_std_iterators5] (0 : usize)) } ] s3
          | s3 = -{resolve'2 x}- s4
          | s4 = bb6 ]
           ]
         ]
      
    | bb11 = s0 [ s0 = -{resolve'3 iter}- s1 | s1 = -{resolve'4 v}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l ()
    | & v : borrowed (t_Vec'0) = v
    | & iter : t_IterMut'0 = any_l ()
    | & _5 : t_IterMut'0 = any_l ()
    | & _6 : borrowed (slice usize) = any_l ()
    | & _7 : borrowed (slice usize) = any_l ()
    | & _8 : borrowed (t_Vec'0) = any_l ()
    | & iter_old : Snapshot.snap_ty (t_IterMut'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (borrowed usize)) = any_l ()
    | & _18 : t_Option'0 = any_l ()
    | & _19 : borrowed (t_IterMut'0) = any_l ()
    | & _20 : borrowed (t_IterMut'0) = any_l ()
    | & __creusot_proc_iter_elem : borrowed usize = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq (borrowed usize)) = any_l ()
    | & x : borrowed usize = any_l () ]
    
    [ return' (result:())-> {[@expl:all_zero ensures #0] [%#s03_std_iterators6] Seq.length (view'0 v.final)
      = Seq.length (view'1 v)}
      {[@expl:all_zero ensures #1] [%#s03_std_iterators7] forall i : int . 0 <= i /\ i < Seq.length (view'1 v)
       -> UIntSize.to_int (index_logic'1 v.final i) = 0}
      (! return' {result}) ]
    
end
module M_03_std_iterators__skip_take [#"03_std_iterators.rs" 35 0 35 48]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 38 20 38 31
  let%span s03_std_iterators1 = "03_std_iterators.rs" 35 30 35 34
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span siter3 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span stake4 = "../../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span stake5 = "../../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span sskip6 = "../../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span sskip7 = "../../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip8 = "../../../../creusot-contracts/src/std/iter/skip.rs" 48 12 54 39
  let%span sskip9 = "../../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip10 = "../../../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sresolve11 = "../../../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sskip12 = "../../../../creusot-contracts/src/std/iter/skip.rs" 73 15 73 24
  let%span sskip13 = "../../../../creusot-contracts/src/std/iter/skip.rs" 74 14 74 45
  let%span sskip14 = "../../../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 21
  let%span sskip15 = "../../../../creusot-contracts/src/std/iter/skip.rs" 80 15 80 21
  let%span sskip16 = "../../../../creusot-contracts/src/std/iter/skip.rs" 81 15 81 21
  let%span sskip17 = "../../../../creusot-contracts/src/std/iter/skip.rs" 82 15 82 32
  let%span sskip18 = "../../../../creusot-contracts/src/std/iter/skip.rs" 83 15 83 32
  let%span sskip19 = "../../../../creusot-contracts/src/std/iter/skip.rs" 84 14 84 42
  let%span stake20 = "../../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake21 = "../../../../creusot-contracts/src/std/iter/take.rs" 56 12 57 92
  let%span sinvariant22 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span stake23 = "../../../../creusot-contracts/src/std/iter/take.rs" 71 15 71 24
  let%span stake24 = "../../../../creusot-contracts/src/std/iter/take.rs" 72 14 72 45
  let%span stake25 = "../../../../creusot-contracts/src/std/iter/take.rs" 77 15 77 21
  let%span stake26 = "../../../../creusot-contracts/src/std/iter/take.rs" 78 15 78 21
  let%span stake27 = "../../../../creusot-contracts/src/std/iter/take.rs" 79 15 79 21
  let%span stake28 = "../../../../creusot-contracts/src/std/iter/take.rs" 80 15 80 32
  let%span stake29 = "../../../../creusot-contracts/src/std/iter/take.rs" 81 15 81 32
  let%span stake30 = "../../../../creusot-contracts/src/std/iter/take.rs" 82 14 82 42
  let%span stake31 = "../../../../creusot-contracts/src/std/iter/take.rs" 24 14 24 68
  let%span stake32 = "../../../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span sseq33 = "../../../../creusot-contracts/src/logic/seq.rs" 444 20 444 95
  let%span siter34 = "../../../../creusot-contracts/src/std/iter.rs" 38 15 38 24
  let%span siter35 = "../../../../creusot-contracts/src/std/iter.rs" 39 14 39 45
  let%span siter36 = "../../../../creusot-contracts/src/std/iter.rs" 43 15 43 21
  let%span siter37 = "../../../../creusot-contracts/src/std/iter.rs" 44 15 44 21
  let%span siter38 = "../../../../creusot-contracts/src/std/iter.rs" 45 15 45 21
  let%span siter39 = "../../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter40 = "../../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter41 = "../../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sresolve42 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sboxed43 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_I'0
  
  predicate inv'2 (_1 : t_I'0)
  
  use prelude.prelude.UIntSize
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: usize }
  
  predicate inv'3 (_1 : t_Take'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Take'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'2 iter
    end
  
  function iter'0 (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake4] inv'3 self  -> inv'2 (iter'0 self)
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  function n'0 (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake5] n'0 self >= 0 /\ n'0 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  let rec take'0 (self:t_I'0) (n:usize) (return'  (ret:t_Take'0))= {[@expl:take 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Take'0)-> {inv'3 result}
      {[%#siter2] iter'0 result = self /\ n'0 result = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_Take'0; t_Skip__n'0: usize }
  
  predicate inv'0 (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'3 iter
    end
  
  function iter'1 (self : t_Skip'0) : t_Take'0
  
  axiom iter'1_spec : forall self : t_Skip'0 . [%#sskip6] inv'0 self  -> inv'3 (iter'1 self)
  
  function n'1 (self : t_Skip'0) : int
  
  axiom n'1_spec : forall self : t_Skip'0 . [%#sskip7] n'1 self >= 0 /\ n'1 self <= UIntSize.to_int (v_MAX'0 : usize)
  
  let rec skip'0 (self:t_Take'0) (n:usize) (return'  (ret:t_Skip'0))= {[@expl:skip 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Skip'0)-> {inv'0 result}
      {[%#siter2] iter'1 result = self /\ n'1 result = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : borrowed (t_Skip'0)) =
    [%#sinvariant22] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 (_1 : borrowed (t_Skip'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (t_Skip'0) [inv'4 x] . inv'4 x = invariant'0 x
  
  type t_Item'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'7 (_1 : t_Item'0)
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate invariant'3 (self : t_Item'0) =
    [%#sboxed43] inv'7 self
  
  predicate inv'8 (_1 : t_Item'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Item'0 [inv'8 x] . inv'8 x = invariant'3 x
  
  predicate invariant'1 (self : Seq.seq t_Item'0) =
    [%#sseq33] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'8 (Seq.get self i)
  
  predicate inv'5 (_1 : Seq.seq t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Seq.seq t_Item'0 [inv'5 x] . inv'5 x = invariant'1 x
  
  use seq.Seq
  
  predicate produces'2 (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'2 (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  axiom produces_trans'2_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter36] inv'2 a)
   -> ([%#siter37] inv'2 b)
   -> ([%#siter38] inv'2 c)
   -> ([%#siter39] produces'2 a ab b)
   -> ([%#siter40] produces'2 b bc c)  -> ([%#siter41] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 (self : t_I'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_I'0 . ([%#siter34] inv'2 self)
   -> ([%#siter35] produces'2 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate produces'1 (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0) =
    [%#stake20] n'0 self = n'0 o + Seq.length visited /\ produces'2 (iter'0 self) visited (iter'0 o)
  
  function produces_trans'1 (a : t_Take'0) (ab : Seq.seq t_Item'0) (b : t_Take'0) (bc : Seq.seq t_Item'0) (c : t_Take'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_Take'0, ab : Seq.seq t_Item'0, b : t_Take'0, bc : Seq.seq t_Item'0, c : t_Take'0 . ([%#stake25] inv'3 a)
   -> ([%#stake26] inv'3 b)
   -> ([%#stake27] inv'3 c)
   -> ([%#stake28] produces'1 a ab b)
   -> ([%#stake29] produces'1 b bc c)  -> ([%#stake30] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Take'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Take'0 . ([%#stake23] inv'3 self)
   -> ([%#stake24] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use seq.Seq
  
  predicate resolve'4 (_1 : t_Item'0)
  
  predicate produces'0 (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0) =
    [%#sskip9] visited = (Seq.empty  : Seq.seq t_Item'0) /\ self = o
    \/ n'1 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . inv'5 s
    /\ Seq.length s = n'1 self
    /\ produces'1 (iter'1 self) (Seq.(++) s visited) (iter'1 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i)))
  
  function produces_trans'0 (a : t_Skip'0) (ab : Seq.seq t_Item'0) (b : t_Skip'0) (bc : Seq.seq t_Item'0) (c : t_Skip'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Skip'0, ab : Seq.seq t_Item'0, b : t_Skip'0, bc : Seq.seq t_Item'0, c : t_Skip'0 . ([%#sskip14] inv'0 a)
   -> ([%#sskip15] inv'0 b)
   -> ([%#sskip16] inv'0 c)
   -> ([%#sskip17] produces'0 a ab b)
   -> ([%#sskip18] produces'0 b bc c)  -> ([%#sskip19] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Skip'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Skip'0 . ([%#sskip12] inv'0 self)
   -> ([%#sskip13] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate invariant'2 (self : borrowed (t_Take'0)) =
    [%#sinvariant22] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'6 (_1 : borrowed (t_Take'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (t_Take'0) [inv'6 x] . inv'6 x = invariant'2 x
  
  predicate resolve'8 (self : borrowed (t_Take'0)) =
    [%#sresolve42] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed (t_Take'0)) =
    resolve'8 _1
  
  function iter_mut'0 (self : borrowed (t_Take'0)) : borrowed t_I'0
  
  axiom iter_mut'0_spec : forall self : borrowed (t_Take'0) . [%#stake31] iter'0 self.current
  = (iter_mut'0 self).current
  /\ iter'0 self.final = (iter_mut'0 self).final
  
  predicate completed'2 (self : borrowed t_I'0)
  
  predicate completed'1 (self : borrowed (t_Take'0)) =
    [%#stake21] n'0 self.current = 0 /\ resolve'6 self
    \/ n'0 self.current > 0 /\ n'0 self.current = n'0 self.final + 1 /\ completed'2 (iter_mut'0 self)
  
  predicate completed'0 (self : borrowed (t_Skip'0)) =
    [%#sskip8] n'1 self.final = 0
    /\ (exists s : Seq.seq t_Item'0, i : borrowed (t_Take'0) . inv'5 s
    /\ inv'6 i
    /\ Seq.length s <= n'1 self.current
    /\ produces'1 (iter'1 self.current) s i.current
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i))
    /\ completed'1 i /\ i.final = iter'1 self.final)
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Skip'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {inv'1 result}
      {[%#siter3] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'9 (_1 : t_I'0)
  
  predicate resolve'7 (self : t_Take'0) =
    [%#stake32] resolve'9 (iter'0 self)
  
  predicate resolve'5 (_1 : t_Take'0) =
    resolve'7 _1
  
  predicate resolve'2 (self : t_Skip'0) =
    [%#sskip10] resolve'5 (iter'1 self)
  
  predicate resolve'0 (_1 : t_Skip'0) =
    resolve'2 _1
  
  predicate resolve'3 (self : t_Option'0) =
    [%#sresolve11] match self with
      | C_Some'0 x -> resolve'4 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_1 : t_Option'0) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec skip_take'0 (iter:t_I'0) (n:usize) (return'  (ret:()))= {[@expl:skip_take 'iter' type invariant] [%#s03_std_iterators1] inv'2 iter}
    (! bb0
    [ bb0 = s0 [ s0 = take'0 {iter} {n} (fun (_ret':t_Take'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = skip'0 {_6} {n} (fun (_ret':t_Skip'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'0 _5}
        Borrow.borrow_mut <t_Skip'0> {_5}
          (fun (_ret':borrowed (t_Skip'0)) ->  [ &_4 <- _ret' ] -{inv'0 _ret'.final}-  [ &_5 <- _ret'.final ] s1)
      | s1 = next'0 {_4} (fun (_ret':t_Option'0) ->  [ &res <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'1 res} s3
      | s3 = -{resolve'1 res}- s4
      | s4 = bb4 ]
      
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators0] res = C_None'0} s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & iter : t_I'0 = iter
    | & n : usize = n
    | & res : t_Option'0 = any_l ()
    | & _4 : borrowed (t_Skip'0) = any_l ()
    | & _5 : t_Skip'0 = any_l ()
    | & _6 : t_Take'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__counter [#"03_std_iterators.rs" 41 0 41 27]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 42 18 42 19
  let%span s03_std_iterators1 = "03_std_iterators.rs" 56 20 56 40
  let%span s03_std_iterators2 = "03_std_iterators.rs" 57 20 57 33
  let%span s03_std_iterators3 = "03_std_iterators.rs" 58 20 58 36
  let%span svec4 = "../../../../creusot-contracts/src/std/vec.rs" 169 26 169 42
  let%span sslice5 = "../../../../creusot-contracts/src/std/slice.rs" 245 0 354 1
  let%span s03_std_iterators6 = "03_std_iterators.rs" 50 23 50 24
  let%span s03_std_iterators7 = "03_std_iterators.rs" 47 23 47 65
  let%span s03_std_iterators8 = "03_std_iterators.rs" 48 22 48 89
  let%span siter9 = "../../../../creusot-contracts/src/std/iter.rs" 59 21 59 25
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 59 27 59 31
  let%span siter11 = "../../../../creusot-contracts/src/std/iter.rs" 53 15 55 69
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 56 15 56 51
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 57 15 57 70
  let%span siter14 = "../../../../creusot-contracts/src/std/iter.rs" 59 4 62 61
  let%span siter15 = "../../../../creusot-contracts/src/std/iter.rs" 58 14 58 88
  let%span siter16 = "../../../../creusot-contracts/src/std/iter.rs" 172 26 174 81
  let%span svec17 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span smodel18 = "../../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 411 14 411 45
  let%span sslice20 = "../../../../creusot-contracts/src/std/slice.rs" 409 4 409 10
  let%span sslice21 = "../../../../creusot-contracts/src/std/slice.rs" 416 15 416 32
  let%span sslice22 = "../../../../creusot-contracts/src/std/slice.rs" 417 15 417 32
  let%span sslice23 = "../../../../creusot-contracts/src/std/slice.rs" 418 14 418 42
  let%span sslice24 = "../../../../creusot-contracts/src/std/slice.rs" 414 4 414 10
  let%span sslice25 = "../../../../creusot-contracts/src/std/slice.rs" 405 12 405 66
  let%span smap_inv26 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 159 12 163 47
  let%span smap_inv27 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 146 12 151 71
  let%span smap_inv28 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv29 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 41 8 54 9
  let%span svec30 = "../../../../creusot-contracts/src/std/vec.rs" 285 20 285 32
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice32 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span sresolve33 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sops34 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops35 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops36 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops37 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops38 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops39 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops40 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span sslice41 = "../../../../creusot-contracts/src/std/slice.rs" 96 14 96 41
  let%span sslice42 = "../../../../creusot-contracts/src/std/slice.rs" 97 14 97 80
  let%span sslice43 = "../../../../creusot-contracts/src/std/slice.rs" 398 20 398 61
  let%span smap_inv44 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 123 12 125 63
  let%span smap_inv45 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 62 8 62 50
  let%span smap_inv46 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 23 15 23 24
  let%span smap_inv47 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 24 14 24 45
  let%span smap_inv48 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 21
  let%span smap_inv49 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 30 15 30 21
  let%span smap_inv50 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 31 15 31 21
  let%span smap_inv51 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 32 15 32 32
  let%span smap_inv52 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 33 15 33 32
  let%span smap_inv53 = "../../../../creusot-contracts/src/std/iter/map_inv.rs" 34 14 34 42
  let%span sops54 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span smodel55 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span sinvariant56 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UInt32
  
  predicate inv'1 (_1 : slice uint32)
  
  axiom inv_axiom'1 [@rewrite] : forall x : slice uint32 [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  function view'4 (self : slice uint32) : Seq.seq uint32
  
  axiom view'4_spec : forall self : slice uint32 . ([%#sslice31] Seq.length (view'4 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice32] view'4 self = Slice.id self)
  
  function view'1 (self : slice uint32) : Seq.seq uint32 =
    [%#smodel18] view'4 self
  
  function view'0 (self : t_Vec'0) : Seq.seq uint32
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec17] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  function view'2 (self : t_Vec'0) : Seq.seq uint32 =
    [%#smodel18] view'0 self
  
  let rec deref'0 (self:t_Vec'0) (return'  (ret:slice uint32))= {[@expl:deref 'self' type invariant] inv'0 self}
    any [ return' (result:slice uint32)-> {inv'1 result} {[%#svec4] view'1 result = view'2 self} (! return' {result}) ] 
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: opaque_ptr; t_Iter__qy95zmarker'0: () }
  
  function view'3 (self : t_Iter'0) : slice uint32
  
  let rec iter'0 (self:slice uint32) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'1 self}
    any [ return' (result:t_Iter'0)-> {[%#sslice5] view'3 result = self} (! return' {result}) ] 
  
  type closure0'1  =
    { field_0'0: borrowed usize }
  
  predicate resolve'2 (self : borrowed closure0'1) =
    [%#sresolve33] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed closure0'1) =
    resolve'2 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate postcondition_once'0 (self : closure0'1) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) (result : uint32)
    
   =
    [%#s03_std_iterators8] let (x, _prod) = args in UIntSize.to_int (self.field_0'0).final
    = UIntSize.to_int (self.field_0'0).current + 1
    /\ UIntSize.to_int (self.field_0'0).final = Seq.length (Snapshot.inner _prod) + 1 /\ result = x
  
  predicate resolve'8 (self : borrowed usize) =
    [%#sresolve33] self.final = self.current
  
  predicate resolve'7 (_1 : borrowed usize) =
    resolve'8 _1
  
  predicate resolve'4 (_1 : closure0'1) =
    resolve'7 _1.field_0'0
  
  predicate unnest'0 (self : closure0'1) (_2 : closure0'1) =
    (_2.field_0'0).final = (self.field_0'0).final
  
  predicate postcondition_mut'0 (self : closure0'1) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) (result_state : closure0'1) (result : uint32)
    
   =
    (let (x, _prod) = args in UIntSize.to_int (result_state.field_0'0).current
    = UIntSize.to_int (self.field_0'0).current + 1
    /\ UIntSize.to_int (result_state.field_0'0).current = Seq.length (Snapshot.inner _prod) + 1 /\ result = x)
    /\ unnest'0 self result_state
  
  function fn_mut_once'0 (self : closure0'1) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) (res : uint32) : ()
  
  axiom fn_mut_once'0_spec : forall self : closure0'1, args : (uint32, Snapshot.snap_ty (Seq.seq uint32)), res : uint32 . [%#sops40] postcondition_once'0 self args res
  = (exists res_state : closure0'1 . postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  function unnest_trans'0 (self : closure0'1) (b : closure0'1) (c : closure0'1) : ()
  
  axiom unnest_trans'0_spec : forall self : closure0'1, b : closure0'1, c : closure0'1 . ([%#sops37] unnest'0 self b)
   -> ([%#sops38] unnest'0 b c)  -> ([%#sops39] unnest'0 self c)
  
  function unnest_refl'0 (self : closure0'1) : ()
  
  axiom unnest_refl'0_spec : forall self : closure0'1 . [%#sops36] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : closure0'1) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) (res_state : closure0'1) (res : uint32) : ()
    
  
  axiom postcondition_mut_unnest'0_spec : forall self : closure0'1, args : (uint32, Snapshot.snap_ty (Seq.seq uint32)), res_state : closure0'1, res : uint32 . ([%#sops34] postcondition_mut'0 self args res_state res)
   -> ([%#sops35] unnest'0 self res_state)
  
  let rec closure0'0 (_1:borrowed closure0'1) (x:uint32) (_prod:Snapshot.snap_ty (Seq.seq uint32)) (return'  (ret:uint32))= {[@expl:closure requires] [%#s03_std_iterators7] UIntSize.to_int ((_1.current).field_0'0).current
    = Seq.length (Snapshot.inner _prod)
    /\ ((_1.current).field_0'0).current < (v_MAX'0 : usize)}
    (! bb0
    [ bb0 = s0
      [ s0 = UIntSize.add {((_1.current).field_0'0).current} {[%#s03_std_iterators6] (1 : usize)}
          (fun (_ret':usize) ->
             [ &_1 <- { _1 with current = { field_0'0 = { (_1.current).field_0'0 with current = _ret' } } } ] 
            s1)
      | s1 = -{resolve'0 _1}- s2
      | s2 =  [ &res1 <- x ] s3
      | s3 =  [ &res <- res1 ] s4
      | s4 =  [ &_0 <- res ] s5
      | s5 = return' {_0} ]
       ]
    )
    [ & _0 : uint32 = any_l ()
    | & _1 : borrowed closure0'1 = _1
    | & x : uint32 = x
    | & res : uint32 = any_l ()
    | & res1 : uint32 = any_l () ]
    
    [ return' (result:uint32)-> {[@expl:closure ensures] [%#s03_std_iterators8] UIntSize.to_int ((_1.final).field_0'0).current
      = UIntSize.to_int ((_1.current).field_0'0).current + 1
      /\ UIntSize.to_int ((_1.final).field_0'0).current = Seq.length (Snapshot.inner _prod) + 1 /\ result = x}
      {[@expl:closure unnest] unnest'0 _1.current _1.final}
      (! return' {result}) ]
    
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : slice uint32) (ix : int) : uint32 =
    [%#sops54] Seq.get (view'4 self) ix
  
  function to_ref_seq'0 (self : slice uint32) : Seq.seq uint32
  
  axiom to_ref_seq'0_spec : forall self : slice uint32 . ([%#sslice41] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice42] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq uint32) (tl : t_Iter'0) =
    [%#sslice25] to_ref_seq'0 (view'3 self) = Seq.(++) visited (to_ref_seq'0 (view'3 tl))
  
  function produces_trans'1 (a : t_Iter'0) (ab : Seq.seq uint32) (b : t_Iter'0) (bc : Seq.seq uint32) (c : t_Iter'0) : ()
    
   =
    [%#sslice24] ()
  
  axiom produces_trans'1_spec : forall a : t_Iter'0, ab : Seq.seq uint32, b : t_Iter'0, bc : Seq.seq uint32, c : t_Iter'0 . ([%#sslice21] produces'0 a ab b)
   -> ([%#sslice22] produces'0 b bc c)  -> ([%#sslice23] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Iter'0) : () =
    [%#sslice20] ()
  
  axiom produces_refl'1_spec : forall self : t_Iter'0 . [%#sslice19] produces'0 self (Seq.empty  : Seq.seq uint32) self
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq uint32) (b : t_Iter'0) (bc : Seq.seq uint32) (c : t_Iter'0) : ()
    
   =
    [%#sslice24] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq uint32, b : t_Iter'0, bc : Seq.seq uint32, c : t_Iter'0 . ([%#sslice21] produces'0 a ab b)
   -> ([%#sslice22] produces'0 b bc c)  -> ([%#sslice23] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice20] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice19] produces'0 self (Seq.empty  : Seq.seq uint32) self
  
  predicate inv'2 (_1 : t_Iter'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Iter'0 [inv'2 x] . inv'2 x = true
  
  predicate inv'3 (_1 : closure0'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : closure0'1 [inv'3 x] . inv'3 x = true
  
  predicate inv'4 (_1 : uint32)
  
  axiom inv_axiom'4 [@rewrite] : forall x : uint32 [inv'4 x] . inv'4 x = true
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  predicate precondition'0 (self : closure0'1) (args : (uint32, Snapshot.snap_ty (Seq.seq uint32))) =
    [%#s03_std_iterators7] let (x, _prod) = args in UIntSize.to_int (self.field_0'0).current
    = Seq.length (Snapshot.inner _prod)
    /\ (self.field_0'0).current < (v_MAX'0 : usize)
  
  predicate inv'9 (_1 : borrowed (t_Iter'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed (t_Iter'0) [inv'9 x] . inv'9 x = true
  
  predicate resolve'5 (self : borrowed (t_Iter'0)) =
    [%#sresolve33] self.final = self.current
  
  function view'5 (self : borrowed (t_Iter'0)) : slice uint32 =
    [%#smodel55] view'3 self.current
  
  use seq.Seq
  
  predicate completed'1 (self : borrowed (t_Iter'0)) =
    [%#sslice43] resolve'5 self /\ view'4 (view'5 self) = (Seq.empty  : Seq.seq uint32)
  
  predicate next_precondition'0 (iter : t_Iter'0) (func : closure0'1) (produced : Seq.seq uint32) =
    [%#smap_inv44] forall e : uint32, i : t_Iter'0 . inv'4 e /\ inv'2 i /\ produces'0 iter (Seq.singleton e) i
     -> precondition'0 func (e, Snapshot.new produced)
  
  predicate inv'10 (_1 : Seq.seq uint32)
  
  axiom inv_axiom'10 [@rewrite] : forall x : Seq.seq uint32 [inv'10 x] . inv'10 x = true
  
  predicate inv'11 (_1 : borrowed closure0'1)
  
  axiom inv_axiom'11 [@rewrite] : forall x : borrowed closure0'1 [inv'11 x] . inv'11 x = true
  
  predicate inv'12 (_1 : uint32)
  
  axiom inv_axiom'12 [@rewrite] : forall x : uint32 [inv'12 x] . inv'12 x = true
  
  use seq.Seq
  
  predicate preservation'0 (iter : t_Iter'0) (func : closure0'1) =
    [%#smap_inv27] forall s : Seq.seq uint32, e1 : uint32, e2 : uint32, f : borrowed closure0'1, b : uint32, i : t_Iter'0 . inv'10 s
    /\ inv'4 e1 /\ inv'4 e2 /\ inv'11 f /\ inv'12 b /\ inv'2 i /\ unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Snapshot.new s)
     -> postcondition_mut'0 f.current (e1, Snapshot.new s) f.final b
     -> precondition'0 f.final (e2, Snapshot.new (Seq.snoc s e1))
  
  predicate reinitialize'0 (_1 : ()) =
    [%#smap_inv26] forall iter : borrowed (t_Iter'0), func : closure0'1 . inv'9 iter /\ inv'3 func
     -> completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty  : Seq.seq uint32) /\ preservation'0 iter.final func
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_Iter'0;
      t_MapInv__func'0: closure0'1;
      t_MapInv__produced'0: Snapshot.snap_ty (Seq.seq uint32) }
  
  predicate invariant'0 (self : t_MapInv'0)
  
  predicate inv'5 (_1 : t_MapInv'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_MapInv'0 [inv'5 x] . inv'5 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> true
    end)
  
  let rec map_inv'0 (self:t_Iter'0) (func:closure0'1) (return'  (ret:t_MapInv'0))= {[@expl:map_inv 'self' type invariant] [%#siter9] inv'2 self}
    {[@expl:map_inv 'func' type invariant] [%#siter10] inv'3 func}
    {[@expl:map_inv requires #0] [%#siter11] forall e : uint32, i2 : t_Iter'0 . inv'4 e /\ inv'2 i2
     -> produces'0 self (Seq.singleton e) i2  -> precondition'0 func (e, Snapshot.new (Seq.empty  : Seq.seq uint32))}
    {[@expl:map_inv requires #1] [%#siter12] reinitialize'0 ()}
    {[@expl:map_inv requires #2] [%#siter13] preservation'0 self func}
    any
    [ return' (result:t_MapInv'0)-> {[%#siter14] inv'5 result}
      {[%#siter15] result
      = { t_MapInv__iter'0 = self;
          t_MapInv__func'0 = func;
          t_MapInv__produced'0 = Snapshot.new (Seq.empty  : Seq.seq uint32) }}
      (! return' {result}) ]
    
  
  predicate inv'6 (_1 : t_Vec'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Vec'0 [inv'6 x] . inv'6 x = true
  
  predicate invariant'1 (self : borrowed (t_MapInv'0)) =
    [%#sinvariant56] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'7 (_1 : borrowed (t_MapInv'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (t_MapInv'0) [inv'7 x] . inv'7 x = invariant'1 x
  
  predicate inv'8 (_1 : Seq.seq uint32)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Seq.seq uint32 [inv'8 x] . inv'8 x = true
  
  predicate resolve'6 (_1 : t_Iter'0) =
    true
  
  predicate resolve'3 (self : t_MapInv'0) =
    [%#smap_inv45] resolve'6 self.t_MapInv__iter'0 /\ resolve'4 self.t_MapInv__func'0
  
  predicate resolve'1 (_1 : t_MapInv'0) =
    resolve'3 _1
  
  use seq.Seq
  
  predicate inv'13 (_1 : Seq.seq (borrowed closure0'1))
  
  axiom inv_axiom'13 [@rewrite] : forall x : Seq.seq (borrowed closure0'1) [inv'13 x] . inv'13 x = true
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [@inline:trivial] (self : t_MapInv'0) (visited : Seq.seq uint32) (succ : t_MapInv'0) =
    [%#smap_inv29] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (borrowed closure0'1) . inv'13 fs
    /\ Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq uint32 . inv'10 s
    /\ Seq.length s = Seq.length visited
    /\ produces'0 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ Snapshot.inner succ.t_MapInv__produced'0 = Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i)))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Snapshot.new (Seq.(++) (Snapshot.inner self.t_MapInv__produced'0) (Seq.([..]) s 0 i))) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'2 (a : t_MapInv'0) (ab : Seq.seq uint32) (b : t_MapInv'0) (bc : Seq.seq uint32) (c : t_MapInv'0) : ()
    
  
  axiom produces_trans'2_spec : forall a : t_MapInv'0, ab : Seq.seq uint32, b : t_MapInv'0, bc : Seq.seq uint32, c : t_MapInv'0 . ([%#smap_inv48] inv'5 a)
   -> ([%#smap_inv49] inv'5 b)
   -> ([%#smap_inv50] inv'5 c)
   -> ([%#smap_inv51] produces'1 a ab b)
   -> ([%#smap_inv52] produces'1 b bc c)  -> ([%#smap_inv53] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 (self : t_MapInv'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_MapInv'0 . ([%#smap_inv46] inv'5 self)
   -> ([%#smap_inv47] produces'1 self (Seq.empty  : Seq.seq uint32) self)
  
  predicate completed'0 (self : borrowed (t_MapInv'0)) =
    [%#smap_inv28] Snapshot.inner (self.final).t_MapInv__produced'0 = (Seq.empty  : Seq.seq uint32)
    /\ completed'1 (Borrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (Borrow.inherit_id (Borrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  predicate from_iter_post'0 (prod : Seq.seq uint32) (res : t_Vec'0) =
    [%#svec30] prod = view'0 res
  
  let rec collect'0 (self:t_MapInv'0) (return'  (ret:t_Vec'0))= {[@expl:collect 'self' type invariant] inv'5 self}
    any
    [ return' (result:t_Vec'0)-> {inv'6 result}
      {[%#siter16] exists done' : borrowed (t_MapInv'0), prod : Seq.seq uint32 . inv'7 done'
      /\ inv'8 prod
      /\ resolve'1 done'.final
      /\ completed'0 done' /\ produces'1 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
    
  
  use seq.Seq
  
  meta "compute_max_steps" 1000000
  
  let rec counter'0 (v:t_Vec'0) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &cnt <- [%#s03_std_iterators0] (0 : usize) ] s1
      | s1 = deref'0 {v} (fun (_ret':slice uint32) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = iter'0 {_7} (fun (_ret':t_Iter'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Borrow.borrow_mut <usize> {cnt}
          (fun (_ret':borrowed usize) ->  [ &_10 <- _ret' ]  [ &cnt <- _ret'.final ] s1)
      | s1 =  [ &_9 <- { field_0'0 = _10 } ] s2
      | s2 = map_inv'0 {_5} {_9} (fun (_ret':t_MapInv'0) ->  [ &_4 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0 [ s0 = collect'0 {_4} (fun (_ret':t_Vec'0) ->  [ &x <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators1] Seq.length (view'0 x) = Seq.length (view'0 v)} s1 | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators2] Seq.(==) (view'0 x) (view'0 v)} s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators3] UIntSize.to_int cnt = Seq.length (view'0 x)} s1 | s1 = bb7 ]
      
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & v : t_Vec'0 = v
    | & cnt : usize = any_l ()
    | & x : t_Vec'0 = any_l ()
    | & _4 : t_MapInv'0 = any_l ()
    | & _5 : t_Iter'0 = any_l ()
    | & _7 : slice uint32 = any_l ()
    | & _9 : closure0'1 = any_l ()
    | & _10 : borrowed usize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__sum_range [#"03_std_iterators.rs" 63 0 63 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 64 16 64 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 66 13 66 14
  let%span s03_std_iterators2 = "03_std_iterators.rs" 66 4 66 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 66 4 66 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 65 16 65 46
  let%span s03_std_iterators5 = "03_std_iterators.rs" 66 4 66 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 66 4 66 7
  let%span s03_std_iterators7 = "03_std_iterators.rs" 67 13 67 14
  let%span s03_std_iterators8 = "03_std_iterators.rs" 61 11 61 18
  let%span s03_std_iterators9 = "03_std_iterators.rs" 62 10 62 21
  let%span siter10 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span srange11 = "../../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span siter13 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter14 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span srange15 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange16 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange17 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange18 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange19 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange20 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange21 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange22 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum23 = "../../../../creusot-contracts/src/std/num.rs" 21 28 21 33
  let%span srange24 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span sresolve25 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.IntSize
  
  type t_Range'0  =
    { t_Range__start'0: isize; t_Range__end'0: isize }
  
  predicate inv'0 (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Range'0) =
    [%#siter13] true
  
  predicate into_iter_post'0 (self : t_Range'0) (res : t_Range'0) =
    [%#siter14] self = res
  
  let rec into_iter'0 (self:t_Range'0) (return'  (ret:t_Range'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter10] into_iter_pre'0 self}
    any [ return' (result:t_Range'0)-> {inv'0 result} {[%#siter10] into_iter_post'0 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function deep_model'0 (self : isize) : int =
    [%#snum23] IntSize.to_int self
  
  use seq.Seq
  
  predicate produces'0 (self : t_Range'0) (visited : Seq.seq isize) (o : t_Range'0) =
    [%#srange11] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'0 (a : t_Range'0) (ab : Seq.seq isize) (b : t_Range'0) (bc : Seq.seq isize) (c : t_Range'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Range'0, ab : Seq.seq isize, b : t_Range'0, bc : Seq.seq isize, c : t_Range'0 . ([%#srange17] inv'0 a)
   -> ([%#srange18] inv'0 b)
   -> ([%#srange19] inv'0 c)
   -> ([%#srange20] produces'0 a ab b)
   -> ([%#srange21] produces'0 b bc c)  -> ([%#srange22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Range'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Range'0 . ([%#srange15] inv'0 self)
   -> ([%#srange16] produces'0 self (Seq.empty  : Seq.seq isize) self)
  
  predicate inv'1 (_1 : Seq.seq isize)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq isize [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : borrowed (t_Range'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Range'0) [inv'2 x] . inv'2 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 isize
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = true
  
  predicate resolve'1 (self : borrowed (t_Range'0)) =
    [%#sresolve25] self.final = self.current
  
  predicate completed'0 (self : borrowed (t_Range'0)) =
    [%#srange24] resolve'1 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Range'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter12] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : borrowed (t_Range'0)) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:isize))= any
    [ good (field_0:isize)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : isize [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec sum_range'0 (n:isize) (return'  (ret:isize))= {[@expl:sum_range requires] [%#s03_std_iterators8] IntSize.to_int n
    >= 0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : isize) ] s1
      | s1 =  [ &_7 <- { t_Range__start'0 = ([%#s03_std_iterators1] (0 : isize)); t_Range__end'0 = n } ] s2
      | s2 = into_iter'0 {_7} (fun (_ret':t_Range'0) ->  [ &iter <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] Snapshot.new iter ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators3] Snapshot.new (Seq.empty  : Seq.seq isize) ] s1 | s1 = bb3 ]
      
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] [%#s03_std_iterators5] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators5] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators5] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] IntSize.to_int i = Seq.length (Snapshot.inner produced)
        /\ i <= n}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = Borrow.borrow_mut <t_Range'0> {iter}
              (fun (_ret':borrowed (t_Range'0)) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <t_Range'0> {_20.current} {Borrow.get_id _20}
              (fun (_ret':borrowed (t_Range'0)) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = C_None'0 } (! bb9) | br1 (x0:isize)-> {_18 = C_Some'0 x0} (! bb8) ]  ]
          
        | bb8 = bb10
        | bb10 = s0
          [ s0 = v_Some'0 {_18} (fun (r0'0:isize) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_23 <- [%#s03_std_iterators6] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb11 ]
          
        | bb11 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 = IntSize.add {i} {[%#s03_std_iterators7] (1 : isize)} (fun (_ret':isize) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
           ]
         ]
      
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : isize = any_l ()
    | & n : isize = n
    | & i : isize = any_l ()
    | & iter : t_Range'0 = any_l ()
    | & _7 : t_Range'0 = any_l ()
    | & iter_old : Snapshot.snap_ty (t_Range'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq isize) = any_l ()
    | & _18 : t_Option'0 = any_l ()
    | & _19 : borrowed (t_Range'0) = any_l ()
    | & _20 : borrowed (t_Range'0) = any_l ()
    | & __creusot_proc_iter_elem : isize = any_l ()
    | & _23 : Snapshot.snap_ty (Seq.seq isize) = any_l () ]
     [ return' (result:isize)-> {[@expl:sum_range ensures] [%#s03_std_iterators9] result = n} (! return' {result}) ] 
end
module M_03_std_iterators__enumerate_range [#"03_std_iterators.rs" 72 0 72 24]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 74 20 74 21
  let%span s03_std_iterators1 = "03_std_iterators.rs" 74 23 74 25
  let%span s03_std_iterators2 = "03_std_iterators.rs" 74 4 74 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 74 4 74 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 73 16 73 93
  let%span s03_std_iterators5 = "03_std_iterators.rs" 74 4 74 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 74 4 74 7
  let%span siter7 = "../../../../creusot-contracts/src/std/iter.rs" 154 27 154 103
  let%span siter8 = "../../../../creusot-contracts/src/std/iter.rs" 155 27 157 54
  let%span siter9 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span sops10 = "../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33
  let%span senumerate11 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 74 12 78 113
  let%span siter12 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span srange13 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span srange14 = "../../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  let%span senumerate15 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter16 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter17 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span senumerate18 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 84 15 84 24
  let%span senumerate19 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 85 14 85 45
  let%span senumerate20 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 90 15 90 21
  let%span senumerate21 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 91 15 91 21
  let%span senumerate22 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 92 15 92 21
  let%span senumerate23 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 93 15 93 32
  let%span senumerate24 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 94 15 94 32
  let%span senumerate25 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 95 14 95 42
  let%span senumerate26 = "../../../../creusot-contracts/src/std/iter/enumerate.rs" 62 12 66 42
  let%span sresolve27 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span srange28 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange29 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange30 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange31 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange32 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange33 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange34 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange35 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum36 = "../../../../creusot-contracts/src/std/num.rs" 21 28 21 33
  let%span sinvariant37 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  
  use prelude.prelude.UIntSize
  
  type t_Range'0  =
    { t_Range__start'0: usize; t_Range__end'0: usize }
  
  predicate inv'3 (_1 : t_Range'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Range'0 [inv'3 x] . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (t_Range'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (t_Range'0) [inv'4 x] . inv'4 x = true
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use prelude.prelude.UIntSize
  
  function deep_model'0 (self : usize) : int =
    [%#snum36] UIntSize.to_int self
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 (self : t_Range'0) (visited : Seq.seq usize) (o : t_Range'0) =
    [%#srange14] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'1 (a : t_Range'0) (ab : Seq.seq usize) (b : t_Range'0) (bc : Seq.seq usize) (c : t_Range'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_Range'0, ab : Seq.seq usize, b : t_Range'0, bc : Seq.seq usize, c : t_Range'0 . ([%#srange30] inv'3 a)
   -> ([%#srange31] inv'3 b)
   -> ([%#srange32] inv'3 c)
   -> ([%#srange33] produces'1 a ab b)
   -> ([%#srange34] produces'1 b bc c)  -> ([%#srange35] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Range'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Range'0 . ([%#srange28] inv'3 self)
   -> ([%#srange29] produces'1 self (Seq.empty  : Seq.seq usize) self)
  
  predicate resolve'2 (self : borrowed (t_Range'0)) =
    [%#sresolve27] self.final = self.current
  
  predicate completed'0 (self : borrowed (t_Range'0)) =
    [%#srange13] resolve'2 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  predicate inv'5 (_1 : Seq.seq usize)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq usize [inv'5 x] . inv'5 x = true
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_Range'0; t_Enumerate__count'0: usize }
  
  predicate invariant'0 (self : t_Enumerate'0)
  
  predicate inv'0 (_1 : t_Enumerate'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> true
    end)
  
  function iter'0 (self : t_Enumerate'0) : t_Range'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate15] inv'0 self  -> inv'3 (iter'0 self)
  
  function n'0 (self : t_Enumerate'0) : int
  
  let rec enumerate'0 (self:t_Range'0) (return'  (ret:t_Enumerate'0))= {[@expl:enumerate 'self' type invariant] inv'3 self}
    {[@expl:enumerate requires #0] [%#siter7] forall i : borrowed (t_Range'0) . inv'4 i /\ completed'0 i
     -> produces'1 i.current (Seq.empty  : Seq.seq usize) i.final}
    {[@expl:enumerate requires #1] [%#siter8] forall s : Seq.seq usize, i : t_Range'0 . inv'5 s
    /\ inv'3 i /\ produces'1 self s i  -> Seq.length s < UIntSize.to_int v_MAX'0}
    any
    [ return' (result:t_Enumerate'0)-> {inv'0 result}
      {[%#siter9] iter'0 result = self /\ n'0 result = 0}
      (! return' {result}) ]
    
  
  predicate into_iter_pre'0 (self : t_Enumerate'0) =
    [%#siter16] true
  
  predicate into_iter_post'0 (self : t_Enumerate'0) (res : t_Enumerate'0) =
    [%#siter17] self = res
  
  let rec into_iter'0 (self:t_Enumerate'0) (return'  (ret:t_Enumerate'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter9] into_iter_pre'0 self}
    any
    [ return' (result:t_Enumerate'0)-> {inv'0 result} {[%#siter9] into_iter_post'0 self result} (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq (usize, usize))) (ix : int) : (usize, usize)
    
   =
    [%#sops10] Seq.get (Snapshot.inner self) ix
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  predicate produces'0 (self : t_Enumerate'0) (visited : Seq.seq (usize, usize)) (o : t_Enumerate'0) =
    [%#senumerate11] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq usize . inv'5 s
    /\ produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UIntSize.to_int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  function produces_trans'0 (a : t_Enumerate'0) (ab : Seq.seq (usize, usize)) (b : t_Enumerate'0) (bc : Seq.seq (usize, usize)) (c : t_Enumerate'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Enumerate'0, ab : Seq.seq (usize, usize), b : t_Enumerate'0, bc : Seq.seq (usize, usize), c : t_Enumerate'0 . ([%#senumerate20] inv'0 a)
   -> ([%#senumerate21] inv'0 b)
   -> ([%#senumerate22] inv'0 c)
   -> ([%#senumerate23] produces'0 a ab b)
   -> ([%#senumerate24] produces'0 b bc c)  -> ([%#senumerate25] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Enumerate'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Enumerate'0 . ([%#senumerate18] inv'0 self)
   -> ([%#senumerate19] produces'0 self (Seq.empty  : Seq.seq (usize, usize)) self)
  
  predicate inv'1 (_1 : Seq.seq (usize, usize))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (usize, usize) [inv'1 x] . inv'1 x = true
  
  predicate invariant'1 (self : borrowed (t_Enumerate'0)) =
    [%#sinvariant37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 (_1 : borrowed (t_Enumerate'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (t_Enumerate'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (usize, usize)
  
  predicate inv'6 (_1 : t_Option'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Option'0 [inv'6 x] . inv'6 x = true
  
  predicate completed'1 (self : borrowed (t_Enumerate'0)) =
    [%#senumerate26] exists inner : borrowed (t_Range'0) . inv'4 inner
    /\ inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'0 inner /\ n'0 self.current = n'0 self.final
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Enumerate'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Option'0)-> {inv'6 result}
      {[%#siter12] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'1 (self : borrowed (t_Enumerate'0)) =
    [%#sresolve27] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Enumerate'0)) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:(usize, usize)))= any
    [ good (field_0:(usize, usize))-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : (usize, usize) [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
    
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec enumerate_range'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = 
        [ &_3 <- { t_Range__start'0 = ([%#s03_std_iterators0] (0 : usize));
                   t_Range__end'0 = ([%#s03_std_iterators1] (10 : usize)) } ]
        
        s1
      | s1 = enumerate'0 {_3} (fun (_ret':t_Enumerate'0) ->  [ &_2 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = into_iter'0 {_2} (fun (_ret':t_Enumerate'0) ->  [ &iter <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] Snapshot.new iter ] s1 | s1 = bb3 ] 
    | bb3 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators3] Snapshot.new (Seq.empty  : Seq.seq (usize, usize)) ] s1 | s1 = bb4 ]
      
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] [%#s03_std_iterators5] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators5] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators5] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] forall i : int . 0 <= i
        /\ i < Seq.length (Snapshot.inner produced)
         -> (let (a, _) = index_logic'0 produced i in a) = (let (_, a) = index_logic'0 produced i in a)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = {inv'0 iter}
            Borrow.borrow_mut <t_Enumerate'0> {iter}
              (fun (_ret':borrowed (t_Enumerate'0)) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &iter <- _ret'.final ] 
                s1)
          | s1 = {inv'0 _15.current}
            Borrow.borrow_final <t_Enumerate'0> {_15.current} {Borrow.get_id _15}
              (fun (_ret':borrowed (t_Enumerate'0)) ->
                 [ &_14 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_15 <- { _15 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_14} (fun (_ret':t_Option'0) ->  [ &_13 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = s0
          [ s0 = {[@expl:type invariant] inv'2 _15} s1
          | s1 = -{resolve'0 _15}- s2
          | s2 = any [ br0 -> {_13 = C_None'0 } (! bb10) | br1 (x0:(usize, usize))-> {_13 = C_Some'0 x0} (! bb9) ]  ]
          
        | bb9 = bb11
        | bb11 = s0
          [ s0 = v_Some'0 {_13} (fun (r0'0:(usize, usize)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_18 <- [%#s03_std_iterators6] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb12 ]
          
        | bb12 = s0
          [ s0 =  [ &produced <- _18 ] s1
          | s1 =  [ &ix <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &x <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = bb5 ]
           ]
         ]
      
    | bb10 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & iter : t_Enumerate'0 = any_l ()
    | & _2 : t_Enumerate'0 = any_l ()
    | & _3 : t_Range'0 = any_l ()
    | & iter_old : Snapshot.snap_ty (t_Enumerate'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & _13 : t_Option'0 = any_l ()
    | & _14 : borrowed (t_Enumerate'0) = any_l ()
    | & _15 : borrowed (t_Enumerate'0) = any_l ()
    | & __creusot_proc_iter_elem : (usize, usize) = any_l ()
    | & _18 : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & ix : usize = any_l ()
    | & x : usize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__my_reverse [#"03_std_iterators.rs" 94 0 94 37]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 96 36 96 55
  let%span s03_std_iterators1 = "03_std_iterators.rs" 101 26 101 27
  let%span s03_std_iterators2 = "03_std_iterators.rs" 101 22 101 27
  let%span s03_std_iterators3 = "03_std_iterators.rs" 101 19 101 20
  let%span s03_std_iterators4 = "03_std_iterators.rs" 101 40 101 41
  let%span s03_std_iterators5 = "03_std_iterators.rs" 101 36 101 41
  let%span s03_std_iterators6 = "03_std_iterators.rs" 101 33 101 34
  let%span s03_std_iterators7 = "03_std_iterators.rs" 101 4 101 7
  let%span s03_std_iterators8 = "03_std_iterators.rs" 101 4 101 7
  let%span s03_std_iterators9 = "03_std_iterators.rs" 100 16 100 80
  let%span s03_std_iterators10 = "03_std_iterators.rs" 99 16 99 76
  let%span s03_std_iterators11 = "03_std_iterators.rs" 98 16 98 78
  let%span s03_std_iterators12 = "03_std_iterators.rs" 97 16 97 34
  let%span s03_std_iterators13 = "03_std_iterators.rs" 101 4 101 7
  let%span s03_std_iterators14 = "03_std_iterators.rs" 101 4 101 7
  let%span s03_std_iterators15 = "03_std_iterators.rs" 102 30 102 31
  let%span s03_std_iterators16 = "03_std_iterators.rs" 103 22 103 52
  let%span s03_std_iterators17 = "03_std_iterators.rs" 94 21 94 26
  let%span s03_std_iterators18 = "03_std_iterators.rs" 93 10 93 44
  let%span sslice19 = "../../../../creusot-contracts/src/std/slice.rs" 245 0 354 1
  let%span siter20 = "../../../../creusot-contracts/src/std/iter.rs" 165 27 165 48
  let%span siter21 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span siter22 = "../../../../creusot-contracts/src/std/iter.rs" 167 26 167 62
  let%span smodel23 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  let%span ssnapshot24 = "../../../../creusot-contracts/src/snapshot.rs" 26 20 26 39
  let%span s03_std_iterators25 = "03_std_iterators.rs" 89 8 89 60
  let%span s03_std_iterators26 = "03_std_iterators.rs" 82 8 82 58
  let%span szip27 = "../../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span siter28 = "../../../../creusot-contracts/src/std/iter.rs" 107 26 110 17
  let%span sslice29 = "../../../../creusot-contracts/src/std/slice.rs" 257 19 257 35
  let%span sslice30 = "../../../../creusot-contracts/src/std/slice.rs" 258 19 258 35
  let%span sslice31 = "../../../../creusot-contracts/src/std/slice.rs" 259 18 259 50
  let%span sops32 = "../../../../creusot-contracts/src/logic/ops.rs" 42 8 42 31
  let%span sops33 = "../../../../creusot-contracts/src/logic/ops.rs" 53 8 53 32
  let%span sslice34 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 41
  let%span sslice35 = "../../../../creusot-contracts/src/std/slice.rs" 29 14 29 42
  let%span smodel36 = "../../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span siter37 = "../../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span szip38 = "../../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip39 = "../../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter40 = "../../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span szip41 = "../../../../creusot-contracts/src/std/iter/zip.rs" 55 15 55 24
  let%span szip42 = "../../../../creusot-contracts/src/std/iter/zip.rs" 56 14 56 45
  let%span szip43 = "../../../../creusot-contracts/src/std/iter/zip.rs" 61 15 61 21
  let%span szip44 = "../../../../creusot-contracts/src/std/iter/zip.rs" 62 15 62 21
  let%span szip45 = "../../../../creusot-contracts/src/std/iter/zip.rs" 63 15 63 21
  let%span szip46 = "../../../../creusot-contracts/src/std/iter/zip.rs" 64 15 64 32
  let%span szip47 = "../../../../creusot-contracts/src/std/iter/zip.rs" 65 15 65 32
  let%span szip48 = "../../../../creusot-contracts/src/std/iter/zip.rs" 66 14 66 42
  let%span srange49 = "../../../../creusot-contracts/src/std/iter/range.rs" 23 12 27 70
  let%span szip50 = "../../../../creusot-contracts/src/std/iter/zip.rs" 32 12 37 71
  let%span sresolve51 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span srange52 = "../../../../creusot-contracts/src/std/iter/range.rs" 33 15 33 24
  let%span srange53 = "../../../../creusot-contracts/src/std/iter/range.rs" 34 14 34 45
  let%span srange54 = "../../../../creusot-contracts/src/std/iter/range.rs" 39 15 39 21
  let%span srange55 = "../../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 21
  let%span srange56 = "../../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 21
  let%span srange57 = "../../../../creusot-contracts/src/std/iter/range.rs" 42 15 42 32
  let%span srange58 = "../../../../creusot-contracts/src/std/iter/range.rs" 43 15 43 32
  let%span srange59 = "../../../../creusot-contracts/src/std/iter/range.rs" 44 14 44 42
  let%span snum60 = "../../../../creusot-contracts/src/std/num.rs" 21 28 21 33
  let%span srange61 = "../../../../creusot-contracts/src/std/iter/range.rs" 15 12 15 78
  let%span sslice62 = "../../../../creusot-contracts/src/std/slice.rs" 18 20 18 30
  let%span sinvariant63 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sinvariant64 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sseq65 = "../../../../creusot-contracts/src/logic/seq.rs" 444 20 444 95
  let%span sboxed66 = "../../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Slice
  
  type t_T'0
  
  use seq.Seq
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.Slice
  
  use seq.Seq
  
  function view'2 (self : slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : slice t_T'0 . ([%#sslice34] Seq.length (view'2 self)
  <= UIntSize.to_int (v_MAX'0 : usize))
  && ([%#sslice35] view'2 self = Slice.id self)
  
  use seq.Seq
  
  predicate inv'13 (_1 : t_T'0)
  
  predicate invariant'4 (self : t_T'0) =
    [%#sboxed66] inv'13 self
  
  predicate inv'12 (_1 : t_T'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_T'0 [inv'12 x] . inv'12 x = invariant'4 x
  
  predicate invariant'3 (self : Seq.seq t_T'0) =
    [%#sseq65] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'12 (Seq.get self i)
  
  predicate inv'11 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : Seq.seq t_T'0 [inv'11 x] . inv'11 x = invariant'3 x
  
  predicate invariant'0 (self : slice t_T'0) =
    [%#sslice62] inv'11 (view'2 self)
  
  predicate inv'2 (_1 : slice t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : slice t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate invariant'2 (self : slice t_T'0) =
    [%#sinvariant64] inv'2 self
  
  predicate inv'4 (_1 : slice t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : slice t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  function view'3 (self : slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel36] view'2 self
  
  let rec len'0 (self:slice t_T'0) (return'  (ret:usize))= {[@expl:len 'self' type invariant] inv'4 self}
    any
    [ return' (result:usize)-> {[%#sslice19] Seq.length (view'3 self) = UIntSize.to_int result} (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  type t_Range'0  =
    { t_Range__start'0: usize; t_Range__end'0: usize }
  
  predicate inv'5 (_1 : t_Range'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Range'0 [inv'5 x] . inv'5 x = true
  
  predicate into_iter_pre'0 (self : t_Range'0) =
    [%#siter37] true
  
  type t_Zip'0  =
    { t_Zip__a'0: t_Range'0; t_Zip__b'0: t_Range'0; t_Zip__index'0: usize; t_Zip__len'0: usize; t_Zip__a_len'0: usize }
  
  predicate inv'0 (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x = true
  
  function itera'0 (self : t_Zip'0) : t_Range'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip38] inv'0 self  -> inv'5 (itera'0 self)
  
  function iterb'0 (self : t_Zip'0) : t_Range'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip39] inv'0 self  -> inv'5 (iterb'0 self)
  
  predicate into_iter_post'0 (self : t_Range'0) (res : t_Range'0) =
    [%#siter40] self = res
  
  let rec zip'0 (self:t_Range'0) (other:t_Range'0) (return'  (ret:t_Zip'0))= {[@expl:zip 'self' type invariant] inv'5 self}
    {[@expl:zip 'other' type invariant] inv'5 other}
    {[@expl:zip requires] [%#siter20] into_iter_pre'0 other}
    any
    [ return' (result:t_Zip'0)-> {inv'0 result}
      {[%#siter21] itera'0 result = self}
      {[%#siter22] into_iter_post'0 other (iterb'0 result)}
      (! return' {result}) ]
    
  
  predicate into_iter_pre'1 (self : t_Zip'0) =
    [%#siter37] true
  
  predicate into_iter_post'1 (self : t_Zip'0) (res : t_Zip'0) =
    [%#siter40] self = res
  
  let rec into_iter'0 (self:t_Zip'0) (return'  (ret:t_Zip'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter21] into_iter_pre'1 self}
    any [ return' (result:t_Zip'0)-> {inv'0 result} {[%#siter21] into_iter_post'1 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  function view'0 (self : borrowed (slice t_T'0)) : Seq.seq t_T'0 =
    [%#smodel23] view'2 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  function view'4 (self : borrowed (slice t_T'0)) : Seq.seq t_T'0 =
    [%#smodel36] view'0 self
  
  function view'1 (self : Snapshot.snap_ty (borrowed (slice t_T'0))) : Seq.seq t_T'0 =
    [%#ssnapshot24] view'4 (Snapshot.inner self)
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  predicate equiv_reverse_range'0 [#"03_std_iterators.rs" 87 0 87 81] (s1 : Seq.seq t_T'0) (s2 : Seq.seq t_T'0) (l : int) (u : int) (n : int)
    
   =
    [%#s03_std_iterators25] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 (n - i)
  
  predicate equiv_range'0 [#"03_std_iterators.rs" 80 0 80 65] (s1 : Seq.seq t_T'0) (s2 : Seq.seq t_T'0) (l : int) (u : int)
    
   =
    [%#s03_std_iterators26] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 i
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'6 (_1 : Seq.seq usize)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Seq.seq usize [inv'6 x] . inv'6 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 (self : usize) : int =
    [%#snum60] UIntSize.to_int self
  
  predicate produces'1 (self : t_Range'0) (visited : Seq.seq usize) (o : t_Range'0) =
    [%#srange49] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'1 (a : t_Range'0) (ab : Seq.seq usize) (b : t_Range'0) (bc : Seq.seq usize) (c : t_Range'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_Range'0, ab : Seq.seq usize, b : t_Range'0, bc : Seq.seq usize, c : t_Range'0 . ([%#srange54] inv'5 a)
   -> ([%#srange55] inv'5 b)
   -> ([%#srange56] inv'5 c)
   -> ([%#srange57] produces'1 a ab b)
   -> ([%#srange58] produces'1 b bc c)  -> ([%#srange59] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Range'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Range'0 . ([%#srange52] inv'5 self)
   -> ([%#srange53] produces'1 self (Seq.empty  : Seq.seq usize) self)
  
  predicate produces'0 (self : t_Zip'0) (visited : Seq.seq (usize, usize)) (o : t_Zip'0) =
    [%#szip27] exists p1 : Seq.seq usize, p2 : Seq.seq usize . inv'6 p1
    /\ inv'6 p2
    /\ Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'1 (iterb'0 self) p2 (iterb'0 o)
  
  function produces_trans'0 (a : t_Zip'0) (ab : Seq.seq (usize, usize)) (b : t_Zip'0) (bc : Seq.seq (usize, usize)) (c : t_Zip'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Zip'0, ab : Seq.seq (usize, usize), b : t_Zip'0, bc : Seq.seq (usize, usize), c : t_Zip'0 . ([%#szip43] inv'0 a)
   -> ([%#szip44] inv'0 b)
   -> ([%#szip45] inv'0 c)
   -> ([%#szip46] produces'0 a ab b)  -> ([%#szip47] produces'0 b bc c)  -> ([%#szip48] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Zip'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Zip'0 . ([%#szip41] inv'0 self)
   -> ([%#szip42] produces'0 self (Seq.empty  : Seq.seq (usize, usize)) self)
  
  predicate inv'1 (_1 : Seq.seq (usize, usize))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (usize, usize) [inv'1 x] . inv'1 x = true
  
  predicate inv'7 (_1 : borrowed (t_Zip'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (t_Zip'0) [inv'7 x] . inv'7 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (usize, usize)
  
  predicate inv'8 (_1 : t_Option'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Option'0 [inv'8 x] . inv'8 x = true
  
  predicate inv'9 (_1 : borrowed (t_Range'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed (t_Range'0) [inv'9 x] . inv'9 x = true
  
  predicate resolve'6 (self : borrowed (t_Range'0)) =
    [%#sresolve51] self.final = self.current
  
  predicate completed'1 (self : borrowed (t_Range'0)) =
    [%#srange61] resolve'6 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  predicate resolve'4 (_1 : borrowed (t_Range'0)) =
    resolve'6 _1
  
  predicate inv'10 (_1 : usize)
  
  axiom inv_axiom'10 [@rewrite] : forall x : usize [inv'10 x] . inv'10 x = true
  
  use seq.Seq
  
  predicate resolve'5 (_1 : usize) =
    true
  
  predicate completed'0 (self : borrowed (t_Zip'0)) =
    [%#szip50] exists a : borrowed (t_Range'0), b : borrowed (t_Range'0) . inv'9 a
    /\ inv'9 b
    /\ a.current = itera'0 self.current
    /\ b.current = iterb'0 self.current
    /\ a.final = itera'0 self.final
    /\ b.final = iterb'0 self.final
    /\ (completed'1 a /\ resolve'4 b
    \/ (exists x : usize . inv'10 x /\ produces'1 a.current (Seq.singleton x) a.final /\ resolve'5 x /\ completed'1 b))
  
  use seq.Seq
  
  let rec next'0 (self:borrowed (t_Zip'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'7 self}
    any
    [ return' (result:t_Option'0)-> {inv'8 result}
      {[%#siter28] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (t_Zip'0)) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_Zip'0)) =
    resolve'2 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:(usize, usize)))= any
    [ good (field_0:(usize, usize))-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : (usize, usize) [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
    
  
  predicate invariant'1 (self : borrowed (slice t_T'0)) =
    [%#sinvariant63] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (slice t_T'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (slice t_T'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Permut
  
  let rec swap'0 (self:borrowed (slice t_T'0)) (a:usize) (b:usize) (return'  (ret:()))= {[@expl:swap 'self' type invariant] inv'3 self}
    {[@expl:swap requires #0] [%#sslice29] UIntSize.to_int a < Seq.length (view'0 self)}
    {[@expl:swap requires #1] [%#sslice30] UIntSize.to_int b < Seq.length (view'0 self)}
    any
    [ return' (result:())-> {[%#sslice31] Permut.exchange (view'2 self.final) (view'0 self) (UIntSize.to_int a) (UIntSize.to_int b)}
      (! return' {result}) ]
    
  
  function index_logic'0 [@inline:trivial] (self : slice t_T'0) (ix : int) : t_T'0 =
    [%#sops32] Seq.get (view'2 self) ix
  
  function index_logic'1 [@inline:trivial] (self : slice t_T'0) (ix : usize) : t_T'0 =
    [%#sops33] Seq.get (view'2 self) (UIntSize.to_int ix)
  
  predicate resolve'3 (self : borrowed (slice t_T'0)) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (slice t_T'0)) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use seq.Reverse
  
  use seq.Seq
  
  meta "compute_max_steps" 1000000
  
  let rec my_reverse'0 (slice:borrowed (slice t_T'0)) (return'  (ret:()))= {[@expl:my_reverse 'slice' type invariant] [%#s03_std_iterators17] inv'3 slice}
    (! bb0
    [ bb0 = s0 [ s0 = len'0 {slice.current} (fun (_ret':usize) ->  [ &n <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &old_v <- [%#s03_std_iterators0] Snapshot.new slice ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UIntSize.eq {[%#s03_std_iterators1] (2 : usize)} {[%#s03_std_iterators2] (0 : usize)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = {[@expl:division by zero] [%#s03_std_iterators2] not _12} s2
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = UIntSize.div {n} {[%#s03_std_iterators1] (2 : usize)} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s1)
      | s1 =  [ &_9 <- { t_Range__start'0 = ([%#s03_std_iterators3] (0 : usize)); t_Range__end'0 = _10 } ] s2
      | s2 = UIntSize.eq {[%#s03_std_iterators4] (2 : usize)} {[%#s03_std_iterators5] (0 : usize)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#s03_std_iterators5] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = UIntSize.div {n} {[%#s03_std_iterators4] (2 : usize)} (fun (_ret':usize) ->  [ &_14 <- _ret' ] s1)
      | s1 =  [ &_13 <- { t_Range__start'0 = ([%#s03_std_iterators6] (0 : usize)); t_Range__end'0 = _14 } ] s2
      | s2 = zip'0 {_9} {_13} (fun (_ret':t_Zip'0) ->  [ &_8 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0 [ s0 = into_iter'0 {_8} (fun (_ret':t_Zip'0) ->  [ &iter <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators7] Snapshot.new iter ] s1 | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators8] Snapshot.new (Seq.empty  : Seq.seq (usize, usize)) ] s1 | s1 = bb8 ]
      
    | bb8 = s0 [ s0 =  [ &old_9_0 <- Snapshot.new slice ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:mut invariant] (Snapshot.inner old_9_0).final = slice.final}
        {[@expl:for invariant] [%#s03_std_iterators13] inv'1 (Snapshot.inner produced)}
        {[@expl:for invariant] [%#s03_std_iterators13] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators13] produces'0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter}
        {[@expl:loop invariant #0] [%#s03_std_iterators12] UIntSize.to_int n = Seq.length (view'0 slice)}
        {[@expl:loop invariant #1] [%#s03_std_iterators11] equiv_range'0 (view'0 slice) (view'1 old_v) (Seq.length (Snapshot.inner produced)) (UIntSize.to_int n
        - Seq.length (Snapshot.inner produced))}
        {[@expl:loop invariant #2] [%#s03_std_iterators10] equiv_reverse_range'0 (view'0 slice) (view'1 old_v) 0 (Seq.length (Snapshot.inner produced)) (UIntSize.to_int n
        - 1)}
        {[@expl:loop invariant #3] [%#s03_std_iterators9] equiv_reverse_range'0 (view'0 slice) (view'1 old_v) (UIntSize.to_int n
        - Seq.length (Snapshot.inner produced)) (UIntSize.to_int n) (UIntSize.to_int n - 1)}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = Borrow.borrow_mut <t_Zip'0> {iter}
              (fun (_ret':borrowed (t_Zip'0)) ->  [ &_31 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = Borrow.borrow_final <t_Zip'0> {_31.current} {Borrow.get_id _31}
              (fun (_ret':borrowed (t_Zip'0)) ->  [ &_30 <- _ret' ]  [ &_31 <- { _31 with current = _ret'.final } ] s2)
          | s2 = next'0 {_30} (fun (_ret':t_Option'0) ->  [ &_29 <- _ret' ] s3)
          | s3 = bb11 ]
          
        | bb11 = s0
          [ s0 = -{resolve'0 _31}- s1
          | s1 = any [ br0 -> {_29 = C_None'0 } (! bb14) | br1 (x0:(usize, usize))-> {_29 = C_Some'0 x0} (! bb13) ]  ]
          
        | bb13 = bb15
        | bb15 = s0
          [ s0 = v_Some'0 {_29} (fun (r0'0:(usize, usize)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 = 
            [ &_34 <- [%#s03_std_iterators14] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)) ]
            
            s2
          | s2 = bb16 ]
          
        | bb16 = s0
          [ s0 =  [ &produced <- _34 ] s1
          | s1 =  [ &i <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &j <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = {inv'2 slice.current}
            Borrow.borrow_mut <slice t_T'0> {slice.current}
              (fun (_ret':borrowed (slice t_T'0)) ->
                 [ &_39 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &slice <- { slice with current = _ret'.final } ] 
                s4)
          | s4 = UIntSize.sub {n} {j} (fun (_ret':usize) ->  [ &_42 <- _ret' ] s5)
          | s5 = UIntSize.sub {_42} {[%#s03_std_iterators15] (1 : usize)} (fun (_ret':usize) ->  [ &_41 <- _ret' ] s6)
          | s6 = swap'0 {_39} {i} {_41} (fun (_ret':()) ->  [ &_38 <- _ret' ] s7)
          | s7 = bb17 ]
          
        | bb17 = s0
          [ s0 = {[@expl:assertion] [%#s03_std_iterators16] index_logic'0 (Snapshot.inner old_v).current (UIntSize.to_int n
            - UIntSize.to_int j
            - 1)
            = index_logic'1 slice.current i}
            s1
          | s1 = bb9 ]
           ]
         ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'3 slice} s1 | s1 = -{resolve'1 slice}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l ()
    | & slice : borrowed (slice t_T'0) = slice
    | & n : usize = any_l ()
    | & old_v : Snapshot.snap_ty (borrowed (slice t_T'0)) = any_l ()
    | & iter : t_Zip'0 = any_l ()
    | & _8 : t_Zip'0 = any_l ()
    | & _9 : t_Range'0 = any_l ()
    | & _10 : usize = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : t_Range'0 = any_l ()
    | & _14 : usize = any_l ()
    | & _16 : bool = any_l ()
    | & iter_old : Snapshot.snap_ty (t_Zip'0) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & _29 : t_Option'0 = any_l ()
    | & _30 : borrowed (t_Zip'0) = any_l ()
    | & _31 : borrowed (t_Zip'0) = any_l ()
    | & __creusot_proc_iter_elem : (usize, usize) = any_l ()
    | & _34 : Snapshot.snap_ty (Seq.seq (usize, usize)) = any_l ()
    | & i : usize = any_l ()
    | & j : usize = any_l ()
    | & _38 : () = any_l ()
    | & _39 : borrowed (slice t_T'0) = any_l ()
    | & _41 : usize = any_l ()
    | & _42 : usize = any_l ()
    | & old_9_0 : Snapshot.snap_ty (borrowed (slice t_T'0)) = any_l () ]
    
    [ return' (result:())-> {[@expl:my_reverse ensures] [%#s03_std_iterators18] Seq.(==) (view'2 slice.final) (Reverse.reverse (view'0 slice))}
      (! return' {result}) ]
    
end
