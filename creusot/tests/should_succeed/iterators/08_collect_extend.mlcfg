
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_Cap_Type
  use prelude.UIntSize
  use prelude.Int
  type t_cap  =
    | C_Cap usize
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Alloc_RawVec_Cap_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) (Alloc_RawVec_Cap_Type.t_cap) 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module C08CollectExtend_Extend
  type t
  type i
  predicate invariant9 (self : t)
  val invariant9 (self : t) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : t)
  val inv9 (_x : t) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : forall x : t . inv9 x = true
  use seq.Seq
  predicate invariant8 (self : Seq.seq t)
  val invariant8 (self : Seq.seq t) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : Seq.seq t)
  val inv8 (_x : Seq.seq t) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : forall x : Seq.seq t . inv8 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Borrow
  predicate invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv7 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv6 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv6 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv6 _x }
    
  function shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv6 self}
    ensures { result = shallow_model2 self }
    
  axiom shallow_model2_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv6 self)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv8 (shallow_model2 self)) && ([#"../../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model2 self) <= UIntSize.to_int max0)
  predicate invariant6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv8 (shallow_model2 self)
  val invariant6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant6 self }
    
  axiom inv6 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv6 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant5 (self : Core_Option_Option_Type.t_option t)
  val invariant5 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Core_Option_Option_Type.t_option t)
  val inv5 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : Core_Option_Option_Type.t_option t . inv5 x = true
  predicate invariant4 (self : borrowed i)
  val invariant4 (self : borrowed i) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed i)
  val inv4 (_x : borrowed i) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed i . inv4 x = true
  use seq.Seq
  predicate inv3 (_x : i)
  val inv3 (_x : i) : bool
    ensures { result = inv3 _x }
    
  predicate produces0 (self : i) (visited : Seq.seq t) (o : i)
  val produces0 (self : i) (visited : Seq.seq t) (o : i) : bool
    ensures { result = produces0 self visited o }
    
  function produces_trans0 (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
  val produces_trans0 (a : i) (ab : Seq.seq t) (b : i) (bc : Seq.seq t) (c : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv3 a}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv8 ab}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv3 b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv8 bc}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv3 c}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : i, ab : Seq.seq t, b : i, bc : Seq.seq t, c : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv3 a)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv8 ab)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv3 b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv8 bc)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv3 c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 40 14 40 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (self : i) : ()
  val produces_refl0 (self : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv3 self}
    ensures { result = produces_refl0 self }
    
  axiom produces_refl0_spec : forall self : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv3 self)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 34 14 34 45] produces0 self (Seq.empty ) self)
  predicate invariant3 (self : i)
  val invariant3 (self : i) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : forall x : i . inv3 x = true
  use prelude.Snapshot
  predicate invariant2 (self : Snapshot.snap_ty (Seq.seq t))
  val invariant2 (self : Snapshot.snap_ty (Seq.seq t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Snapshot.snap_ty (Seq.seq t))
  val inv2 (_x : Snapshot.snap_ty (Seq.seq t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Snapshot.snap_ty (Seq.seq t) . inv2 x = true
  predicate invariant1 (self : Snapshot.snap_ty i)
  val invariant1 (self : Snapshot.snap_ty i) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Snapshot.snap_ty i)
  val inv1 (_x : Snapshot.snap_ty i) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Snapshot.snap_ty i . inv1 x = true
  predicate invariant0 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
    
  val invariant0 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
  val inv0 (_x : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) . inv0 x = true
  predicate completed0 (self : borrowed i)
  val completed0 (self : borrowed i) : bool
    ensures { result = completed0 self }
    
  predicate resolve6 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve6 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve6 self }
    
  predicate resolve5 (self : i)
  val resolve5 (self : i) : bool
    ensures { result = resolve5 self }
    
  use seq.Seq
  function shallow_model0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model2 ( * self)
  val shallow_model0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model0 self }
    
  val push0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (value : t) : ()
    requires {inv7 self}
    requires {inv9 value}
    ensures { [#"../../../../../creusot-contracts/src/std/vec.rs" 78 26 78 51] shallow_model2 ( ^ self) = Seq.snoc (shallow_model0 self) value }
    
  use seq.Seq
  predicate resolve4 (self : Core_Option_Option_Type.t_option t)
  val resolve4 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = resolve4 self }
    
  predicate resolve3 (self : borrowed i) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve3 (self : borrowed i) : bool
    ensures { result = resolve3 self }
    
  val next0 (self : borrowed i) : Core_Option_Option_Type.t_option t
    requires {inv4 self}
    ensures { [#"../../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match result with
      | Core_Option_Option_Type.C_None -> completed0 self
      | Core_Option_Option_Type.C_Some v -> produces0 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv5 result }
    
  use seq.Seq
  use prelude.Snapshot
  function shallow_model3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model0 self
  val shallow_model3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model3 self }
    
  use prelude.Snapshot
  function shallow_model1 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    
   =
    [#"../../../../../creusot-contracts/src/snapshot.rs" 27 20 27 48] shallow_model3 (Snapshot.inner self)
  val shallow_model1 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    ensures { result = shallow_model1 self }
    
  use prelude.Snapshot
  use prelude.Snapshot
  predicate resolve2 (self : Snapshot.snap_ty (Seq.seq t))
  val resolve2 (self : Snapshot.snap_ty (Seq.seq t)) : bool
    ensures { result = resolve2 self }
    
  use prelude.Snapshot
  predicate resolve1 (self : Snapshot.snap_ty i)
  val resolve1 (self : Snapshot.snap_ty i) : bool
    ensures { result = resolve1 self }
    
  use prelude.Snapshot
  predicate into_iter_post0 (self : i) (res : i) =
    [#"../../../../../creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post0 (self : i) (res : i) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : i) =
    [#"../../../../../creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre0 (self : i) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : i) : i
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv3 self}
    ensures { [#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    ensures { inv3 result }
    
  predicate resolve0 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
    
  val resolve0 (self : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = resolve0 self }
    
  use prelude.Snapshot
  let rec cfg extend [#"../08_collect_extend.rs" 25 0 25 66] [@cfg:stackify] [@cfg:subregion_analysis] (vec : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (iter : i) : ()
    requires {[#"../08_collect_extend.rs" 25 40 25 43] inv7 vec}
    requires {[#"../08_collect_extend.rs" 25 58 25 62] inv3 iter}
    ensures { [#"../08_collect_extend.rs" 21 0 24 2] exists prod : Seq.seq t . exists done' : borrowed i . inv8 prod /\ inv4 done' /\ completed0 done' /\ produces0 iter prod ( * done') /\ shallow_model2 ( ^ vec) = Seq.(++) (shallow_model0 vec) prod }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var vec : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) = vec;
  var iter : i = iter;
  var old_vec : Snapshot.snap_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)));
  var iter1 : i;
  var iter_old : Snapshot.snap_ty i;
  var produced : Snapshot.snap_ty (Seq.seq t);
  var _17 : Core_Option_Option_Type.t_option t;
  var _18 : borrowed i;
  var _19 : borrowed i;
  var __creusot_proc_iter_elem : t;
  var _22 : Snapshot.snap_ty (Seq.seq t);
  var x : t;
  var _25 : ();
  var _26 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../08_collect_extend.rs" 26 18 26 35] old_vec <- ([#"../08_collect_extend.rs" 26 18 26 35] Snapshot.new vec);
    goto BB2
  }
  BB2 {
    assert { [@expl:type invariant] inv0 old_vec };
    assume { resolve0 old_vec };
    [#"../08_collect_extend.rs" 27 4 27 35] iter1 <- ([#"../08_collect_extend.rs" 27 4 27 35] into_iter0 iter);
    iter <- any i;
    goto BB3
  }
  BB3 {
    [#"../08_collect_extend.rs" 27 4 27 35] iter_old <- ([#"../08_collect_extend.rs" 27 4 27 35] Snapshot.new iter1);
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] inv1 iter_old };
    assume { resolve1 iter_old };
    [#"../08_collect_extend.rs" 27 4 27 35] produced <- ([#"../08_collect_extend.rs" 27 4 27 35] Snapshot.new (Seq.empty ));
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] inv2 produced };
    assume { resolve2 produced };
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    invariant { [#"../08_collect_extend.rs" 27 4 27 35] inv3 iter1 };
    invariant { [#"../08_collect_extend.rs" 27 4 27 35] produces0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter1 };
    invariant { [#"../08_collect_extend.rs" 27 16 27 33]  ^ Snapshot.inner old_vec =  ^ vec };
    invariant { [#"../08_collect_extend.rs" 27 4 27 35] Seq.(==) (shallow_model0 vec) (Seq.(++) (shallow_model1 old_vec) (Snapshot.inner produced)) };
    goto BB9
  }
  BB9 {
    [#"../08_collect_extend.rs" 27 4 27 35] _19 <- Borrow.borrow_mut iter1;
    [#"../08_collect_extend.rs" 27 4 27 35] iter1 <-  ^ _19;
    assume { inv3 ( ^ _19) };
    [#"../08_collect_extend.rs" 27 4 27 35] _18 <- Borrow.borrow_final ( * _19) (Borrow.get_id _19);
    [#"../08_collect_extend.rs" 27 4 27 35] _19 <- { _19 with current = ( ^ _18) ; };
    assume { inv3 ( ^ _18) };
    [#"../08_collect_extend.rs" 27 4 27 35] _17 <- ([#"../08_collect_extend.rs" 27 4 27 35] next0 _18);
    _18 <- any borrowed i;
    goto BB10
  }
  BB10 {
    assert { [@expl:type invariant] inv4 _19 };
    assume { resolve3 _19 };
    switch (_17)
      | Core_Option_Option_Type.C_None -> goto BB11
      | Core_Option_Option_Type.C_Some _ -> goto BB12
      end
  }
  BB11 {
    assert { [@expl:type invariant] inv5 _17 };
    assume { resolve4 _17 };
    assert { [@expl:type invariant] inv3 iter1 };
    assume { resolve5 iter1 };
    assert { [@expl:type invariant] inv7 vec };
    assume { resolve6 vec };
    [#"../08_collect_extend.rs" 27 4 27 35] _0 <- ([#"../08_collect_extend.rs" 27 4 27 35] ());
    goto BB20
  }
  BB12 {
    goto BB14
  }
  BB13 {
    assert { [@expl:type invariant] inv3 iter1 };
    assume { resolve5 iter1 };
    assert { [@expl:type invariant] inv7 vec };
    assume { resolve6 vec };
    assert { [@expl:type invariant] inv5 _17 };
    assume { resolve4 _17 };
    assert { [#"../08_collect_extend.rs" 27 4 27 35] false };
    absurd
  }
  BB14 {
    [#"../../../../../creusot-contracts-proc/src/lib.rs" 654 0 654 51] __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _17;
    _17 <- (let Core_Option_Option_Type.C_Some x0 = _17 in Core_Option_Option_Type.C_Some (any t));
    assert { [@expl:type invariant] inv5 _17 };
    assume { resolve4 _17 };
    [#"../08_collect_extend.rs" 27 4 27 35] _22 <- ([#"../08_collect_extend.rs" 27 4 27 35] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB15
  }
  BB15 {
    [#"../08_collect_extend.rs" 27 4 27 35] produced <- _22;
    _22 <- any Snapshot.snap_ty (Seq.seq t);
    assert { [@expl:type invariant] inv2 produced };
    assume { resolve2 produced };
    [#"../../../../../creusot-contracts-proc/src/lib.rs" 654 0 654 51] x <- __creusot_proc_iter_elem;
    __creusot_proc_iter_elem <- any t;
    [#"../08_collect_extend.rs" 30 8 30 11] _26 <- Borrow.borrow_mut ( * vec);
    [#"../08_collect_extend.rs" 30 8 30 11] vec <- { vec with current = ( ^ _26) ; };
    assume { inv6 ( ^ _26) };
    [#"../08_collect_extend.rs" 30 8 30 19] _25 <- ([#"../08_collect_extend.rs" 30 8 30 19] push0 _26 x);
    _26 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    x <- any t;
    goto BB16
  }
  BB16 {
    goto BB17
  }
  BB17 {
    goto BB18
  }
  BB18 {
    goto BB19
  }
  BB19 {
    goto BB8
  }
  BB20 {
    goto BB21
  }
  BB21 {
    goto BB22
  }
  BB22 {
    return _0
  }
  
end
module C08CollectExtend_Collect
  type i
  type item0
  predicate invariant8 (self : item0)
  val invariant8 (self : item0) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : item0)
  val inv8 (_x : item0) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : forall x : item0 . inv8 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Borrow
  predicate invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)))
  val invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)))
  val inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) . inv7 x = true
  use seq.Seq
  predicate invariant6 (self : Seq.seq item0)
  val invariant6 (self : Seq.seq item0) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Seq.seq item0)
  val inv6 (_x : Seq.seq item0) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Seq.seq item0 . inv6 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv5 (_x : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))
  val inv5 (_x : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv5 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq item0
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq item0
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv5 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv5 self)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv6 (shallow_model0 self)) && ([#"../../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant5 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv6 (shallow_model0 self)
  val invariant5 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant5 self }
    
  axiom inv5 : forall x : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global) . inv5 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant4 (self : Core_Option_Option_Type.t_option item0)
  val invariant4 (self : Core_Option_Option_Type.t_option item0) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Core_Option_Option_Type.t_option item0)
  val inv4 (_x : Core_Option_Option_Type.t_option item0) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : Core_Option_Option_Type.t_option item0 . inv4 x = true
  predicate invariant3 (self : borrowed i)
  val invariant3 (self : borrowed i) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : borrowed i)
  val inv3 (_x : borrowed i) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : borrowed i . inv3 x = true
  use seq.Seq
  predicate inv2 (_x : i)
  val inv2 (_x : i) : bool
    ensures { result = inv2 _x }
    
  predicate produces0 (self : i) (visited : Seq.seq item0) (o : i)
  val produces0 (self : i) (visited : Seq.seq item0) (o : i) : bool
    ensures { result = produces0 self visited o }
    
  function produces_trans0 (a : i) (ab : Seq.seq item0) (b : i) (bc : Seq.seq item0) (c : i) : ()
  val produces_trans0 (a : i) (ab : Seq.seq item0) (b : i) (bc : Seq.seq item0) (c : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv2 a}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv6 ab}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv2 b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv6 bc}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv2 c}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : i, ab : Seq.seq item0, b : i, bc : Seq.seq item0, c : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv2 a)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv6 ab)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv2 b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv6 bc)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv2 c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 40 14 40 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (self : i) : ()
  val produces_refl0 (self : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv2 self}
    ensures { result = produces_refl0 self }
    
  axiom produces_refl0_spec : forall self : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv2 self)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 34 14 34 45] produces0 self (Seq.empty ) self)
  predicate invariant2 (self : i)
  val invariant2 (self : i) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : forall x : i . inv2 x = true
  use prelude.Snapshot
  predicate invariant1 (self : Snapshot.snap_ty (Seq.seq item0))
  val invariant1 (self : Snapshot.snap_ty (Seq.seq item0)) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Snapshot.snap_ty (Seq.seq item0))
  val inv1 (_x : Snapshot.snap_ty (Seq.seq item0)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Snapshot.snap_ty (Seq.seq item0) . inv1 x = true
  predicate invariant0 (self : Snapshot.snap_ty i)
  val invariant0 (self : Snapshot.snap_ty i) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Snapshot.snap_ty i)
  val inv0 (_x : Snapshot.snap_ty i) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Snapshot.snap_ty i . inv0 x = true
  predicate completed0 (self : borrowed i)
  val completed0 (self : borrowed i) : bool
    ensures { result = completed0 self }
    
  predicate resolve6 (self : item0)
  val resolve6 (self : item0) : bool
    ensures { result = resolve6 self }
    
  use seq.Seq
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : item0
    
   =
    [#"../../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model0 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : item0
    ensures { result = index_logic0 self ix }
    
  predicate resolve5 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 51 8 51 85] forall i : int . 0 <= i /\ i < Seq.length (shallow_model0 self)
     -> resolve6 (index_logic0 self i)
  val resolve5 (self : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve5 self }
    
  predicate resolve4 (self : i)
  val resolve4 (self : i) : bool
    ensures { result = resolve4 self }
    
  use seq.Seq
  function shallow_model2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq item0
    
   =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model0 ( * self)
  val shallow_model2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq item0
    ensures { result = shallow_model2 self }
    
  val push0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global))) (value : item0) : ()
    requires {inv7 self}
    requires {inv8 value}
    ensures { [#"../../../../../creusot-contracts/src/std/vec.rs" 78 26 78 51] shallow_model0 ( ^ self) = Seq.snoc (shallow_model2 self) value }
    
  use seq.Seq
  predicate resolve3 (self : Core_Option_Option_Type.t_option item0)
  val resolve3 (self : Core_Option_Option_Type.t_option item0) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : borrowed i) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed i) : bool
    ensures { result = resolve2 self }
    
  val next0 (self : borrowed i) : Core_Option_Option_Type.t_option item0
    requires {inv3 self}
    ensures { [#"../../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match result with
      | Core_Option_Option_Type.C_None -> completed0 self
      | Core_Option_Option_Type.C_Some v -> produces0 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv4 result }
    
  use seq.Seq
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  predicate resolve1 (self : Snapshot.snap_ty (Seq.seq item0))
  val resolve1 (self : Snapshot.snap_ty (Seq.seq item0)) : bool
    ensures { result = resolve1 self }
    
  use prelude.Snapshot
  predicate resolve0 (self : Snapshot.snap_ty i)
  val resolve0 (self : Snapshot.snap_ty i) : bool
    ensures { result = resolve0 self }
    
  use prelude.Snapshot
  predicate into_iter_post0 (self : i) (res : i) =
    [#"../../../../../creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post0 (self : i) (res : i) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : i) =
    [#"../../../../../creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre0 (self : i) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : i) : i
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv2 self}
    ensures { [#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    ensures { inv2 result }
    
  val new0 (_1 : ()) : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../../../creusot-contracts/src/std/vec.rs" 68 26 68 44] Seq.length (shallow_model0 result) = 0 }
    ensures { inv5 result }
    
  let rec cfg collect [#"../08_collect_extend.rs" 42 0 42 52] [@cfg:stackify] [@cfg:subregion_analysis] (iter : i) : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global)
    requires {[#"../08_collect_extend.rs" 42 28 42 32] inv2 iter}
    ensures { [#"../08_collect_extend.rs" 38 0 41 2] exists prod : Seq.seq item0 . exists done' : borrowed i . inv6 prod /\ inv3 done' /\ completed0 done' /\ produces0 iter prod ( * done') /\ shallow_model0 result = prod }
    ensures { [#"../08_collect_extend.rs" 42 40 42 52] inv5 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global);
  var iter : i = iter;
  var res : Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global);
  var iter1 : i;
  var iter_old : Snapshot.snap_ty i;
  var produced : Snapshot.snap_ty (Seq.seq item0);
  var _15 : Core_Option_Option_Type.t_option item0;
  var _16 : borrowed i;
  var _17 : borrowed i;
  var __creusot_proc_iter_elem : item0;
  var _20 : Snapshot.snap_ty (Seq.seq item0);
  var x : item0;
  var _23 : ();
  var _24 : borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../08_collect_extend.rs" 43 18 43 28] res <- ([#"../08_collect_extend.rs" 43 18 43 28] new0 ([#"../08_collect_extend.rs" 43 18 43 28] ()));
    goto BB2
  }
  BB2 {
    [#"../08_collect_extend.rs" 45 4 45 40] iter1 <- ([#"../08_collect_extend.rs" 45 4 45 40] into_iter0 iter);
    iter <- any i;
    goto BB3
  }
  BB3 {
    [#"../08_collect_extend.rs" 45 4 45 40] iter_old <- ([#"../08_collect_extend.rs" 45 4 45 40] Snapshot.new iter1);
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] inv0 iter_old };
    assume { resolve0 iter_old };
    [#"../08_collect_extend.rs" 45 4 45 40] produced <- ([#"../08_collect_extend.rs" 45 4 45 40] Snapshot.new (Seq.empty ));
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] inv1 produced };
    assume { resolve1 produced };
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    invariant { [#"../08_collect_extend.rs" 45 4 45 40] inv2 iter1 };
    invariant { [#"../08_collect_extend.rs" 45 4 45 40] produces0 (Snapshot.inner iter_old) (Snapshot.inner produced) iter1 };
    invariant { [#"../08_collect_extend.rs" 45 4 45 40] Seq.(==) (shallow_model0 res) (Snapshot.inner produced) };
    goto BB10
  }
  BB10 {
    [#"../08_collect_extend.rs" 45 4 45 40] _17 <- Borrow.borrow_mut iter1;
    [#"../08_collect_extend.rs" 45 4 45 40] iter1 <-  ^ _17;
    assume { inv2 ( ^ _17) };
    [#"../08_collect_extend.rs" 45 4 45 40] _16 <- Borrow.borrow_final ( * _17) (Borrow.get_id _17);
    [#"../08_collect_extend.rs" 45 4 45 40] _17 <- { _17 with current = ( ^ _16) ; };
    assume { inv2 ( ^ _16) };
    [#"../08_collect_extend.rs" 45 4 45 40] _15 <- ([#"../08_collect_extend.rs" 45 4 45 40] next0 _16);
    _16 <- any borrowed i;
    goto BB11
  }
  BB11 {
    assert { [@expl:type invariant] inv3 _17 };
    assume { resolve2 _17 };
    switch (_15)
      | Core_Option_Option_Type.C_None -> goto BB12
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB12 {
    assert { [@expl:type invariant] inv4 _15 };
    assume { resolve3 _15 };
    assert { [@expl:type invariant] inv2 iter1 };
    assume { resolve4 iter1 };
    goto BB21
  }
  BB13 {
    goto BB15
  }
  BB14 {
    assert { [@expl:type invariant] inv2 iter1 };
    assume { resolve4 iter1 };
    assert { [@expl:type invariant] inv5 res };
    assume { resolve5 res };
    assert { [@expl:type invariant] inv4 _15 };
    assume { resolve3 _15 };
    assert { [#"../08_collect_extend.rs" 45 4 45 40] false };
    absurd
  }
  BB15 {
    [#"../../../../../creusot-contracts-proc/src/lib.rs" 654 0 654 51] __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _15;
    _15 <- (let Core_Option_Option_Type.C_Some x0 = _15 in Core_Option_Option_Type.C_Some (any item0));
    assert { [@expl:type invariant] inv4 _15 };
    assume { resolve3 _15 };
    [#"../08_collect_extend.rs" 45 4 45 40] _20 <- ([#"../08_collect_extend.rs" 45 4 45 40] Snapshot.new (Seq.(++) (Snapshot.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB16
  }
  BB16 {
    [#"../08_collect_extend.rs" 45 4 45 40] produced <- _20;
    _20 <- any Snapshot.snap_ty (Seq.seq item0);
    assert { [@expl:type invariant] inv1 produced };
    assume { resolve1 produced };
    [#"../../../../../creusot-contracts-proc/src/lib.rs" 654 0 654 51] x <- __creusot_proc_iter_elem;
    __creusot_proc_iter_elem <- any item0;
    [#"../08_collect_extend.rs" 47 8 47 11] _24 <- Borrow.borrow_mut res;
    [#"../08_collect_extend.rs" 47 8 47 11] res <-  ^ _24;
    assume { inv5 ( ^ _24) };
    [#"../08_collect_extend.rs" 47 8 47 19] _23 <- ([#"../08_collect_extend.rs" 47 8 47 19] push0 _24 x);
    _24 <- any borrowed (Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global));
    x <- any item0;
    goto BB17
  }
  BB17 {
    goto BB18
  }
  BB18 {
    goto BB19
  }
  BB19 {
    goto BB20
  }
  BB20 {
    goto BB9
  }
  BB21 {
    goto BB22
  }
  BB22 {
    [#"../08_collect_extend.rs" 49 4 49 7] _0 <- res;
    res <- any Alloc_Vec_Vec_Type.t_vec item0 (Alloc_Alloc_Global_Type.t_global);
    goto BB23
  }
  BB23 {
    goto BB24
  }
  BB24 {
    return _0
  }
  
end
module Core_Mem_ManuallyDrop_ManuallyDrop_Type
  type t_manuallydrop 't =
    | C_ManuallyDrop 't
    
end
module Alloc_Vec_IntoIter_IntoIter_Type
  use prelude.Opaque
  use Core_Mem_ManuallyDrop_ManuallyDrop_Type as Core_Mem_ManuallyDrop_ManuallyDrop_Type
  use prelude.UIntSize
  use prelude.Int
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_intoiter 't 'a =
    | C_IntoIter (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't) usize (Core_Mem_ManuallyDrop_ManuallyDrop_Type.t_manuallydrop 'a) (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) opaque_ptr
    
end
module C08CollectExtend_ExtendIndex
  use prelude.UInt32
  use prelude.Slice
  predicate invariant7 (self : slice uint32) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant7 (self : slice uint32) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : slice uint32)
  val inv7 (_x : slice uint32) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : slice uint32 . inv7 x = true
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_IntoIter_IntoIter_Type as Alloc_Vec_IntoIter_IntoIter_Type
  use seq.Seq
  predicate inv5 (_x : Seq.seq uint32)
  val inv5 (_x : Seq.seq uint32) : bool
    ensures { result = inv5 _x }
    
  predicate inv3 (_x : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model7 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
    
  val shallow_model7 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
    ensures { result = shallow_model7 self }
    
  predicate produces0 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (visited : Seq.seq uint32) (rhs : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 237 12 237 41] shallow_model7 self = Seq.(++) visited (shallow_model7 rhs)
  val produces0 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (visited : Seq.seq uint32) (rhs : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = produces0 self visited rhs }
    
  function produces_trans0 (a : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (ab : Seq.seq uint32) (b : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (bc : Seq.seq uint32) (c : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    
   =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 246 4 246 10] ()
  val produces_trans0 (a : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (ab : Seq.seq uint32) (b : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) (bc : Seq.seq uint32) (c : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 248 15 248 32] produces0 a ab b}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 249 15 249 32] produces0 b bc c}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 251 22 251 23] inv3 a}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 251 31 251 33] inv5 ab}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 251 43 251 44] inv3 b}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 251 52 251 54] inv5 bc}
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 251 64 251 65] inv3 c}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global), ab : Seq.seq uint32, b : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global), bc : Seq.seq uint32, c : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 248 15 248 32] produces0 a ab b)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 249 15 249 32] produces0 b bc c)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 251 22 251 23] inv3 a)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 251 31 251 33] inv5 ab)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 251 43 251 44] inv3 b)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 251 52 251 54] inv5 bc)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 251 64 251 65] inv3 c)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 250 14 250 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    
   =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 241 4 241 10] ()
  val produces_refl0 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 244 21 244 25] inv3 self}
    ensures { result = produces_refl0 self }
    
  axiom produces_refl0_spec : forall self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 244 21 244 25] inv3 self)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 243 14 243 45] produces0 self (Seq.empty ) self)
  use prelude.Borrow
  predicate invariant6 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)))
    
   =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)))
  val inv6 (_x : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) . inv6 x = true
  predicate invariant5 (self : Seq.seq uint32) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : Seq.seq uint32) : bool
    ensures { result = invariant5 self }
    
  axiom inv5 : forall x : Seq.seq uint32 . inv5 x = true
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)))
  val inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) . inv4 x = true
  predicate invariant3 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : forall x : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv5 (shallow_model0 self)) && ([#"../../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv5 (shallow_model0 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : forall x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  predicate invariant1 (self : slice uint32) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : slice uint32) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : slice uint32)
  val inv1 (_x : slice uint32) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : slice uint32 . inv1 x = true
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use prelude.Snapshot
  use seq.Seq
  use prelude.Slice
  function shallow_model6 (self : slice uint32) : Seq.seq uint32
  val shallow_model6 (self : slice uint32) : Seq.seq uint32
    requires {[#"../../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv7 self}
    ensures { result = shallow_model6 self }
    
  axiom shallow_model6_spec : forall self : slice uint32 . ([#"../../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv7 self)
   -> ([#"../../../../../creusot-contracts/src/std/slice.rs" 19 4 19 50] inv5 (shallow_model6 self)) && ([#"../../../../../creusot-contracts/src/std/slice.rs" 18 14 18 42] shallow_model6 self = Slice.id self) && ([#"../../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model6 self) <= UIntSize.to_int max0)
  function shallow_model2 (self : slice uint32) : Seq.seq uint32 =
    [#"../../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model6 self
  val shallow_model2 (self : slice uint32) : Seq.seq uint32
    ensures { result = shallow_model2 self }
    
  use prelude.Snapshot
  function shallow_model1 (self : Snapshot.snap_ty (slice uint32)) : Seq.seq uint32 =
    [#"../../../../../creusot-contracts/src/snapshot.rs" 27 20 27 48] shallow_model2 (Snapshot.inner self)
  val shallow_model1 (self : Snapshot.snap_ty (slice uint32)) : Seq.seq uint32
    ensures { result = shallow_model1 self }
    
  predicate resolve2 (self : uint32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : uint32) : bool
    ensures { result = resolve2 self }
    
  use seq.Seq
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : uint32
    
   =
    [#"../../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model0 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : uint32
    ensures { result = index_logic0 self ix }
    
  predicate resolve1 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 51 8 51 85] forall i : int . 0 <= i /\ i < Seq.length (shallow_model0 self)
     -> resolve2 (index_logic0 self i)
  val resolve1 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve0 self }
    
  function shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq uint32
    
   =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model0 ( * self)
  val shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq uint32
    ensures { result = shallow_model4 self }
    
  function shallow_model8 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq uint32
    
   =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model7 ( * self)
  val shallow_model8 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : Seq.seq uint32
    ensures { result = shallow_model8 self }
    
  predicate resolve3 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)))
    
   =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve3 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve3 self }
    
  predicate completed0 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)))
    
   =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 230 20 230 57] resolve3 self /\ shallow_model8 self = Seq.empty 
  val completed0 (self : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = completed0 self }
    
  val extend0 [#"../08_collect_extend.rs" 25 0 25 66] (vec : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))) (iter : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    requires {[#"../08_collect_extend.rs" 25 40 25 43] inv4 vec}
    requires {[#"../08_collect_extend.rs" 25 58 25 62] inv3 iter}
    ensures { [#"../08_collect_extend.rs" 21 0 24 2] exists prod : Seq.seq uint32 . exists done' : borrowed (Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) . inv5 prod /\ inv6 done' /\ completed0 done' /\ produces0 iter prod ( * done') /\ shallow_model0 ( ^ vec) = Seq.(++) (shallow_model4 vec) prod }
    
  predicate into_iter_post0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (res : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 174 20 174 33] shallow_model0 self = shallow_model7 res
  val into_iter_post0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (res : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 168 20 168 24] true
  val into_iter_pre0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global)
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv2 self}
    ensures { [#"../../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    ensures { inv3 result }
    
  use prelude.Snapshot
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32 =
    [#"../../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model0 self
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
    ensures { result = shallow_model3 self }
    
  val deref0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : slice uint32
    requires {inv0 self}
    ensures { [#"../../../../../creusot-contracts/src/std/vec.rs" 147 26 147 42] shallow_model2 result = shallow_model3 self }
    ensures { inv1 result }
    
  let rec cfg extend_index [#"../08_collect_extend.rs" 52 0 52 51] [@cfg:stackify] [@cfg:subregion_analysis] (v1 : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (v2 : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var v1 : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) = v1;
  var v2 : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) = v2;
  var oldv1 : Snapshot.snap_ty (slice uint32);
  var oldv2 : Snapshot.snap_ty (slice uint32);
  var _7 : ();
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global));
  var _9 : borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global));
  var _10 : Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    [#"../08_collect_extend.rs" 53 16 53 33] oldv1 <- ([#"../08_collect_extend.rs" 53 16 53 33] Snapshot.new (deref0 v1));
    goto BB1
  }
  BB1 {
    [#"../08_collect_extend.rs" 54 16 54 33] oldv2 <- ([#"../08_collect_extend.rs" 54 16 54 33] Snapshot.new (deref0 v2));
    goto BB2
  }
  BB2 {
    [#"../08_collect_extend.rs" 55 11 55 18] _9 <- Borrow.borrow_mut v1;
    [#"../08_collect_extend.rs" 55 11 55 18] v1 <-  ^ _9;
    [#"../08_collect_extend.rs" 55 11 55 18] _8 <- Borrow.borrow_final ( * _9) (Borrow.get_id _9);
    [#"../08_collect_extend.rs" 55 11 55 18] _9 <- { _9 with current = ( ^ _8) ; };
    [#"../08_collect_extend.rs" 55 20 55 34] _10 <- ([#"../08_collect_extend.rs" 55 20 55 34] into_iter0 v2);
    v2 <- any Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global);
    goto BB3
  }
  BB3 {
    [#"../08_collect_extend.rs" 55 4 55 35] _7 <- ([#"../08_collect_extend.rs" 55 4 55 35] extend0 _8 _10);
    _8 <- any borrowed (Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global));
    _10 <- any Alloc_Vec_IntoIter_IntoIter_Type.t_intoiter uint32 (Alloc_Alloc_Global_Type.t_global);
    goto BB4
  }
  BB4 {
    assume { resolve0 _9 };
    assume { resolve1 v1 };
    assert { [@expl:assertion] [#"../08_collect_extend.rs" 57 4 57 55] Seq.(==) (shallow_model0 v1) (Seq.(++) (shallow_model1 oldv1) (shallow_model1 oldv2)) };
    goto BB5
  }
  BB5 {
    [#"../08_collect_extend.rs" 52 52 58 1] _0 <- ([#"../08_collect_extend.rs" 52 52 58 1] ());
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module C08CollectExtend_CollectExample
  type i
  use prelude.UInt32
  use seq.Seq
  predicate inv1 (_x : Seq.seq uint32)
  val inv1 (_x : Seq.seq uint32) : bool
    ensures { result = inv1 _x }
    
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq uint32
    requires {[#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self)
   -> ([#"../../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv1 (shallow_model0 self)) && ([#"../../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv1 (shallow_model0 self)
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : forall x : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  use prelude.Borrow
  predicate invariant2 (self : borrowed i)
  val invariant2 (self : borrowed i) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed i)
  val inv2 (_x : borrowed i) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed i . inv2 x = true
  predicate invariant1 (self : Seq.seq uint32) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Seq.seq uint32) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : forall x : Seq.seq uint32 . inv1 x = true
  use seq.Seq
  predicate inv0 (_x : i)
  val inv0 (_x : i) : bool
    ensures { result = inv0 _x }
    
  predicate produces0 (self : i) (visited : Seq.seq uint32) (o : i)
  val produces0 (self : i) (visited : Seq.seq uint32) (o : i) : bool
    ensures { result = produces0 self visited o }
    
  function produces_trans0 (a : i) (ab : Seq.seq uint32) (b : i) (bc : Seq.seq uint32) (c : i) : ()
  val produces_trans0 (a : i) (ab : Seq.seq uint32) (b : i) (bc : Seq.seq uint32) (c : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv0 a}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv1 ab}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv0 b}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv1 bc}
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv0 c}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : i, ab : Seq.seq uint32, b : i, bc : Seq.seq uint32, c : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 38 15 38 32] produces0 a ab b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 39 15 39 32] produces0 b bc c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 22 41 23] inv0 a)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 31 41 33] inv1 ab)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 52 41 53] inv0 b)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 61 41 63] inv1 bc)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 41 82 41 83] inv0 c)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 40 14 40 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (self : i) : ()
  val produces_refl0 (self : i) : ()
    requires {[#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv0 self}
    ensures { result = produces_refl0 self }
    
  axiom produces_refl0_spec : forall self : i . ([#"../../../../../creusot-contracts/src/std/iter.rs" 35 21 35 25] inv0 self)
   -> ([#"../../../../../creusot-contracts/src/std/iter.rs" 34 14 34 45] produces0 self (Seq.empty ) self)
  predicate invariant0 (self : i)
  val invariant0 (self : i) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : i . inv0 x = true
  use seq.Seq
  use prelude.UInt32
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : uint32
    
   =
    [#"../../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model0 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : uint32
    ensures { result = index_logic0 self ix }
    
  predicate resolve1 (self : uint32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve1 (self : uint32) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../../creusot-contracts/src/std/vec.rs" 51 8 51 85] forall i : int . 0 <= i /\ i < Seq.length (shallow_model0 self)
     -> resolve1 (index_logic0 self i)
  val resolve0 (self : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve0 self }
    
  predicate completed0 (self : borrowed i)
  val completed0 (self : borrowed i) : bool
    ensures { result = completed0 self }
    
  val collect0 [#"../08_collect_extend.rs" 42 0 42 52] (iter : i) : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global)
    requires {[#"../08_collect_extend.rs" 42 28 42 32] inv0 iter}
    ensures { [#"../08_collect_extend.rs" 38 0 41 2] exists prod : Seq.seq uint32 . exists done' : borrowed i . inv1 prod /\ inv2 done' /\ completed0 done' /\ produces0 iter prod ( * done') /\ shallow_model0 result = prod }
    ensures { [#"../08_collect_extend.rs" 42 40 42 52] inv3 result }
    
  let rec cfg collect_example [#"../08_collect_extend.rs" 61 0 61 56] [@cfg:stackify] [@cfg:subregion_analysis] (iter : i) : ()
    requires {[#"../08_collect_extend.rs" 60 0 60 130] forall fin : i . forall prod : Seq.seq uint32 . inv0 fin
     -> produces0 iter prod fin
     -> (forall i : int . 0 <= i /\ i < Seq.length prod  -> UInt32.to_int (Seq.get prod i) = i)}
    requires {[#"../08_collect_extend.rs" 61 48 61 52] inv0 iter}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var iter : i = iter;
  var v : Alloc_Vec_Vec_Type.t_vec uint32 (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../08_collect_extend.rs" 62 22 62 35] v <- ([#"../08_collect_extend.rs" 62 22 62 35] collect0 iter);
    iter <- any i;
    goto BB2
  }
  BB2 {
    assume { resolve0 v };
    assert { [@expl:assertion] [#"../08_collect_extend.rs" 64 4 64 75] forall i : int . 0 <= i /\ i < Seq.length (shallow_model0 v)
     -> UInt32.to_int (index_logic0 v i) = i };
    goto BB3
  }
  BB3 {
    [#"../08_collect_extend.rs" 61 57 65 1] _0 <- ([#"../08_collect_extend.rs" 61 57 65 1] ());
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
