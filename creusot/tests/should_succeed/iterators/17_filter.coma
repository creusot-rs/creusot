module M_17_filter__qyi17392541228996028033__produces_refl [#"17_filter.rs" 51 4 51 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 50 14 50 45
  let%span s17_filter1 = "17_filter.rs" 48 4 48 10
  let%span s17_filter2 = "17_filter.rs" 64 12 76 17
  let%span scommon3 = "common.rs" 14 14 14 45
  let%span scommon4 = "common.rs" 18 15 18 32
  let%span scommon5 = "common.rs" 19 15 19 32
  let%span scommon6 = "common.rs" 20 14 20 42
  let%span s17_filter7 = "17_filter.rs" 24 12 30 122
  let%span sops8 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops9 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  
  use seq.Seq
  
  type t_I'0
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon4] produces'1 a ab b)
   -> ([%#scommon5] produces'1 b bc c)  -> ([%#scommon6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#scommon3] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter7] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter2] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"17_filter.rs" 51 4 51 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : [%#s17_filter0] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
end
module M_17_filter__qyi17392541228996028033__produces_trans [#"17_filter.rs" 58 4 58 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 55 15 55 32
  let%span s17_filter1 = "17_filter.rs" 56 15 56 32
  let%span s17_filter2 = "17_filter.rs" 57 14 57 42
  let%span s17_filter3 = "17_filter.rs" 53 4 53 10
  let%span s17_filter4 = "17_filter.rs" 64 12 76 17
  let%span s17_filter5 = "17_filter.rs" 24 12 30 122
  let%span scommon6 = "common.rs" 14 14 14 45
  let%span scommon7 = "common.rs" 18 15 18 32
  let%span scommon8 = "common.rs" 19 15 19 32
  let%span scommon9 = "common.rs" 20 14 20 42
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon7] produces'1 a ab b)
   -> ([%#scommon8] produces'1 b bc c)  -> ([%#scommon9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon6] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self
  
  use prelude.prelude.Borrow
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter5] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter4] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"17_filter.rs" 58 4 58 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#s17_filter1] produces'0 b bc c)
   -> ([%#s17_filter0] produces'0 a ab b)  -> ([%#s17_filter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_17_filter__qyi17392541228996028033__next [#"17_filter.rs" 84 4 84 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 85 23 85 40
  let%span s17_filter1 = "17_filter.rs" 86 27 86 51
  let%span s17_filter2 = "17_filter.rs" 88 8 88 31
  let%span s17_filter3 = "17_filter.rs" 90 20 90 129
  let%span s17_filter4 = "17_filter.rs" 89 20 89 46
  let%span s17_filter5 = "17_filter.rs" 88 20 88 29
  let%span s17_filter6 = "17_filter.rs" 94 23 94 58
  let%span s17_filter7 = "17_filter.rs" 95 12 95 71
  let%span s17_filter8 = "17_filter.rs" 84 17 84 21
  let%span s17_filter9 = "17_filter.rs" 84 26 84 41
  let%span s17_filter10 = "17_filter.rs" 80 14 83 5
  let%span sindex11 = "../../../../creusot-contracts/src/logic/ops/index.rs" 89 8 89 33
  let%span scommon12 = "common.rs" 27 17 27 21
  let%span scommon13 = "common.rs" 27 26 27 44
  let%span scommon14 = "common.rs" 23 14 26 5
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 162 27 162 52
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 163 26 163 71
  let%span s17_filter17 = "17_filter.rs" 42 12 44 43
  let%span s17_filter18 = "17_filter.rs" 64 12 76 17
  let%span scommon19 = "common.rs" 14 14 14 45
  let%span scommon20 = "common.rs" 18 15 18 32
  let%span scommon21 = "common.rs" 19 15 19 32
  let%span scommon22 = "common.rs" 20 14 20 42
  let%span sops23 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops24 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops25 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops26 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops27 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops28 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops29 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  let%span sresolve30 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span s17_filter31 = "17_filter.rs" 24 12 30 122
  let%span sinvariant32 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sinvariant33 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  type t_I'0
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon20] produces'0 a ab b)
   -> ([%#scommon21] produces'0 b bc c)  -> ([%#scommon22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon19] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Snapshot
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'3 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops29] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops26] unnest'0 self b)
   -> ([%#sops27] unnest'0 b c)  -> ([%#sops28] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops25] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops23] postcondition_mut'0 self args res_state res)
   -> ([%#sops24] unnest'0 self res_state)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq t_Item'0)) (ix : int) : t_Item'0 =
    [%#sindex11] Seq.get (Snapshot.inner self) ix
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter31] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'1 (_1 : t_I'0)
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'9 (_1 : t_Filter'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Filter'0 [inv'9 x] . inv'9 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  predicate invariant'1 (self : borrowed (t_Filter'0)) =
    [%#sinvariant32] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'0 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'0 x] . inv'0 x = invariant'1 x
  
  predicate invariant'2 (self : borrowed t_I'0) =
    [%#sinvariant32] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'5 (_1 : borrowed t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed t_I'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'3 (_1 : t_Item'0)
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : borrowed t_I'0)
  
  use seq.Seq
  
  let rec next'1 (self:borrowed t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#scommon12] inv'5 self}
    any
    [ return' (result:t_Option'0)-> {[%#scommon13] inv'4 result}
      {[%#scommon14] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use seq.Seq
  
  predicate invariant'3 (self : borrowed t_F'0) =
    [%#sinvariant32] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'6 (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'4 (self : t_Item'0) =
    [%#sinvariant33] inv'3 self
  
  predicate inv'10 (_1 : t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'7 (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'7 x] . inv'7 x = (let (x0) = x in inv'10 x0)
  
  predicate inv'8 (_1 : bool)
  
  axiom inv_axiom'5 [@rewrite] : forall x : bool [inv'8 x] . inv'8 x = true
  
  let rec call_mut'0 (self:borrowed t_F'0) (args:t_Item'0) (return'  (ret:bool))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops15] precondition'0 self.current args}
    any
    [ return' (result:bool)-> {inv'8 result}
      {[%#sops16] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : t_Item'0)
  
  predicate resolve'2 (self : borrowed (t_Filter'0)) =
    [%#sresolve30] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (t_Filter'0)) =
    resolve'2 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  predicate completed'0 [#"17_filter.rs" 40 4 40 35] (self : borrowed (t_Filter'0)) =
    [%#s17_filter17] (exists s : Seq.seq t_Item'0, e : borrowed t_I'0 . produces'0 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use map.Map
  
  use map.Map
  
  predicate produces'1 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter18] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'0 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  meta "compute_max_steps" 1000000
  
  let rec next'0 (self:borrowed (t_Filter'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#s17_filter8] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#s17_filter0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &produced <- [%#s17_filter1] Snapshot.new (Seq.empty  : Seq.seq t_Item'0) ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &old_3_0 <- Snapshot.new self ] s1 | s1 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:mut invariant] (Snapshot.inner old_3_0).final = self.final}
        {[@expl:loop invariant #0] [%#s17_filter5] inv'0 self}
        {[@expl:loop invariant #1] [%#s17_filter4] (self.current).t_Filter__func'0
        = ((Snapshot.inner old_self).current).t_Filter__func'0}
        {[@expl:loop invariant #2] [%#s17_filter3] forall i : int . 0 <= i /\ i < Seq.length (Snapshot.inner produced)
         -> postcondition_mut'0 (self.current).t_Filter__func'0 (index_logic'0 produced i) (self.current).t_Filter__func'0 false}
        {[@expl:loop invariant #3] [%#s17_filter2] produces'0 ((Snapshot.inner old_self).current).t_Filter__iter'0 (Snapshot.inner produced) (self.current).t_Filter__iter'0}
        {[@expl:loop invariant #4] [%#s17_filter2] unnest'0 ((Snapshot.inner old_self).current).t_Filter__func'0 (self.current).t_Filter__func'0}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = {inv'1 (self.current).t_Filter__iter'0}
            Borrow.borrow_mut <t_I'0> {(self.current).t_Filter__iter'0}
              (fun (_ret':borrowed t_I'0) ->
                 [ &_16 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__iter'0 = _ret'.final } } ] 
                s1)
          | s1 = next'1 {_16} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
          | s2 = bb5 ]
          
        | bb5 = any [ br0 -> {_15 = C_None'0 } (! bb13) | br1 (x0:t_Item'0)-> {_15 = C_Some'0 x0} (! bb6) ] 
        | bb6 = bb7
        | bb7 = s0
          [ s0 = v_Some'0 {_15} (fun (r0'0:t_Item'0) ->  [ &n <- r0'0 ] s1)
          | s1 =  [ &_19 <- [%#s17_filter6] Snapshot.new (Seq.snoc (Snapshot.inner produced) n) ] s2
          | s2 = bb8 ]
          
        | bb8 = s0
          [ s0 =  [ &produced <- _19 ] s1
          | s1 = {[@expl:assertion] [%#s17_filter7] produces'0 ((Snapshot.inner old_self).current).t_Filter__iter'0 (Snapshot.inner produced) (self.current).t_Filter__iter'0}
            s2
          | s2 = {inv'2 (self.current).t_Filter__func'0}
            Borrow.borrow_mut <t_F'0> {(self.current).t_Filter__func'0}
              (fun (_ret':borrowed t_F'0) ->
                 [ &_24 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__func'0 = _ret'.final } } ] 
                s3)
          | s3 =  [ &_27 <- n ] s4
          | s4 =  [ &_25 <- (_27) ] s5
          | s5 = call_mut'0 {_24} {_25} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s6)
          | s6 = bb9 ]
          
        | bb9 = any [ br0 -> {_23 = false} (! bb12) | br1 -> {_23} (! bb10) ] 
        | bb12 = s0 [ s0 = {[@expl:type invariant] inv'3 n} s1 | s1 = -{resolve'0 n}- s2 | s2 = bb14 ] 
        | bb14 = bb15
        | bb15 = bb3 ]
         ]
      
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match _15 with
          | C_Some'0 x'0 -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _15 with
          | C_Some'0 x'1 -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb16 ]
      
    | bb16 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb19 ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 =  [ &_0 <- C_Some'0 n ] s3
      | s3 = bb11 ]
      
    | bb11 = bb17
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self : borrowed (t_Filter'0) = self
    | & old_self : Snapshot.snap_ty (borrowed (t_Filter'0)) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & _15 : t_Option'0 = any_l ()
    | & _16 : borrowed t_I'0 = any_l ()
    | & n : t_Item'0 = any_l ()
    | & _19 : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & _23 : bool = any_l ()
    | & _24 : borrowed t_F'0 = any_l ()
    | & _25 : t_Item'0 = any_l ()
    | & _27 : t_Item'0 = any_l ()
    | & old_3_0 : Snapshot.snap_ty (borrowed (t_Filter'0)) = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:next result type invariant] [%#s17_filter9] inv'4 result}
      {[@expl:next ensures] [%#s17_filter10] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'1 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
end
module M_17_filter__filter [#"17_filter.rs" 110 0 112 39]
  let%span s17_filter0 = "17_filter.rs" 110 30 110 34
  let%span s17_filter1 = "17_filter.rs" 110 39 110 40
  let%span s17_filter2 = "17_filter.rs" 106 11 106 23
  let%span s17_filter3 = "17_filter.rs" 107 11 107 29
  let%span s17_filter4 = "17_filter.rs" 108 11 108 21
  let%span s17_filter5 = "17_filter.rs" 110 48 110 60
  let%span s17_filter6 = "17_filter.rs" 109 10 109 49
  let%span s17_filter7 = "17_filter.rs" 137 16 137 59
  let%span s17_filter8 = "17_filter.rs" 131 16 131 57
  let%span s17_filter9 = "17_filter.rs" 143 16 143 126
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  let%span scommon17 = "common.rs" 14 14 14 45
  let%span scommon18 = "common.rs" 18 15 18 32
  let%span scommon19 = "common.rs" 19 15 19 32
  let%span scommon20 = "common.rs" 20 14 20 42
  let%span s17_filter21 = "17_filter.rs" 24 12 30 122
  
  type t_I'0
  
  type t_P'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_P'0 }
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 (_1 : t_I'0)
  
  predicate inv'1 (_1 : t_P'0)
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon18] produces'0 a ab b)
   -> ([%#scommon19] produces'0 b bc c)  -> ([%#scommon20] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon17] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
  
  predicate postcondition_once'0 (self : t_P'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_P'0)
  
  predicate postcondition_mut'0 (self : t_P'0) (args : t_Item'0) (result_state : t_P'0) (result : bool)
  
  function fn_mut_once'0 (self : t_P'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_P'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_P'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_P'0) (_2 : t_P'0)
  
  function unnest_trans'0 (self : t_P'0) (b : t_P'0) (c : t_P'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_P'0, b : t_P'0, c : t_P'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_P'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_P'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_P'0) (args : t_Item'0) (res_state : t_P'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_P'0, args : t_Item'0, res_state : t_P'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  predicate immutable'0 [#"17_filter.rs" 136 0 136 54] (_1 : t_P'0) =
    [%#s17_filter7] forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g
  
  predicate precondition'0 (self : t_P'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"17_filter.rs" 130 0 130 60] (_1 : t_P'0) =
    [%#s17_filter8] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
  
  predicate precise'0 [#"17_filter.rs" 142 0 142 52] (_1 : t_P'0) =
    [%#s17_filter9] forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter21] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'2 x] . inv'2 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'0 iter /\ inv'1 func
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec filter'0 (iter:t_I'0) (f:t_P'0) (return'  (ret:t_Filter'0))= {[@expl:filter 'iter' type invariant] [%#s17_filter0] inv'0 iter}
    {[@expl:filter 'f' type invariant] [%#s17_filter1] inv'1 f}
    {[@expl:filter requires #0] [%#s17_filter2] immutable'0 f}
    {[@expl:filter requires #1] [%#s17_filter3] no_precondition'0 f}
    {[@expl:filter requires #2] [%#s17_filter4] precise'0 f}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- { t_Filter__iter'0 = iter; t_Filter__func'0 = f } ] s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_Filter'0 = any_l () | & iter : t_I'0 = iter | & f : t_P'0 = f ] 
    [ return' (result:t_Filter'0)-> {[@expl:filter result type invariant] [%#s17_filter5] inv'2 result}
      {[@expl:filter ensures] [%#s17_filter6] result.t_Filter__iter'0 = iter /\ result.t_Filter__func'0 = f}
      (! return' {result}) ]
    
end
module M_17_filter__less_than [#"17_filter.rs" 119 0 119 49]
  let%span s17_filter0 = "17_filter.rs" 117 10 117 70
  let%span s17_filter1 = "17_filter.rs" 118 10 118 79
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span s17_filter3 = "17_filter.rs" 122 22 122 40
  let%span siter4 = "../../../../creusot-contracts/src/std/iter.rs" 144 27 144 47
  let%span siter5 = "../../../../creusot-contracts/src/std/iter.rs" 145 27 145 53
  let%span siter6 = "../../../../creusot-contracts/src/std/iter.rs" 146 27 146 45
  let%span siter7 = "../../../../creusot-contracts/src/std/iter.rs" 172 26 174 81
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sindex9 = "../../../../creusot-contracts/src/logic/ops/index.rs" 23 8 23 31
  let%span sseq10 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span svec11 = "../../../../creusot-contracts/src/std/vec.rs" 191 20 191 24
  let%span svec12 = "../../../../creusot-contracts/src/std/vec.rs" 197 20 197 33
  let%span sfilter13 = "../../../../creusot-contracts/src/std/iter/filter.rs" 58 16 58 59
  let%span sfilter14 = "../../../../creusot-contracts/src/std/iter/filter.rs" 50 16 50 57
  let%span sfilter15 = "../../../../creusot-contracts/src/std/iter/filter.rs" 65 16 65 126
  let%span sfilter16 = "../../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter17 = "../../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter18 = "../../../../creusot-contracts/src/std/iter/filter.rs" 77 12 79 47
  let%span sfilter19 = "../../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span svec20 = "../../../../creusot-contracts/src/std/vec.rs" 285 20 285 32
  let%span sresolve21 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sops22 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops23 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops24 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops25 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops26 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops27 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops28 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  let%span sfilter29 = "../../../../creusot-contracts/src/std/iter/filter.rs" 104 15 104 24
  let%span sfilter30 = "../../../../creusot-contracts/src/std/iter/filter.rs" 105 14 105 45
  let%span sfilter31 = "../../../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 21
  let%span sfilter32 = "../../../../creusot-contracts/src/std/iter/filter.rs" 111 15 111 21
  let%span sfilter33 = "../../../../creusot-contracts/src/std/iter/filter.rs" 112 15 112 21
  let%span sfilter34 = "../../../../creusot-contracts/src/std/iter/filter.rs" 113 15 113 32
  let%span sfilter35 = "../../../../creusot-contracts/src/std/iter/filter.rs" 114 15 114 32
  let%span sfilter36 = "../../../../creusot-contracts/src/std/iter/filter.rs" 115 14 115 42
  let%span svec37 = "../../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  let%span svec38 = "../../../../creusot-contracts/src/std/vec.rs" 257 20 257 57
  let%span sinvariant39 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span svec40 = "../../../../creusot-contracts/src/std/vec.rs" 270 14 270 45
  let%span svec41 = "../../../../creusot-contracts/src/std/vec.rs" 268 4 268 10
  let%span svec42 = "../../../../creusot-contracts/src/std/vec.rs" 275 15 275 32
  let%span svec43 = "../../../../creusot-contracts/src/std/vec.rs" 276 15 276 32
  let%span svec44 = "../../../../creusot-contracts/src/std/vec.rs" 277 14 277 42
  let%span svec45 = "../../../../creusot-contracts/src/std/vec.rs" 273 4 273 10
  let%span smodel46 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Vec'0) =
    [%#svec11] true
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: () }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: usize;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  predicate inv'1 (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq uint32
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec8] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  function view'1 (self : t_IntoIter'0) : Seq.seq uint32
  
  predicate into_iter_post'0 (self : t_Vec'0) (res : t_IntoIter'0) =
    [%#svec12] view'0 self = view'1 res
  
  let rec into_iter'0 (self:t_Vec'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter2] into_iter_pre'0 self}
    any
    [ return' (result:t_IntoIter'0)-> {inv'1 result} {[%#siter2] into_iter_post'0 self result} (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  type closure2'1  =
    { field_0'0: uint32 }
  
  predicate resolve'2 (self : borrowed closure2'1) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed closure2'1) =
    resolve'2 _1
  
  use prelude.prelude.Intrinsic
  
  predicate postcondition_once'0 (self : closure2'1) (args : uint32) (result : bool) =
    [%#s17_filter3] let (i) = args in result = (i < self.field_0'0)
  
  predicate resolve'3 (_1 : closure2'1) =
    true
  
  predicate unnest'0 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  predicate postcondition_mut'1 (self : closure2'1) (args : uint32) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = (i < result_state.field_0'0)) /\ unnest'0 self result_state
  
  function fn_mut_once'0 (self : closure2'1) (args : uint32) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : closure2'1, args : uint32, res : bool . [%#sops28] postcondition_once'0 self args res
  = (exists res_state : closure2'1 . postcondition_mut'1 self args res_state res /\ resolve'3 res_state)
  
  function unnest_trans'0 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'0_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops25] unnest'0 self b)
   -> ([%#sops26] unnest'0 b c)  -> ([%#sops27] unnest'0 self c)
  
  function unnest_refl'0 (self : closure2'1) : ()
  
  axiom unnest_refl'0_spec : forall self : closure2'1 . [%#sops24] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : closure2'1) (args : uint32) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : closure2'1, args : uint32, res_state : closure2'1, res : bool . ([%#sops22] postcondition_mut'1 self args res_state res)
   -> ([%#sops23] unnest'0 self res_state)
  
  let rec closure2'0 (_1:borrowed closure2'1) (i:uint32) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 _1}- s1
      | s1 = UInt32.lt {i} {(_1.current).field_0'0} (fun (_ret':bool) ->  [ &res <- _ret' ] s2)
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & _1 : borrowed closure2'1 = _1 | & i : uint32 = i | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:closure ensures] [%#s17_filter3] result = (i < (_1.final).field_0'0)}
      {[@expl:closure unnest] unnest'0 _1.current _1.final}
      (! return' {result}) ]
    
  
  predicate inv'2 (_1 : closure2'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : closure2'1 [inv'2 x] . inv'2 x = true
  
  predicate postcondition_once'1 (self : closure2'1) (args : uint32) (result : bool) =
    [%#s17_filter3] let (i) = args in result = (i < self.field_0'0)
  
  predicate postcondition_mut'0 (self : closure2'1) (args : uint32) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = (i < result_state.field_0'0)) /\ unnest'0 self result_state
  
  function fn_mut_once'1 (self : closure2'1) (args : uint32) (res : bool) : ()
  
  axiom fn_mut_once'1_spec : forall self : closure2'1, args : uint32, res : bool . [%#sops28] postcondition_once'1 self args res
  = (exists res_state : closure2'1 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'1 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  function unnest_trans'1 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'1_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops25] unnest'1 self b)
   -> ([%#sops26] unnest'1 b c)  -> ([%#sops27] unnest'1 self c)
  
  function unnest_refl'1 (self : closure2'1) : ()
  
  axiom unnest_refl'1_spec : forall self : closure2'1 . [%#sops24] unnest'1 self self
  
  function postcondition_mut_unnest'1 (self : closure2'1) (args : uint32) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'1_spec : forall self : closure2'1, args : uint32, res_state : closure2'1, res : bool . ([%#sops22] postcondition_mut'0 self args res_state res)
   -> ([%#sops23] unnest'1 self res_state)
  
  predicate immutable'0 (_1 : closure2'1) =
    [%#sfilter13] forall f : closure2'1, g : closure2'1 . unnest'1 f g  -> f = g
  
  predicate precondition'0 (self : closure2'1) (args : uint32) =
    let (i) = args in true
  
  predicate no_precondition'0 (_1 : closure2'1) =
    [%#sfilter14] forall f : closure2'1, i : uint32 . precondition'0 f (i)
  
  predicate precise'0 (_1 : closure2'1) =
    [%#sfilter15] forall f1 : closure2'1, f2 : closure2'1, i : uint32 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_IntoIter'0; t_Filter__predicate'0: closure2'1 }
  
  predicate invariant'0 (self : t_Filter'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> true
    end)
  
  function iter'0 (self : t_Filter'0) : t_IntoIter'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter16] inv'3 self  -> inv'1 (iter'0 self)
  
  function func'0 (self : t_Filter'0) : closure2'1
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter17] inv'3 self  -> inv'2 (func'0 self)
  
  let rec filter'0 (self:t_IntoIter'0) (predicate':closure2'1) (return'  (ret:t_Filter'0))= {[@expl:filter 'self' type invariant] inv'1 self}
    {[@expl:filter 'predicate' type invariant] inv'2 predicate'}
    {[@expl:filter requires #0] [%#siter4] immutable'0 predicate'}
    {[@expl:filter requires #1] [%#siter5] no_precondition'0 predicate'}
    {[@expl:filter requires #2] [%#siter6] precise'0 predicate'}
    any
    [ return' (result:t_Filter'0)-> {inv'3 result}
      {[%#siter2] iter'0 result = self /\ func'0 result = predicate'}
      (! return' {result}) ]
    
  
  predicate invariant'1 (self : borrowed (t_Filter'0)) =
    [%#sinvariant39] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate inv'5 (_1 : Seq.seq uint32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq uint32 [inv'5 x] . inv'5 x = true
  
  predicate resolve'1 (_1 : t_Filter'0) =
    true
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 (self : t_IntoIter'0) (visited : Seq.seq uint32) (rhs : t_IntoIter'0) =
    [%#svec37] view'1 self = Seq.(++) visited (view'1 rhs)
  
  function produces_trans'1 (a : t_IntoIter'0) (ab : Seq.seq uint32) (b : t_IntoIter'0) (bc : Seq.seq uint32) (c : t_IntoIter'0) : ()
    
   =
    [%#svec45] ()
  
  axiom produces_trans'1_spec : forall a : t_IntoIter'0, ab : Seq.seq uint32, b : t_IntoIter'0, bc : Seq.seq uint32, c : t_IntoIter'0 . ([%#svec42] produces'1 a ab b)
   -> ([%#svec43] produces'1 b bc c)  -> ([%#svec44] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_IntoIter'0) : () =
    [%#svec41] ()
  
  axiom produces_refl'1_spec : forall self : t_IntoIter'0 . [%#svec40] produces'1 self (Seq.empty  : Seq.seq uint32) self
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 (self : t_Filter'0) (visited : Seq.seq uint32) (succ : t_Filter'0) =
    [%#sfilter19] unnest'1 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq uint32, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  function produces_trans'0 (a : t_Filter'0) (ab : Seq.seq uint32) (b : t_Filter'0) (bc : Seq.seq uint32) (c : t_Filter'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Filter'0, ab : Seq.seq uint32, b : t_Filter'0, bc : Seq.seq uint32, c : t_Filter'0 . ([%#sfilter31] inv'3 a)
   -> ([%#sfilter32] inv'3 b)
   -> ([%#sfilter33] inv'3 c)
   -> ([%#sfilter34] produces'0 a ab b)
   -> ([%#sfilter35] produces'0 b bc c)  -> ([%#sfilter36] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Filter'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Filter'0 . ([%#sfilter29] inv'3 self)
   -> ([%#sfilter30] produces'0 self (Seq.empty  : Seq.seq uint32) self)
  
  predicate resolve'4 (self : borrowed (t_IntoIter'0)) =
    [%#sresolve21] self.final = self.current
  
  function view'2 (self : borrowed (t_IntoIter'0)) : Seq.seq uint32 =
    [%#smodel46] view'1 self.current
  
  predicate completed'1 (self : borrowed (t_IntoIter'0)) =
    [%#svec38] resolve'4 self /\ view'2 self = (Seq.empty  : Seq.seq uint32)
  
  predicate completed'0 (self : borrowed (t_Filter'0)) =
    [%#sfilter18] (exists s : Seq.seq uint32, e : borrowed (t_IntoIter'0) . produces'1 (iter'0 self.current) s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (func'0 self.current) (Seq.get s i) (func'0 self.final) false))
    /\ func'0 self.current = func'0 self.final
  
  predicate from_iter_post'0 (prod : Seq.seq uint32) (res : t_Vec'0) =
    [%#svec20] prod = view'0 res
  
  let rec collect'0 (self:t_Filter'0) (return'  (ret:t_Vec'0))= {[@expl:collect 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Vec'0)-> {inv'0 result}
      {[%#siter7] exists done' : borrowed (t_Filter'0), prod : Seq.seq uint32 . inv'4 done'
      /\ inv'5 prod
      /\ resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
    
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : uint32 =
    [%#sindex9] Seq.get (view'0 self) ix
  
  predicate contains'0 (self : Seq.seq uint32) (x : uint32) =
    [%#sseq10] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  let rec less_than'0 (v:t_Vec'0) (n:uint32) (return'  (ret:t_Vec'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {v} (fun (_ret':t_IntoIter'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_8 <- { field_0'0 = n } ] s1
      | s1 = filter'0 {_6} {_8} (fun (_ret':t_Filter'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = collect'0 {_5} (fun (_ret':t_Vec'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_Vec'0 = any_l ()
    | & v : t_Vec'0 = v
    | & n : uint32 = n
    | & _5 : t_Filter'0 = any_l ()
    | & _6 : t_IntoIter'0 = any_l ()
    | & _8 : closure2'1 = any_l () ]
    
    [ return' (result:t_Vec'0)-> {[@expl:less_than ensures #0] [%#s17_filter0] forall i : int . 0 <= i
      /\ i < Seq.length (view'0 result)  -> index_logic'0 result i < n}
      {[@expl:less_than ensures #1] [%#s17_filter1] forall i : int . 0 <= i /\ i < Seq.length (view'0 result)
       -> contains'0 (view'0 v) (index_logic'0 result i)}
      (! return' {result}) ]
    
end
module M_17_filter__qyi17392541228996028033__next__refines [#"17_filter.rs" 84 4 84 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 84 4 84 41
  let%span s17_filter1 = "17_filter.rs" 42 12 44 43
  let%span s17_filter2 = "17_filter.rs" 64 12 76 17
  let%span s17_filter3 = "17_filter.rs" 24 12 30 122
  let%span sinvariant4 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span scommon5 = "common.rs" 14 14 14 45
  let%span scommon6 = "common.rs" 18 15 18 32
  let%span scommon7 = "common.rs" 19 15 19 32
  let%span scommon8 = "common.rs" 20 14 20 42
  let%span sops9 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon6] produces'1 a ab b)
   -> ([%#scommon7] produces'1 b bc c)  -> ([%#scommon8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops15] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops12] unnest'0 self b)
   -> ([%#sops13] unnest'0 b c)  -> ([%#sops14] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops11] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops9] postcondition_mut'0 self args res_state res)
   -> ([%#sops10] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'4 (_1 : t_I'0)
  
  predicate inv'5 (_1 : t_F'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'4 iter /\ inv'5 func
    end)
  
  predicate invariant'1 (self : borrowed (t_Filter'0)) =
    [%#sinvariant4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'0 x] . inv'0 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : borrowed t_I'0)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate completed'0 [#"17_filter.rs" 40 4 40 35] (self : borrowed (t_Filter'0)) =
    [%#s17_filter1] (exists s : Seq.seq t_Item'0, e : borrowed t_I'0 . produces'1 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use seq.Seq
  
  use map.Map
  
  use map.Map
  
  predicate produces'0 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter2] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  predicate inv'2 (_1 : t_Item'0)
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  goal refines : [%#s17_filter0] forall self : borrowed (t_Filter'0) . inv'0 self
   -> inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_17_filter__qyi17392541228996028033__produces_refl__refines [#"17_filter.rs" 51 4 51 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 51 4 51 26
  let%span s17_filter1 = "17_filter.rs" 64 12 76 17
  let%span scommon2 = "common.rs" 14 14 14 45
  let%span scommon3 = "common.rs" 18 15 18 32
  let%span scommon4 = "common.rs" 19 15 19 32
  let%span scommon5 = "common.rs" 20 14 20 42
  let%span s17_filter6 = "17_filter.rs" 24 12 30 122
  let%span sops7 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops8 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops9 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon3] produces'1 a ab b)
   -> ([%#scommon4] produces'1 b bc c)  -> ([%#scommon5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#scommon2] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self
  
  use prelude.prelude.Borrow
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter6] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  goal refines : [%#s17_filter0] forall self : t_Filter'0 . forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
end
module M_17_filter__qyi17392541228996028033__produces_trans__refines [#"17_filter.rs" 58 4 58 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 58 4 58 90
  let%span s17_filter1 = "17_filter.rs" 64 12 76 17
  let%span scommon2 = "common.rs" 14 14 14 45
  let%span scommon3 = "common.rs" 18 15 18 32
  let%span scommon4 = "common.rs" 19 15 19 32
  let%span scommon5 = "common.rs" 20 14 20 42
  let%span s17_filter6 = "17_filter.rs" 24 12 30 122
  let%span sops7 = "../../../../creusot-contracts/src/std/ops.rs" 109 15 109 59
  let%span sops8 = "../../../../creusot-contracts/src/std/ops.rs" 110 14 110 36
  let%span sops9 = "../../../../creusot-contracts/src/std/ops.rs" 115 14 115 31
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 120 15 120 29
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 121 15 121 26
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 122 14 122 28
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 127 14 128 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon3] produces'1 a ab b)
   -> ([%#scommon4] produces'1 b bc c)  -> ([%#scommon5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon2] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self
  
  use prelude.prelude.Borrow
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter6] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 62 4 62 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  goal refines : [%#s17_filter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
