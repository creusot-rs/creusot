module M_17_filter__qyi17392541228996028033__produces_refl [#"17_filter.rs" 52 4 52 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 50 15 50 24
  let%span s17_filter1 = "17_filter.rs" 51 14 51 45
  let%span s17_filter2 = "17_filter.rs" 48 4 48 10
  let%span s17_filter3 = "17_filter.rs" 67 8 80 9
  let%span scommon4 = "common.rs" 14 15 14 24
  let%span scommon5 = "common.rs" 15 14 15 45
  let%span scommon6 = "common.rs" 19 15 19 21
  let%span scommon7 = "common.rs" 20 15 20 21
  let%span scommon8 = "common.rs" 21 15 21 21
  let%span scommon9 = "common.rs" 22 15 22 32
  let%span scommon10 = "common.rs" 23 15 23 32
  let%span scommon11 = "common.rs" 24 14 24 42
  let%span s17_filter12 = "17_filter.rs" 24 12 30 122
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops17 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops18 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops19 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  predicate inv'1 (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon6] inv'1 a)
   -> ([%#scommon7] inv'1 b)
   -> ([%#scommon8] inv'1 c)
   -> ([%#scommon9] produces'1 a ab b)
   -> ([%#scommon10] produces'1 b bc c)  -> ([%#scommon11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#scommon4] inv'1 self)
   -> ([%#scommon5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops19] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops16] unnest'0 self b)
   -> ([%#sops17] unnest'0 b c)  -> ([%#sops18] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops15] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops13] postcondition_mut'0 self args res_state res)
   -> ([%#sops14] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter12] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'0 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter3] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"17_filter.rs" 52 4 52 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : ([%#s17_filter0] inv'0 self)
   -> ([%#s17_filter1] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_17_filter__qyi17392541228996028033__produces_trans [#"17_filter.rs" 62 4 62 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 56 15 56 21
  let%span s17_filter1 = "17_filter.rs" 57 15 57 21
  let%span s17_filter2 = "17_filter.rs" 58 15 58 21
  let%span s17_filter3 = "17_filter.rs" 59 15 59 32
  let%span s17_filter4 = "17_filter.rs" 60 15 60 32
  let%span s17_filter5 = "17_filter.rs" 61 14 61 42
  let%span s17_filter6 = "17_filter.rs" 54 4 54 10
  let%span s17_filter7 = "17_filter.rs" 67 8 80 9
  let%span scommon8 = "common.rs" 14 15 14 24
  let%span scommon9 = "common.rs" 15 14 15 45
  let%span scommon10 = "common.rs" 19 15 19 21
  let%span scommon11 = "common.rs" 20 15 20 21
  let%span scommon12 = "common.rs" 21 15 21 21
  let%span scommon13 = "common.rs" 22 15 22 32
  let%span scommon14 = "common.rs" 23 15 23 32
  let%span scommon15 = "common.rs" 24 14 24 42
  let%span s17_filter16 = "17_filter.rs" 24 12 30 122
  let%span sops17 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops18 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops19 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops20 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops21 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops22 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops23 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  predicate inv'1 (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon10] inv'1 a)
   -> ([%#scommon11] inv'1 b)
   -> ([%#scommon12] inv'1 c)
   -> ([%#scommon13] produces'1 a ab b)
   -> ([%#scommon14] produces'1 b bc c)  -> ([%#scommon15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#scommon8] inv'1 self)
   -> ([%#scommon9] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops23] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops20] unnest'0 self b)
   -> ([%#sops21] unnest'0 b c)  -> ([%#sops22] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops19] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops17] postcondition_mut'0 self args res_state res)
   -> ([%#sops18] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter16] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'0 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter7] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"17_filter.rs" 62 4 62 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
    
  
  goal vc_produces_trans'0 : ([%#s17_filter4] produces'0 b bc c)
   -> ([%#s17_filter3] produces'0 a ab b)
   -> ([%#s17_filter2] inv'0 c)
   -> ([%#s17_filter1] inv'0 b)  -> ([%#s17_filter0] inv'0 a)  -> ([%#s17_filter5] produces'0 a (Seq.(++) ab bc) c)
end
module M_17_filter__qyi17392541228996028033__next [#"17_filter.rs" 88 4 88 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 89 23 89 40
  let%span s17_filter1 = "17_filter.rs" 90 27 90 51
  let%span s17_filter2 = "17_filter.rs" 92 8 92 31
  let%span s17_filter3 = "17_filter.rs" 94 20 94 129
  let%span s17_filter4 = "17_filter.rs" 93 20 93 46
  let%span s17_filter5 = "17_filter.rs" 92 20 92 29
  let%span s17_filter6 = "17_filter.rs" 98 23 98 58
  let%span s17_filter7 = "17_filter.rs" 99 12 99 71
  let%span s17_filter8 = "17_filter.rs" 88 17 88 21
  let%span s17_filter9 = "17_filter.rs" 83 15 83 24
  let%span s17_filter10 = "17_filter.rs" 88 26 88 41
  let%span s17_filter11 = "17_filter.rs" 84 14 87 5
  let%span sops12 = "../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33
  let%span scommon13 = "common.rs" 31 17 31 21
  let%span scommon14 = "common.rs" 31 26 31 44
  let%span scommon15 = "common.rs" 27 14 30 5
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 158 27 158 52
  let%span sops17 = "../../../../creusot-contracts/src/std/ops.rs" 159 26 159 71
  let%span s17_filter18 = "17_filter.rs" 42 12 44 43
  let%span s17_filter19 = "17_filter.rs" 67 8 80 9
  let%span scommon20 = "common.rs" 14 15 14 24
  let%span scommon21 = "common.rs" 15 14 15 45
  let%span scommon22 = "common.rs" 19 15 19 21
  let%span scommon23 = "common.rs" 20 15 20 21
  let%span scommon24 = "common.rs" 21 15 21 21
  let%span scommon25 = "common.rs" 22 15 22 32
  let%span scommon26 = "common.rs" 23 15 23 32
  let%span scommon27 = "common.rs" 24 14 24 42
  let%span sops28 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops29 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops30 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops31 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops32 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops33 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops34 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span sresolve35 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant36 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span s17_filter37 = "17_filter.rs" 24 12 30 122
  let%span sinvariant38 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  type t_I'0
  
  predicate inv'1 (_1 : t_I'0)
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon22] inv'1 a)
   -> ([%#scommon23] inv'1 b)
   -> ([%#scommon24] inv'1 c)
   -> ([%#scommon25] produces'0 a ab b)
   -> ([%#scommon26] produces'0 b bc c)  -> ([%#scommon27] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#scommon20] inv'1 self)
   -> ([%#scommon21] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Snapshot
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'3 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops34] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops31] unnest'0 self b)
   -> ([%#sops32] unnest'0 b c)  -> ([%#sops33] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops30] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops28] postcondition_mut'0 self args res_state res)
   -> ([%#sops29] unnest'0 self res_state)
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use prelude.prelude.Snapshot
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Snapshot.snap_ty (Seq.seq t_Item'0)) (ix : int) : t_Item'0 =
    [%#sops12] Seq.get (Snapshot.inner self) ix
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate invariant'3 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter37] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'9 (_1 : t_Filter'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Filter'0 [inv'9 x] . inv'9 x
  = (invariant'3 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  predicate invariant'0 (self : borrowed (t_Filter'0)) =
    [%#sinvariant36] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'0 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 (self : borrowed t_I'0) =
    [%#sinvariant36] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'5 (_1 : borrowed t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed t_I'0 [inv'5 x] . inv'5 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'3 (_1 : t_Item'0)
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : borrowed t_I'0)
  
  use seq.Seq
  
  let rec next'1 (self:borrowed t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#scommon13] inv'5 self}
    any
    [ return' (result:t_Option'0)-> {[%#scommon14] inv'4 result}
      {[%#scommon15] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
    
  
  use seq.Seq
  
  predicate invariant'2 (self : borrowed t_F'0) =
    [%#sinvariant36] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'6 (_1 : borrowed t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed t_F'0 [inv'6 x] . inv'6 x = invariant'2 x
  
  predicate invariant'4 (self : t_Item'0) =
    [%#sinvariant38] inv'3 self
  
  predicate inv'10 (_1 : t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'7 (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'7 x] . inv'7 x = (let (x0) = x in inv'10 x0)
  
  predicate inv'8 (_1 : bool)
  
  axiom inv_axiom'5 [@rewrite] : forall x : bool [inv'8 x] . inv'8 x = true
  
  let rec call_mut'0 (self:borrowed t_F'0) (args:t_Item'0) (return'  (ret:bool))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops16] precondition'0 self.current args}
    any
    [ return' (result:bool)-> {inv'8 result}
      {[%#sops17] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
    
  
  predicate resolve'0 (_1 : t_Item'0)
  
  predicate resolve'2 (self : borrowed (t_Filter'0)) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (t_Filter'0)) =
    resolve'2 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  predicate completed'0 [#"17_filter.rs" 40 4 40 35] (self : borrowed (t_Filter'0)) =
    [%#s17_filter18] (exists s : Seq.seq t_Item'0, e : borrowed t_I'0 . produces'0 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use map.Map
  
  use map.Map
  
  predicate produces'1 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter19] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'0 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  meta "compute_max_steps" 1000000
  
  let rec next'0 (self:borrowed (t_Filter'0)) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#s17_filter8] inv'0 self}
    {[@expl:next requires] [%#s17_filter9] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#s17_filter0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &produced <- [%#s17_filter1] Snapshot.new (Seq.empty  : Seq.seq t_Item'0) ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &old_3_0 <- Snapshot.new self ] s1 | s1 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:mut invariant] (Snapshot.inner old_3_0).final = self.final}
        {[@expl:loop invariant #0] [%#s17_filter5] inv'0 self}
        {[@expl:loop invariant #1] [%#s17_filter4] (self.current).t_Filter__func'0
        = ((Snapshot.inner old_self).current).t_Filter__func'0}
        {[@expl:loop invariant #2] [%#s17_filter3] forall i : int . 0 <= i /\ i < Seq.length (Snapshot.inner produced)
         -> postcondition_mut'0 (self.current).t_Filter__func'0 (index_logic'0 produced i) (self.current).t_Filter__func'0 false}
        {[@expl:loop invariant #3] [%#s17_filter2] produces'0 ((Snapshot.inner old_self).current).t_Filter__iter'0 (Snapshot.inner produced) (self.current).t_Filter__iter'0}
        {[@expl:loop invariant #4] [%#s17_filter2] unnest'0 ((Snapshot.inner old_self).current).t_Filter__func'0 (self.current).t_Filter__func'0}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = {inv'1 (self.current).t_Filter__iter'0}
            Borrow.borrow_mut <t_I'0> {(self.current).t_Filter__iter'0}
              (fun (_ret':borrowed t_I'0) ->
                 [ &_16 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__iter'0 = _ret'.final } } ] 
                s1)
          | s1 = next'1 {_16} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
          | s2 = bb5 ]
          
        | bb5 = any [ br0 -> {_15 = C_None'0 } (! bb13) | br1 (x0:t_Item'0)-> {_15 = C_Some'0 x0} (! bb6) ] 
        | bb6 = bb7
        | bb7 = s0
          [ s0 = v_Some'0 {_15} (fun (r0'0:t_Item'0) ->  [ &n <- r0'0 ] s1)
          | s1 =  [ &_19 <- [%#s17_filter6] Snapshot.new (Seq.snoc (Snapshot.inner produced) n) ] s2
          | s2 = bb8 ]
          
        | bb8 = s0
          [ s0 =  [ &produced <- _19 ] s1
          | s1 = {[@expl:assertion] [%#s17_filter7] produces'0 ((Snapshot.inner old_self).current).t_Filter__iter'0 (Snapshot.inner produced) (self.current).t_Filter__iter'0}
            s2
          | s2 = {inv'2 (self.current).t_Filter__func'0}
            Borrow.borrow_mut <t_F'0> {(self.current).t_Filter__func'0}
              (fun (_ret':borrowed t_F'0) ->
                 [ &_24 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__func'0 = _ret'.final } } ] 
                s3)
          | s3 =  [ &_27 <- n ] s4
          | s4 =  [ &_25 <- (_27) ] s5
          | s5 = call_mut'0 {_24} {_25} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s6)
          | s6 = bb9 ]
          
        | bb9 = any [ br0 -> {_23 = false} (! bb12) | br1 -> {_23} (! bb10) ] 
        | bb12 = s0 [ s0 = {[@expl:type invariant] inv'3 n} s1 | s1 = -{resolve'0 n}- s2 | s2 = bb14 ] 
        | bb14 = bb15
        | bb15 = bb3 ]
         ]
      
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match _15 with
          | C_Some'0 x'0 -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _15 with
          | C_Some'0 x'1 -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb16 ]
      
    | bb16 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb19 ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 =  [ &_0 <- C_Some'0 n ] s3
      | s3 = bb11 ]
      
    | bb11 = bb17
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = any_l ()
    | & self : borrowed (t_Filter'0) = self
    | & old_self : Snapshot.snap_ty (borrowed (t_Filter'0)) = any_l ()
    | & produced : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & _15 : t_Option'0 = any_l ()
    | & _16 : borrowed t_I'0 = any_l ()
    | & n : t_Item'0 = any_l ()
    | & _19 : Snapshot.snap_ty (Seq.seq t_Item'0) = any_l ()
    | & _23 : bool = any_l ()
    | & _24 : borrowed t_F'0 = any_l ()
    | & _25 : t_Item'0 = any_l ()
    | & _27 : t_Item'0 = any_l ()
    | & old_3_0 : Snapshot.snap_ty (borrowed (t_Filter'0)) = any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:next result type invariant] [%#s17_filter10] inv'4 result}
      {[@expl:next ensures] [%#s17_filter11] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'1 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
    
end
module M_17_filter__filter [#"17_filter.rs" 114 0 116 39]
  let%span s17_filter0 = "17_filter.rs" 114 30 114 34
  let%span s17_filter1 = "17_filter.rs" 114 39 114 40
  let%span s17_filter2 = "17_filter.rs" 110 11 110 23
  let%span s17_filter3 = "17_filter.rs" 111 11 111 29
  let%span s17_filter4 = "17_filter.rs" 112 11 112 21
  let%span s17_filter5 = "17_filter.rs" 114 48 114 60
  let%span s17_filter6 = "17_filter.rs" 113 10 113 49
  let%span s17_filter7 = "17_filter.rs" 141 16 141 59
  let%span s17_filter8 = "17_filter.rs" 135 16 135 57
  let%span s17_filter9 = "17_filter.rs" 147 16 147 126
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span scommon17 = "common.rs" 14 15 14 24
  let%span scommon18 = "common.rs" 15 14 15 45
  let%span scommon19 = "common.rs" 19 15 19 21
  let%span scommon20 = "common.rs" 20 15 20 21
  let%span scommon21 = "common.rs" 21 15 21 21
  let%span scommon22 = "common.rs" 22 15 22 32
  let%span scommon23 = "common.rs" 23 15 23 32
  let%span scommon24 = "common.rs" 24 14 24 42
  let%span s17_filter25 = "17_filter.rs" 24 12 30 122
  
  type t_I'0
  
  type t_P'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_P'0 }
  
  use prelude.prelude.Intrinsic
  
  predicate inv'0 (_1 : t_I'0)
  
  predicate inv'1 (_1 : t_P'0)
  
  use prelude.prelude.Borrow
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon19] inv'0 a)
   -> ([%#scommon20] inv'0 b)
   -> ([%#scommon21] inv'0 c)
   -> ([%#scommon22] produces'0 a ab b)
   -> ([%#scommon23] produces'0 b bc c)  -> ([%#scommon24] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#scommon17] inv'0 self)
   -> ([%#scommon18] produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate postcondition_once'0 (self : t_P'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_P'0)
  
  predicate postcondition_mut'0 (self : t_P'0) (args : t_Item'0) (result_state : t_P'0) (result : bool)
  
  function fn_mut_once'0 (self : t_P'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_P'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_P'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_P'0) (_2 : t_P'0)
  
  function unnest_trans'0 (self : t_P'0) (b : t_P'0) (c : t_P'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_P'0, b : t_P'0, c : t_P'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_P'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_P'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_P'0) (args : t_Item'0) (res_state : t_P'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_P'0, args : t_Item'0, res_state : t_P'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  predicate immutable'0 [#"17_filter.rs" 140 0 140 54] (_1 : t_P'0) =
    [%#s17_filter7] forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g
  
  predicate precondition'0 (self : t_P'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"17_filter.rs" 134 0 134 60] (_1 : t_P'0) =
    [%#s17_filter8] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
  
  predicate precise'0 [#"17_filter.rs" 146 0 146 52] (_1 : t_P'0) =
    [%#s17_filter9] forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter25] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'2 x] . inv'2 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'0 iter /\ inv'1 func
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec filter'0 (iter:t_I'0) (f:t_P'0) (return'  (ret:t_Filter'0))= {[@expl:filter 'iter' type invariant] [%#s17_filter0] inv'0 iter}
    {[@expl:filter 'f' type invariant] [%#s17_filter1] inv'1 f}
    {[@expl:filter requires #0] [%#s17_filter2] immutable'0 f}
    {[@expl:filter requires #1] [%#s17_filter3] no_precondition'0 f}
    {[@expl:filter requires #2] [%#s17_filter4] precise'0 f}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- { t_Filter__iter'0 = iter; t_Filter__func'0 = f } ] s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_Filter'0 = any_l () | & iter : t_I'0 = iter | & f : t_P'0 = f ] 
    [ return' (result:t_Filter'0)-> {[@expl:filter result type invariant] [%#s17_filter5] inv'2 result}
      {[@expl:filter ensures] [%#s17_filter6] result.t_Filter__iter'0 = iter /\ result.t_Filter__func'0 = f}
      (! return' {result}) ]
    
end
module M_17_filter__less_than [#"17_filter.rs" 123 0 123 49]
  let%span s17_filter0 = "17_filter.rs" 121 10 121 70
  let%span s17_filter1 = "17_filter.rs" 122 10 122 79
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 101 0 213 1
  let%span s17_filter3 = "17_filter.rs" 126 22 126 40
  let%span siter4 = "../../../../creusot-contracts/src/std/iter.rs" 144 27 144 47
  let%span siter5 = "../../../../creusot-contracts/src/std/iter.rs" 145 27 145 53
  let%span siter6 = "../../../../creusot-contracts/src/std/iter.rs" 146 27 146 45
  let%span siter7 = "../../../../creusot-contracts/src/std/iter.rs" 172 26 174 81
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sops9 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  let%span sseq10 = "../../../../creusot-contracts/src/logic/seq.rs" 200 20 200 77
  let%span svec11 = "../../../../creusot-contracts/src/std/vec.rs" 191 20 191 24
  let%span svec12 = "../../../../creusot-contracts/src/std/vec.rs" 197 20 197 33
  let%span sfilter13 = "../../../../creusot-contracts/src/std/iter/filter.rs" 58 16 58 59
  let%span sfilter14 = "../../../../creusot-contracts/src/std/iter/filter.rs" 50 16 50 57
  let%span sfilter15 = "../../../../creusot-contracts/src/std/iter/filter.rs" 65 16 65 126
  let%span sfilter16 = "../../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter17 = "../../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter18 = "../../../../creusot-contracts/src/std/iter/filter.rs" 77 12 79 47
  let%span sfilter19 = "../../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 17
  let%span svec20 = "../../../../creusot-contracts/src/std/vec.rs" 285 20 285 32
  let%span sord21 = "../../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span sord22 = "../../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span sord23 = "../../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span sord24 = "../../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span sord25 = "../../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span sord26 = "../../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span sord27 = "../../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span sord28 = "../../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span sord29 = "../../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span sord30 = "../../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span sord31 = "../../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span sord32 = "../../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span sord33 = "../../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span sresolve34 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sops35 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops36 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops37 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops38 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops39 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops40 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops41 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span sfilter42 = "../../../../creusot-contracts/src/std/iter/filter.rs" 104 15 104 24
  let%span sfilter43 = "../../../../creusot-contracts/src/std/iter/filter.rs" 105 14 105 45
  let%span sfilter44 = "../../../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 21
  let%span sfilter45 = "../../../../creusot-contracts/src/std/iter/filter.rs" 111 15 111 21
  let%span sfilter46 = "../../../../creusot-contracts/src/std/iter/filter.rs" 112 15 112 21
  let%span sfilter47 = "../../../../creusot-contracts/src/std/iter/filter.rs" 113 15 113 32
  let%span sfilter48 = "../../../../creusot-contracts/src/std/iter/filter.rs" 114 15 114 32
  let%span sfilter49 = "../../../../creusot-contracts/src/std/iter/filter.rs" 115 14 115 42
  let%span svec50 = "../../../../creusot-contracts/src/std/vec.rs" 264 12 264 41
  let%span svec51 = "../../../../creusot-contracts/src/std/vec.rs" 257 20 257 57
  let%span sord52 = "../../../../creusot-contracts/src/logic/ord.rs" 185 16 191 17
  let%span sinvariant53 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span svec54 = "../../../../creusot-contracts/src/std/vec.rs" 270 14 270 45
  let%span svec55 = "../../../../creusot-contracts/src/std/vec.rs" 268 4 268 10
  let%span svec56 = "../../../../creusot-contracts/src/std/vec.rs" 275 15 275 32
  let%span svec57 = "../../../../creusot-contracts/src/std/vec.rs" 276 15 276 32
  let%span svec58 = "../../../../creusot-contracts/src/std/vec.rs" 277 14 277 42
  let%span svec59 = "../../../../creusot-contracts/src/std/vec.rs" 273 4 273 10
  let%span smodel60 = "../../../../creusot-contracts/src/model.rs" 106 8 106 22
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt64
  
  type t_Cap'0  =
    { t_Cap__0'0: UInt64.t }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Vec'0) =
    [%#svec11] true
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: () }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: opaque_ptr }
  
  predicate inv'1 (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt32
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq UInt32.t
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec8] Seq.length (view'0 self) <= UInt64.to_uint (v_MAX'0 : UInt64.t)
  
  function view'1 (self : t_IntoIter'0) : Seq.seq UInt32.t
  
  predicate into_iter_post'0 (self : t_Vec'0) (res : t_IntoIter'0) =
    [%#svec12] view'0 self = view'1 res
  
  let rec into_iter'0 (self:t_Vec'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter2] into_iter_pre'0 self}
    any
    [ return' (result:t_IntoIter'0)-> {inv'1 result} {[%#siter2] into_iter_post'0 self result} (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  type closure2'1  =
    { field_0'0: UInt32.t }
  
  predicate resolve'2 (self : borrowed closure2'1) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed closure2'1) =
    resolve'2 _1
  
  use prelude.prelude.Intrinsic
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use prelude.prelude.UInt32
  
  function cmp_log'0 (self : UInt32.t) (o : UInt32.t) : t_Ordering'0 =
    [%#sord52] if UInt32.ult self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord33] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt32.t, y : UInt32.t . ([%#sord31] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord32] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt32.t, y : UInt32.t . ([%#sord29] cmp_log'0 x y = C_Less'0)
   -> ([%#sord30] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt32.t) (y : UInt32.t) (z : UInt32.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt32.t, y : UInt32.t, z : UInt32.t, o : t_Ordering'0 . ([%#sord26] cmp_log'0 x y
  = o)  -> ([%#sord27] cmp_log'0 y z = o)  -> ([%#sord28] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt32.t) : ()
  
  axiom refl'0_spec : forall x : UInt32.t . [%#sord25] cmp_log'0 x x = C_Equal'0
  
  use prelude.prelude.UInt32
  
  function cmp_gt_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord24] UInt32.ugt x y
  = (cmp_log'0 x y = C_Greater'0)
  
  use prelude.prelude.UInt32
  
  function cmp_ge_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord23] UInt32.uge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord22] UInt32.ult x y = (cmp_log'0 x y = C_Less'0)
  
  use prelude.prelude.UInt32
  
  function cmp_le_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord21] UInt32.ule x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate postcondition_once'0 (self : closure2'1) (args : UInt32.t) (result : bool) =
    [%#s17_filter3] let (i) = args in result = UInt32.ult i self.field_0'0
  
  predicate resolve'3 (_1 : closure2'1) =
    true
  
  predicate unnest'0 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  predicate postcondition_mut'1 (self : closure2'1) (args : UInt32.t) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = UInt32.ult i result_state.field_0'0) /\ unnest'0 self result_state
  
  function fn_mut_once'0 (self : closure2'1) (args : UInt32.t) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : closure2'1, args : UInt32.t, res : bool . [%#sops41] postcondition_once'0 self args res
  = (exists res_state : closure2'1 . postcondition_mut'1 self args res_state res /\ resolve'3 res_state)
  
  function unnest_trans'0 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'0_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops38] unnest'0 self b)
   -> ([%#sops39] unnest'0 b c)  -> ([%#sops40] unnest'0 self c)
  
  function unnest_refl'0 (self : closure2'1) : ()
  
  axiom unnest_refl'0_spec : forall self : closure2'1 . [%#sops37] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : closure2'1) (args : UInt32.t) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : closure2'1, args : UInt32.t, res_state : closure2'1, res : bool . ([%#sops35] postcondition_mut'1 self args res_state res)
   -> ([%#sops36] unnest'0 self res_state)
  
  let rec closure2'0 (_1:borrowed closure2'1) (i:UInt32.t) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 _1}- s1
      | s1 = UInt32.lt {i} {(_1.current).field_0'0} (fun (_ret':bool) ->  [ &res <- _ret' ] s2)
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () | & _1 : borrowed closure2'1 = _1 | & i : UInt32.t = i | & res : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:closure ensures] [%#s17_filter3] result = UInt32.ult i (_1.final).field_0'0}
      {[@expl:closure unnest] unnest'0 _1.current _1.final}
      (! return' {result}) ]
    
  
  predicate inv'2 (_1 : closure2'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : closure2'1 [inv'2 x] . inv'2 x = true
  
  predicate postcondition_once'1 (self : closure2'1) (args : UInt32.t) (result : bool) =
    [%#s17_filter3] let (i) = args in result = UInt32.ult i self.field_0'0
  
  predicate postcondition_mut'0 (self : closure2'1) (args : UInt32.t) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = UInt32.ult i result_state.field_0'0) /\ unnest'0 self result_state
  
  function fn_mut_once'1 (self : closure2'1) (args : UInt32.t) (res : bool) : ()
  
  axiom fn_mut_once'1_spec : forall self : closure2'1, args : UInt32.t, res : bool . [%#sops41] postcondition_once'1 self args res
  = (exists res_state : closure2'1 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'1 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  function unnest_trans'1 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'1_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops38] unnest'1 self b)
   -> ([%#sops39] unnest'1 b c)  -> ([%#sops40] unnest'1 self c)
  
  function unnest_refl'1 (self : closure2'1) : ()
  
  axiom unnest_refl'1_spec : forall self : closure2'1 . [%#sops37] unnest'1 self self
  
  function postcondition_mut_unnest'1 (self : closure2'1) (args : UInt32.t) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'1_spec : forall self : closure2'1, args : UInt32.t, res_state : closure2'1, res : bool . ([%#sops35] postcondition_mut'0 self args res_state res)
   -> ([%#sops36] unnest'1 self res_state)
  
  predicate immutable'0 (_1 : closure2'1) =
    [%#sfilter13] forall f : closure2'1, g : closure2'1 . unnest'1 f g  -> f = g
  
  predicate precondition'0 (self : closure2'1) (args : UInt32.t) =
    let (i) = args in true
  
  predicate no_precondition'0 (_1 : closure2'1) =
    [%#sfilter14] forall f : closure2'1, i : UInt32.t . precondition'0 f (i)
  
  predicate precise'0 (_1 : closure2'1) =
    [%#sfilter15] forall f1 : closure2'1, f2 : closure2'1, i : UInt32.t . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_IntoIter'0; t_Filter__predicate'0: closure2'1 }
  
  predicate invariant'0 (self : t_Filter'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> true
    end)
  
  function iter'0 (self : t_Filter'0) : t_IntoIter'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter16] inv'3 self  -> inv'1 (iter'0 self)
  
  function func'0 (self : t_Filter'0) : closure2'1
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter17] inv'3 self  -> inv'2 (func'0 self)
  
  let rec filter'0 (self:t_IntoIter'0) (predicate':closure2'1) (return'  (ret:t_Filter'0))= {[@expl:filter 'self' type invariant] inv'1 self}
    {[@expl:filter 'predicate' type invariant] inv'2 predicate'}
    {[@expl:filter requires #0] [%#siter4] immutable'0 predicate'}
    {[@expl:filter requires #1] [%#siter5] no_precondition'0 predicate'}
    {[@expl:filter requires #2] [%#siter6] precise'0 predicate'}
    any
    [ return' (result:t_Filter'0)-> {inv'3 result}
      {[%#siter2] iter'0 result = self /\ func'0 result = predicate'}
      (! return' {result}) ]
    
  
  predicate invariant'1 (self : borrowed (t_Filter'0)) =
    [%#sinvariant53] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate inv'5 (_1 : Seq.seq UInt32.t)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq UInt32.t [inv'5 x] . inv'5 x = true
  
  predicate resolve'1 (_1 : t_Filter'0) =
    true
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 (self : t_IntoIter'0) (visited : Seq.seq UInt32.t) (rhs : t_IntoIter'0) =
    [%#svec50] view'1 self = Seq.(++) visited (view'1 rhs)
  
  function produces_trans'1 (a : t_IntoIter'0) (ab : Seq.seq UInt32.t) (b : t_IntoIter'0) (bc : Seq.seq UInt32.t) (c : t_IntoIter'0) : ()
    
   =
    [%#svec59] ()
  
  axiom produces_trans'1_spec : forall a : t_IntoIter'0, ab : Seq.seq UInt32.t, b : t_IntoIter'0, bc : Seq.seq UInt32.t, c : t_IntoIter'0 . ([%#svec56] produces'1 a ab b)
   -> ([%#svec57] produces'1 b bc c)  -> ([%#svec58] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_IntoIter'0) : () =
    [%#svec55] ()
  
  axiom produces_refl'1_spec : forall self : t_IntoIter'0 . [%#svec54] produces'1 self (Seq.empty  : Seq.seq UInt32.t) self
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 (self : t_Filter'0) (visited : Seq.seq UInt32.t) (succ : t_Filter'0) =
    [%#sfilter19] unnest'1 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq UInt32.t, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  function produces_trans'0 (a : t_Filter'0) (ab : Seq.seq UInt32.t) (b : t_Filter'0) (bc : Seq.seq UInt32.t) (c : t_Filter'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_Filter'0, ab : Seq.seq UInt32.t, b : t_Filter'0, bc : Seq.seq UInt32.t, c : t_Filter'0 . ([%#sfilter44] inv'3 a)
   -> ([%#sfilter45] inv'3 b)
   -> ([%#sfilter46] inv'3 c)
   -> ([%#sfilter47] produces'0 a ab b)
   -> ([%#sfilter48] produces'0 b bc c)  -> ([%#sfilter49] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Filter'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Filter'0 . ([%#sfilter42] inv'3 self)
   -> ([%#sfilter43] produces'0 self (Seq.empty  : Seq.seq UInt32.t) self)
  
  predicate resolve'4 (self : borrowed (t_IntoIter'0)) =
    [%#sresolve34] self.final = self.current
  
  function view'2 (self : borrowed (t_IntoIter'0)) : Seq.seq UInt32.t =
    [%#smodel60] view'1 self.current
  
  predicate completed'1 (self : borrowed (t_IntoIter'0)) =
    [%#svec51] resolve'4 self /\ view'2 self = (Seq.empty  : Seq.seq UInt32.t)
  
  predicate completed'0 (self : borrowed (t_Filter'0)) =
    [%#sfilter18] (exists s : Seq.seq UInt32.t, e : borrowed (t_IntoIter'0) . produces'1 (iter'0 self.current) s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (func'0 self.current) (Seq.get s i) (func'0 self.final) false))
    /\ func'0 self.current = func'0 self.final
  
  predicate from_iter_post'0 (prod : Seq.seq UInt32.t) (res : t_Vec'0) =
    [%#svec20] prod = view'0 res
  
  let rec collect'0 (self:t_Filter'0) (return'  (ret:t_Vec'0))= {[@expl:collect 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Vec'0)-> {inv'0 result}
      {[%#siter7] exists done' : borrowed (t_Filter'0), prod : Seq.seq UInt32.t . inv'4 done'
      /\ inv'5 prod
      /\ resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
    
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : UInt32.t =
    [%#sops9] Seq.get (view'0 self) ix
  
  predicate contains'0 (self : Seq.seq UInt32.t) (e : UInt32.t) =
    [%#sseq10] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = e
  
  meta "compute_max_steps" 1000000
  
  let rec less_than'0 (v:t_Vec'0) (n:UInt32.t) (return'  (ret:t_Vec'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {v} (fun (_ret':t_IntoIter'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_8 <- { field_0'0 = n } ] s1
      | s1 = filter'0 {_6} {_8} (fun (_ret':t_Filter'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = collect'0 {_5} (fun (_ret':t_Vec'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_Vec'0 = any_l ()
    | & v : t_Vec'0 = v
    | & n : UInt32.t = n
    | & _5 : t_Filter'0 = any_l ()
    | & _6 : t_IntoIter'0 = any_l ()
    | & _8 : closure2'1 = any_l () ]
    
    [ return' (result:t_Vec'0)-> {[@expl:less_than ensures #0] [%#s17_filter0] forall i : int . 0 <= i
      /\ i < Seq.length (view'0 result)  -> UInt32.ult (index_logic'0 result i) n}
      {[@expl:less_than ensures #1] [%#s17_filter1] forall i : int . 0 <= i /\ i < Seq.length (view'0 result)
       -> contains'0 (view'0 v) (index_logic'0 result i)}
      (! return' {result}) ]
    
end
module M_17_filter__qyi17392541228996028033__next__refines [#"17_filter.rs" 88 4 88 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 88 4 88 41
  let%span s17_filter1 = "17_filter.rs" 42 12 44 43
  let%span s17_filter2 = "17_filter.rs" 67 8 80 9
  let%span sinvariant3 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span scommon4 = "common.rs" 14 15 14 24
  let%span scommon5 = "common.rs" 15 14 15 45
  let%span scommon6 = "common.rs" 19 15 19 21
  let%span scommon7 = "common.rs" 20 15 20 21
  let%span scommon8 = "common.rs" 21 15 21 21
  let%span scommon9 = "common.rs" 22 15 22 32
  let%span scommon10 = "common.rs" 23 15 23 32
  let%span scommon11 = "common.rs" 24 14 24 42
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops17 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops18 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span s17_filter19 = "17_filter.rs" 24 12 30 122
  
  use prelude.prelude.Borrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate inv'4 (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon6] inv'4 a)
   -> ([%#scommon7] inv'4 b)
   -> ([%#scommon8] inv'4 c)
   -> ([%#scommon9] produces'1 a ab b)
   -> ([%#scommon10] produces'1 b bc c)  -> ([%#scommon11] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#scommon4] inv'4 self)
   -> ([%#scommon5] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops18] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops15] unnest'0 self b)
   -> ([%#sops16] unnest'0 b c)  -> ([%#sops17] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops14] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops12] postcondition_mut'0 self args res_state res)
   -> ([%#sops13] unnest'0 self res_state)
  
  predicate invariant'1 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter19] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'5 (_1 : t_F'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'1 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'4 iter /\ inv'5 func
    end)
  
  predicate invariant'0 (self : borrowed (t_Filter'0)) =
    [%#sinvariant3] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 (_1 : borrowed (t_Filter'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_Filter'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : borrowed t_I'0)
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate completed'0 [#"17_filter.rs" 40 4 40 35] (self : borrowed (t_Filter'0)) =
    [%#s17_filter1] (exists s : Seq.seq t_Item'0, e : borrowed t_I'0 . produces'1 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use seq.Seq
  
  use map.Map
  
  use map.Map
  
  predicate produces'0 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter2] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  predicate inv'2 (_1 : t_Item'0)
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  goal refines : [%#s17_filter0] forall self : borrowed (t_Filter'0) . inv'0 self
   -> inv'0 self
  /\ inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_17_filter__qyi17392541228996028033__produces_refl__refines [#"17_filter.rs" 52 4 52 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 52 4 52 26
  let%span s17_filter1 = "17_filter.rs" 67 8 80 9
  let%span scommon2 = "common.rs" 14 15 14 24
  let%span scommon3 = "common.rs" 15 14 15 45
  let%span scommon4 = "common.rs" 19 15 19 21
  let%span scommon5 = "common.rs" 20 15 20 21
  let%span scommon6 = "common.rs" 21 15 21 21
  let%span scommon7 = "common.rs" 22 15 22 32
  let%span scommon8 = "common.rs" 23 15 23 32
  let%span scommon9 = "common.rs" 24 14 24 42
  let%span s17_filter10 = "17_filter.rs" 24 12 30 122
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops17 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use prelude.prelude.Borrow
  
  predicate inv'1 (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon4] inv'1 a)
   -> ([%#scommon5] inv'1 b)
   -> ([%#scommon6] inv'1 c)
   -> ([%#scommon7] produces'1 a ab b)
   -> ([%#scommon8] produces'1 b bc c)  -> ([%#scommon9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . ([%#scommon2] inv'1 self)
   -> ([%#scommon3] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops17] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops14] unnest'0 self b)
   -> ([%#sops15] unnest'0 b c)  -> ([%#sops16] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops13] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops11] postcondition_mut'0 self args res_state res)
   -> ([%#sops12] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter10] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'0 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  goal refines : [%#s17_filter0] forall self : t_Filter'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : () . produces'0 self (Seq.empty  : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty  : Seq.seq t_Item'0) self)
end
module M_17_filter__qyi17392541228996028033__produces_trans__refines [#"17_filter.rs" 62 4 62 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 62 4 62 90
  let%span s17_filter1 = "17_filter.rs" 67 8 80 9
  let%span scommon2 = "common.rs" 14 15 14 24
  let%span scommon3 = "common.rs" 15 14 15 45
  let%span scommon4 = "common.rs" 19 15 19 21
  let%span scommon5 = "common.rs" 20 15 20 21
  let%span scommon6 = "common.rs" 21 15 21 21
  let%span scommon7 = "common.rs" 22 15 22 32
  let%span scommon8 = "common.rs" 23 15 23 32
  let%span scommon9 = "common.rs" 24 14 24 42
  let%span sops10 = "../../../../creusot-contracts/src/std/ops.rs" 105 15 105 59
  let%span sops11 = "../../../../creusot-contracts/src/std/ops.rs" 106 14 106 36
  let%span sops12 = "../../../../creusot-contracts/src/std/ops.rs" 111 14 111 31
  let%span sops13 = "../../../../creusot-contracts/src/std/ops.rs" 116 15 116 29
  let%span sops14 = "../../../../creusot-contracts/src/std/ops.rs" 117 15 117 26
  let%span sops15 = "../../../../creusot-contracts/src/std/ops.rs" 118 14 118 28
  let%span sops16 = "../../../../creusot-contracts/src/std/ops.rs" 123 14 124 105
  let%span s17_filter17 = "17_filter.rs" 24 12 30 122
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate inv'1 (_1 : t_I'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 25 4 25 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
    
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon4] inv'1 a)
   -> ([%#scommon5] inv'1 b)
   -> ([%#scommon6] inv'1 c)
   -> ([%#scommon7] produces'1 a ab b)
   -> ([%#scommon8] produces'1 b bc c)  -> ([%#scommon9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 16 4 16 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . ([%#scommon2] inv'1 self)
   -> ([%#scommon3] produces'1 self (Seq.empty  : Seq.seq t_Item'0) self)
  
  use prelude.prelude.Borrow
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  use prelude.prelude.Int
  
  use map.Map
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 66 4 66 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate invariant'0 [#"17_filter.rs" 21 4 21 30] (self : t_Filter'0) =
    [%#s17_filter17] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'0 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  goal refines : [%#s17_filter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b /\ inv'0 c /\ inv'0 b /\ inv'0 a
   -> produces'0 b bc c
  /\ produces'0 a ab b
  /\ inv'0 c
  /\ inv'0 b /\ inv'0 a /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
