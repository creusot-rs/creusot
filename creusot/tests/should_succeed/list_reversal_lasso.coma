
module Core_Ptr_NonNull_NonNull_Type
  use prelude.prelude.Opaque
  
  type t_nonnull 't =
    | C_NonNull opaque_ptr
  
  function any_l (_ : 'b) : 'a
  
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
  
  function any_l (_ : 'b) : 'a
  
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as PhantomData'0
  
  use Core_Ptr_NonNull_NonNull_Type as NonNull'0
  
  type t_unique 't =
    | C_Unique (NonNull'0.t_nonnull 't) (PhantomData'0.t_phantomdata 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't))= any
    [ good (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_RawVec_Cap_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_cap  =
    | C_Cap usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_cap (input:t_cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Cap'0
  
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_rawvec 't 'a =
    | C_RawVec (Unique'0.t_unique 't) (Cap'0.t_cap) 'a
  
  function any_l (_ : 'b) : 'a
  
  let rec t_rawvec < 't > < 'a > (input:t_rawvec 't 'a) (ret  (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc <> input} {false} any ]
    
end
module Alloc_Vec_Vec_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use Alloc_RawVec_RawVec_Type as RawVec'0
  
  type t_vec 't 'a =
    | C_Vec (RawVec'0.t_rawvec 't 'a) usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_vec < 't > < 'a > (input:t_vec 't 'a) (ret  (buf:RawVec'0.t_rawvec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module ListReversalLasso_Memory_Type
  use Alloc_Alloc_Global_Type as Global'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  type t_memory  =
    | C_Memory (Vec'0.t_vec usize (Global'0.t_global))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_memory (input:t_memory) (ret  (field_0:Vec'0.t_vec usize (Global'0.t_global)))= any
    [ good (field_0:Vec'0.t_vec usize (Global'0.t_global))-> {C_Memory field_0 = input} (! ret {field_0})
    | bad (field_0:Vec'0.t_vec usize (Global'0.t_global))-> {C_Memory field_0 <> input} {false} any ]
    
  
  function memory_0 [@inline:trivial] (self : t_memory) : Vec'0.t_vec usize (Global'0.t_global) =
    match self with
      | C_Memory a -> a
      end
end
module CreusotContracts_Logic_Seq2_Seq_Type
  use seq.Seq
  
  type t_seq 't =
    | C_Seq (Seq.seq 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_seq < 't > (input:t_seq 't) (ret  (field_0:Seq.seq 't))= any
    [ good (field_0:Seq.seq 't)-> {C_Seq field_0 = input} (! ret {field_0})
    | bad (field_0:Seq.seq 't)-> {C_Seq field_0 <> input} {false} any ]
    
  
  function seq_0 [@inline:trivial] (self : t_seq 't) : Seq.seq 't =
    match self with
      | C_Seq a -> a
      end
end
module ListReversalLasso_Impl1_Index
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 28 15 28 34
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 29 14 29 44
  
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span3 = "" 0 0 0 0
  
  let%span span4 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span5 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span6 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span7 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span8 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span10 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span11 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span12 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span13 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span14 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span15 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span16 = "../../../../creusot-contracts/src/std/slice.rs" 107 20 107 37
  
  let%span span17 = "../../../../creusot-contracts/src/std/slice.rs" 100 20 100 37
  
  let%span span18 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span20 = "" 0 0 0 0
  
  let%span span21 = "" 0 0 0 0
  
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span23 = "" 0 0 0 0
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'4 (self : Seq'0.t_seq usize) =
    [%#span2] true
  
  predicate inv'4 (_x : Seq'0.t_seq usize)
  
  axiom inv'4 : forall x : Seq'0.t_seq usize . inv'4 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span3] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span4] inv'4 self)  -> ([%#span5] len'0 self >= 0)
  
  predicate inv'3 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'1 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'1_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span6] inv'3 self)
   -> ([%#span8] inv'4 (shallow_model'1 self))
  && ([%#span7] len'0 (shallow_model'1 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'3 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span9] inv'4 (shallow_model'1 self)
  
  axiom inv'3 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'3 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span10] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span12] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span11] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  predicate invariant'2 (self : usize) =
    [%#span2] true
  
  predicate inv'2 (_x : usize)
  
  axiom inv'2 : forall x : usize . inv'2 x = true
  
  predicate invariant'1 (self : usize) =
    [%#span2] true
  
  predicate inv'1 (_x : usize)
  
  axiom inv'1 : forall x : usize . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span2] true
  
  predicate inv'0 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  axiom inv'0 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'0 x = true
  
  use seq.Seq
  
  function index_logic'2 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'1 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span13] index_logic'2 (shallow_model'1 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span14] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span15] len'0 (shallow_model'1 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'1 (ListReversalLasso_Memory_Type.memory_0 self))
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Slice
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq'0.t_seq usize) (out : usize) =
    [%#span16] index_logic'2 seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq'0.t_seq usize) =
    [%#span17] UIntSize.to_int self < len'0 seq
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize =
    [%#span18] shallow_model'1 self
  
  let rec index'0 (self:Vec'0.t_vec usize (Global'0.t_global)) (index:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span21] inv'1 index}
    {[@expl:precondition] [%#span20] inv'0 self}
    {[@expl:precondition] [%#span19] in_bounds'0 index (shallow_model'0 self)}
    any
    [ return' (result:usize)-> {[%#span23] inv'2 result}
      {[%#span22] has_value'0 index (shallow_model'0 self) result}
      (! return' {result}) ]
    
  
  let rec index (self:Memory'0.t_memory) (i:usize) (return'  (ret:usize))= {[%#slist_reversal_lasso0] nonnull_ptr'0 self i}
    (! bb0
    [ bb0 = s0
      [ s0 = Memory'0.t_memory {self}
          (fun (r0'0:Vec'0.t_vec usize (Global'0.t_global)) ->
            index'0 {r0'0} {i} (fun (_ret':usize) ->  [ &_6 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &_5 <- _6 ] s1 | s1 =  [ &_0 <- _5 ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & self : Memory'0.t_memory = self
    | & i : usize = i
    | & _5 : usize = any_l ()
    | & _6 : usize = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso1] result = index_logic'0 self i}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl2_IndexMut
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 36 15 36 34
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 37 14 37 47
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 38 14 38 47
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 39 14 39 47
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 40 4 40 113
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span6 = "" 0 0 0 0
  
  let%span span7 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span8 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span13 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span14 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span15 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span16 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span17 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span18 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span19 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span20 = "../../../../creusot-contracts/src/std/slice.rs" 114 8 114 96
  
  let%span span21 = "../../../../creusot-contracts/src/std/slice.rs" 107 20 107 37
  
  let%span span22 = "../../../../creusot-contracts/src/std/slice.rs" 100 20 100 37
  
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span24 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span25 = "" 0 0 0 0
  
  let%span span26 = "" 0 0 0 0
  
  let%span span27 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span28 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span29 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span30 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span31 = "" 0 0 0 0
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'4 (self : Seq'0.t_seq usize) =
    [%#span5] true
  
  predicate inv'4 (_x : Seq'0.t_seq usize)
  
  axiom inv'4 : forall x : Seq'0.t_seq usize . inv'4 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span6] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span7] inv'4 self)  -> ([%#span8] len'0 self >= 0)
  
  predicate inv'3 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span9] inv'3 self)
   -> ([%#span11] inv'4 (shallow_model'0 self))
  && ([%#span10] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'3 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span12] inv'4 (shallow_model'0 self)
  
  axiom inv'3 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : borrowed usize) =
    [%#span5] true
  
  predicate inv'2 (_x : borrowed usize)
  
  axiom inv'2 : forall x : borrowed usize . inv'2 x = true
  
  predicate invariant'1 (self : usize) =
    [%#span5] true
  
  predicate inv'1 (_x : usize)
  
  axiom inv'1 : forall x : usize . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (Vec'0.t_vec usize (Global'0.t_global))) =
    [%#span5] true
  
  predicate inv'0 (_x : borrowed (Vec'0.t_vec usize (Global'0.t_global)))
  
  axiom inv'0 : forall x : borrowed (Vec'0.t_vec usize (Global'0.t_global)) . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span13] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span15] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span14] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  use seq.Seq
  
  function index_logic'2 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'1 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span16] index_logic'2 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span17] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span18] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span19]  ^ self =  * self
  
  predicate resolve'0 (self : borrowed usize) =
    [%#span19]  ^ self =  * self
  
  use prelude.prelude.Slice
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq'0.t_seq usize) (fin : Seq'0.t_seq usize) =
    [%#span20] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < len'0 old'
     -> index_logic'2 old' i = index_logic'2 fin i
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq'0.t_seq usize) (out : usize) =
    [%#span21] index_logic'2 seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq'0.t_seq usize) =
    [%#span22] UIntSize.to_int self < len'0 seq
  
  function shallow_model'1 (self : borrowed (Vec'0.t_vec usize (Global'0.t_global))) : Seq'0.t_seq usize =
    [%#span23] shallow_model'0 ( * self)
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_vec usize (Global'0.t_global))) (index:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span26] inv'1 index}
    {[@expl:precondition] [%#span25] inv'0 self}
    {[@expl:precondition] [%#span24] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:borrowed usize)-> {[%#span31] inv'2 result}
      {[%#span30] len'0 (shallow_model'0 ( ^ self)) = len'0 (shallow_model'1 self)}
      {[%#span29] resolve_elswhere'0 index (shallow_model'1 self) (shallow_model'0 ( ^ self))}
      {[%#span28] has_value'0 index (shallow_model'0 ( ^ self)) ( ^ result)}
      {[%#span27] has_value'0 index (shallow_model'1 self) ( * result)}
      (! return' {result}) ]
    
  
  let rec index_mut (self:borrowed (Memory'0.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[%#slist_reversal_lasso0] nonnull_ptr'0 ( * self) i}
    (! bb0
    [ bb0 = s0
      [ s0 = Memory'0.t_memory { * self}
          (fun (r0'0:Vec'0.t_vec usize (Global'0.t_global)) ->
            Borrow.borrow_final
              <Vec'0.t_vec usize (Global'0.t_global)>
              {r0'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Vec'0.t_vec usize (Global'0.t_global))) ->
                 [ &_11 <- _ret' ] 
                Memory'0.t_memory { * self}
                  (fun (l_0'0:Vec'0.t_vec usize (Global'0.t_global)) ->
                     [ &self <- { self with current = Memory'0.C_Memory ( ^ _11) ; } ] 
                    s1)))
      | s1 = index_mut'0 {_11} {i} (fun (_ret':borrowed usize) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <usize> { * _10} {Borrow.get_id _10}
          (fun (_ret':borrowed usize) ->  [ &_9 <- _ret' ]  [ &_10 <- { _10 with current = ( ^ _9) ; } ] s1)
      | s1 = Borrow.borrow_final <usize> { * _9} {Borrow.get_id _9}
          (fun (_ret':borrowed usize) ->  [ &_3 <- _ret' ]  [ &_9 <- { _9 with current = ( ^ _3) ; } ] s2)
      | s2 = Borrow.borrow_final <usize> { * _3} {Borrow.get_id _3}
          (fun (_ret':borrowed usize) ->  [ &_0 <- _ret' ]  [ &_3 <- { _3 with current = ( ^ _0) ; } ] s3)
      | s3 = -{resolve'0 _10}- s4
      | s4 = -{resolve'0 _9}- s5
      | s5 = -{resolve'0 _3}- s6
      | s6 = -{resolve'1 self}- s7
      | s7 = return' {_0} ]
       ]
    )
    [ & _0 : borrowed usize = any_l ()
    | & self : borrowed (Memory'0.t_memory) = self
    | & i : usize = i
    | & _3 : borrowed usize = any_l ()
    | & _9 : borrowed usize = any_l ()
    | & _10 : borrowed usize = any_l ()
    | & _11 : borrowed (Vec'0.t_vec usize (Global'0.t_global)) = any_l () ]
    
    [ return' (result:borrowed usize)-> {[@expl:postcondition] [%#slist_reversal_lasso4] forall j : usize . nonnull_ptr'0 ( * self) j
      /\ i <> j  -> index_logic'0 ( ^ self) j = index_logic'0 ( * self) j}
      {[@expl:postcondition] [%#slist_reversal_lasso3] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[@expl:postcondition] [%#slist_reversal_lasso2]  ^ result = index_logic'0 ( ^ self) i}
      {[@expl:postcondition] [%#slist_reversal_lasso1]  * result = index_logic'0 ( * self) i}
      (! return' {result}) ]
    
end
module CreusotContracts_Snapshot_Snapshot_Type
  type t_snapshot 't
end
module ListReversalLasso_Impl4_ListReversalSafe
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 66 20 66 24
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 68 20 68 52
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 69 20 69 52
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 70 20 70 45
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 71 19 71 23
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 63 15 63 40
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 64 15 64 47
  
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span8 = "" 0 0 0 0
  
  let%span span9 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span10 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span15 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span16 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span17 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span18 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span19 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span20 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span21 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span22 = "../list_reversal_lasso.rs" 36 15 36 34
  
  let%span span23 = "../list_reversal_lasso.rs" 37 14 37 47
  
  let%span span24 = "../list_reversal_lasso.rs" 38 14 38 47
  
  let%span span25 = "../list_reversal_lasso.rs" 39 14 39 47
  
  let%span span26 = "../list_reversal_lasso.rs" 40 4 40 113
  
  let%span span27 = "../list_reversal_lasso.rs" 28 15 28 34
  
  let%span span28 = "../list_reversal_lasso.rs" 29 14 29 44
  
  let%span span29 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span30 = "../list_reversal_lasso.rs" 56 8 58 9
  
  let%span span31 = "../../../../creusot-contracts/src/snapshot.rs" 45 15 45 16
  
  let%span span32 = "../../../../creusot-contracts/src/snapshot.rs" 43 14 43 28
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'2 (self : Seq'0.t_seq usize) =
    [%#span7] true
  
  predicate inv'2 (_x : Seq'0.t_seq usize)
  
  axiom inv'2 : forall x : Seq'0.t_seq usize . inv'2 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span8] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span9] inv'2 self)  -> ([%#span10] len'0 self >= 0)
  
  predicate inv'1 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span11] inv'1 self)
   -> ([%#span13] inv'2 (shallow_model'0 self))
  && ([%#span12] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'1 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span14] inv'2 (shallow_model'0 self)
  
  axiom inv'1 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'1 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span15] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span17] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span16] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : borrowed (Memory'0.t_memory)) =
    [%#span7] true
  
  predicate inv'0 (_x : borrowed (Memory'0.t_memory))
  
  axiom inv'0 : forall x : borrowed (Memory'0.t_memory) . inv'0 x = true
  
  use CreusotContracts_Snapshot_Snapshot_Type as Snapshot'0
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span18]  ^ self =  * self
  
  predicate resolve'0 (self : borrowed usize) =
    [%#span18]  ^ self =  * self
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  use seq.Seq
  
  function index_logic'2 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'1 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span19] index_logic'2 (shallow_model'0 self) (UIntSize.to_int ix)
  
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span20] index_logic'1 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span21] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  let rec index_mut'0 (self:borrowed (Memory'0.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span22] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span26] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'0 ( ^ self) j = index_logic'0 ( * self) j}
      {[%#span25] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span24]  ^ result = index_logic'0 ( ^ self) i}
      {[%#span23]  * result = index_logic'0 ( * self) i}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Memory'0.t_memory) (i:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span27] nonnull_ptr'0 self i}
    any [ return' (result:usize)-> {[%#span28] result = index_logic'0 self i} (! return' {result}) ] 
  
  function deref'0 (self : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))) : borrowed (Memory'0.t_memory)
  
  constant null'0 : usize = [%#span29] (18446744073709551615 : usize)
  
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : Memory'0.t_memory) =
    [%#span30] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'0 self i = null'0 \/ nonnull_ptr'0 self (index_logic'0 self i)
  
  function new'0 (x : borrowed (Memory'0.t_memory)) : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))
  
  axiom new'0_spec : forall x : borrowed (Memory'0.t_memory) . ([%#span31] inv'0 x)
   -> ([%#span32] deref'0 (new'0 x) = x)
  
  let rec list_reversal_safe (self:borrowed (Memory'0.t_memory)) (l:usize) (return'  (ret:usize))= {[%#slist_reversal_lasso6] l
    = null'0
    \/ nonnull_ptr'0 ( * self) l}
    {[%#slist_reversal_lasso5] mem_is_well_formed'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &old_1_0 <- new'0 self ] s2
      | s2 = bb1 ]
      
    | bb1 = bb1
      [ bb1 = {[@expl:loop invariant]  ^ deref'0 old_1_0 =  ^ self}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] mem_is_well_formed'0 ( * self)}
        {[@expl:loop invariant] [%#slist_reversal_lasso2] l = null'0 \/ nonnull_ptr'0 ( * self) l}
        {[@expl:loop invariant] [%#slist_reversal_lasso1] r = null'0 \/ nonnull_ptr'0 ( * self) r}
        (! s0) [ s0 = bb2 ] 
        [ bb2 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso4] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
          | s1 = any [ br0 -> {_12 = false} (! bb6) | br1 -> {_12} (! bb3) ]  ]
          
        | bb3 = s0
          [ s0 =  [ &tmp <- l ] s1
          | s1 = index'0 { * self} {l} (fun (_ret':usize) ->  [ &_16 <- _ret' ] s2)
          | s2 = bb4 ]
          
        | bb4 = s0
          [ s0 =  [ &l <- _16 ] s1
          | s1 = Borrow.borrow_mut <Memory'0.t_memory> { * self}
              (fun (_ret':borrowed (Memory'0.t_memory)) ->
                 [ &_21 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _21) ; } ] 
                s2)
          | s2 = index_mut'0 {_21} {tmp} (fun (_ret':borrowed usize) ->  [ &_20 <- _ret' ] s3)
          | s3 = bb5 ]
          
        | bb5 = s0
          [ s0 =  [ &_20 <- { _20 with current = r ; } ] s1
          | s1 = -{resolve'0 _20}- s2
          | s2 =  [ &r <- tmp ] s3
          | s3 = bb1 ]
           ]
         ]
      
    | bb6 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & self : borrowed (Memory'0.t_memory) = self
    | & l : usize = l
    | & r : usize = any_l ()
    | & _12 : bool = any_l ()
    | & tmp : usize = any_l ()
    | & _16 : usize = any_l ()
    | & _20 : borrowed usize = any_l ()
    | & _21 : borrowed (Memory'0.t_memory) = any_l ()
    | & old_1_0 : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory)) = any_l () ]
     [ return' (result:usize)-> (! return' {result}) ] 
end
module ListReversalLasso_Impl4_ListReversalList
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 100 20 100 24
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 101 20 101 35
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 103 20 103 44
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 104 20 104 59
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 105 20 105 76
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 107 19 107 23
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 109 16 109 36
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 97 15 97 31
  
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 98 14 98 47
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span11 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span16 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span17 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span18 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span19 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span20 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span21 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span22 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span23 = "../list_reversal_lasso.rs" 83 12 85 98
  
  let%span span24 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span25 = "../list_reversal_lasso.rs" 93 12 93 53
  
  let%span span26 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span27 = "" 0 0 0 0
  
  let%span span28 = "" 0 0 0 0
  
  let%span span29 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  
  let%span span30 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  let%span span31 = "" 0 0 0 0
  
  let%span span32 = "../list_reversal_lasso.rs" 36 15 36 34
  
  let%span span33 = "../list_reversal_lasso.rs" 37 14 37 47
  
  let%span span34 = "../list_reversal_lasso.rs" 38 14 38 47
  
  let%span span35 = "../list_reversal_lasso.rs" 39 14 39 47
  
  let%span span36 = "../list_reversal_lasso.rs" 40 4 40 113
  
  let%span span37 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 19 115 23
  
  let%span span38 = "../../../../creusot-contracts/src/logic/seq2.rs" 113 14 113 40
  
  let%span span39 = "../../../../creusot-contracts/src/logic/seq2.rs" 114 4 114 100
  
  let%span span40 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 4 115 32
  
  let%span span41 = "../../../../creusot-contracts/src/snapshot.rs" 45 15 45 16
  
  let%span span42 = "../../../../creusot-contracts/src/snapshot.rs" 43 14 43 28
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate inv'2 (_x : Seq'0.t_seq usize)
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span9] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span10] inv'2 self)  -> ([%#span11] len'0 self >= 0)
  
  predicate inv'5 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span12] inv'5 self)
   -> ([%#span14] inv'2 (shallow_model'0 self))
  && ([%#span13] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'5 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span15] inv'2 (shallow_model'0 self)
  
  axiom inv'5 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'5 x = true
  
  predicate invariant'4 (self : usize) =
    [%#span16] true
  
  predicate inv'4 (_x : usize)
  
  axiom inv'4 : forall x : usize . inv'4 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : borrowed usize) =
    [%#span16] true
  
  predicate inv'3 (_x : borrowed usize)
  
  axiom inv'3 : forall x : borrowed usize . inv'3 x = true
  
  predicate invariant'2 (self : Seq'0.t_seq usize) =
    [%#span16] true
  
  axiom inv'2 : forall x : Seq'0.t_seq usize . inv'2 x = true
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  predicate invariant'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span16] true
  
  predicate inv'1 (_x : borrowed (Memory'0.t_memory))
  
  axiom inv'1 : forall x : borrowed (Memory'0.t_memory) . inv'1 x = true
  
  use prelude.prelude.Int
  
  predicate invariant'0 (self : int) =
    [%#span16] true
  
  predicate inv'0 (_x : int)
  
  axiom inv'0 : forall x : int . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span17] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span19] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span18] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'2 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span20] index_logic'0 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  function index_logic'1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span21] index_logic'2 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span22] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span23] first = (if h = l then last else index_logic'0 s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (index_logic'0 s i)
    /\ index_logic'1 self (index_logic'0 s i) = (if i = h - 1 then last else index_logic'0 s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j
     -> index_logic'0 s i <> index_logic'0 s j)
  
  constant null'0 : usize = [%#span24] (18446744073709551615 : usize)
  
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize)
    
   =
    [%#span25] list_seg'0 self first s null'0 0 (len'0 s)
  
  use CreusotContracts_Snapshot_Snapshot_Type as Snapshot'0
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span26]  ^ self =  * self
  
  predicate resolve'0 (self : borrowed usize) =
    [%#span26]  ^ self =  * self
  
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span28] inv'4 src}
    {[@expl:precondition] [%#span27] inv'3 dest}
    any
    [ return' (result:usize)-> {[%#span31] inv'4 result}
      {[%#span30] result =  * dest}
      {[%#span29]  ^ dest = src}
      (! return' {result}) ]
    
  
  let rec index_mut'0 (self:borrowed (Memory'0.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span32] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span36] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'1 ( ^ self) j = index_logic'1 ( * self) j}
      {[%#span35] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span34]  ^ result = index_logic'1 ( ^ self) i}
      {[%#span33]  * result = index_logic'1 ( * self) i}
      (! return' {result}) ]
    
  
  function deref'2 (self : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))) : borrowed (Memory'0.t_memory)
  
  use seq.Reverse
  
  function reverse'0 (self : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom reverse'0_spec : forall self : Seq'0.t_seq usize . ([%#span37] inv'2 self)
   -> ([%#span40] inv'2 (reverse'0 self))
  && ([%#span39] forall i : int . 0 <= i /\ i < len'0 (reverse'0 self)
   -> index_logic'0 (reverse'0 self) i = index_logic'0 self (len'0 self - 1 - i))
  && ([%#span38] len'0 (reverse'0 self) = len'0 self)
  
  function deref'1 (self : Snapshot'0.t_snapshot (Seq'0.t_seq usize)) : Seq'0.t_seq usize
  
  function deref'0 (self : Snapshot'0.t_snapshot int) : int
  
  function new'1 (x : borrowed (Memory'0.t_memory)) : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))
  
  axiom new'1_spec : forall x : borrowed (Memory'0.t_memory) . ([%#span41] inv'1 x)
   -> ([%#span42] deref'2 (new'1 x) = x)
  
  function new'0 (x : int) : Snapshot'0.t_snapshot int
  
  axiom new'0_spec : forall x : int . ([%#span41] inv'0 x)  -> ([%#span42] deref'0 (new'0 x) = x)
  
  let rec list_reversal_list (self:borrowed (Memory'0.t_memory)) (l:usize) (s:Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso7] list'0 ( * self) l (deref'1 s)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso1] new'0 0 ] s2
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &old_2_0 <- new'1 self ] s1 | s1 = bb2 ] 
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant]  ^ deref'2 old_2_0 =  ^ self}
        {[@expl:loop invariant] [%#slist_reversal_lasso4] list_seg'0 ( * self) r (reverse'0 (deref'1 s)) null'0 (len'0 (deref'1 s)
        - deref'0 n) (len'0 (deref'1 s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] list_seg'0 ( * self) l (deref'1 s) null'0 (deref'0 n) (len'0 (deref'1 s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso2] 0 <= deref'0 n /\ deref'0 n <= len'0 (deref'1 s)}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso5] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1)
          | s1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb4) ]  ]
          
        | bb4 = s0
          [ s0 = Borrow.borrow_mut <Memory'0.t_memory> { * self}
              (fun (_ret':borrowed (Memory'0.t_memory)) ->
                 [ &_21 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _21) ; } ] 
                s1)
          | s1 = index_mut'0 {_21} {l} (fun (_ret':borrowed usize) ->  [ &_20 <- _ret' ] s2)
          | s2 = bb5 ]
          
        | bb5 = s0
          [ s0 = Borrow.borrow_final <usize> { * _20} {Borrow.get_id _20}
              (fun (_ret':borrowed usize) ->  [ &_19 <- _ret' ]  [ &_20 <- { _20 with current = ( ^ _19) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _19} {Borrow.get_id _19}
              (fun (_ret':borrowed usize) ->  [ &_18 <- _ret' ]  [ &_19 <- { _19 with current = ( ^ _18) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_25 <- _ret' ]  [ &r <-  ^ _25 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _25} {Borrow.get_id _25}
              (fun (_ret':borrowed usize) ->  [ &_24 <- _ret' ]  [ &_25 <- { _25 with current = ( ^ _24) ; } ] s4)
          | s4 = replace'0 {_24} {l} (fun (_ret':usize) ->  [ &_23 <- _ret' ] s5)
          | s5 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _25}- s1
          | s1 = replace'0 {_18} {_23} (fun (_ret':usize) ->  [ &_17 <- _ret' ] s2)
          | s2 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = -{resolve'0 _19}- s2
          | s2 =  [ &l <- _17 ] (any [ any_ (_any:usize)-> (!  [ &_17 <- _any ] s3) ] )
          | s3 =  [ &_27 <- [%#slist_reversal_lasso6] new'0 (deref'0 n + 1) ] s4
          | s4 = bb8 ]
          
        | bb8 = s0
          [ s0 =  [ &n <- _27 ] (any [ any_ (_any:Snapshot'0.t_snapshot int)-> (!  [ &_27 <- _any ] s1) ] ) | s1 = bb2 ]
           ]
         ]
      
    | bb9 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & self : borrowed (Memory'0.t_memory) = self
    | & l : usize = l
    | & s : Snapshot'0.t_snapshot (Seq'0.t_seq usize) = s
    | & r : usize = any_l ()
    | & n : Snapshot'0.t_snapshot int = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : borrowed usize = any_l ()
    | & _19 : borrowed usize = any_l ()
    | & _20 : borrowed usize = any_l ()
    | & _21 : borrowed (Memory'0.t_memory) = any_l ()
    | & _23 : usize = any_l ()
    | & _24 : borrowed usize = any_l ()
    | & _25 : borrowed usize = any_l ()
    | & _27 : Snapshot'0.t_snapshot int = any_l ()
    | & old_2_0 : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory)) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso8] list'0 ( ^ self) result (reverse'0 (deref'1 s))}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl4_ListReversalLoop
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 126 20 126 24
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 127 20 127 35
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 129 20 129 48
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 129 8 129 50
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 137 19 137 23
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 138 12 138 77
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 140 16 140 36
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 143 8 145 54
  
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 122 15 122 26
  
  let%span slist_reversal_lasso9 = "../list_reversal_lasso.rs" 123 15 123 32
  
  let%span slist_reversal_lasso10 = "../list_reversal_lasso.rs" 124 14 124 101
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span13 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span16 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span17 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span19 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span20 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span21 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span22 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span23 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span24 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span25 = "../list_reversal_lasso.rs" 83 12 85 98
  
  let%span span26 = "../list_reversal_lasso.rs" 118 12 118 53
  
  let%span span27 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 18 107 22
  
  let%span span28 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 24 107 29
  
  let%span span29 = "../../../../creusot-contracts/src/logic/seq2.rs" 104 14 104 54
  
  let%span span30 = "../../../../creusot-contracts/src/logic/seq2.rs" 105 4 106 62
  
  let%span span31 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 4 107 44
  
  let%span span32 = "../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span span33 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span span34 = "../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span span35 = "../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span span36 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span37 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 21 58 22
  
  let%span span38 = "../../../../creusot-contracts/src/logic/seq2.rs" 56 14 56 31
  
  let%span span39 = "../../../../creusot-contracts/src/logic/seq2.rs" 57 14 57 28
  
  let%span span40 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 4 58 34
  
  let%span span41 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span42 = "" 0 0 0 0
  
  let%span span43 = "" 0 0 0 0
  
  let%span span44 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  
  let%span span45 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  let%span span46 = "" 0 0 0 0
  
  let%span span47 = "../list_reversal_lasso.rs" 36 15 36 34
  
  let%span span48 = "../list_reversal_lasso.rs" 37 14 37 47
  
  let%span span49 = "../list_reversal_lasso.rs" 38 14 38 47
  
  let%span span50 = "../list_reversal_lasso.rs" 39 14 39 47
  
  let%span span51 = "../list_reversal_lasso.rs" 40 4 40 113
  
  let%span span52 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 19 115 23
  
  let%span span53 = "../../../../creusot-contracts/src/logic/seq2.rs" 113 14 113 40
  
  let%span span54 = "../../../../creusot-contracts/src/logic/seq2.rs" 114 4 114 100
  
  let%span span55 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 4 115 32
  
  let%span span56 = "../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33
  
  let%span span57 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span58 = "../../../../creusot-contracts/src/snapshot.rs" 45 15 45 16
  
  let%span span59 = "../../../../creusot-contracts/src/snapshot.rs" 43 14 43 28
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate inv'2 (_x : Seq'0.t_seq usize)
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span11] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span12] inv'2 self)  -> ([%#span13] len'0 self >= 0)
  
  predicate inv'5 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span14] inv'5 self)
   -> ([%#span16] inv'2 (shallow_model'0 self))
  && ([%#span15] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'5 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span17] inv'2 (shallow_model'0 self)
  
  axiom inv'5 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'5 x = true
  
  predicate invariant'4 (self : usize) =
    [%#span18] true
  
  predicate inv'4 (_x : usize)
  
  axiom inv'4 : forall x : usize . inv'4 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : borrowed usize) =
    [%#span18] true
  
  predicate inv'3 (_x : borrowed usize)
  
  axiom inv'3 : forall x : borrowed usize . inv'3 x = true
  
  predicate invariant'2 (self : Seq'0.t_seq usize) =
    [%#span18] true
  
  axiom inv'2 : forall x : Seq'0.t_seq usize . inv'2 x = true
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  predicate invariant'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span18] true
  
  predicate inv'1 (_x : borrowed (Memory'0.t_memory))
  
  axiom inv'1 : forall x : borrowed (Memory'0.t_memory) . inv'1 x = true
  
  use prelude.prelude.Int
  
  predicate invariant'0 (self : int) =
    [%#span18] true
  
  predicate inv'0 (_x : int)
  
  axiom inv'0 : forall x : int . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span19] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span21] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span20] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use seq.Seq
  
  function index_logic'2 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'3 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span22] index_logic'2 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  function index_logic'1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span23] index_logic'3 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span24] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span25] first = (if h = l then last else index_logic'2 s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (index_logic'2 s i)
    /\ index_logic'1 self (index_logic'2 s i) = (if i = h - 1 then last else index_logic'2 s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j
     -> index_logic'2 s i <> index_logic'2 s j)
  
  predicate loop'0 [#"../list_reversal_lasso.rs" 116 4 116 55] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize)
    
   =
    [%#span26] list_seg'0 self first s (index_logic'2 s 0) 0 (len'0 s)
  
  use CreusotContracts_Snapshot_Snapshot_Type as Snapshot'0
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  function concat'0 (self : Seq'0.t_seq usize) (other : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom concat'0_spec : forall self : Seq'0.t_seq usize, other : Seq'0.t_seq usize . ([%#span27] inv'2 self)
   -> ([%#span28] inv'2 other)
   -> ([%#span31] inv'2 (concat'0 self other))
  && ([%#span30] forall i : int . 0 <= i /\ i < len'0 (concat'0 self other)
   -> index_logic'2 (concat'0 self other) i
  = (if i < len'0 self then index_logic'2 self i else index_logic'2 other (i - len'0 self)))
  && ([%#span29] len'0 (concat'0 self other) = len'0 self + len'0 other)
  
  use prelude.seq_ext.SeqExt
  
  function subsequence'0 (self : Seq'0.t_seq usize) (n : int) (m : int) : Seq'0.t_seq usize
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq usize, n : int, m : int . ([%#span32] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#span33] inv'2 self)
   -> ([%#span36] inv'2 (subsequence'0 self n m))
  && ([%#span35] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'2 (subsequence'0 self n m) i = index_logic'2 self (n + i))
  && ([%#span34] len'0 (subsequence'0 self n m) = m - n)
  
  use seq.Seq
  
  function singleton'0 (v : usize) : Seq'0.t_seq usize
  
  axiom singleton'0_spec : forall v : usize . ([%#span37] inv'4 v)
   -> ([%#span40] inv'2 (singleton'0 v))
  && ([%#span39] index_logic'2 (singleton'0 v) 0 = v) && ([%#span38] len'0 (singleton'0 v) = 1)
  
  predicate resolve'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span41]  ^ self =  * self
  
  predicate resolve'0 (self : borrowed usize) =
    [%#span41]  ^ self =  * self
  
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span43] inv'4 src}
    {[@expl:precondition] [%#span42] inv'3 dest}
    any
    [ return' (result:usize)-> {[%#span46] inv'4 result}
      {[%#span45] result =  * dest}
      {[%#span44]  ^ dest = src}
      (! return' {result}) ]
    
  
  let rec index_mut'0 (self:borrowed (Memory'0.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span47] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span51] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'1 ( ^ self) j = index_logic'1 ( * self) j}
      {[%#span50] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span49]  ^ result = index_logic'1 ( ^ self) i}
      {[%#span48]  * result = index_logic'1 ( * self) i}
      (! return' {result}) ]
    
  
  function deref'2 (self : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))) : borrowed (Memory'0.t_memory)
  
  use seq.Reverse
  
  function reverse'0 (self : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom reverse'0_spec : forall self : Seq'0.t_seq usize . ([%#span52] inv'2 self)
   -> ([%#span55] inv'2 (reverse'0 self))
  && ([%#span54] forall i : int . 0 <= i /\ i < len'0 (reverse'0 self)
   -> index_logic'2 (reverse'0 self) i = index_logic'2 self (len'0 self - 1 - i))
  && ([%#span53] len'0 (reverse'0 self) = len'0 self)
  
  function deref'1 (self : Snapshot'0.t_snapshot (Seq'0.t_seq usize)) : Seq'0.t_seq usize
  
  function index_logic'0 [@inline:trivial] (self : Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (ix : int) : usize =
    [%#span56] index_logic'2 (deref'1 self) ix
  
  constant null'0 : usize = [%#span57] (18446744073709551615 : usize)
  
  function deref'0 (self : Snapshot'0.t_snapshot int) : int
  
  function new'1 (x : borrowed (Memory'0.t_memory)) : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))
  
  axiom new'1_spec : forall x : borrowed (Memory'0.t_memory) . ([%#span58] inv'1 x)
   -> ([%#span59] deref'2 (new'1 x) = x)
  
  function new'0 (x : int) : Snapshot'0.t_snapshot int
  
  axiom new'0_spec : forall x : int . ([%#span58] inv'0 x)  -> ([%#span59] deref'0 (new'0 x) = x)
  
  let rec list_reversal_loop (self:borrowed (Memory'0.t_memory)) (l:usize) (s:Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso9] loop'0 ( * self) l (deref'1 s)}
    {[%#slist_reversal_lasso8] len'0 (deref'1 s) > 0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso1] new'0 0 ] s2
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &old_2_0 <- new'1 self ] s1 | s1 = bb2 ] 
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant]  ^ deref'2 old_2_0 =  ^ self}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] deref'0 n <= len'0 (deref'1 s)
         -> list_seg'0 ( * self) r (reverse'0 (deref'1 s)) null'0 (len'0 (deref'1 s) - deref'0 n) (len'0 (deref'1 s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] deref'0 n <= len'0 (deref'1 s)
         -> list_seg'0 ( * self) l (deref'1 s) (index_logic'0 s 0) (deref'0 n) (len'0 (deref'1 s))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] deref'0 n = len'0 (deref'1 s) + 1
         -> l = null'0
        /\ r = index_logic'0 s 0
        /\ nonnull_ptr'0 ( * self) r
        /\ index_logic'1 ( * self) r = index_logic'0 s (len'0 (deref'1 s) - 1)
        /\ list_seg'0 ( * self) (index_logic'0 s (len'0 (deref'1 s)
        - 1)) (reverse'0 (deref'1 s)) (index_logic'0 s 0) 0 (len'0 (deref'1 s) - 1)}
        {[@expl:loop invariant] [%#slist_reversal_lasso2] 0 <= deref'0 n /\ deref'0 n <= len'0 (deref'1 s) + 1}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso4] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
          | s1 = any [ br0 -> {_17 = false} (! bb9) | br1 -> {_17} (! bb4) ]  ]
          
        | bb4 = s0
          [ s0 = {[@expl:assertion] [%#slist_reversal_lasso5] deref'0 n = len'0 (deref'1 s)
             -> l = index_logic'2 (reverse'0 (deref'1 s)) (len'0 (deref'1 s) - 1)}
            s1
          | s1 = Borrow.borrow_mut <Memory'0.t_memory> { * self}
              (fun (_ret':borrowed (Memory'0.t_memory)) ->
                 [ &_25 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _25) ; } ] 
                s2)
          | s2 = index_mut'0 {_25} {l} (fun (_ret':borrowed usize) ->  [ &_24 <- _ret' ] s3)
          | s3 = bb5 ]
          
        | bb5 = s0
          [ s0 = Borrow.borrow_final <usize> { * _24} {Borrow.get_id _24}
              (fun (_ret':borrowed usize) ->  [ &_23 <- _ret' ]  [ &_24 <- { _24 with current = ( ^ _23) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _23} {Borrow.get_id _23}
              (fun (_ret':borrowed usize) ->  [ &_22 <- _ret' ]  [ &_23 <- { _23 with current = ( ^ _22) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_29 <- _ret' ]  [ &r <-  ^ _29 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _29} {Borrow.get_id _29}
              (fun (_ret':borrowed usize) ->  [ &_28 <- _ret' ]  [ &_29 <- { _29 with current = ( ^ _28) ; } ] s4)
          | s4 = replace'0 {_28} {l} (fun (_ret':usize) ->  [ &_27 <- _ret' ] s5)
          | s5 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _29}- s1
          | s1 = replace'0 {_22} {_27} (fun (_ret':usize) ->  [ &_21 <- _ret' ] s2)
          | s2 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _24}- s1
          | s1 = -{resolve'0 _23}- s2
          | s2 =  [ &l <- _21 ] (any [ any_ (_any:usize)-> (!  [ &_21 <- _any ] s3) ] )
          | s3 =  [ &_31 <- [%#slist_reversal_lasso6] new'0 (deref'0 n + 1) ] s4
          | s4 = bb8 ]
          
        | bb8 = s0
          [ s0 =  [ &n <- _31 ] (any [ any_ (_any:Snapshot'0.t_snapshot int)-> (!  [ &_31 <- _any ] s1) ] ) | s1 = bb2 ]
           ]
         ]
      
    | bb9 = s0
      [ s0 = -{resolve'1 self}- s1
      | s1 = {[@expl:assertion] [%#slist_reversal_lasso7] forall i : int . 0 <= i /\ i < len'0 (deref'1 s)
         -> index_logic'2 (concat'0 (singleton'0 (index_logic'0 s 0)) (reverse'0 (subsequence'0 (deref'1 s) 1 (len'0 (deref'1 s))))) i
        = (if i = 0 then index_logic'0 s 0 else index_logic'2 (reverse'0 (deref'1 s)) (i - 1))}
        s2
      | s2 =  [ &_0 <- r ] s3
      | s3 = return' {_0} ]
       ]
    )
    [ & _0 : usize = any_l ()
    | & self : borrowed (Memory'0.t_memory) = self
    | & l : usize = l
    | & s : Snapshot'0.t_snapshot (Seq'0.t_seq usize) = s
    | & r : usize = any_l ()
    | & n : Snapshot'0.t_snapshot int = any_l ()
    | & _17 : bool = any_l ()
    | & _21 : usize = any_l ()
    | & _22 : borrowed usize = any_l ()
    | & _23 : borrowed usize = any_l ()
    | & _24 : borrowed usize = any_l ()
    | & _25 : borrowed (Memory'0.t_memory) = any_l ()
    | & _27 : usize = any_l ()
    | & _28 : borrowed usize = any_l ()
    | & _29 : borrowed usize = any_l ()
    | & _31 : Snapshot'0.t_snapshot int = any_l ()
    | & old_2_0 : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory)) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso10] loop'0 ( ^ self) result (concat'0 (singleton'0 (index_logic'0 s 0)) (reverse'0 (subsequence'0 (deref'1 s) 1 (len'0 (deref'1 s)))))}
      (! return' {result}) ]
    
end
module ListReversalLasso_Impl4_ListReversalLasso
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 169 20 169 24
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 170 20 170 35
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 172 20 172 58
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 172 8 172 60
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 190 19 190 23
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 192 16 192 36
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 161 15 161 38
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 162 14 162 54
  
  let%span span8 = "" 0 0 0 0
  
  let%span span9 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span10 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span16 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span17 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span18 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span19 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span20 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span21 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span22 = "../list_reversal_lasso.rs" 83 12 85 98
  
  let%span span23 = "../list_reversal_lasso.rs" 152 8 158 9
  
  let%span span24 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span25 = "" 0 0 0 0
  
  let%span span26 = "" 0 0 0 0
  
  let%span span27 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  
  let%span span28 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  let%span span29 = "" 0 0 0 0
  
  let%span span30 = "../list_reversal_lasso.rs" 36 15 36 34
  
  let%span span31 = "../list_reversal_lasso.rs" 37 14 37 47
  
  let%span span32 = "../list_reversal_lasso.rs" 38 14 38 47
  
  let%span span33 = "../list_reversal_lasso.rs" 39 14 39 47
  
  let%span span34 = "../list_reversal_lasso.rs" 40 4 40 113
  
  let%span span35 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span36 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 19 115 23
  
  let%span span37 = "../../../../creusot-contracts/src/logic/seq2.rs" 113 14 113 40
  
  let%span span38 = "../../../../creusot-contracts/src/logic/seq2.rs" 114 4 114 100
  
  let%span span39 = "../../../../creusot-contracts/src/logic/seq2.rs" 115 4 115 32
  
  let%span span40 = "../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33
  
  let%span span41 = "../../../../creusot-contracts/src/snapshot.rs" 45 15 45 16
  
  let%span span42 = "../../../../creusot-contracts/src/snapshot.rs" 43 14 43 28
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate inv'2 (_x : Seq'0.t_seq usize)
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span8] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span9] inv'2 self)  -> ([%#span10] len'0 self >= 0)
  
  predicate inv'5 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span11] inv'5 self)
   -> ([%#span13] inv'2 (shallow_model'0 self))
  && ([%#span12] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'5 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span14] inv'2 (shallow_model'0 self)
  
  axiom inv'5 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'5 x = true
  
  predicate invariant'4 (self : usize) =
    [%#span15] true
  
  predicate inv'4 (_x : usize)
  
  axiom inv'4 : forall x : usize . inv'4 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : borrowed usize) =
    [%#span15] true
  
  predicate inv'3 (_x : borrowed usize)
  
  axiom inv'3 : forall x : borrowed usize . inv'3 x = true
  
  predicate invariant'2 (self : Seq'0.t_seq usize) =
    [%#span15] true
  
  axiom inv'2 : forall x : Seq'0.t_seq usize . inv'2 x = true
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  predicate invariant'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span15] true
  
  predicate inv'1 (_x : borrowed (Memory'0.t_memory))
  
  axiom inv'1 : forall x : borrowed (Memory'0.t_memory) . inv'1 x = true
  
  use prelude.prelude.Int
  
  predicate invariant'0 (self : int) =
    [%#span15] true
  
  predicate inv'0 (_x : int)
  
  axiom inv'0 : forall x : int . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span16] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span18] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span17] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use seq.Seq
  
  function index_logic'1 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'3 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span19] index_logic'1 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  function index_logic'2 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span20] index_logic'3 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span21] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span22] first = (if h = l then last else index_logic'1 s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (index_logic'1 s i)
    /\ index_logic'2 self (index_logic'1 s i) = (if i = h - 1 then last else index_logic'1 s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j
     -> index_logic'1 s i <> index_logic'1 s j)
  
  predicate lasso'0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : Memory'0.t_memory) (first : usize) (s1 : Seq'0.t_seq usize) (s2 : Seq'0.t_seq usize)
    
   =
    [%#span23] let mid = if len'0 s2 = 0 then index_logic'1 s1 (len'0 s1 - 1) else index_logic'1 s2 0 in len'0 s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < len'0 s1 /\ 0 <= j /\ j < len'0 s2
     -> index_logic'1 s1 i <> index_logic'1 s2 j)
    /\ list_seg'0 self first s1 mid 0 (len'0 s1)
    /\ list_seg'0 self mid s2 (index_logic'1 s1 (len'0 s1 - 1)) 0 (len'0 s2)
  
  use CreusotContracts_Snapshot_Snapshot_Type as Snapshot'0
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Memory'0.t_memory)) =
    [%#span24]  ^ self =  * self
  
  predicate resolve'0 (self : borrowed usize) =
    [%#span24]  ^ self =  * self
  
  let rec replace'0 (dest:borrowed usize) (src:usize) (return'  (ret:usize))= {[@expl:precondition] [%#span26] inv'4 src}
    {[@expl:precondition] [%#span25] inv'3 dest}
    any
    [ return' (result:usize)-> {[%#span29] inv'4 result}
      {[%#span28] result =  * dest}
      {[%#span27]  ^ dest = src}
      (! return' {result}) ]
    
  
  let rec index_mut'0 (self:borrowed (Memory'0.t_memory)) (i:usize) (return'  (ret:borrowed usize))= {[@expl:precondition] [%#span30] nonnull_ptr'0 ( * self) i}
    any
    [ return' (result:borrowed usize)-> {[%#span34] forall j : usize . nonnull_ptr'0 ( * self) j /\ i <> j
       -> index_logic'2 ( ^ self) j = index_logic'2 ( * self) j}
      {[%#span33] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( * self)))
      = len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self)))}
      {[%#span32]  ^ result = index_logic'2 ( ^ self) i}
      {[%#span31]  * result = index_logic'2 ( * self) i}
      (! return' {result}) ]
    
  
  function deref'2 (self : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))) : borrowed (Memory'0.t_memory)
  
  constant null'0 : usize = [%#span35] (18446744073709551615 : usize)
  
  use seq.Reverse
  
  function reverse'0 (self : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom reverse'0_spec : forall self : Seq'0.t_seq usize . ([%#span36] inv'2 self)
   -> ([%#span39] inv'2 (reverse'0 self))
  && ([%#span38] forall i : int . 0 <= i /\ i < len'0 (reverse'0 self)
   -> index_logic'1 (reverse'0 self) i = index_logic'1 self (len'0 self - 1 - i))
  && ([%#span37] len'0 (reverse'0 self) = len'0 self)
  
  function deref'1 (self : Snapshot'0.t_snapshot (Seq'0.t_seq usize)) : Seq'0.t_seq usize
  
  function index_logic'0 [@inline:trivial] (self : Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (ix : int) : usize =
    [%#span40] index_logic'1 (deref'1 self) ix
  
  function deref'0 (self : Snapshot'0.t_snapshot int) : int
  
  function new'1 (x : borrowed (Memory'0.t_memory)) : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory))
  
  axiom new'1_spec : forall x : borrowed (Memory'0.t_memory) . ([%#span41] inv'1 x)
   -> ([%#span42] deref'2 (new'1 x) = x)
  
  function new'0 (x : int) : Snapshot'0.t_snapshot int
  
  axiom new'0_spec : forall x : int . ([%#span41] inv'0 x)  -> ([%#span42] deref'0 (new'0 x) = x)
  
  let rec list_reversal_lasso (self:borrowed (Memory'0.t_memory)) (l:usize) (s1:Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (s2:Snapshot'0.t_snapshot (Seq'0.t_seq usize)) (return'  (ret:usize))= {[%#slist_reversal_lasso6] lasso'0 ( * self) l (deref'1 s1) (deref'1 s2)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso0] (18446744073709551615 : usize) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso1] new'0 0 ] s2
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &old_2_0 <- new'1 self ] s1 | s1 = bb2 ] 
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant]  ^ deref'2 old_2_0 =  ^ self}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] let mid = if len'0 (deref'1 s2) = 0 then
          index_logic'0 s1 (len'0 (deref'1 s1) - 1)
        else
          index_logic'0 s2 (len'0 (deref'1 s2) - 1)
         in len'0 (deref'1 s1) + len'0 (deref'1 s2) < deref'0 n
         -> list_seg'0 ( * self) l (reverse'0 (deref'1 s1)) null'0 (deref'0 n - len'0 (deref'1 s1)
        - len'0 (deref'1 s2)) (len'0 (deref'1 s1))
        /\ list_seg'0 ( * self) r (deref'1 s1) mid (2 * len'0 (deref'1 s1) + len'0 (deref'1 s2)
        - deref'0 n) (len'0 (deref'1 s1))
        /\ list_seg'0 ( * self) mid (reverse'0 (deref'1 s2)) (index_logic'0 s1 (len'0 (deref'1 s1)
        - 1)) 0 (len'0 (deref'1 s2))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] len'0 (deref'1 s1) < deref'0 n
        /\ deref'0 n <= len'0 (deref'1 s1) + len'0 (deref'1 s2)
         -> list_seg'0 ( * self) l (deref'1 s2) (index_logic'0 s1 (len'0 (deref'1 s1) - 1)) (deref'0 n
        - len'0 (deref'1 s1)) (len'0 (deref'1 s2))
        /\ list_seg'0 ( * self) r (reverse'0 (deref'1 s2)) (index_logic'0 s1 (len'0 (deref'1 s1)
        - 1)) (len'0 (deref'1 s1) + len'0 (deref'1 s2) - deref'0 n) (len'0 (deref'1 s2))
        /\ list_seg'0 ( * self) (index_logic'0 s1 (len'0 (deref'1 s1)
        - 1)) (reverse'0 (deref'1 s1)) null'0 0 (len'0 (deref'1 s1))}
        {[@expl:loop invariant] [%#slist_reversal_lasso3] let mid = if len'0 (deref'1 s2) = 0 then
          index_logic'0 s1 (len'0 (deref'1 s1) - 1)
        else
          index_logic'0 s2 0
         in deref'0 n <= len'0 (deref'1 s1)
         -> list_seg'0 ( * self) l (deref'1 s1) mid (deref'0 n) (len'0 (deref'1 s1))
        /\ list_seg'0 ( * self) mid (deref'1 s2) (index_logic'0 s1 (len'0 (deref'1 s1) - 1)) 0 (len'0 (deref'1 s2))
        /\ list_seg'0 ( * self) r (reverse'0 (deref'1 s1)) null'0 (len'0 (deref'1 s1) - deref'0 n) (len'0 (deref'1 s1))}
        {[@expl:loop invariant] [%#slist_reversal_lasso2] 0 <= deref'0 n
        /\ deref'0 n <= 2 * len'0 (deref'1 s1) + len'0 (deref'1 s2)}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = UIntSize.ne {l} {[%#slist_reversal_lasso4] (18446744073709551615 : usize)}
              (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
          | s1 = any [ br0 -> {_17 = false} (! bb9) | br1 -> {_17} (! bb4) ]  ]
          
        | bb4 = s0
          [ s0 = Borrow.borrow_mut <Memory'0.t_memory> { * self}
              (fun (_ret':borrowed (Memory'0.t_memory)) ->
                 [ &_23 <- _ret' ] 
                 [ &self <- { self with current = ( ^ _23) ; } ] 
                s1)
          | s1 = index_mut'0 {_23} {l} (fun (_ret':borrowed usize) ->  [ &_22 <- _ret' ] s2)
          | s2 = bb5 ]
          
        | bb5 = s0
          [ s0 = Borrow.borrow_final <usize> { * _22} {Borrow.get_id _22}
              (fun (_ret':borrowed usize) ->  [ &_21 <- _ret' ]  [ &_22 <- { _22 with current = ( ^ _21) ; } ] s1)
          | s1 = Borrow.borrow_final <usize> { * _21} {Borrow.get_id _21}
              (fun (_ret':borrowed usize) ->  [ &_20 <- _ret' ]  [ &_21 <- { _21 with current = ( ^ _20) ; } ] s2)
          | s2 = Borrow.borrow_mut <usize> {r} (fun (_ret':borrowed usize) ->  [ &_27 <- _ret' ]  [ &r <-  ^ _27 ] s3)
          | s3 = Borrow.borrow_final <usize> { * _27} {Borrow.get_id _27}
              (fun (_ret':borrowed usize) ->  [ &_26 <- _ret' ]  [ &_27 <- { _27 with current = ( ^ _26) ; } ] s4)
          | s4 = replace'0 {_26} {l} (fun (_ret':usize) ->  [ &_25 <- _ret' ] s5)
          | s5 = bb6 ]
          
        | bb6 = s0
          [ s0 = -{resolve'0 _27}- s1
          | s1 = replace'0 {_20} {_25} (fun (_ret':usize) ->  [ &_19 <- _ret' ] s2)
          | s2 = bb7 ]
          
        | bb7 = s0
          [ s0 = -{resolve'0 _22}- s1
          | s1 = -{resolve'0 _21}- s2
          | s2 =  [ &l <- _19 ] (any [ any_ (_any:usize)-> (!  [ &_19 <- _any ] s3) ] )
          | s3 =  [ &_29 <- [%#slist_reversal_lasso5] new'0 (deref'0 n + 1) ] s4
          | s4 = bb8 ]
          
        | bb8 = s0
          [ s0 =  [ &n <- _29 ] (any [ any_ (_any:Snapshot'0.t_snapshot int)-> (!  [ &_29 <- _any ] s1) ] ) | s1 = bb2 ]
           ]
         ]
      
    | bb9 = s0 [ s0 = -{resolve'1 self}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : usize = any_l ()
    | & self : borrowed (Memory'0.t_memory) = self
    | & l : usize = l
    | & s1 : Snapshot'0.t_snapshot (Seq'0.t_seq usize) = s1
    | & s2 : Snapshot'0.t_snapshot (Seq'0.t_seq usize) = s2
    | & r : usize = any_l ()
    | & n : Snapshot'0.t_snapshot int = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : usize = any_l ()
    | & _20 : borrowed usize = any_l ()
    | & _21 : borrowed usize = any_l ()
    | & _22 : borrowed usize = any_l ()
    | & _23 : borrowed (Memory'0.t_memory) = any_l ()
    | & _25 : usize = any_l ()
    | & _26 : borrowed usize = any_l ()
    | & _27 : borrowed usize = any_l ()
    | & _29 : Snapshot'0.t_snapshot int = any_l ()
    | & old_2_0 : Snapshot'0.t_snapshot (borrowed (Memory'0.t_memory)) = any_l () ]
    
    [ return' (result:usize)-> {[@expl:postcondition] [%#slist_reversal_lasso7] lasso'0 ( ^ self) result (deref'1 s1) (reverse'0 (deref'1 s2))}
      (! return' {result}) ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 198 15 198 37
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 199 14 202 5
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 203 14 203 25
  
  let%span sseq23 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq24 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span5 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span6 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span7 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span8 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'0 (self : Seq'0.t_seq usize) =
    [%#span5] true
  
  predicate inv'0 (_x : Seq'0.t_seq usize)
  
  axiom inv'0 : forall x : Seq'0.t_seq usize . inv'0 x = true
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#sseq23] inv'0 self)  -> ([%#sseq24] len'0 self >= 0)
  
  constant empty'0 : Seq'0.t_seq usize = [%#span6] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span8] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span7] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use prelude.prelude.UIntSize
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq usize) (x : int) : usize
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  constant s  : Seq'0.t_seq usize
  
  constant i  : int
  
  constant p  : int
  
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq'0.t_seq usize) (i : int) (p : int) : Option'0.t_option int
    
  
  goal vc_find_ptr_in_seq : ([%#slist_reversal_lasso0] 0 <= i /\ i <= len'0 s)
   -> ([%#sseq23] inv'0 s)
  /\ (([%#sseq24] len'0 s >= 0)
   -> match i = len'0 s with
    | True -> [%#slist_reversal_lasso1] match Option'0.C_None with
      | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
      | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
      end
    | False -> match UIntSize.to_int (index_logic'0 s i) = p with
      | True -> [%#slist_reversal_lasso1] match Option'0.C_Some i with
        | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
        | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
        end
      | False -> (([%#slist_reversal_lasso0] 0 <= i + 1 /\ i + 1 <= len'0 s)
      /\ 0 <= ([%#slist_reversal_lasso2] len'0 s - i)
      /\ ([%#slist_reversal_lasso2] len'0 s - (i + 1)) < ([%#slist_reversal_lasso2] len'0 s - i))
      /\ (([%#slist_reversal_lasso1] match find_ptr_in_seq s (i + 1) p with
        | Option'0.C_None -> forall j : int . i + 1 <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
        | Option'0.C_Some j -> i + 1 <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
        end)
       -> ([%#slist_reversal_lasso1] match find_ptr_in_seq s (i + 1) p with
        | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
        | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
        end))
      end
    end)
end
module ListReversalLasso_Impl4_Pigeon_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 213 15 213 21
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 214 4 214 67
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 215 4 215 113
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 216 14 216 26
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 217 14 217 20
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 218 14 218 15
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 198 15 198 37
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 199 14 202 5
  
  let%span slist_reversal_lasso8 = "../list_reversal_lasso.rs" 203 14 203 25
  
  let%span sseq29 = "../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span sseq210 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span sseq211 = "../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span sseq212 = "../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span sseq213 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span sseq214 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq215 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span sseq216 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 18 107 22
  
  let%span sseq217 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 24 107 29
  
  let%span sseq218 = "../../../../creusot-contracts/src/logic/seq2.rs" 104 14 104 54
  
  let%span sseq219 = "../../../../creusot-contracts/src/logic/seq2.rs" 105 4 106 62
  
  let%span sseq220 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 4 107 44
  
  let%span span21 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span22 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span23 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span24 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span25 = "../list_reversal_lasso.rs" 205 8 209 9
  
  use prelude.prelude.UIntSize
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'0 (self : Seq'0.t_seq usize) =
    [%#span21] true
  
  predicate inv'0 (_x : Seq'0.t_seq usize)
  
  axiom inv'0 : forall x : Seq'0.t_seq usize . inv'0 x = true
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#sseq214] inv'0 self)  -> ([%#sseq215] len'0 self >= 0)
  
  constant empty'0 : Seq'0.t_seq usize = [%#span22] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span24] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span23] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function concat'0 (self : Seq'0.t_seq usize) (other : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom concat'0_spec : forall self : Seq'0.t_seq usize, other : Seq'0.t_seq usize . ([%#sseq216] inv'0 self)
   -> ([%#sseq217] inv'0 other)
   -> ([%#sseq220] inv'0 (concat'0 self other))
  && ([%#sseq219] forall i : int . 0 <= i /\ i < len'0 (concat'0 self other)
   -> index_logic'0 (concat'0 self other) i
  = (if i < len'0 self then index_logic'0 self i else index_logic'0 other (i - len'0 self)))
  && ([%#sseq218] len'0 (concat'0 self other) = len'0 self + len'0 other)
  
  use prelude.seq_ext.SeqExt
  
  function subsequence'0 (self : Seq'0.t_seq usize) (n : int) (m : int) : Seq'0.t_seq usize
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq usize, n : int, m : int . ([%#sseq29] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq210] inv'0 self)
   -> ([%#sseq213] inv'0 (subsequence'0 self n m))
  && ([%#sseq212] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq211] len'0 (subsequence'0 self n m) = m - n)
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  use prelude.prelude.UIntSize
  
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq'0.t_seq usize) (i : int) (p : int) : Option'0.t_option int
    
  
  axiom find_ptr_in_seq'0_def : forall s : Seq'0.t_seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span25] if i = len'0 s then
    Option'0.C_None
  else
    if UIntSize.to_int (index_logic'0 s i) = p then Option'0.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  
  axiom find_ptr_in_seq'0_spec : forall s : Seq'0.t_seq usize, i : int, p : int . ([%#slist_reversal_lasso6] 0 <= i
  /\ i <= len'0 s)
   -> ([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s i p with
    | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
    | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
    end)
  
  constant s  : Seq'0.t_seq usize
  
  constant n  : int
  
  function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq'0.t_seq usize) (n : int) : bool
  
  goal vc_pigeon : ([%#slist_reversal_lasso2] forall j : int . forall i : int . 0 <= i
  /\ i < len'0 s /\ 0 <= j /\ j < len'0 s /\ i <> j  -> index_logic'0 s i <> index_logic'0 s j)
   -> ([%#slist_reversal_lasso1] forall i : int . 0 <= i /\ i < len'0 s  -> UIntSize.to_int (index_logic'0 s i) < n)
   -> ([%#slist_reversal_lasso0] 0 <= n)
   -> match n = 0 with
    | True -> ([%#slist_reversal_lasso4] true) && ([%#slist_reversal_lasso3] len'0 s <= n)
    | False -> ([%#slist_reversal_lasso6] 0 <= 0 /\ 0 <= len'0 s)
    /\ (([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s 0 (n - 1) with
      | Option'0.C_None -> forall j : int . 0 <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> n - 1
      | Option'0.C_Some j -> 0 <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = n - 1
      end)
     -> match find_ptr_in_seq'0 s 0 (n - 1) with
      | Option'0.C_None -> ((([%#slist_reversal_lasso2] forall j : int . forall i : int . 0 <= i
      /\ i < len'0 s /\ 0 <= j /\ j < len'0 s /\ i <> j  -> index_logic'0 s i <> index_logic'0 s j)
      && ([%#slist_reversal_lasso1] forall i : int . 0 <= i /\ i < len'0 s
       -> UIntSize.to_int (index_logic'0 s i) < n - 1)
      && ([%#slist_reversal_lasso0] 0 <= n - 1))
      /\ 0 <= ([%#slist_reversal_lasso5] n) /\ ([%#slist_reversal_lasso5] n - 1) < ([%#slist_reversal_lasso5] n))
      /\ (([%#slist_reversal_lasso4] pigeon s (n - 1)) && ([%#slist_reversal_lasso3] len'0 s <= n - 1)
       -> ([%#slist_reversal_lasso4] pigeon s (n - 1)) && ([%#slist_reversal_lasso3] len'0 s <= n))
      | Option'0.C_Some i -> ([%#slist_reversal_lasso6] 0 <= i + 1 /\ i + 1 <= len'0 s)
      /\ (([%#slist_reversal_lasso7] match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Option'0.C_None -> forall j : int . i + 1 <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> n - 1
        | Option'0.C_Some j -> i + 1 <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = n - 1
        end)
       -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Option'0.C_None -> (([%#sseq210] inv'0 s) && ([%#sseq29] 0 <= 0 /\ 0 <= i /\ i <= len'0 s))
        /\ (([%#sseq213] inv'0 (subsequence'0 s 0 i))
        && ([%#sseq212] forall i' : int . 0 <= i' /\ i' < len'0 (subsequence'0 s 0 i)
         -> index_logic'0 (subsequence'0 s 0 i) i' = index_logic'0 s (0 + i'))
        && ([%#sseq211] len'0 (subsequence'0 s 0 i) = i - 0)
         -> ([%#sseq214] inv'0 s)
        /\ (([%#sseq215] len'0 s >= 0)
         -> (([%#sseq210] inv'0 s) && ([%#sseq29] 0 <= i + 1 /\ i + 1 <= len'0 s /\ len'0 s <= len'0 s))
        /\ (([%#sseq213] inv'0 (subsequence'0 s (i + 1) (len'0 s)))
        && ([%#sseq212] forall i' : int . 0 <= i' /\ i' < len'0 (subsequence'0 s (i + 1) (len'0 s))
         -> index_logic'0 (subsequence'0 s (i + 1) (len'0 s)) i' = index_logic'0 s (i + 1 + i'))
        && ([%#sseq211] len'0 (subsequence'0 s (i + 1) (len'0 s)) = len'0 s - (i + 1))
         -> (([%#sseq217] inv'0 (subsequence'0 s (i + 1) (len'0 s))) && ([%#sseq216] inv'0 (subsequence'0 s 0 i)))
        /\ (([%#sseq220] inv'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))))
        && ([%#sseq219] forall i' : int . 0 <= i'
        /\ i' < len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s)))
         -> index_logic'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) i'
        = (if i' < len'0 (subsequence'0 s 0 i) then
          index_logic'0 (subsequence'0 s 0 i) i'
        else
          index_logic'0 (subsequence'0 s (i + 1) (len'0 s)) (i' - len'0 (subsequence'0 s 0 i))
        ))
        && ([%#sseq218] len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s)))
        = len'0 (subsequence'0 s 0 i) + len'0 (subsequence'0 s (i + 1) (len'0 s)))
         -> ((([%#slist_reversal_lasso2] forall j : int . forall i' : int . 0 <= i'
        /\ i' < len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s)))
        /\ 0 <= j /\ j < len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) /\ i' <> j
         -> index_logic'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) i'
        <> index_logic'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) j)
        && ([%#slist_reversal_lasso1] forall i' : int . 0 <= i'
        /\ i' < len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s)))
         -> UIntSize.to_int (index_logic'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) i')
        < n - 1)
        && ([%#slist_reversal_lasso0] 0 <= n - 1))
        /\ 0 <= ([%#slist_reversal_lasso5] n) /\ ([%#slist_reversal_lasso5] n - 1) < ([%#slist_reversal_lasso5] n))
        /\ (([%#slist_reversal_lasso4] pigeon (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) (n
        - 1))
        && ([%#slist_reversal_lasso3] len'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s)))
        <= n - 1)
         -> ([%#slist_reversal_lasso4] pigeon (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) (n
        - 1))
        && ([%#slist_reversal_lasso3] len'0 s <= n))))))
        | Option'0.C_Some _ -> ([%#slist_reversal_lasso4] true) && ([%#slist_reversal_lasso3] len'0 s <= n)
        end)
      end)
    end
end
module ListReversalLasso_Impl4_FindLassoAux_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 236 15 236 40
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 237 15 237 53
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 238 15 238 56
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 239 14 242 5
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 243 4 243 39
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 198 15 198 37
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 199 14 202 5
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 203 14 203 25
  
  let%span svec8 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span svec9 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span svec10 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span sseq211 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq212 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span slist_reversal_lasso13 = "../list_reversal_lasso.rs" 213 15 213 21
  
  let%span slist_reversal_lasso14 = "../list_reversal_lasso.rs" 214 4 214 67
  
  let%span slist_reversal_lasso15 = "../list_reversal_lasso.rs" 215 4 215 113
  
  let%span slist_reversal_lasso16 = "../list_reversal_lasso.rs" 216 14 216 26
  
  let%span slist_reversal_lasso17 = "../list_reversal_lasso.rs" 217 14 217 20
  
  let%span slist_reversal_lasso18 = "../list_reversal_lasso.rs" 218 14 218 15
  
  let%span sseq219 = "../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span sseq220 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span sseq221 = "../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span sseq222 = "../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span sseq223 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span24 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span25 = "" 0 0 0 0
  
  let%span span26 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span27 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span28 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span29 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span30 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 18 107 22
  
  let%span span31 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 24 107 29
  
  let%span span32 = "../../../../creusot-contracts/src/logic/seq2.rs" 104 14 104 54
  
  let%span span33 = "../../../../creusot-contracts/src/logic/seq2.rs" 105 4 106 62
  
  let%span span34 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 4 107 44
  
  let%span span35 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 21 58 22
  
  let%span span36 = "../../../../creusot-contracts/src/logic/seq2.rs" 56 14 56 31
  
  let%span span37 = "../../../../creusot-contracts/src/logic/seq2.rs" 57 14 57 28
  
  let%span span38 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 4 58 34
  
  let%span span39 = "../../../../creusot-contracts/src/logic/seq2.rs" 99 8 99 39
  
  let%span span40 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span41 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span42 = "../list_reversal_lasso.rs" 205 8 209 9
  
  let%span span43 = "../list_reversal_lasso.rs" 220 8 232 9
  
  let%span span44 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span45 = "../list_reversal_lasso.rs" 83 12 85 98
  
  let%span span46 = "../list_reversal_lasso.rs" 152 8 158 9
  
  let%span span47 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span48 = "../list_reversal_lasso.rs" 93 12 93 53
  
  let%span span49 = "../list_reversal_lasso.rs" 56 8 58 9
  
  use prelude.prelude.UIntSize
  
  predicate invariant'2 (self : usize) =
    [%#span24] true
  
  predicate inv'2 (_x : usize)
  
  axiom inv'2 : forall x : usize . inv'2 x = true
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'1 (self : Seq'0.t_seq usize) =
    [%#span24] true
  
  predicate inv'1 (_x : Seq'0.t_seq usize)
  
  axiom inv'1 : forall x : Seq'0.t_seq usize . inv'1 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span25] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#sseq211] inv'1 self)  -> ([%#sseq212] len'0 self >= 0)
  
  predicate inv'0 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#svec8] inv'0 self)
   -> ([%#svec10] inv'1 (shallow_model'0 self))
  && ([%#svec9] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'0 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span26] inv'1 (shallow_model'0 self)
  
  axiom inv'0 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span27] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span29] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span28] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use prelude.seq_ext.SeqExt
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function subsequence'0 (self : Seq'0.t_seq usize) (n : int) (m : int) : Seq'0.t_seq usize
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq usize, n : int, m : int . ([%#sseq219] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq220] inv'1 self)
   -> ([%#sseq223] inv'1 (subsequence'0 self n m))
  && ([%#sseq222] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq221] len'0 (subsequence'0 self n m) = m - n)
  
  use seq.Seq
  
  function concat'0 (self : Seq'0.t_seq usize) (other : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom concat'0_spec : forall self : Seq'0.t_seq usize, other : Seq'0.t_seq usize . ([%#span30] inv'1 self)
   -> ([%#span31] inv'1 other)
   -> ([%#span34] inv'1 (concat'0 self other))
  && ([%#span33] forall i : int . 0 <= i /\ i < len'0 (concat'0 self other)
   -> index_logic'0 (concat'0 self other) i
  = (if i < len'0 self then index_logic'0 self i else index_logic'0 other (i - len'0 self)))
  && ([%#span32] len'0 (concat'0 self other) = len'0 self + len'0 other)
  
  use seq.Seq
  
  function singleton'0 (v : usize) : Seq'0.t_seq usize
  
  axiom singleton'0_spec : forall v : usize . ([%#span35] inv'2 v)
   -> ([%#span38] inv'1 (singleton'0 v))
  && ([%#span37] index_logic'0 (singleton'0 v) 0 = v) && ([%#span36] len'0 (singleton'0 v) = 1)
  
  function push'0 [@inline:trivial] (self : Seq'0.t_seq usize) (v : usize) : Seq'0.t_seq usize =
    [%#span39] concat'0 self (singleton'0 v)
  
  function index_logic'2 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span40] index_logic'0 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  function index_logic'1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span41] index_logic'2 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq'0.t_seq usize) (i : int) (p : int) : Option'0.t_option int
    
  
  axiom find_ptr_in_seq'0_def : forall s : Seq'0.t_seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span42] if i = len'0 s then
    Option'0.C_None
  else
    if UIntSize.to_int (index_logic'0 s i) = p then Option'0.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  
  axiom find_ptr_in_seq'0_spec : forall s : Seq'0.t_seq usize, i : int, p : int . ([%#slist_reversal_lasso5] 0 <= i
  /\ i <= len'0 s)
   -> ([%#slist_reversal_lasso6] match find_ptr_in_seq'0 s i p with
    | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'0 s j) <> p
    | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = p
    end)
  
  function pigeon'0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq'0.t_seq usize) (n : int) : bool
  
  axiom pigeon'0_def : forall s : Seq'0.t_seq usize, n : int . pigeon'0 s n
  = ([%#span43] if n = 0 then
    true
  else
    match find_ptr_in_seq'0 s 0 (n - 1) with
      | Option'0.C_None -> pigeon'0 s (n - 1)
      | Option'0.C_Some i -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Option'0.C_None -> pigeon'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) (n - 1)
        | Option'0.C_Some _ -> true
        end
      end
  )
  
  axiom pigeon'0_spec : forall s : Seq'0.t_seq usize, n : int . ([%#slist_reversal_lasso13] 0 <= n)
   -> ([%#slist_reversal_lasso14] forall i : int . 0 <= i /\ i < len'0 s  -> UIntSize.to_int (index_logic'0 s i) < n)
   -> ([%#slist_reversal_lasso15] forall j : int . forall i : int . 0 <= i
  /\ i < len'0 s /\ 0 <= j /\ j < len'0 s /\ i <> j  -> index_logic'0 s i <> index_logic'0 s j)
   -> ([%#slist_reversal_lasso17] pigeon'0 s n) && ([%#slist_reversal_lasso16] len'0 s <= n)
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span44] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span45] first = (if h = l then last else index_logic'0 s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (index_logic'0 s i)
    /\ index_logic'1 self (index_logic'0 s i) = (if i = h - 1 then last else index_logic'0 s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j
     -> index_logic'0 s i <> index_logic'0 s j)
  
  predicate lasso'0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : Memory'0.t_memory) (first : usize) (s1 : Seq'0.t_seq usize) (s2 : Seq'0.t_seq usize)
    
   =
    [%#span46] let mid = if len'0 s2 = 0 then index_logic'0 s1 (len'0 s1 - 1) else index_logic'0 s2 0 in len'0 s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < len'0 s1 /\ 0 <= j /\ j < len'0 s2
     -> index_logic'0 s1 i <> index_logic'0 s2 j)
    /\ list_seg'0 self first s1 mid 0 (len'0 s1)
    /\ list_seg'0 self mid s2 (index_logic'0 s1 (len'0 s1 - 1)) 0 (len'0 s2)
  
  constant null'0 : usize = [%#span47] (18446744073709551615 : usize)
  
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize)
    
   =
    [%#span48] list_seg'0 self first s null'0 0 (len'0 s)
  
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : Memory'0.t_memory) =
    [%#span49] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'1 self i = null'0 \/ nonnull_ptr'0 self (index_logic'1 self i)
  
  constant self  : Memory'0.t_memory
  
  constant first  : usize
  
  constant last  : usize
  
  constant s  : Seq'0.t_seq usize
  
  function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : Memory'0.t_memory) (first : usize) (last : usize) (s : Seq'0.t_seq usize) : (Seq'0.t_seq usize, Option'0.t_option (Seq'0.t_seq usize))
    
  
  goal vc_find_lasso_aux : ([%#slist_reversal_lasso2] list_seg'0 self first s last 0 (len'0 s))
   -> ([%#slist_reversal_lasso1] last = null'0 \/ nonnull_ptr'0 self last)
   -> ([%#slist_reversal_lasso0] mem_is_well_formed'0 self)
   -> match last = null'0 with
    | True -> [%#slist_reversal_lasso3] match (s, Option'0.C_None) with
      | (s, Option'0.C_None) -> list'0 self first s
      | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
      end
    | False -> ([%#slist_reversal_lasso5] 0 <= 0 /\ 0 <= len'0 s)
    /\ (([%#slist_reversal_lasso6] match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Option'0.C_None -> forall j : int . 0 <= j /\ j < len'0 s
       -> UIntSize.to_int (index_logic'0 s j) <> UIntSize.to_int last
      | Option'0.C_Some j -> 0 <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'0 s j) = UIntSize.to_int last
      end)
     -> match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Option'0.C_None -> ([%#svec8] inv'0 (ListReversalLasso_Memory_Type.memory_0 self))
      /\ (([%#svec10] inv'1 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
      && ([%#svec9] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
      <= UIntSize.to_int (max'0 : usize))
       -> ([%#sseq211] inv'1 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
      /\ (([%#sseq212] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) >= 0)
       -> (([%#slist_reversal_lasso15] forall j : int . forall i : int . 0 <= i
      /\ i < len'0 s /\ 0 <= j /\ j < len'0 s /\ i <> j  -> index_logic'0 s i <> index_logic'0 s j)
      && ([%#slist_reversal_lasso14] forall i : int . 0 <= i /\ i < len'0 s
       -> UIntSize.to_int (index_logic'0 s i) < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
      && ([%#slist_reversal_lasso13] 0 <= len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))))
      /\ (([%#slist_reversal_lasso17] pigeon'0 s (len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))))
      && ([%#slist_reversal_lasso16] len'0 s <= len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)))
       -> match pigeon'0 s (len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))) with
        | True -> ((([%#slist_reversal_lasso2] list_seg'0 self first (push'0 s last) (index_logic'1 self last) 0 (len'0 (push'0 s last)))
        && ([%#slist_reversal_lasso1] index_logic'1 self last = null'0 \/ nonnull_ptr'0 self (index_logic'1 self last))
        && ([%#slist_reversal_lasso0] mem_is_well_formed'0 self))
        /\ 0
        <= ([%#slist_reversal_lasso4] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) - len'0 s)
        /\ ([%#slist_reversal_lasso4] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
        - len'0 (push'0 s last))
        < ([%#slist_reversal_lasso4] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) - len'0 s))
        /\ (([%#slist_reversal_lasso3] match find_lasso_aux self first (index_logic'1 self last) (push'0 s last) with
          | (s, Option'0.C_None) -> list'0 self first s
          | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
          end)
         -> ([%#slist_reversal_lasso3] match find_lasso_aux self first (index_logic'1 self last) (push'0 s last) with
          | (s, Option'0.C_None) -> list'0 self first s
          | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
          end))
        | False -> [%#slist_reversal_lasso3] match (s, Option'0.C_None) with
          | (s, Option'0.C_None) -> list'0 self first s
          | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
          end
        end)))
      | Option'0.C_Some i -> (([%#sseq220] inv'1 s) && ([%#sseq219] 0 <= 0 /\ 0 <= i + 1 /\ i + 1 <= len'0 s))
      /\ (([%#sseq223] inv'1 (subsequence'0 s 0 (i + 1)))
      && ([%#sseq222] forall i' : int . 0 <= i' /\ i' < len'0 (subsequence'0 s 0 (i + 1))
       -> index_logic'0 (subsequence'0 s 0 (i + 1)) i' = index_logic'0 s (0 + i'))
      && ([%#sseq221] len'0 (subsequence'0 s 0 (i + 1)) = i + 1 - 0)
       -> ([%#sseq211] inv'1 s)
      /\ (([%#sseq212] len'0 s >= 0)
       -> (([%#sseq220] inv'1 s) && ([%#sseq219] 0 <= i + 1 /\ i + 1 <= len'0 s /\ len'0 s <= len'0 s))
      /\ (([%#sseq223] inv'1 (subsequence'0 s (i + 1) (len'0 s)))
      && ([%#sseq222] forall i' : int . 0 <= i' /\ i' < len'0 (subsequence'0 s (i + 1) (len'0 s))
       -> index_logic'0 (subsequence'0 s (i + 1) (len'0 s)) i' = index_logic'0 s (i + 1 + i'))
      && ([%#sseq221] len'0 (subsequence'0 s (i + 1) (len'0 s)) = len'0 s - (i + 1))
       -> ([%#slist_reversal_lasso3] match (subsequence'0 s 0 (i + 1), Option'0.C_Some (subsequence'0 s (i
      + 1) (len'0 s))) with
        | (s, Option'0.C_None) -> list'0 self first s
        | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
        end))))
      end)
    end
end
module ListReversalLasso_Impl4_FindLasso_Impl
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 264 15 264 40
  
  let%span slist_reversal_lasso1 = "../list_reversal_lasso.rs" 265 15 265 55
  
  let%span slist_reversal_lasso2 = "../list_reversal_lasso.rs" 266 14 269 5
  
  let%span slist_reversal_lasso3 = "../list_reversal_lasso.rs" 236 15 236 40
  
  let%span slist_reversal_lasso4 = "../list_reversal_lasso.rs" 237 15 237 53
  
  let%span slist_reversal_lasso5 = "../list_reversal_lasso.rs" 238 15 238 56
  
  let%span slist_reversal_lasso6 = "../list_reversal_lasso.rs" 239 14 242 5
  
  let%span slist_reversal_lasso7 = "../list_reversal_lasso.rs" 243 4 243 39
  
  let%span span8 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span9 = "" 0 0 0 0
  
  let%span span10 = "../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span span11 = "../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span14 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span15 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span16 = "../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span17 = "../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span18 = "../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span19 = "../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32
  
  let%span span20 = "../list_reversal_lasso.rs" 21 8 21 31
  
  let%span span21 = "../list_reversal_lasso.rs" 50 20 50 70
  
  let%span span22 = "../list_reversal_lasso.rs" 83 12 85 98
  
  let%span span23 = "../list_reversal_lasso.rs" 198 15 198 37
  
  let%span span24 = "../list_reversal_lasso.rs" 199 14 202 5
  
  let%span span25 = "../list_reversal_lasso.rs" 203 14 203 25
  
  let%span span26 = "../list_reversal_lasso.rs" 205 8 209 9
  
  let%span span27 = "../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span span28 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span span29 = "../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span span30 = "../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span span31 = "../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span32 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 18 107 22
  
  let%span span33 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 24 107 29
  
  let%span span34 = "../../../../creusot-contracts/src/logic/seq2.rs" 104 14 104 54
  
  let%span span35 = "../../../../creusot-contracts/src/logic/seq2.rs" 105 4 106 62
  
  let%span span36 = "../../../../creusot-contracts/src/logic/seq2.rs" 107 4 107 44
  
  let%span span37 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 21 58 22
  
  let%span span38 = "../../../../creusot-contracts/src/logic/seq2.rs" 56 14 56 31
  
  let%span span39 = "../../../../creusot-contracts/src/logic/seq2.rs" 57 14 57 28
  
  let%span span40 = "../../../../creusot-contracts/src/logic/seq2.rs" 58 4 58 34
  
  let%span span41 = "../../../../creusot-contracts/src/logic/seq2.rs" 99 8 99 39
  
  let%span span42 = "../list_reversal_lasso.rs" 213 15 213 21
  
  let%span span43 = "../list_reversal_lasso.rs" 214 4 214 67
  
  let%span span44 = "../list_reversal_lasso.rs" 215 4 215 113
  
  let%span span45 = "../list_reversal_lasso.rs" 216 14 216 26
  
  let%span span46 = "../list_reversal_lasso.rs" 217 14 217 20
  
  let%span span47 = "../list_reversal_lasso.rs" 218 14 218 15
  
  let%span span48 = "../list_reversal_lasso.rs" 220 8 232 9
  
  let%span span49 = "../list_reversal_lasso.rs" 152 8 158 9
  
  let%span span50 = "../list_reversal_lasso.rs" 13 0 13 15
  
  let%span span51 = "../list_reversal_lasso.rs" 93 12 93 53
  
  let%span span52 = "../list_reversal_lasso.rs" 56 8 58 9
  
  let%span span53 = "../list_reversal_lasso.rs" 245 8 259 9
  
  use prelude.prelude.UIntSize
  
  predicate invariant'2 (self : usize) =
    [%#span8] true
  
  predicate inv'2 (_x : usize)
  
  axiom inv'2 : forall x : usize . inv'2 x = true
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate inv'0 (_x : Seq'0.t_seq usize)
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span9] (18446744073709551615 : usize)
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq usize) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq usize . ([%#span10] inv'0 self)  -> ([%#span11] len'0 self >= 0)
  
  predicate inv'1 (_x : Vec'0.t_vec usize (Global'0.t_global))
  
  function shallow_model'0 (self : Vec'0.t_vec usize (Global'0.t_global)) : Seq'0.t_seq usize
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_vec usize (Global'0.t_global) . ([%#span12] inv'1 self)
   -> ([%#span14] inv'0 (shallow_model'0 self))
  && ([%#span13] len'0 (shallow_model'0 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'1 (self : Vec'0.t_vec usize (Global'0.t_global)) =
    [%#span15] inv'0 (shallow_model'0 self)
  
  axiom inv'1 : forall x : Vec'0.t_vec usize (Global'0.t_global) . inv'1 x = true
  
  predicate invariant'0 (self : Seq'0.t_seq usize) =
    [%#span8] true
  
  axiom inv'0 : forall x : Seq'0.t_seq usize . inv'0 x = true
  
  constant empty'0 : Seq'0.t_seq usize = [%#span16] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span18] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span17] len'0 (empty'0 : Seq'0.t_seq usize) = 0
  
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  
  use seq.Seq
  
  function index_logic'1 (self : Seq'0.t_seq usize) (x : int) : usize
  
  function index_logic'2 [@inline:trivial] (self : Vec'0.t_vec usize (Global'0.t_global)) (ix : usize) : usize =
    [%#span19] index_logic'1 (shallow_model'0 self) (UIntSize.to_int ix)
  
  use ListReversalLasso_Memory_Type as Memory'0
  
  function index_logic'0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : Memory'0.t_memory) (i : usize) : usize =
    [%#span20] index_logic'2 (ListReversalLasso_Memory_Type.memory_0 self) i
  
  predicate nonnull_ptr'0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : Memory'0.t_memory) (i : usize) =
    [%#span21] len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int (max'0 : usize)
    /\ UIntSize.to_int i < len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))
  
  predicate list_seg'0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize) (last : usize) (l : int) (h : int)
    
   =
    [%#span22] first = (if h = l then last else index_logic'1 s l)
    /\ (forall i : int . l <= i /\ i < h
     -> nonnull_ptr'0 self (index_logic'1 s i)
    /\ index_logic'0 self (index_logic'1 s i) = (if i = h - 1 then last else index_logic'1 s (i + 1)))
    /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j
     -> index_logic'1 s i <> index_logic'1 s j)
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  function find_ptr_in_seq'0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq'0.t_seq usize) (i : int) (p : int) : Option'0.t_option int
    
  
  axiom find_ptr_in_seq'0_def : forall s : Seq'0.t_seq usize, i : int, p : int . find_ptr_in_seq'0 s i p
  = ([%#span26] if i = len'0 s then
    Option'0.C_None
  else
    if UIntSize.to_int (index_logic'1 s i) = p then Option'0.C_Some i else find_ptr_in_seq'0 s (i + 1) p
  )
  
  axiom find_ptr_in_seq'0_spec : forall s : Seq'0.t_seq usize, i : int, p : int . ([%#span23] 0 <= i /\ i <= len'0 s)
   -> ([%#span24] match find_ptr_in_seq'0 s i p with
    | Option'0.C_None -> forall j : int . i <= j /\ j < len'0 s  -> UIntSize.to_int (index_logic'1 s j) <> p
    | Option'0.C_Some j -> i <= j /\ j < len'0 s /\ UIntSize.to_int (index_logic'1 s j) = p
    end)
  
  use prelude.seq_ext.SeqExt
  
  function subsequence'0 (self : Seq'0.t_seq usize) (n : int) (m : int) : Seq'0.t_seq usize
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq usize, n : int, m : int . ([%#span27] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#span28] inv'0 self)
   -> ([%#span31] inv'0 (subsequence'0 self n m))
  && ([%#span30] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'1 (subsequence'0 self n m) i = index_logic'1 self (n + i))
  && ([%#span29] len'0 (subsequence'0 self n m) = m - n)
  
  use seq.Seq
  
  function concat'0 (self : Seq'0.t_seq usize) (other : Seq'0.t_seq usize) : Seq'0.t_seq usize
  
  axiom concat'0_spec : forall self : Seq'0.t_seq usize, other : Seq'0.t_seq usize . ([%#span32] inv'0 self)
   -> ([%#span33] inv'0 other)
   -> ([%#span36] inv'0 (concat'0 self other))
  && ([%#span35] forall i : int . 0 <= i /\ i < len'0 (concat'0 self other)
   -> index_logic'1 (concat'0 self other) i
  = (if i < len'0 self then index_logic'1 self i else index_logic'1 other (i - len'0 self)))
  && ([%#span34] len'0 (concat'0 self other) = len'0 self + len'0 other)
  
  use seq.Seq
  
  function singleton'0 (v : usize) : Seq'0.t_seq usize
  
  axiom singleton'0_spec : forall v : usize . ([%#span37] inv'2 v)
   -> ([%#span40] inv'0 (singleton'0 v))
  && ([%#span39] index_logic'1 (singleton'0 v) 0 = v) && ([%#span38] len'0 (singleton'0 v) = 1)
  
  function push'0 [@inline:trivial] (self : Seq'0.t_seq usize) (v : usize) : Seq'0.t_seq usize =
    [%#span41] concat'0 self (singleton'0 v)
  
  function pigeon'0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq'0.t_seq usize) (n : int) : bool
  
  axiom pigeon'0_def : forall s : Seq'0.t_seq usize, n : int . pigeon'0 s n
  = ([%#span48] if n = 0 then
    true
  else
    match find_ptr_in_seq'0 s 0 (n - 1) with
      | Option'0.C_None -> pigeon'0 s (n - 1)
      | Option'0.C_Some i -> match find_ptr_in_seq'0 s (i + 1) (n - 1) with
        | Option'0.C_None -> pigeon'0 (concat'0 (subsequence'0 s 0 i) (subsequence'0 s (i + 1) (len'0 s))) (n - 1)
        | Option'0.C_Some _ -> true
        end
      end
  )
  
  axiom pigeon'0_spec : forall s : Seq'0.t_seq usize, n : int . ([%#span42] 0 <= n)
   -> ([%#span43] forall i : int . 0 <= i /\ i < len'0 s  -> UIntSize.to_int (index_logic'1 s i) < n)
   -> ([%#span44] forall j : int . forall i : int . 0 <= i /\ i < len'0 s /\ 0 <= j /\ j < len'0 s /\ i <> j
   -> index_logic'1 s i <> index_logic'1 s j)  -> ([%#span46] pigeon'0 s n) && ([%#span45] len'0 s <= n)
  
  predicate lasso'0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : Memory'0.t_memory) (first : usize) (s1 : Seq'0.t_seq usize) (s2 : Seq'0.t_seq usize)
    
   =
    [%#span49] let mid = if len'0 s2 = 0 then index_logic'1 s1 (len'0 s1 - 1) else index_logic'1 s2 0 in len'0 s1 > 0
    /\ (forall j : int . forall i : int . 0 <= i /\ i < len'0 s1 /\ 0 <= j /\ j < len'0 s2
     -> index_logic'1 s1 i <> index_logic'1 s2 j)
    /\ list_seg'0 self first s1 mid 0 (len'0 s1)
    /\ list_seg'0 self mid s2 (index_logic'1 s1 (len'0 s1 - 1)) 0 (len'0 s2)
  
  constant null'0 : usize = [%#span50] (18446744073709551615 : usize)
  
  predicate list'0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : Memory'0.t_memory) (first : usize) (s : Seq'0.t_seq usize)
    
   =
    [%#span51] list_seg'0 self first s null'0 0 (len'0 s)
  
  predicate mem_is_well_formed'0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : Memory'0.t_memory) =
    [%#span52] forall i : usize . nonnull_ptr'0 self i
     -> index_logic'0 self i = null'0 \/ nonnull_ptr'0 self (index_logic'0 self i)
  
  function find_lasso_aux'0 [#"../list_reversal_lasso.rs" 244 4 244 95] (self : Memory'0.t_memory) (first : usize) (last : usize) (s : Seq'0.t_seq usize) : (Seq'0.t_seq usize, Option'0.t_option (Seq'0.t_seq usize))
    
  
  axiom find_lasso_aux'0_def : forall self : Memory'0.t_memory, first : usize, last : usize, s : Seq'0.t_seq usize . find_lasso_aux'0 self first last s
  = ([%#span53] if last = null'0 then
    (s, Option'0.C_None)
  else
    match find_ptr_in_seq'0 s 0 (UIntSize.to_int last) with
      | Option'0.C_None -> if pigeon'0 s (len'0 (shallow_model'0 (ListReversalLasso_Memory_Type.memory_0 self))) then
        find_lasso_aux'0 self first (index_logic'0 self last) (push'0 s last)
      else
        (s, Option'0.C_None)
      
      | Option'0.C_Some i -> (subsequence'0 s 0 (i + 1), Option'0.C_Some (subsequence'0 s (i + 1) (len'0 s)))
      end
  )
  
  axiom find_lasso_aux'0_spec : forall self : Memory'0.t_memory, first : usize, last : usize, s : Seq'0.t_seq usize . ([%#slist_reversal_lasso3] mem_is_well_formed'0 self)
   -> ([%#slist_reversal_lasso4] last = null'0 \/ nonnull_ptr'0 self last)
   -> ([%#slist_reversal_lasso5] list_seg'0 self first s last 0 (len'0 s))
   -> ([%#slist_reversal_lasso6] match find_lasso_aux'0 self first last s with
    | (s, Option'0.C_None) -> list'0 self first s
    | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
    end)
  
  constant self  : Memory'0.t_memory
  
  constant first  : usize
  
  function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : Memory'0.t_memory) (first : usize) : (Seq'0.t_seq usize, Option'0.t_option (Seq'0.t_seq usize))
    
  
  goal vc_find_lasso : ([%#slist_reversal_lasso1] first = null'0 \/ nonnull_ptr'0 self first)
   -> ([%#slist_reversal_lasso0] mem_is_well_formed'0 self)
   -> (([%#slist_reversal_lasso5] list_seg'0 self first empty'0 first 0 (len'0 empty'0))
  && ([%#slist_reversal_lasso4] first = null'0 \/ nonnull_ptr'0 self first)
  && ([%#slist_reversal_lasso3] mem_is_well_formed'0 self))
  /\ (([%#slist_reversal_lasso6] match find_lasso_aux'0 self first first empty'0 with
    | (s, Option'0.C_None) -> list'0 self first s
    | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
    end)
   -> ([%#slist_reversal_lasso2] match find_lasso_aux'0 self first first empty'0 with
    | (s, Option'0.C_None) -> list'0 self first s
    | (s1, Option'0.C_Some s2) -> lasso'0 self first s1 s2
    end))
end
module ListReversalLasso_Impl0
  
end
module ListReversalLasso_Impl1
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 30 4 30 35
  
  goal index_refn : [%#slist_reversal_lasso0] true
end
module ListReversalLasso_Impl2
  let%span slist_reversal_lasso0 = "../list_reversal_lasso.rs" 41 4 41 47
  
  goal index_mut_refn : [%#slist_reversal_lasso0] true
end
