
module ListReversalLasso_Null_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize
end
module ListReversalLasso_Null
  use prelude.Int
  use prelude.UIntSize
  let constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module ListReversalLasso_Memory_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_memory  =
    | C_Memory (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
    
  let function memory_0 (self : t_memory) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Memory a -> a
      end
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv result }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] Inv1.inv (shallow_model self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic_Stub
  type t
  type a
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : usize) : t
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic_Interface
  type t
  type a
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : usize) : t
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : usize) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic
  type t
  type a
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    axiom .
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : usize) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (ShallowModel0.shallow_model self) (UIntSize.to_int ix)
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : usize) : t
    ensures { result = index_logic self ix }
    
end
module ListReversalLasso_Impl0_IndexLogic_Stub
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
end
module ListReversalLasso_Impl0_IndexLogic_Interface
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
  val index_logic [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic self i }
    
end
module ListReversalLasso_Impl0_IndexLogic
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic_Stub as IndexLogic0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] IndexLogic0.index_logic (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic self i }
    
end
module ListReversalLasso_Impl3_NonnullPtr_Stub
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
end
module ListReversalLasso_Impl3_NonnullPtr_Interface
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
  val nonnull_ptr [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr self i }
    
end
module ListReversalLasso_Impl3_NonnullPtr
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int Max0.mAX' /\ UIntSize.to_int i < Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr self i }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl12_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  use seq.Seq
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 141 27 141 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {Inv0.inv self}
    requires {Inv1.inv index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 142 26 142 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    ensures { Inv2.inv result }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 108 20 108 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module ListReversalLasso_Impl1_Index_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  val index [#"../list_reversal_lasso.rs" 30 4 30 35] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 28 15 28 34] NonnullPtr0.nonnull_ptr self i}
    ensures { [#"../list_reversal_lasso.rs" 29 14 29 44] result = IndexLogic0.index_logic self i }
    
end
module ListReversalLasso_Impl1_Index
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = usize
  let rec cfg index [#"../list_reversal_lasso.rs" 30 4 30 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 28 15 28 34] NonnullPtr0.nonnull_ptr self i}
    ensures { [#"../list_reversal_lasso.rs" 29 14 29 44] result = IndexLogic0.index_logic self i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : ListReversalLasso_Memory_Type.t_memory = self;
  var i : usize = i;
  var _5 : usize;
  var _6 : usize;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../list_reversal_lasso.rs" 31 9 31 18] Index0.index ([#"../list_reversal_lasso.rs" 31 9 31 15] ListReversalLasso_Memory_Type.memory_0 self) i);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../list_reversal_lasso.rs" 31 8 31 18] _6);
    _0 <- ([#"../list_reversal_lasso.rs" 31 8 31 18] _5);
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl13_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = borrowed Output0.output
  use seq.Seq
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 132 27 132 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {Inv0.inv self}
    requires {Inv1.inv index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 133 26 133 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 134 26 134 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 135 26 135 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    ensures { Inv2.inv result }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 8 122 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module ListReversalLasso_Impl2_IndexMut_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  val index_mut [#"../list_reversal_lasso.rs" 41 4 41 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] NonnullPtr0.nonnull_ptr ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = IndexLogic0.index_logic ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = IndexLogic0.index_logic ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . NonnullPtr0.nonnull_ptr ( * self) j /\ i <> j -> IndexLogic0.index_logic ( ^ self) j = IndexLogic0.index_logic ( * self) j }
    
end
module ListReversalLasso_Impl2_IndexMut
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv2.inv,
    type Output0.output = usize
  let rec cfg index_mut [#"../list_reversal_lasso.rs" 41 4 41 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] NonnullPtr0.nonnull_ptr ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = IndexLogic0.index_logic ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = IndexLogic0.index_logic ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . NonnullPtr0.nonnull_ptr ( * self) j /\ i <> j -> IndexLogic0.index_logic ( ^ self) j = IndexLogic0.index_logic ( * self) j }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var i : usize = i;
  var _3 : borrowed usize;
  var _9 : borrowed usize;
  var _10 : borrowed usize;
  var _11 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    _11 <- Borrow.borrow_mut (ListReversalLasso_Memory_Type.memory_0 ( * self));
    self <- { self with current = (let ListReversalLasso_Memory_Type.C_Memory a =  * self in ListReversalLasso_Memory_Type.C_Memory ( ^ _11)) };
    _10 <- ([#"../list_reversal_lasso.rs" 42 13 42 22] IndexMut0.index_mut _11 i);
    _11 <- any borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
    goto BB1
  }
  BB1 {
    _9 <- Borrow.borrow_mut ( * _10);
    _10 <- { _10 with current = ( ^ _9) };
    _3 <- Borrow.borrow_mut ( * _9);
    _9 <- { _9 with current = ( ^ _3) };
    _0 <- Borrow.borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve0.resolve _10 };
    assume { Resolve0.resolve _9 };
    assume { Resolve0.resolve _3 };
    assume { Resolve1.resolve self };
    return _0
  }
  
end
module ListReversalLasso_Impl3_MemIsWellFormed_Stub
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
end
module ListReversalLasso_Impl3_MemIsWellFormed_Interface
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
  val mem_is_well_formed [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed self }
    
end
module ListReversalLasso_Impl3_MemIsWellFormed
  use prelude.Int
  use prelude.UIntSize
  clone ListReversalLasso_Null_Stub as Null0
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
   =
    [#"../list_reversal_lasso.rs" 56 8 58 9] forall i : usize . NonnullPtr0.nonnull_ptr self i -> IndexLogic0.index_logic self i = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self (IndexLogic0.index_logic self i)
  val mem_is_well_formed [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed self }
    
end
module ListReversalLasso_Impl4_ListReversalSafe_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  val list_reversal_safe [#"../list_reversal_lasso.rs" 65 4 65 59] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 63 15 63 40] MemIsWellFormed0.mem_is_well_formed ( * self)}
    requires {[#"../list_reversal_lasso.rs" 64 15 64 47] l = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) l}
    
end
module ListReversalLasso_Impl4_ListReversalSafe
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = usize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone ListReversalLasso_Impl1_Index_Interface as Index0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  let rec cfg list_reversal_safe [#"../list_reversal_lasso.rs" 65 4 65 59] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 63 15 63 40] MemIsWellFormed0.mem_is_well_formed ( * self)}
    requires {[#"../list_reversal_lasso.rs" 64 15 64 47] l = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) l}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var r : usize;
  var tmp : usize;
  var _16 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 66 20 66 24] [#"../list_reversal_lasso.rs" 66 20 66 24] (18446744073709551615 : usize));
    goto BB1
  }
  BB1 {
    invariant { [#"../list_reversal_lasso.rs" 68 20 68 52] r = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) r };
    invariant { [#"../list_reversal_lasso.rs" 69 20 69 52] l = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) l };
    invariant { [#"../list_reversal_lasso.rs" 70 20 70 45] MemIsWellFormed0.mem_is_well_formed ( * self) };
    goto BB2
  }
  BB2 {
    switch ([#"../list_reversal_lasso.rs" 71 14 71 23] l <> ([#"../list_reversal_lasso.rs" 71 19 71 23] [#"../list_reversal_lasso.rs" 71 19 71 23] (18446744073709551615 : usize)))
      | False -> goto BB6
      | True -> goto BB3
      end
  }
  BB3 {
    tmp <- l;
    _16 <- ([#"../list_reversal_lasso.rs" 73 16 73 23] Index0.index ([#"../list_reversal_lasso.rs" 73 16 73 20]  * self) l);
    goto BB4
  }
  BB4 {
    l <- _16;
    _21 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _21) };
    _20 <- ([#"../list_reversal_lasso.rs" 74 12 74 21] IndexMut0.index_mut _21 tmp);
    _21 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _20 <- { _20 with current = r };
    assume { Resolve1.resolve _20 };
    r <- tmp;
    goto BB1
  }
  BB6 {
    assume { Resolve0.resolve self };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListSeg_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list_seg [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
end
module ListReversalLasso_Impl4_ListSeg_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list_seg [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
  val list_seg [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg self first s last l h }
    
end
module ListReversalLasso_Impl4_ListSeg
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  predicate list_seg [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> NonnullPtr0.nonnull_ptr self (Seq.get s i) /\ IndexLogic0.index_logic self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg self first s last l h }
    
end
module ListReversalLasso_Impl4_List_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_List_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
  val list [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list self first s }
    
end
module ListReversalLasso_Impl4_List
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Null_Stub as Null0
  predicate list [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 93 12 93 53] ListSeg0.list_seg self first s Null0.nULL' 0 (Seq.length s)
  val list [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list self first s }
    
end
module Core_Mem_Replace_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val replace (dest : borrowed t) (src : t) : t
    requires {Inv0.inv dest}
    requires {Inv1.inv src}
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { Inv1.inv result }
    
end
module ListReversalLasso_Impl4_ListReversalList_Interface
  use prelude.Borrow
  use prelude.Ghost
  use seq.Reverse
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_List_Stub as List0
  val list_reversal_list [#"../list_reversal_lasso.rs" 99 4 99 79] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 97 15 97 31] List0.list ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 98 14 98 47] List0.list ( ^ self) result (Reverse.reverse (Ghost.inner s)) }
    
end
module ListReversalLasso_Impl4_ListReversalList
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  use seq.Reverse
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed usize
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed usize,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = ListReversalLasso_Memory_Type.t_memory
  let rec cfg list_reversal_list [#"../list_reversal_lasso.rs" 99 4 99 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 97 15 97 31] List0.list ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 98 14 98 47] List0.list ( ^ self) result (Reverse.reverse (Ghost.inner s)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s : Ghost.ghost_ty (Seq.seq usize) = s;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _17 : usize;
  var _18 : borrowed usize;
  var _19 : borrowed usize;
  var _20 : borrowed usize;
  var _21 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _23 : usize;
  var _24 : borrowed usize;
  var _25 : borrowed usize;
  var _27 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 100 20 100 24] [#"../list_reversal_lasso.rs" 100 20 100 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 101 20 101 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 103 20 103 44] 0 <= Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s) };
    invariant { [#"../list_reversal_lasso.rs" 104 20 104 59] ListSeg0.list_seg ( * self) l (Ghost.inner s) Null0.nULL' (Ghost.inner n) (Seq.length (Ghost.inner s)) };
    invariant { [#"../list_reversal_lasso.rs" 105 20 105 76] ListSeg0.list_seg ( * self) r (Reverse.reverse (Ghost.inner s)) Null0.nULL' (Seq.length (Ghost.inner s) - Ghost.inner n) (Seq.length (Ghost.inner s)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 107 14 107 23] l <> ([#"../list_reversal_lasso.rs" 107 19 107 23] [#"../list_reversal_lasso.rs" 107 19 107 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _21 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _21) };
    _20 <- ([#"../list_reversal_lasso.rs" 108 39 108 46] IndexMut0.index_mut _21 l);
    _21 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _19 <- Borrow.borrow_mut ( * _20);
    _20 <- { _20 with current = ( ^ _19) };
    _18 <- Borrow.borrow_mut ( * _19);
    _19 <- { _19 with current = ( ^ _18) };
    _25 <- Borrow.borrow_mut r;
    r <-  ^ _25;
    _24 <- Borrow.borrow_mut ( * _25);
    _25 <- { _25 with current = ( ^ _24) };
    _23 <- ([#"../list_reversal_lasso.rs" 108 48 108 76] Replace0.replace _24 l);
    _24 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { Resolve1.resolve _25 };
    _17 <- ([#"../list_reversal_lasso.rs" 108 16 108 77] Replace0.replace _18 _23);
    _18 <- any borrowed usize;
    _23 <- any usize;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve _20 };
    assume { Resolve1.resolve _19 };
    l <- _17;
    _17 <- any usize;
    _27 <- ([#"../list_reversal_lasso.rs" 109 16 109 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _27;
    _27 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { Resolve0.resolve self };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_Loop_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate loop_ [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Loop_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate loop_ [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
  val loop_ [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = loop_ self first s }
    
end
module ListReversalLasso_Impl4_Loop
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  predicate loop_ [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 118 12 118 53] ListSeg0.list_seg self first s (Seq.get s 0) 0 (Seq.length s)
  val loop_ [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = loop_ self first s }
    
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Interface
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 86 8 86 33] Seq.get (Ghost.inner self) ix
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module ListReversalLasso_Impl4_ListReversalLoop_Interface
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use seq.Reverse
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = usize
  clone ListReversalLasso_Impl4_Loop_Stub as Loop0
  val list_reversal_loop [#"../list_reversal_lasso.rs" 125 4 125 79] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 122 15 122 26] Seq.length (Ghost.inner s) > 0}
    requires {[#"../list_reversal_lasso.rs" 123 15 123 32] Loop0.loop_ ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 124 14 124 101] Loop0.loop_ ( ^ self) result (Seq.(++) (Seq.singleton (IndexLogic0.index_logic s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) }
    
end
module ListReversalLasso_Impl4_ListReversalLoop
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  use seq.Reverse
  use seq_ext.SeqExt
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed usize
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed usize,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic2 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic1 with
    function IndexLogic0.index_logic = IndexLogic2.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl4_Loop as Loop0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic1.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = usize
  clone ListReversalLasso_Null as Null0
  let rec cfg list_reversal_loop [#"../list_reversal_lasso.rs" 125 4 125 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 122 15 122 26] Seq.length (Ghost.inner s) > 0}
    requires {[#"../list_reversal_lasso.rs" 123 15 123 32] Loop0.loop_ ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 124 14 124 101] Loop0.loop_ ( ^ self) result (Seq.(++) (Seq.singleton (IndexLogic0.index_logic s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s : Ghost.ghost_ty (Seq.seq usize) = s;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _21 : usize;
  var _22 : borrowed usize;
  var _23 : borrowed usize;
  var _24 : borrowed usize;
  var _25 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _27 : usize;
  var _28 : borrowed usize;
  var _29 : borrowed usize;
  var _31 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 126 20 126 24] [#"../list_reversal_lasso.rs" 126 20 126 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 127 20 127 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 129 20 129 48] 0 <= Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s) + 1 };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n = Seq.length (Ghost.inner s) + 1 -> l = Null0.nULL' /\ r = IndexLogic0.index_logic s 0 /\ NonnullPtr0.nonnull_ptr ( * self) r /\ IndexLogic1.index_logic ( * self) r = IndexLogic0.index_logic s (Seq.length (Ghost.inner s) - 1) /\ ListSeg0.list_seg ( * self) (IndexLogic0.index_logic s (Seq.length (Ghost.inner s) - 1)) (Reverse.reverse (Ghost.inner s)) (IndexLogic0.index_logic s 0) 0 (Seq.length (Ghost.inner s) - 1) };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n <= Seq.length (Ghost.inner s) -> ListSeg0.list_seg ( * self) l (Ghost.inner s) (IndexLogic0.index_logic s 0) (Ghost.inner n) (Seq.length (Ghost.inner s)) };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n <= Seq.length (Ghost.inner s) -> ListSeg0.list_seg ( * self) r (Reverse.reverse (Ghost.inner s)) Null0.nULL' (Seq.length (Ghost.inner s) - Ghost.inner n) (Seq.length (Ghost.inner s)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 137 14 137 23] l <> ([#"../list_reversal_lasso.rs" 137 19 137 23] [#"../list_reversal_lasso.rs" 137 19 137 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 138 12 138 77] Ghost.inner n = Seq.length (Ghost.inner s) -> l = Seq.get (Reverse.reverse (Ghost.inner s)) (Seq.length (Ghost.inner s) - 1) };
    _25 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _25) };
    _24 <- ([#"../list_reversal_lasso.rs" 139 39 139 46] IndexMut0.index_mut _25 l);
    _25 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _23 <- Borrow.borrow_mut ( * _24);
    _24 <- { _24 with current = ( ^ _23) };
    _22 <- Borrow.borrow_mut ( * _23);
    _23 <- { _23 with current = ( ^ _22) };
    _29 <- Borrow.borrow_mut r;
    r <-  ^ _29;
    _28 <- Borrow.borrow_mut ( * _29);
    _29 <- { _29 with current = ( ^ _28) };
    _27 <- ([#"../list_reversal_lasso.rs" 139 48 139 76] Replace0.replace _28 l);
    _28 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { Resolve1.resolve _29 };
    _21 <- ([#"../list_reversal_lasso.rs" 139 16 139 77] Replace0.replace _22 _27);
    _22 <- any borrowed usize;
    _27 <- any usize;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve _24 };
    assume { Resolve1.resolve _23 };
    l <- _21;
    _21 <- any usize;
    _31 <- ([#"../list_reversal_lasso.rs" 140 16 140 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _31;
    _31 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { Resolve0.resolve self };
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 143 8 145 54] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner s) -> Seq.get (Seq.(++) (Seq.singleton (IndexLogic0.index_logic s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) i = (if i = 0 then
      IndexLogic0.index_logic s 0
    else
      Seq.get (Reverse.reverse (Ghost.inner s)) (i - 1)
    ) };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_Lasso_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate lasso [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Lasso_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate lasso [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
  val lasso [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso self first s1 s2 }
    
end
module ListReversalLasso_Impl4_Lasso
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  predicate lasso [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 152 8 158 9] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0 /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2 -> Seq.get s1 i <> Seq.get s2 j) /\ ListSeg0.list_seg self first s1 mid 0 (Seq.length s1) /\ ListSeg0.list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  val lasso [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso self first s1 s2 }
    
end
module ListReversalLasso_Impl4_ListReversalLasso_Interface
  use prelude.Borrow
  use prelude.Ghost
  use seq.Reverse
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  val list_reversal_lasso [#"../list_reversal_lasso.rs" 163 4 168 12] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s1 : Ghost.ghost_ty (Seq.seq usize)) (s2 : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 161 15 161 38] Lasso0.lasso ( * self) l (Ghost.inner s1) (Ghost.inner s2)}
    ensures { [#"../list_reversal_lasso.rs" 162 14 162 54] Lasso0.lasso ( ^ self) result (Ghost.inner s1) (Reverse.reverse (Ghost.inner s2)) }
    
end
module ListReversalLasso_Impl4_ListReversalLasso
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Borrow
  use seq.Reverse
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed usize
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed usize,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic2 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic1 with
    function IndexLogic0.index_logic = IndexLogic2.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic1.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone ListReversalLasso_Null as Null0
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = usize
  let rec cfg list_reversal_lasso [#"../list_reversal_lasso.rs" 163 4 168 12] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s1 : Ghost.ghost_ty (Seq.seq usize)) (s2 : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 161 15 161 38] Lasso0.lasso ( * self) l (Ghost.inner s1) (Ghost.inner s2)}
    ensures { [#"../list_reversal_lasso.rs" 162 14 162 54] Lasso0.lasso ( ^ self) result (Ghost.inner s1) (Reverse.reverse (Ghost.inner s2)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s1 : Ghost.ghost_ty (Seq.seq usize) = s1;
  var s2 : Ghost.ghost_ty (Seq.seq usize) = s2;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _19 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed usize;
  var _22 : borrowed usize;
  var _23 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _25 : usize;
  var _26 : borrowed usize;
  var _27 : borrowed usize;
  var _29 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 169 20 169 24] [#"../list_reversal_lasso.rs" 169 20 169 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 170 20 170 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 172 20 172 58] 0 <= Ghost.inner n /\ Ghost.inner n <= 2 * Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] let mid = if Seq.length (Ghost.inner s2) = 0 then
      IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)
    else
      IndexLogic0.index_logic s2 0
     in Ghost.inner n <= Seq.length (Ghost.inner s1) -> ListSeg0.list_seg ( * self) l (Ghost.inner s1) mid (Ghost.inner n) (Seq.length (Ghost.inner s1)) /\ ListSeg0.list_seg ( * self) mid (Ghost.inner s2) (IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)) 0 (Seq.length (Ghost.inner s2)) /\ ListSeg0.list_seg ( * self) r (Reverse.reverse (Ghost.inner s1)) Null0.nULL' (Seq.length (Ghost.inner s1) - Ghost.inner n) (Seq.length (Ghost.inner s1)) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] Seq.length (Ghost.inner s1) < Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) -> ListSeg0.list_seg ( * self) l (Ghost.inner s2) (IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)) (Ghost.inner n - Seq.length (Ghost.inner s1)) (Seq.length (Ghost.inner s2)) /\ ListSeg0.list_seg ( * self) r (Reverse.reverse (Ghost.inner s2)) (IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)) (Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) - Ghost.inner n) (Seq.length (Ghost.inner s2)) /\ ListSeg0.list_seg ( * self) (IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)) (Reverse.reverse (Ghost.inner s1)) Null0.nULL' 0 (Seq.length (Ghost.inner s1)) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] let mid = if Seq.length (Ghost.inner s2) = 0 then
      IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)
    else
      IndexLogic0.index_logic s2 (Seq.length (Ghost.inner s2) - 1)
     in Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) < Ghost.inner n -> ListSeg0.list_seg ( * self) l (Reverse.reverse (Ghost.inner s1)) Null0.nULL' (Ghost.inner n - Seq.length (Ghost.inner s1) - Seq.length (Ghost.inner s2)) (Seq.length (Ghost.inner s1)) /\ ListSeg0.list_seg ( * self) r (Ghost.inner s1) mid (2 * Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) - Ghost.inner n) (Seq.length (Ghost.inner s1)) /\ ListSeg0.list_seg ( * self) mid (Reverse.reverse (Ghost.inner s2)) (IndexLogic0.index_logic s1 (Seq.length (Ghost.inner s1) - 1)) 0 (Seq.length (Ghost.inner s2)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 190 14 190 23] l <> ([#"../list_reversal_lasso.rs" 190 19 190 23] [#"../list_reversal_lasso.rs" 190 19 190 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _23 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _23) };
    _22 <- ([#"../list_reversal_lasso.rs" 191 39 191 46] IndexMut0.index_mut _23 l);
    _23 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _21 <- Borrow.borrow_mut ( * _22);
    _22 <- { _22 with current = ( ^ _21) };
    _20 <- Borrow.borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    _27 <- Borrow.borrow_mut r;
    r <-  ^ _27;
    _26 <- Borrow.borrow_mut ( * _27);
    _27 <- { _27 with current = ( ^ _26) };
    _25 <- ([#"../list_reversal_lasso.rs" 191 48 191 76] Replace0.replace _26 l);
    _26 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { Resolve1.resolve _27 };
    _19 <- ([#"../list_reversal_lasso.rs" 191 16 191 77] Replace0.replace _20 _25);
    _20 <- any borrowed usize;
    _25 <- any usize;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve _22 };
    assume { Resolve1.resolve _21 };
    l <- _19;
    _19 <- any usize;
    _29 <- ([#"../list_reversal_lasso.rs" 192 16 192 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _29;
    _29 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { Resolve0.resolve self };
    _0 <- r;
    return _0
  }
  
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Stub
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Interface
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  val find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { [#"../list_reversal_lasso.rs" 199 14 202 5] match (result) with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end }
    ensures { result = find_ptr_in_seq s i p }
    
  axiom find_ptr_in_seq_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 199 14 202 5] match (find_ptr_in_seq s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
end
module ListReversalLasso_Impl4_FindPtrInSeq
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  val find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { [#"../list_reversal_lasso.rs" 199 14 202 5] match (result) with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end }
    ensures { result = find_ptr_in_seq s i p }
    
  axiom def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq s i p = ([#"../list_reversal_lasso.rs" 205 8 209 9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq s (i + 1) p
  )
  axiom find_ptr_in_seq_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 199 14 202 5] match (find_ptr_in_seq s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
end
module ListReversalLasso_Impl4_FindPtrInSeq_Impl
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec ghost function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { [#"../list_reversal_lasso.rs" 199 14 202 5] match (result) with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end }
    variant {[#"../list_reversal_lasso.rs" 203 14 203 25] Seq.length s - i}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 205 8 209 9] if pure {i = Seq.length s} then
      Core_Option_Option_Type.C_None
    else
      if pure {UIntSize.to_int (Seq.get s i) = p} then Core_Option_Option_Type.C_Some i else find_ptr_in_seq s (i + 1) p
    
end
module ListReversalLasso_Impl4_Pigeon_Stub
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
end
module ListReversalLasso_Impl4_Pigeon_Interface
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
  val pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { [#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n }
    ensures { [#"../list_reversal_lasso.rs" 217 14 217 20] result }
    ensures { result = pigeon s n }
    
  axiom pigeon_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 217 14 217 20] pigeon s n) && ([#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n)
end
module ListReversalLasso_Impl4_Pigeon
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq_Stub as FindPtrInSeq0 with
    axiom .
  function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
  val pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { [#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n }
    ensures { [#"../list_reversal_lasso.rs" 217 14 217 20] result }
    ensures { result = pigeon s n }
    
  axiom def : forall s : Seq.seq usize, n : int . pigeon s n = ([#"../list_reversal_lasso.rs" 220 8 232 9] if n = 0 then
    true
  else
    match (FindPtrInSeq0.find_ptr_in_seq s 0 (n - 1)) with
      | Core_Option_Option_Type.C_None -> pigeon s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match (FindPtrInSeq0.find_ptr_in_seq s (i + 1) (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  axiom pigeon_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 217 14 217 20] pigeon s n) && ([#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n)
end
module ListReversalLasso_Impl4_Pigeon_Impl
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  let rec ghost function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { [#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n }
    ensures { [#"../list_reversal_lasso.rs" 217 14 217 20] result }
    variant {[#"../list_reversal_lasso.rs" 218 14 218 15] n}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 220 8 232 9] if pure {n = 0} then
      true
    else
      match (FindPtrInSeq0.find_ptr_in_seq s 0 (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon s (n - 1)
        | Core_Option_Option_Type.C_Some i -> match (FindPtrInSeq0.find_ptr_in_seq s (i + 1) (n - 1)) with
          | Core_Option_Option_Type.C_None -> pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
          | Core_Option_Option_Type.C_Some _ -> true
          end
        end
    
end
module ListReversalLasso_Impl4_FindLassoAux_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
end
module ListReversalLasso_Impl4_FindLassoAux_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  val find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 236 15 236 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 237 15 237 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last}
    requires {[#"../list_reversal_lasso.rs" 238 15 238 56] ListSeg0.list_seg self first s last 0 (Seq.length s)}
    ensures { [#"../list_reversal_lasso.rs" 239 14 242 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    ensures { result = find_lasso_aux self first last s }
    
  axiom find_lasso_aux_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([#"../list_reversal_lasso.rs" 236 15 236 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 237 15 237 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last) -> ([#"../list_reversal_lasso.rs" 238 15 238 56] ListSeg0.list_seg self first s last 0 (Seq.length s)) -> ([#"../list_reversal_lasso.rs" 239 14 242 5] match (find_lasso_aux self first last s) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLassoAux
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq_Stub as FindPtrInSeq0 with
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl4_Pigeon_Stub as Pigeon0 with
    axiom .
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    axiom .
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  val find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 236 15 236 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 237 15 237 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last}
    requires {[#"../list_reversal_lasso.rs" 238 15 238 56] ListSeg0.list_seg self first s last 0 (Seq.length s)}
    ensures { [#"../list_reversal_lasso.rs" 239 14 242 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    ensures { result = find_lasso_aux self first last s }
    
  axiom def : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . find_lasso_aux self first last s = ([#"../list_reversal_lasso.rs" 245 8 259 9] if last = Null0.nULL' then
    (s, Core_Option_Option_Type.C_None)
  else
    match (FindPtrInSeq0.find_ptr_in_seq s 0 (UIntSize.to_int last)) with
      | Core_Option_Option_Type.C_None -> if Pigeon0.pigeon s (Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self))) then
        find_lasso_aux self first (IndexLogic0.index_logic self last) (Seq.snoc s last)
      else
        (s, Core_Option_Option_Type.C_None)
      
      | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
      end
  )
  axiom find_lasso_aux_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([#"../list_reversal_lasso.rs" 236 15 236 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 237 15 237 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last) -> ([#"../list_reversal_lasso.rs" 238 15 238 56] ListSeg0.list_seg self first s last 0 (Seq.length s)) -> ([#"../list_reversal_lasso.rs" 239 14 242 5] match (find_lasso_aux self first last s) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLassoAux_Impl
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq_ext.SeqExt
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl4_Pigeon as Pigeon0 with
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    axiom .
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  let rec ghost function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 236 15 236 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 237 15 237 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last}
    requires {[#"../list_reversal_lasso.rs" 238 15 238 56] ListSeg0.list_seg self first s last 0 (Seq.length s)}
    ensures { [#"../list_reversal_lasso.rs" 239 14 242 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    variant {[#"../list_reversal_lasso.rs" 243 4 243 39] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self)) - Seq.length s}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 245 8 259 9] if pure {last = Null0.nULL'} then
      (s, Core_Option_Option_Type.C_None)
    else
      match (FindPtrInSeq0.find_ptr_in_seq s 0 (UIntSize.to_int last)) with
        | Core_Option_Option_Type.C_None -> if let b' = let a' = ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self) in Seq.length a' in Pigeon0.pigeon s b' then
          let c' = IndexLogic0.index_logic self last in find_lasso_aux self first c' (Seq.snoc s last)
        else
          (s, Core_Option_Option_Type.C_None)
        
        | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
        end
    
end
module ListReversalLasso_Impl4_FindLasso_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
end
module ListReversalLasso_Impl4_FindLasso_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  val find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 264 15 264 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 265 15 265 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first}
    ensures { [#"../list_reversal_lasso.rs" 266 14 269 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    ensures { result = find_lasso self first }
    
  axiom find_lasso_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize . ([#"../list_reversal_lasso.rs" 264 15 264 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 265 15 265 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first) -> ([#"../list_reversal_lasso.rs" 266 14 269 5] match (find_lasso self first) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLasso
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  clone ListReversalLasso_Impl4_FindLassoAux_Stub as FindLassoAux0 with
    axiom .
  function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
   =
    [#"../list_reversal_lasso.rs" 272 13 272 65] FindLassoAux0.find_lasso_aux self first first (Seq.empty )
  val find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 264 15 264 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 265 15 265 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first}
    ensures { [#"../list_reversal_lasso.rs" 266 14 269 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    ensures { result = find_lasso self first }
    
  axiom find_lasso_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize . ([#"../list_reversal_lasso.rs" 264 15 264 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 265 15 265 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first) -> ([#"../list_reversal_lasso.rs" 266 14 269 5] match (find_lasso self first) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLasso_Impl
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Seq.seq usize
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Seq.seq usize,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl4_Pigeon as Pigeon0 with
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    axiom .
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  clone ListReversalLasso_Impl4_FindLassoAux as FindLassoAux0 with
    predicate MemIsWellFormed0.mem_is_well_formed = MemIsWellFormed0.mem_is_well_formed,
    val Null0.nULL' = Null0.nULL',
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    predicate ListSeg0.list_seg = ListSeg0.list_seg,
    predicate List0.list = List0.list,
    predicate Lasso0.lasso = Lasso0.lasso,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Pigeon0.pigeon = Pigeon0.pigeon,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    axiom .
  let rec ghost function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 264 15 264 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 265 15 265 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first}
    ensures { [#"../list_reversal_lasso.rs" 266 14 269 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 272 13 272 65] FindLassoAux0.find_lasso_aux self first first (Seq.empty )
end
module ListReversalLasso_Impl0
  
end
module ListReversalLasso_Impl1
  goal index_refn : [#"../list_reversal_lasso.rs" 30 4 30 35] true
end
module ListReversalLasso_Impl2
  goal index_mut_refn : [#"../list_reversal_lasso.rs" 41 4 41 47] true
end
