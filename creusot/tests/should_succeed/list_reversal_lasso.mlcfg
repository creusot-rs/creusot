
module ListReversalLasso_Null_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize
end
module ListReversalLasso_Null
  use prelude.Int
  use prelude.UIntSize
  let constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module ListReversalLasso_Memory_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_memory  =
    | C_Memory (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
    
  let function memory_0 (self : t_memory) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Memory a -> a
      end
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic_Stub
  type t
  type s
  use prelude.Int
  use prelude.UIntSize
  function index_logic [@inline:trivial] (self : s) (ix : usize) : t
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic_Interface
  type t
  type s
  use prelude.Int
  use prelude.UIntSize
  function index_logic [@inline:trivial] (self : s) (ix : usize) : t
end
module CreusotContracts_Logic_Ops_Impl1_IndexLogic
  type t
  type s
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = s,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function index_logic [@inline:trivial] (self : s) (ix : usize) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 26 8 26 32] Seq.get (ShallowModel0.shallow_model self) (UIntSize.to_int ix)
  val index_logic [@inline:trivial] (self : s) (ix : usize) : t
    ensures { result = index_logic self ix }
    
end
module ListReversalLasso_Impl0_IndexLogic_Stub
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 19 4 19 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
end
module ListReversalLasso_Impl0_IndexLogic_Interface
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 19 4 19 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
end
module ListReversalLasso_Impl0_IndexLogic
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic_Stub as IndexLogic0 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic [#"../list_reversal_lasso.rs" 19 4 19 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 20 8 20 31] IndexLogic0.index_logic (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic [#"../list_reversal_lasso.rs" 19 4 19 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic self i }
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../../creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../../creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module ListReversalLasso_Impl3_NonnullPtr_Stub
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 47 4 47 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
end
module ListReversalLasso_Impl3_NonnullPtr_Interface
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 47 4 47 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
end
module ListReversalLasso_Impl3_NonnullPtr
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate nonnull_ptr [#"../list_reversal_lasso.rs" 47 4 47 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 48 20 48 70] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int Max0.mAX' /\ UIntSize.to_int i < Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr [#"../list_reversal_lasso.rs" 47 4 47 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr self i }
    
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 38 8 38 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl13_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 127 27 127 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 128 26 128 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 102 20 102 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 108 20 108 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module ListReversalLasso_Impl1_Index_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  val index [#"../list_reversal_lasso.rs" 29 4 29 35] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 27 15 27 34] NonnullPtr0.nonnull_ptr self i}
    ensures { [#"../list_reversal_lasso.rs" 28 14 28 44] result = IndexLogic0.index_logic self i }
    
end
module ListReversalLasso_Impl1_Index
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg index [#"../list_reversal_lasso.rs" 29 4 29 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 27 15 27 34] NonnullPtr0.nonnull_ptr self i}
    ensures { [#"../list_reversal_lasso.rs" 28 14 28 44] result = IndexLogic0.index_logic self i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : ListReversalLasso_Memory_Type.t_memory;
  var i_2 : usize;
  var _5 : usize;
  var _6 : usize;
  var _7 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _8 : usize;
  {
    self_1 <- self;
    i_2 <- i;
    goto BB0
  }
  BB0 {
    _7 <- ListReversalLasso_Memory_Type.memory_0 self_1;
    _8 <- i_2;
    _6 <- ([#"../list_reversal_lasso.rs" 30 9 30 18] Index0.index _7 _8);
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _0 <- _5;
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 23 20 23 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 54 8 54 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl14_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 118 27 118 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 119 26 119 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 120 26 120 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 121 26 121 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 122 26 122 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 114 8 114 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module ListReversalLasso_Impl2_IndexMut_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  val index_mut [#"../list_reversal_lasso.rs" 40 4 40 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 35 15 35 34] NonnullPtr0.nonnull_ptr ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 36 14 36 47]  * result = IndexLogic0.index_logic ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  ^ result = IndexLogic0.index_logic ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 39 4 39 113] forall j : usize . NonnullPtr0.nonnull_ptr ( * self) j /\ i <> j -> IndexLogic0.index_logic ( ^ self) j = IndexLogic0.index_logic ( * self) j }
    
end
module ListReversalLasso_Impl2_IndexMut
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = usize,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg index_mut [#"../list_reversal_lasso.rs" 40 4 40 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 35 15 35 34] NonnullPtr0.nonnull_ptr ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 36 14 36 47]  * result = IndexLogic0.index_logic ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  ^ result = IndexLogic0.index_logic ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 39 4 39 113] forall j : usize . NonnullPtr0.nonnull_ptr ( * self) j /\ i <> j -> IndexLogic0.index_logic ( ^ self) j = IndexLogic0.index_logic ( * self) j }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed usize;
  var self_1 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var i_2 : usize;
  var _3 : borrowed usize;
  var _9 : borrowed usize;
  var _10 : borrowed usize;
  var _11 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _12 : usize;
  {
    self_1 <- self;
    i_2 <- i;
    goto BB0
  }
  BB0 {
    _11 <- borrow_mut (ListReversalLasso_Memory_Type.memory_0 ( * self_1));
    self_1 <- { self_1 with current = (let ListReversalLasso_Memory_Type.C_Memory a =  * self_1 in ListReversalLasso_Memory_Type.C_Memory ( ^ _11)) };
    _12 <- i_2;
    _10 <- ([#"../list_reversal_lasso.rs" 41 13 41 22] IndexMut0.index_mut _11 _12);
    goto BB1
  }
  BB1 {
    _9 <- borrow_mut ( * _10);
    _10 <- { _10 with current = ( ^ _9) };
    _3 <- borrow_mut ( * _9);
    _9 <- { _9 with current = ( ^ _3) };
    _0 <- borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve0.resolve _10 };
    assume { Resolve0.resolve _9 };
    assume { Resolve0.resolve _3 };
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module ListReversalLasso_Impl3_MemIsWellFormed_Stub
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 52 4 52 43] (self : ListReversalLasso_Memory_Type.t_memory)
end
module ListReversalLasso_Impl3_MemIsWellFormed_Interface
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 52 4 52 43] (self : ListReversalLasso_Memory_Type.t_memory)
end
module ListReversalLasso_Impl3_MemIsWellFormed
  use prelude.Int
  use prelude.UIntSize
  clone ListReversalLasso_Null_Stub as Null0
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  predicate mem_is_well_formed [#"../list_reversal_lasso.rs" 52 4 52 43] (self : ListReversalLasso_Memory_Type.t_memory)
   =
    [#"../list_reversal_lasso.rs" 53 8 55 9] forall i : usize . NonnullPtr0.nonnull_ptr self i -> IndexLogic0.index_logic self i = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self (IndexLogic0.index_logic self i)
  val mem_is_well_formed [#"../list_reversal_lasso.rs" 52 4 52 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed self }
    
end
module ListReversalLasso_Impl4_ListReversalSafe_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  val list_reversal_safe [#"../list_reversal_lasso.rs" 62 4 62 59] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 60 15 60 40] MemIsWellFormed0.mem_is_well_formed ( * self)}
    requires {[#"../list_reversal_lasso.rs" 61 15 61 47] l = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) l}
    
end
module ListReversalLasso_Impl4_ListReversalSafe
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl1_Index_Interface as Index0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  let rec cfg list_reversal_safe [#"../list_reversal_lasso.rs" 62 4 62 59] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 60 15 60 40] MemIsWellFormed0.mem_is_well_formed ( * self)}
    requires {[#"../list_reversal_lasso.rs" 61 15 61 47] l = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self) l}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var l_2 : usize;
  var _3 : ();
  var r_6 : usize;
  var _7 : ();
  var _11 : ();
  var _12 : bool;
  var _13 : usize;
  var tmp_14 : usize;
  var _15 : usize;
  var _16 : usize;
  var _17 : ListReversalLasso_Memory_Type.t_memory;
  var _18 : usize;
  var _19 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _22 : usize;
  var _23 : usize;
  var _24 : ();
  var _25 : ();
  var _26 : ();
  {
    self_1 <- self;
    l_2 <- l;
    goto BB0
  }
  BB0 {
    r_6 <- ([#"../list_reversal_lasso.rs" 63 20 63 24] (18446744073709551615 : usize));
    goto BB1
  }
  BB1 {
    invariant { [#"../list_reversal_lasso.rs" 65 20 65 52] r_6 = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self_1) r_6 };
    invariant { [#"../list_reversal_lasso.rs" 66 20 66 52] l_2 = Null0.nULL' \/ NonnullPtr0.nonnull_ptr ( * self_1) l_2 };
    invariant { [#"../list_reversal_lasso.rs" 67 20 67 45] MemIsWellFormed0.mem_is_well_formed ( * self_1) };
    goto BB2
  }
  BB2 {
    _13 <- l_2;
    _12 <- ([#"../list_reversal_lasso.rs" 68 14 68 23] _13 <> ([#"../list_reversal_lasso.rs" 68 19 68 23] (18446744073709551615 : usize)));
    switch (_12)
      | False -> goto BB6
      | True -> goto BB3
      end
  }
  BB3 {
    tmp_14 <- l_2;
    _17 <-  * self_1;
    _18 <- l_2;
    _16 <- ([#"../list_reversal_lasso.rs" 70 16 70 23] Index0.index _17 _18);
    goto BB4
  }
  BB4 {
    _15 <- _16;
    l_2 <- _15;
    _15 <- any usize;
    _19 <- r_6;
    _21 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _21) };
    _22 <- tmp_14;
    _20 <- ([#"../list_reversal_lasso.rs" 71 12 71 21] IndexMut0.index_mut _21 _22);
    goto BB5
  }
  BB5 {
    _20 <- { _20 with current = _19 };
    _19 <- any usize;
    assume { Resolve0.resolve _20 };
    _23 <- tmp_14;
    r_6 <- _23;
    _23 <- any usize;
    _11 <- ();
    goto BB1
  }
  BB6 {
    assume { Resolve1.resolve self_1 };
    _7 <- ();
    _0 <- r_6;
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListSeg_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list_seg [#"../list_reversal_lasso.rs" 78 4 78 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
end
module ListReversalLasso_Impl4_ListSeg_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list_seg [#"../list_reversal_lasso.rs" 78 4 78 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
end
module ListReversalLasso_Impl4_ListSeg
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  predicate list_seg [#"../list_reversal_lasso.rs" 78 4 78 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 80 12 82 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> NonnullPtr0.nonnull_ptr self (Seq.get s i) /\ IndexLogic0.index_logic self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg [#"../list_reversal_lasso.rs" 78 4 78 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg self first s last l h }
    
end
module ListReversalLasso_Impl4_List_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list [#"../list_reversal_lasso.rs" 87 4 87 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_List_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate list [#"../list_reversal_lasso.rs" 87 4 87 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_List
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Null_Stub as Null0
  predicate list [#"../list_reversal_lasso.rs" 87 4 87 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 89 12 89 53] ListSeg0.list_seg self first s Null0.nULL' 0 (Seq.length s)
  val list [#"../list_reversal_lasso.rs" 87 4 87 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list self first s }
    
end
module Core_Mem_Replace_Interface
  type t
  use prelude.Borrow
  val replace (dest : borrowed t) (src : t) : t
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    
end
module ListReversalLasso_Impl4_ListReversalList_Interface
  use prelude.Borrow
  use prelude.Ghost
  use seq.Reverse
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_List_Stub as List0
  val list_reversal_list [#"../list_reversal_lasso.rs" 95 4 95 79] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 93 15 93 31] List0.list ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 94 14 94 47] List0.list ( ^ self) result (Reverse.reverse (Ghost.inner s)) }
    
end
module ListReversalLasso_Impl4_ListReversalList
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use seq.Reverse
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  let rec cfg list_reversal_list [#"../list_reversal_lasso.rs" 95 4 95 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 93 15 93 31] List0.list ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 94 14 94 47] List0.list ( ^ self) result (Reverse.reverse (Ghost.inner s)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var l_2 : usize;
  var s_3 : Ghost.ghost_ty (Seq.seq usize);
  var _4 : ();
  var r_7 : usize;
  var n_8 : Ghost.ghost_ty int;
  var _11 : ();
  var _12 : ();
  var _16 : ();
  var _17 : bool;
  var _18 : usize;
  var _19 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed usize;
  var _22 : borrowed usize;
  var _23 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _24 : usize;
  var _25 : usize;
  var _26 : borrowed usize;
  var _27 : borrowed usize;
  var _28 : usize;
  var _29 : Ghost.ghost_ty int;
  var _32 : ();
  var _33 : ();
  var _34 : ();
  var _35 : ();
  {
    self_1 <- self;
    l_2 <- l;
    s_3 <- s;
    goto BB0
  }
  BB0 {
    r_7 <- ([#"../list_reversal_lasso.rs" 96 20 96 24] (18446744073709551615 : usize));
    _11 <- ();
    n_8 <- ([#"../list_reversal_lasso.rs" 97 20 97 46] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 99 20 99 44] 0 <= Ghost.inner n_8 /\ Ghost.inner n_8 <= Seq.length (Ghost.inner s_3) };
    invariant { [#"../list_reversal_lasso.rs" 100 20 100 59] ListSeg0.list_seg ( * self_1) l_2 (Ghost.inner s_3) Null0.nULL' (Ghost.inner n_8) (Seq.length (Ghost.inner s_3)) };
    invariant { [#"../list_reversal_lasso.rs" 101 20 101 76] ListSeg0.list_seg ( * self_1) r_7 (Reverse.reverse (Ghost.inner s_3)) Null0.nULL' (Seq.length (Ghost.inner s_3) - Ghost.inner n_8) (Seq.length (Ghost.inner s_3)) };
    goto BB3
  }
  BB3 {
    _18 <- l_2;
    _17 <- ([#"../list_reversal_lasso.rs" 103 14 103 23] _18 <> ([#"../list_reversal_lasso.rs" 103 19 103 23] (18446744073709551615 : usize)));
    switch (_17)
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _23 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _23) };
    _24 <- l_2;
    _22 <- ([#"../list_reversal_lasso.rs" 104 39 104 46] IndexMut0.index_mut _23 _24);
    goto BB5
  }
  BB5 {
    _21 <- borrow_mut ( * _22);
    _22 <- { _22 with current = ( ^ _21) };
    _20 <- borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    _27 <- borrow_mut r_7;
    r_7 <-  ^ _27;
    _26 <- borrow_mut ( * _27);
    _27 <- { _27 with current = ( ^ _26) };
    _28 <- l_2;
    _25 <- ([#"../list_reversal_lasso.rs" 104 48 104 76] Replace0.replace _26 _28);
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve _27 };
    _19 <- ([#"../list_reversal_lasso.rs" 104 16 104 77] Replace0.replace _20 _25);
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve _21 };
    assume { Resolve0.resolve _22 };
    l_2 <- _19;
    _19 <- any usize;
    _32 <- ();
    _29 <- ([#"../list_reversal_lasso.rs" 105 16 105 47] Ghost.new (Ghost.inner n_8 + 1));
    goto BB8
  }
  BB8 {
    n_8 <- _29;
    _29 <- any Ghost.ghost_ty int;
    _16 <- ();
    goto BB2
  }
  BB9 {
    assume { Resolve1.resolve self_1 };
    _12 <- ();
    _0 <- r_7;
    return _0
  }
  
end
module ListReversalLasso_Impl4_Loop_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate loop_ [#"../list_reversal_lasso.rs" 111 4 111 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Loop_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate loop_ [#"../list_reversal_lasso.rs" 111 4 111 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Loop
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  predicate loop_ [#"../list_reversal_lasso.rs" 111 4 111 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 113 12 113 53] ListSeg0.list_seg self first s (Seq.get s 0) 0 (Seq.length s)
  val loop_ [#"../list_reversal_lasso.rs" 111 4 111 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = loop_ self first s }
    
end
module ListReversalLasso_Impl4_ListReversalLoop_Interface
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use seq.Reverse
  use prelude.UIntSize
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Loop_Stub as Loop0
  val list_reversal_loop [#"../list_reversal_lasso.rs" 120 4 120 79] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 117 15 117 26] Seq.length (Ghost.inner s) > 0}
    requires {[#"../list_reversal_lasso.rs" 118 15 118 32] Loop0.loop_ ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 119 14 119 101] Loop0.loop_ ( ^ self) result (Seq.(++) (Seq.singleton (Seq.get s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) }
    
end
module ListReversalLasso_Impl4_ListReversalLoop
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use seq_ext.SeqExt
  use seq.Reverse
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_Loop as Loop0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  let rec cfg list_reversal_loop [#"../list_reversal_lasso.rs" 120 4 120 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 117 15 117 26] Seq.length (Ghost.inner s) > 0}
    requires {[#"../list_reversal_lasso.rs" 118 15 118 32] Loop0.loop_ ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 119 14 119 101] Loop0.loop_ ( ^ self) result (Seq.(++) (Seq.singleton (Seq.get s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var l_2 : usize;
  var s_3 : Ghost.ghost_ty (Seq.seq usize);
  var _4 : ();
  var r_8 : usize;
  var n_9 : Ghost.ghost_ty int;
  var _12 : ();
  var _13 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : ();
  var _23 : usize;
  var _24 : borrowed usize;
  var _25 : borrowed usize;
  var _26 : borrowed usize;
  var _27 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _28 : usize;
  var _29 : usize;
  var _30 : borrowed usize;
  var _31 : borrowed usize;
  var _32 : usize;
  var _33 : Ghost.ghost_ty int;
  var _36 : ();
  var _37 : ();
  var _38 : ();
  var _39 : ();
  var _40 : ();
  {
    self_1 <- self;
    l_2 <- l;
    s_3 <- s;
    goto BB0
  }
  BB0 {
    r_8 <- ([#"../list_reversal_lasso.rs" 121 20 121 24] (18446744073709551615 : usize));
    _12 <- ();
    n_9 <- ([#"../list_reversal_lasso.rs" 122 20 122 46] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 124 20 124 48] 0 <= Ghost.inner n_9 /\ Ghost.inner n_9 <= Seq.length (Ghost.inner s_3) + 1 };
    invariant { [#"../list_reversal_lasso.rs" 124 8 124 50] Ghost.inner n_9 = Seq.length (Ghost.inner s_3) + 1 -> l_2 = Null0.nULL' /\ r_8 = Seq.get s_3 0 /\ NonnullPtr0.nonnull_ptr ( * self_1) r_8 /\ IndexLogic0.index_logic ( * self_1) r_8 = Seq.get s_3 (Seq.length (Ghost.inner s_3) - 1) /\ ListSeg0.list_seg ( * self_1) (Seq.get s_3 (Seq.length (Ghost.inner s_3) - 1)) (Reverse.reverse (Ghost.inner s_3)) (Seq.get s_3 0) 0 (Seq.length (Ghost.inner s_3) - 1) };
    invariant { [#"../list_reversal_lasso.rs" 124 8 124 50] Ghost.inner n_9 <= Seq.length (Ghost.inner s_3) -> ListSeg0.list_seg ( * self_1) l_2 (Ghost.inner s_3) (Seq.get s_3 0) (Ghost.inner n_9) (Seq.length (Ghost.inner s_3)) };
    invariant { [#"../list_reversal_lasso.rs" 124 8 124 50] Ghost.inner n_9 <= Seq.length (Ghost.inner s_3) -> ListSeg0.list_seg ( * self_1) r_8 (Reverse.reverse (Ghost.inner s_3)) Null0.nULL' (Seq.length (Ghost.inner s_3) - Ghost.inner n_9) (Seq.length (Ghost.inner s_3)) };
    goto BB3
  }
  BB3 {
    _20 <- l_2;
    _19 <- ([#"../list_reversal_lasso.rs" 132 14 132 23] _20 <> ([#"../list_reversal_lasso.rs" 132 19 132 23] (18446744073709551615 : usize)));
    switch (_19)
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 133 12 133 77] Ghost.inner n_9 = Seq.length (Ghost.inner s_3) -> l_2 = Seq.get (Reverse.reverse (Ghost.inner s_3)) (Seq.length (Ghost.inner s_3) - 1) };
    _21 <- ();
    _27 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _27) };
    _28 <- l_2;
    _26 <- ([#"../list_reversal_lasso.rs" 134 39 134 46] IndexMut0.index_mut _27 _28);
    goto BB5
  }
  BB5 {
    _25 <- borrow_mut ( * _26);
    _26 <- { _26 with current = ( ^ _25) };
    _24 <- borrow_mut ( * _25);
    _25 <- { _25 with current = ( ^ _24) };
    _31 <- borrow_mut r_8;
    r_8 <-  ^ _31;
    _30 <- borrow_mut ( * _31);
    _31 <- { _31 with current = ( ^ _30) };
    _32 <- l_2;
    _29 <- ([#"../list_reversal_lasso.rs" 134 48 134 76] Replace0.replace _30 _32);
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve _31 };
    _23 <- ([#"../list_reversal_lasso.rs" 134 16 134 77] Replace0.replace _24 _29);
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve _25 };
    assume { Resolve0.resolve _26 };
    l_2 <- _23;
    _23 <- any usize;
    _36 <- ();
    _33 <- ([#"../list_reversal_lasso.rs" 135 16 135 47] Ghost.new (Ghost.inner n_9 + 1));
    goto BB8
  }
  BB8 {
    n_9 <- _33;
    _33 <- any Ghost.ghost_ty int;
    _18 <- ();
    goto BB2
  }
  BB9 {
    assume { Resolve1.resolve self_1 };
    _13 <- ();
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 138 8 140 54] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner s_3) -> Seq.get (Seq.(++) (Seq.singleton (Seq.get s_3 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s_3) 1 (Seq.length (Ghost.inner s_3))))) i = (if i = 0 then
      Seq.get s_3 0
    else
      Seq.get (Reverse.reverse (Ghost.inner s_3)) (i - 1)
    ) };
    _40 <- ();
    _0 <- r_8;
    return _0
  }
  
end
module ListReversalLasso_Impl4_Lasso_Stub
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate lasso [#"../list_reversal_lasso.rs" 145 4 145 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Lasso_Interface
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  predicate lasso [#"../list_reversal_lasso.rs" 145 4 145 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
end
module ListReversalLasso_Impl4_Lasso
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  predicate lasso [#"../list_reversal_lasso.rs" 145 4 145 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 146 8 152 9] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0 /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2 -> Seq.get s1 i <> Seq.get s2 j) /\ ListSeg0.list_seg self first s1 mid 0 (Seq.length s1) /\ ListSeg0.list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  val lasso [#"../list_reversal_lasso.rs" 145 4 145 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso self first s1 s2 }
    
end
module ListReversalLasso_Impl4_ListReversalLasso_Interface
  use prelude.Borrow
  use prelude.Ghost
  use seq.Reverse
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  val list_reversal_lasso [#"../list_reversal_lasso.rs" 157 4 162 12] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s1 : Ghost.ghost_ty (Seq.seq usize)) (s2 : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 155 15 155 38] Lasso0.lasso ( * self) l (Ghost.inner s1) (Ghost.inner s2)}
    ensures { [#"../list_reversal_lasso.rs" 156 14 156 54] Lasso0.lasso ( ^ self) result (Ghost.inner s1) (Reverse.reverse (Ghost.inner s2)) }
    
end
module ListReversalLasso_Impl4_ListReversalLasso
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use seq.Reverse
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = ListReversalLasso_Memory_Type.t_memory
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = usize
  clone ListReversalLasso_Impl2_IndexMut_Interface as IndexMut0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  let rec cfg list_reversal_lasso [#"../list_reversal_lasso.rs" 157 4 162 12] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s1 : Ghost.ghost_ty (Seq.seq usize)) (s2 : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 155 15 155 38] Lasso0.lasso ( * self) l (Ghost.inner s1) (Ghost.inner s2)}
    ensures { [#"../list_reversal_lasso.rs" 156 14 156 54] Lasso0.lasso ( ^ self) result (Ghost.inner s1) (Reverse.reverse (Ghost.inner s2)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var l_2 : usize;
  var s1_3 : Ghost.ghost_ty (Seq.seq usize);
  var s2_4 : Ghost.ghost_ty (Seq.seq usize);
  var _5 : ();
  var r_8 : usize;
  var n_9 : Ghost.ghost_ty int;
  var _12 : ();
  var _13 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : usize;
  var _22 : borrowed usize;
  var _23 : borrowed usize;
  var _24 : borrowed usize;
  var _25 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _26 : usize;
  var _27 : usize;
  var _28 : borrowed usize;
  var _29 : borrowed usize;
  var _30 : usize;
  var _31 : Ghost.ghost_ty int;
  var _34 : ();
  var _35 : ();
  var _36 : ();
  var _37 : ();
  {
    self_1 <- self;
    l_2 <- l;
    s1_3 <- s1;
    s2_4 <- s2;
    goto BB0
  }
  BB0 {
    r_8 <- ([#"../list_reversal_lasso.rs" 163 20 163 24] (18446744073709551615 : usize));
    _12 <- ();
    n_9 <- ([#"../list_reversal_lasso.rs" 164 20 164 46] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 166 20 166 58] 0 <= Ghost.inner n_9 /\ Ghost.inner n_9 <= 2 * Seq.length (Ghost.inner s1_3) + Seq.length (Ghost.inner s2_4) };
    invariant { [#"../list_reversal_lasso.rs" 166 8 166 60] let mid = if Seq.length (Ghost.inner s2_4) = 0 then
      Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)
    else
      Seq.get s2_4 0
     in Ghost.inner n_9 <= Seq.length (Ghost.inner s1_3) -> ListSeg0.list_seg ( * self_1) l_2 (Ghost.inner s1_3) mid (Ghost.inner n_9) (Seq.length (Ghost.inner s1_3)) /\ ListSeg0.list_seg ( * self_1) mid (Ghost.inner s2_4) (Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)) 0 (Seq.length (Ghost.inner s2_4)) /\ ListSeg0.list_seg ( * self_1) r_8 (Reverse.reverse (Ghost.inner s1_3)) Null0.nULL' (Seq.length (Ghost.inner s1_3) - Ghost.inner n_9) (Seq.length (Ghost.inner s1_3)) };
    invariant { [#"../list_reversal_lasso.rs" 166 8 166 60] Seq.length (Ghost.inner s1_3) < Ghost.inner n_9 /\ Ghost.inner n_9 <= Seq.length (Ghost.inner s1_3) + Seq.length (Ghost.inner s2_4) -> ListSeg0.list_seg ( * self_1) l_2 (Ghost.inner s2_4) (Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)) (Ghost.inner n_9 - Seq.length (Ghost.inner s1_3)) (Seq.length (Ghost.inner s2_4)) /\ ListSeg0.list_seg ( * self_1) r_8 (Reverse.reverse (Ghost.inner s2_4)) (Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)) (Seq.length (Ghost.inner s1_3) + Seq.length (Ghost.inner s2_4) - Ghost.inner n_9) (Seq.length (Ghost.inner s2_4)) /\ ListSeg0.list_seg ( * self_1) (Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)) (Reverse.reverse (Ghost.inner s1_3)) Null0.nULL' 0 (Seq.length (Ghost.inner s1_3)) };
    invariant { [#"../list_reversal_lasso.rs" 166 8 166 60] let mid = if Seq.length (Ghost.inner s2_4) = 0 then
      Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)
    else
      Seq.get s2_4 (Seq.length (Ghost.inner s2_4) - 1)
     in Seq.length (Ghost.inner s1_3) + Seq.length (Ghost.inner s2_4) < Ghost.inner n_9 -> ListSeg0.list_seg ( * self_1) l_2 (Reverse.reverse (Ghost.inner s1_3)) Null0.nULL' (Ghost.inner n_9 - Seq.length (Ghost.inner s1_3) - Seq.length (Ghost.inner s2_4)) (Seq.length (Ghost.inner s1_3)) /\ ListSeg0.list_seg ( * self_1) r_8 (Ghost.inner s1_3) mid (2 * Seq.length (Ghost.inner s1_3) + Seq.length (Ghost.inner s2_4) - Ghost.inner n_9) (Seq.length (Ghost.inner s1_3)) /\ ListSeg0.list_seg ( * self_1) mid (Reverse.reverse (Ghost.inner s2_4)) (Seq.get s1_3 (Seq.length (Ghost.inner s1_3) - 1)) 0 (Seq.length (Ghost.inner s2_4)) };
    goto BB3
  }
  BB3 {
    _20 <- l_2;
    _19 <- ([#"../list_reversal_lasso.rs" 184 14 184 23] _20 <> ([#"../list_reversal_lasso.rs" 184 19 184 23] (18446744073709551615 : usize)));
    switch (_19)
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _25 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _25) };
    _26 <- l_2;
    _24 <- ([#"../list_reversal_lasso.rs" 185 39 185 46] IndexMut0.index_mut _25 _26);
    goto BB5
  }
  BB5 {
    _23 <- borrow_mut ( * _24);
    _24 <- { _24 with current = ( ^ _23) };
    _22 <- borrow_mut ( * _23);
    _23 <- { _23 with current = ( ^ _22) };
    _29 <- borrow_mut r_8;
    r_8 <-  ^ _29;
    _28 <- borrow_mut ( * _29);
    _29 <- { _29 with current = ( ^ _28) };
    _30 <- l_2;
    _27 <- ([#"../list_reversal_lasso.rs" 185 48 185 76] Replace0.replace _28 _30);
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve _29 };
    _21 <- ([#"../list_reversal_lasso.rs" 185 16 185 77] Replace0.replace _22 _27);
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve _23 };
    assume { Resolve0.resolve _24 };
    l_2 <- _21;
    _21 <- any usize;
    _34 <- ();
    _31 <- ([#"../list_reversal_lasso.rs" 186 16 186 47] Ghost.new (Ghost.inner n_9 + 1));
    goto BB8
  }
  BB8 {
    n_9 <- _31;
    _31 <- any Ghost.ghost_ty int;
    _18 <- ();
    goto BB2
  }
  BB9 {
    assume { Resolve1.resolve self_1 };
    _13 <- ();
    _0 <- r_8;
    return _0
  }
  
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Stub
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 198 4 198 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Interface
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 198 4 198 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 192 15 192 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 193 14 196 5] match (find_ptr_in_seq s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
end
module ListReversalLasso_Impl4_FindPtrInSeq
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq [#"../list_reversal_lasso.rs" 198 4 198 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  val find_ptr_in_seq [#"../list_reversal_lasso.rs" 198 4 198 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 192 15 192 37] 0 <= i /\ i <= Seq.length s}
    ensures { result = find_ptr_in_seq s i p }
    
  axiom def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq s i p = ([#"../list_reversal_lasso.rs" 199 8 203 9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq s (i + 1) p
  )
  axiom find_ptr_in_seq_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 192 15 192 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 193 14 196 5] match (find_ptr_in_seq s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
end
module ListReversalLasso_Impl4_FindPtrInSeq_Impl
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec ghost function find_ptr_in_seq [#"../list_reversal_lasso.rs" 198 4 198 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 192 15 192 37] 0 <= i /\ i <= Seq.length s}
    ensures { [#"../list_reversal_lasso.rs" 193 14 196 5] match (result) with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end }
    variant {[#"../list_reversal_lasso.rs" 197 14 197 25] Seq.length s - i}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 199 8 203 9] if pure {i = Seq.length s} then
      Core_Option_Option_Type.C_None
    else
      if pure {UIntSize.to_int (Seq.get s i) = p} then Core_Option_Option_Type.C_Some i else find_ptr_in_seq s (i + 1) p
    
end
module ListReversalLasso_Impl4_Pigeon_Stub
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  function pigeon [#"../list_reversal_lasso.rs" 213 4 213 42] (s : Seq.seq usize) (n : int) : bool
end
module ListReversalLasso_Impl4_Pigeon_Interface
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  function pigeon [#"../list_reversal_lasso.rs" 213 4 213 42] (s : Seq.seq usize) (n : int) : bool
  axiom pigeon_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 207 15 207 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 208 4 208 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 209 4 209 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 211 14 211 20] pigeon s n) && ([#"../list_reversal_lasso.rs" 210 14 210 26] Seq.length s <= n)
end
module ListReversalLasso_Impl4_Pigeon
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq_Stub as FindPtrInSeq0 with
    axiom .
  function pigeon [#"../list_reversal_lasso.rs" 213 4 213 42] (s : Seq.seq usize) (n : int) : bool
  val pigeon [#"../list_reversal_lasso.rs" 213 4 213 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 207 15 207 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 208 4 208 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 209 4 209 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { result = pigeon s n }
    
  axiom def : forall s : Seq.seq usize, n : int . pigeon s n = ([#"../list_reversal_lasso.rs" 214 8 226 9] if n = 0 then
    true
  else
    match (FindPtrInSeq0.find_ptr_in_seq s 0 (n - 1)) with
      | Core_Option_Option_Type.C_None -> pigeon s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match (FindPtrInSeq0.find_ptr_in_seq s (i + 1) (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  axiom pigeon_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 207 15 207 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 208 4 208 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 209 4 209 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 211 14 211 20] pigeon s n) && ([#"../list_reversal_lasso.rs" 210 14 210 26] Seq.length s <= n)
end
module ListReversalLasso_Impl4_Pigeon_Impl
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  let rec ghost function pigeon [#"../list_reversal_lasso.rs" 213 4 213 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 207 15 207 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 208 4 208 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 209 4 209 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { [#"../list_reversal_lasso.rs" 210 14 210 26] Seq.length s <= n }
    ensures { [#"../list_reversal_lasso.rs" 211 14 211 20] result }
    variant {[#"../list_reversal_lasso.rs" 212 14 212 15] n}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 214 8 226 9] if pure {n = 0} then
      true
    else
      match (FindPtrInSeq0.find_ptr_in_seq s 0 (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon s (n - 1)
        | Core_Option_Option_Type.C_Some i -> match (FindPtrInSeq0.find_ptr_in_seq s (i + 1) (n - 1)) with
          | Core_Option_Option_Type.C_None -> pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
          | Core_Option_Option_Type.C_Some _ -> true
          end
        end
    
end
module ListReversalLasso_Impl4_FindLassoAux_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 238 4 238 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
end
module ListReversalLasso_Impl4_FindLassoAux_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 238 4 238 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  axiom find_lasso_aux_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([#"../list_reversal_lasso.rs" 230 15 230 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 231 15 231 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last) -> ([#"../list_reversal_lasso.rs" 232 15 232 56] ListSeg0.list_seg self first s last 0 (Seq.length s)) -> ([#"../list_reversal_lasso.rs" 233 14 236 5] match (find_lasso_aux self first last s) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLassoAux
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq_ext.SeqExt
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq_Stub as FindPtrInSeq0 with
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic_Stub as IndexLogic0
  clone ListReversalLasso_Impl4_Pigeon_Stub as Pigeon0 with
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso_aux [#"../list_reversal_lasso.rs" 238 4 238 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  val find_lasso_aux [#"../list_reversal_lasso.rs" 238 4 238 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 230 15 230 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 231 15 231 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last}
    requires {[#"../list_reversal_lasso.rs" 232 15 232 56] ListSeg0.list_seg self first s last 0 (Seq.length s)}
    ensures { result = find_lasso_aux self first last s }
    
  axiom def : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . find_lasso_aux self first last s = ([#"../list_reversal_lasso.rs" 239 8 253 9] if last = Null0.nULL' then
    (s, Core_Option_Option_Type.C_None)
  else
    match (FindPtrInSeq0.find_ptr_in_seq s 0 (UIntSize.to_int last)) with
      | Core_Option_Option_Type.C_None -> if Pigeon0.pigeon s (Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self))) then
        find_lasso_aux self first (IndexLogic0.index_logic self last) (Seq.snoc s last)
      else
        (s, Core_Option_Option_Type.C_None)
      
      | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
      end
  )
  axiom find_lasso_aux_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([#"../list_reversal_lasso.rs" 230 15 230 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 231 15 231 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last) -> ([#"../list_reversal_lasso.rs" 232 15 232 56] ListSeg0.list_seg self first s last 0 (Seq.length s)) -> ([#"../list_reversal_lasso.rs" 233 14 236 5] match (find_lasso_aux self first last s) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLassoAux_Impl
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq_ext.SeqExt
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl4_Pigeon as Pigeon0 with
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    axiom .
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  let rec ghost function find_lasso_aux [#"../list_reversal_lasso.rs" 238 4 238 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 230 15 230 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 231 15 231 53] last = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self last}
    requires {[#"../list_reversal_lasso.rs" 232 15 232 56] ListSeg0.list_seg self first s last 0 (Seq.length s)}
    ensures { [#"../list_reversal_lasso.rs" 233 14 236 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    variant {[#"../list_reversal_lasso.rs" 237 4 237 39] Seq.length (ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self)) - Seq.length s}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 239 8 253 9] if pure {last = Null0.nULL'} then
      (s, Core_Option_Option_Type.C_None)
    else
      match (FindPtrInSeq0.find_ptr_in_seq s 0 (UIntSize.to_int last)) with
        | Core_Option_Option_Type.C_None -> if let b' = let a' = ShallowModel0.shallow_model (ListReversalLasso_Memory_Type.memory_0 self) in Seq.length a' in Pigeon0.pigeon s b' then
          let c' = IndexLogic0.index_logic self last in find_lasso_aux self first c' (Seq.snoc s last)
        else
          (s, Core_Option_Option_Type.C_None)
        
        | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
        end
    
end
module ListReversalLasso_Impl4_FindLasso_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso [#"../list_reversal_lasso.rs" 263 4 263 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
end
module ListReversalLasso_Impl4_FindLasso_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  function find_lasso [#"../list_reversal_lasso.rs" 263 4 263 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  axiom find_lasso_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize . ([#"../list_reversal_lasso.rs" 257 15 257 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 258 15 258 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first) -> ([#"../list_reversal_lasso.rs" 259 14 262 5] match (find_lasso self first) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLasso
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl4_ListSeg_Stub as ListSeg0
  use seq.Seq
  clone ListReversalLasso_Impl4_Lasso_Stub as Lasso0
  clone ListReversalLasso_Impl4_List_Stub as List0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl3_NonnullPtr_Stub as NonnullPtr0
  clone ListReversalLasso_Null_Stub as Null0
  clone ListReversalLasso_Impl3_MemIsWellFormed_Stub as MemIsWellFormed0
  clone ListReversalLasso_Impl4_FindLassoAux_Stub as FindLassoAux0 with
    predicate MemIsWellFormed0.mem_is_well_formed = MemIsWellFormed0.mem_is_well_formed,
    val Null0.nULL' = Null0.nULL',
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    predicate ListSeg0.list_seg = ListSeg0.list_seg,
    predicate List0.list = List0.list,
    predicate Lasso0.lasso = Lasso0.lasso,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  function find_lasso [#"../list_reversal_lasso.rs" 263 4 263 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
   =
    [#"../list_reversal_lasso.rs" 265 13 265 65] FindLassoAux0.find_lasso_aux self first first (Seq.empty )
  val find_lasso [#"../list_reversal_lasso.rs" 263 4 263 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 257 15 257 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 258 15 258 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first}
    ensures { result = find_lasso self first }
    
  axiom find_lasso_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize . ([#"../list_reversal_lasso.rs" 257 15 257 40] MemIsWellFormed0.mem_is_well_formed self) -> ([#"../list_reversal_lasso.rs" 258 15 258 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first) -> ([#"../list_reversal_lasso.rs" 259 14 262 5] match (find_lasso self first) with
    | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
    end)
end
module ListReversalLasso_Impl4_FindLasso_Impl
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl1_IndexLogic as IndexLogic1 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone ListReversalLasso_Impl4_FindPtrInSeq as FindPtrInSeq0 with
    axiom .
  clone ListReversalLasso_Impl4_Pigeon as Pigeon0 with
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    axiom .
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  clone ListReversalLasso_Impl0_IndexLogic as IndexLogic0 with
    function IndexLogic0.index_logic = IndexLogic1.index_logic
  clone ListReversalLasso_Impl3_NonnullPtr as NonnullPtr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone ListReversalLasso_Impl4_ListSeg as ListSeg0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone ListReversalLasso_Impl4_Lasso as Lasso0 with
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Null as Null0
  clone ListReversalLasso_Impl4_List as List0 with
    val Null0.nULL' = Null0.nULL',
    predicate ListSeg0.list_seg = ListSeg0.list_seg
  clone ListReversalLasso_Impl3_MemIsWellFormed as MemIsWellFormed0 with
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Null0.nULL' = Null0.nULL'
  clone ListReversalLasso_Impl4_FindLassoAux as FindLassoAux0 with
    predicate MemIsWellFormed0.mem_is_well_formed = MemIsWellFormed0.mem_is_well_formed,
    val Null0.nULL' = Null0.nULL',
    predicate NonnullPtr0.nonnull_ptr = NonnullPtr0.nonnull_ptr,
    predicate ListSeg0.list_seg = ListSeg0.list_seg,
    predicate List0.list = List0.list,
    predicate Lasso0.lasso = Lasso0.lasso,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Pigeon0.pigeon = Pigeon0.pigeon,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function FindPtrInSeq0.find_ptr_in_seq = FindPtrInSeq0.find_ptr_in_seq,
    val Max0.mAX' = Max0.mAX',
    axiom .
  let rec ghost function find_lasso [#"../list_reversal_lasso.rs" 263 4 263 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 257 15 257 40] MemIsWellFormed0.mem_is_well_formed self}
    requires {[#"../list_reversal_lasso.rs" 258 15 258 55] first = Null0.nULL' \/ NonnullPtr0.nonnull_ptr self first}
    ensures { [#"../list_reversal_lasso.rs" 259 14 262 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> List0.list self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> Lasso0.lasso self first s1 s2
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 265 13 265 65] FindLassoAux0.find_lasso_aux self first first (Seq.empty )
end
module ListReversalLasso_Impl0
  
end
module ListReversalLasso_Impl1
  
end
module ListReversalLasso_Impl2
  
end
