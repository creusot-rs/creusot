
module ListReversalLasso_Null_Stub
  use prelude.UIntSize
  use prelude.Int
  val constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize
end
module ListReversalLasso_Null
  use prelude.UIntSize
  use prelude.Int
  let constant nULL' [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.UIntSize
  use prelude.Int
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module ListReversalLasso_Memory_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_memory  =
    | C_Memory (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
    
  let function memory_0 (self : t_memory) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Memory a -> a
      end
end
module Core_Num_Impl11_Max_Stub
  use prelude.UIntSize
  use prelude.Int
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.UIntSize
  use prelude.Int
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module ListReversalLasso_Impl1_Index
  use prelude.UIntSize
  use seq.Seq
  predicate invariant4 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : Seq.seq usize) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Seq.seq usize)
  val inv4 (_x : Seq.seq usize) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv4 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self}
    ensures { result = shallow_model1 self }
    
  axiom shallow_model1_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv4 (shallow_model1 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model1 self) <= UIntSize.to_int max0)
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv4 (shallow_model1 self)
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  predicate invariant2 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : usize) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : usize)
  val inv2 (_x : usize) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv2 x = true
  predicate invariant1 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : usize)
  val inv1 (_x : usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv1 x = true
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model1 self) (UIntSize.to_int ix)
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic1 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic1 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic0 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model1 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model1 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  use prelude.Borrow
  use prelude.Slice
  predicate has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) : bool
    ensures { result = has_value0 self seq out }
    
  predicate in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) : bool
    ensures { result = in_bounds0 self seq }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    ensures { result = shallow_model0 self }
    
  val index0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (index : usize) : usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 141 27 141 46] in_bounds0 index (shallow_model0 self)}
    requires {inv0 self}
    requires {inv1 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 142 26 142 54] has_value0 index (shallow_model0 self) result }
    ensures { inv2 result }
    
  let rec cfg index [#"../list_reversal_lasso.rs" 30 4 30 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 28 15 28 34] nonnull_ptr0 self i}
    ensures { [#"../list_reversal_lasso.rs" 29 14 29 44] result = index_logic0 self i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : ListReversalLasso_Memory_Type.t_memory = self;
  var i : usize = i;
  var _5 : usize;
  var _6 : usize;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../list_reversal_lasso.rs" 31 9 31 18] index0 ([#"../list_reversal_lasso.rs" 31 9 31 15] ListReversalLasso_Memory_Type.memory_0 self) i);
    goto BB1
  }
  BB1 {
    _5 <- ([#"../list_reversal_lasso.rs" 31 8 31 18] _6);
    _0 <- ([#"../list_reversal_lasso.rs" 31 8 31 18] _5);
    return _0
  }
  
end
module ListReversalLasso_Impl2_IndexMut
  use prelude.UIntSize
  use seq.Seq
  predicate invariant4 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : Seq.seq usize) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Seq.seq usize)
  val inv4 (_x : Seq.seq usize) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv4 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv4 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv4 (shallow_model0 self)
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  use prelude.Borrow
  predicate invariant2 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : borrowed usize) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed usize)
  val inv2 (_x : borrowed usize) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : borrowed usize . inv2 x = true
  predicate invariant1 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : usize)
  val inv1 (_x : usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv1 x = true
  predicate invariant0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)))
  val inv0 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) . inv0 x = true
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic1 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic1 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic0 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate resolve1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed usize) : bool
    ensures { result = resolve0 self }
    
  use prelude.Slice
  predicate resolve_elswhere0 [@inline:trivial] (self : usize) (old' : Seq.seq usize) (fin : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere0 [@inline:trivial] (self : usize) (old' : Seq.seq usize) (fin : Seq.seq usize) : bool
    ensures { result = resolve_elswhere0 self old' fin }
    
  predicate has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) : bool
    ensures { result = has_value0 self seq out }
    
  predicate in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) : bool
    ensures { result = in_bounds0 self seq }
    
  function shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : Seq.seq usize
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model0 ( * self)
  val shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : Seq.seq usize
    ensures { result = shallow_model1 self }
    
  val index_mut0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (index : usize) : borrowed usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 132 27 132 46] in_bounds0 index (shallow_model1 self)}
    requires {inv0 self}
    requires {inv1 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 133 26 133 54] has_value0 index (shallow_model1 self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 134 26 134 57] has_value0 index (shallow_model0 ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 135 26 135 62] resolve_elswhere0 index (shallow_model1 self) (shallow_model0 ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (shallow_model0 ( ^ self)) = Seq.length (shallow_model1 self) }
    ensures { inv2 result }
    
  let rec cfg index_mut [#"../list_reversal_lasso.rs" 41 4 41 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] nonnull_ptr0 ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = index_logic0 ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = index_logic0 ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . nonnull_ptr0 ( * self) j /\ i <> j -> index_logic0 ( ^ self) j = index_logic0 ( * self) j }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var i : usize = i;
  var _3 : borrowed usize;
  var _9 : borrowed usize;
  var _10 : borrowed usize;
  var _11 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    _11 <- Borrow.borrow_mut (ListReversalLasso_Memory_Type.memory_0 ( * self));
    self <- { self with current = (let ListReversalLasso_Memory_Type.C_Memory a =  * self in ListReversalLasso_Memory_Type.C_Memory ( ^ _11)) };
    _10 <- ([#"../list_reversal_lasso.rs" 42 13 42 22] index_mut0 _11 i);
    _11 <- any borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
    goto BB1
  }
  BB1 {
    _9 <- Borrow.borrow_mut ( * _10);
    _10 <- { _10 with current = ( ^ _9) };
    _3 <- Borrow.borrow_mut ( * _9);
    _9 <- { _9 with current = ( ^ _3) };
    _0 <- Borrow.borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { resolve0 _10 };
    assume { resolve0 _9 };
    assume { resolve0 _3 };
    assume { resolve1 self };
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListReversalSafe
  use prelude.UIntSize
  use seq.Seq
  predicate invariant1 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Seq.seq usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Seq.seq usize)
  val inv1 (_x : Seq.seq usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv1 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv1 (shallow_model0 self)
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use prelude.Borrow
  predicate resolve1 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed usize) : bool
    ensures { result = resolve1 self }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic1 self ix }
    
  function index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic1 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic0 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  val index_mut0 [#"../list_reversal_lasso.rs" 41 4 41 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] nonnull_ptr0 ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = index_logic0 ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = index_logic0 ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . nonnull_ptr0 ( * self) j /\ i <> j -> index_logic0 ( ^ self) j = index_logic0 ( * self) j }
    
  val index0 [#"../list_reversal_lasso.rs" 30 4 30 35] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 28 15 28 34] nonnull_ptr0 self i}
    ensures { [#"../list_reversal_lasso.rs" 29 14 29 44] result = index_logic0 self i }
    
  predicate resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) : bool
    ensures { result = resolve0 self }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  predicate mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [#"../list_reversal_lasso.rs" 56 8 58 9] forall i : usize . nonnull_ptr0 self i -> index_logic0 self i = null0 \/ nonnull_ptr0 self (index_logic0 self i)
  val mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed0 self }
    
  let rec cfg list_reversal_safe [#"../list_reversal_lasso.rs" 65 4 65 59] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) : usize
    requires {[#"../list_reversal_lasso.rs" 63 15 63 40] mem_is_well_formed0 ( * self)}
    requires {[#"../list_reversal_lasso.rs" 64 15 64 47] l = null0 \/ nonnull_ptr0 ( * self) l}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var r : usize;
  var tmp : usize;
  var _16 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 66 20 66 24] [#"../list_reversal_lasso.rs" 66 20 66 24] (18446744073709551615 : usize));
    goto BB1
  }
  BB1 {
    invariant { [#"../list_reversal_lasso.rs" 68 20 68 52] r = null0 \/ nonnull_ptr0 ( * self) r };
    invariant { [#"../list_reversal_lasso.rs" 69 20 69 52] l = null0 \/ nonnull_ptr0 ( * self) l };
    invariant { [#"../list_reversal_lasso.rs" 70 20 70 45] mem_is_well_formed0 ( * self) };
    goto BB2
  }
  BB2 {
    switch ([#"../list_reversal_lasso.rs" 71 14 71 23] l <> ([#"../list_reversal_lasso.rs" 71 19 71 23] [#"../list_reversal_lasso.rs" 71 19 71 23] (18446744073709551615 : usize)))
      | False -> goto BB6
      | True -> goto BB3
      end
  }
  BB3 {
    tmp <- l;
    _16 <- ([#"../list_reversal_lasso.rs" 73 16 73 23] index0 ([#"../list_reversal_lasso.rs" 73 16 73 20]  * self) l);
    goto BB4
  }
  BB4 {
    l <- _16;
    _21 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _21) };
    _20 <- ([#"../list_reversal_lasso.rs" 74 12 74 21] index_mut0 _21 tmp);
    _21 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _20 <- { _20 with current = r };
    assume { resolve1 _20 };
    r <- tmp;
    goto BB1
  }
  BB6 {
    assume { resolve0 self };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListReversalList
  use prelude.UIntSize
  use seq.Seq
  predicate invariant3 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Seq.seq usize) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Seq.seq usize)
  val inv3 (_x : Seq.seq usize) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv3 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv3 (shallow_model0 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  predicate invariant1 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : usize)
  val inv1 (_x : usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv1 x = true
  use prelude.Borrow
  predicate invariant0 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed usize) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed usize)
  val inv0 (_x : borrowed usize) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : borrowed usize . inv0 x = true
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic2 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic2 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic1 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> nonnull_ptr0 self (Seq.get s i) /\ index_logic1 self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg0 self first s last l h }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  predicate list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 93 12 93 53] list_seg0 self first s null0 0 (Seq.length s)
  val list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list0 self first s }
    
  use prelude.Ghost
  use prelude.Int
  predicate resolve1 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed usize) : bool
    ensures { result = resolve1 self }
    
  val replace0 (dest : borrowed usize) (src : usize) : usize
    requires {inv0 dest}
    requires {inv1 src}
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { inv1 result }
    
  val index_mut0 [#"../list_reversal_lasso.rs" 41 4 41 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] nonnull_ptr0 ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = index_logic1 ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = index_logic1 ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . nonnull_ptr0 ( * self) j /\ i <> j -> index_logic1 ( ^ self) j = index_logic1 ( * self) j }
    
  predicate resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) : bool
    ensures { result = resolve0 self }
    
  use seq.Reverse
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  let rec cfg list_reversal_list [#"../list_reversal_lasso.rs" 99 4 99 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 97 15 97 31] list0 ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 98 14 98 47] list0 ( ^ self) result (Reverse.reverse (Ghost.inner s)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s : Ghost.ghost_ty (Seq.seq usize) = s;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _17 : usize;
  var _18 : borrowed usize;
  var _19 : borrowed usize;
  var _20 : borrowed usize;
  var _21 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _23 : usize;
  var _24 : borrowed usize;
  var _25 : borrowed usize;
  var _27 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 100 20 100 24] [#"../list_reversal_lasso.rs" 100 20 100 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 101 20 101 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 103 20 103 44] 0 <= Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s) };
    invariant { [#"../list_reversal_lasso.rs" 104 20 104 59] list_seg0 ( * self) l (Ghost.inner s) null0 (Ghost.inner n) (Seq.length (Ghost.inner s)) };
    invariant { [#"../list_reversal_lasso.rs" 105 20 105 76] list_seg0 ( * self) r (Reverse.reverse (Ghost.inner s)) null0 (Seq.length (Ghost.inner s) - Ghost.inner n) (Seq.length (Ghost.inner s)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 107 14 107 23] l <> ([#"../list_reversal_lasso.rs" 107 19 107 23] [#"../list_reversal_lasso.rs" 107 19 107 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _21 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _21) };
    _20 <- ([#"../list_reversal_lasso.rs" 108 39 108 46] index_mut0 _21 l);
    _21 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _19 <- Borrow.borrow_mut ( * _20);
    _20 <- { _20 with current = ( ^ _19) };
    _18 <- Borrow.borrow_mut ( * _19);
    _19 <- { _19 with current = ( ^ _18) };
    _25 <- Borrow.borrow_mut r;
    r <-  ^ _25;
    _24 <- Borrow.borrow_mut ( * _25);
    _25 <- { _25 with current = ( ^ _24) };
    _23 <- ([#"../list_reversal_lasso.rs" 108 48 108 76] replace0 _24 l);
    _24 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { resolve1 _25 };
    _17 <- ([#"../list_reversal_lasso.rs" 108 16 108 77] replace0 _18 _23);
    _18 <- any borrowed usize;
    _23 <- any usize;
    goto BB7
  }
  BB7 {
    assume { resolve1 _20 };
    assume { resolve1 _19 };
    l <- _17;
    _17 <- any usize;
    _27 <- ([#"../list_reversal_lasso.rs" 109 16 109 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _27;
    _27 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { resolve0 self };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListReversalLoop
  use prelude.UIntSize
  use seq.Seq
  predicate invariant3 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Seq.seq usize) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Seq.seq usize)
  val inv3 (_x : Seq.seq usize) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv3 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv3 (shallow_model0 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  predicate invariant1 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : usize)
  val inv1 (_x : usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv1 x = true
  use prelude.Borrow
  predicate invariant0 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed usize) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed usize)
  val inv0 (_x : borrowed usize) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : borrowed usize . inv0 x = true
  use seq.Seq
  function index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic3 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic3 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic1 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic1 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> nonnull_ptr0 self (Seq.get s i) /\ index_logic1 self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg0 self first s last l h }
    
  predicate loop0 [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 118 12 118 53] list_seg0 self first s (Seq.get s 0) 0 (Seq.length s)
  val loop0 [#"../list_reversal_lasso.rs" 116 4 116 55] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = loop0 self first s }
    
  use prelude.Ghost
  use prelude.Int
  predicate resolve1 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed usize) : bool
    ensures { result = resolve1 self }
    
  val replace0 (dest : borrowed usize) (src : usize) : usize
    requires {inv0 dest}
    requires {inv1 src}
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { inv1 result }
    
  val index_mut0 [#"../list_reversal_lasso.rs" 41 4 41 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] nonnull_ptr0 ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = index_logic1 ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = index_logic1 ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . nonnull_ptr0 ( * self) j /\ i <> j -> index_logic1 ( ^ self) j = index_logic1 ( * self) j }
    
  use seq.Seq
  use seq_ext.SeqExt
  use seq.Seq
  predicate resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) : bool
    ensures { result = resolve0 self }
    
  use seq.Reverse
  use prelude.Ghost
  function index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq usize)) (ix : int) : usize =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33] Seq.get (Ghost.inner self) ix
  val index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq usize)) (ix : int) : usize
    ensures { result = index_logic0 self ix }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  use prelude.Ghost
  use prelude.Ghost
  let rec cfg list_reversal_loop [#"../list_reversal_lasso.rs" 125 4 125 79] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 122 15 122 26] Seq.length (Ghost.inner s) > 0}
    requires {[#"../list_reversal_lasso.rs" 123 15 123 32] loop0 ( * self) l (Ghost.inner s)}
    ensures { [#"../list_reversal_lasso.rs" 124 14 124 101] loop0 ( ^ self) result (Seq.(++) (Seq.singleton (index_logic0 s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s : Ghost.ghost_ty (Seq.seq usize) = s;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _21 : usize;
  var _22 : borrowed usize;
  var _23 : borrowed usize;
  var _24 : borrowed usize;
  var _25 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _27 : usize;
  var _28 : borrowed usize;
  var _29 : borrowed usize;
  var _31 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 126 20 126 24] [#"../list_reversal_lasso.rs" 126 20 126 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 127 20 127 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 129 20 129 48] 0 <= Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s) + 1 };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n = Seq.length (Ghost.inner s) + 1 -> l = null0 /\ r = index_logic0 s 0 /\ nonnull_ptr0 ( * self) r /\ index_logic1 ( * self) r = index_logic0 s (Seq.length (Ghost.inner s) - 1) /\ list_seg0 ( * self) (index_logic0 s (Seq.length (Ghost.inner s) - 1)) (Reverse.reverse (Ghost.inner s)) (index_logic0 s 0) 0 (Seq.length (Ghost.inner s) - 1) };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n <= Seq.length (Ghost.inner s) -> list_seg0 ( * self) l (Ghost.inner s) (index_logic0 s 0) (Ghost.inner n) (Seq.length (Ghost.inner s)) };
    invariant { [#"../list_reversal_lasso.rs" 129 8 129 50] Ghost.inner n <= Seq.length (Ghost.inner s) -> list_seg0 ( * self) r (Reverse.reverse (Ghost.inner s)) null0 (Seq.length (Ghost.inner s) - Ghost.inner n) (Seq.length (Ghost.inner s)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 137 14 137 23] l <> ([#"../list_reversal_lasso.rs" 137 19 137 23] [#"../list_reversal_lasso.rs" 137 19 137 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 138 12 138 77] Ghost.inner n = Seq.length (Ghost.inner s) -> l = Seq.get (Reverse.reverse (Ghost.inner s)) (Seq.length (Ghost.inner s) - 1) };
    _25 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _25) };
    _24 <- ([#"../list_reversal_lasso.rs" 139 39 139 46] index_mut0 _25 l);
    _25 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _23 <- Borrow.borrow_mut ( * _24);
    _24 <- { _24 with current = ( ^ _23) };
    _22 <- Borrow.borrow_mut ( * _23);
    _23 <- { _23 with current = ( ^ _22) };
    _29 <- Borrow.borrow_mut r;
    r <-  ^ _29;
    _28 <- Borrow.borrow_mut ( * _29);
    _29 <- { _29 with current = ( ^ _28) };
    _27 <- ([#"../list_reversal_lasso.rs" 139 48 139 76] replace0 _28 l);
    _28 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { resolve1 _29 };
    _21 <- ([#"../list_reversal_lasso.rs" 139 16 139 77] replace0 _22 _27);
    _22 <- any borrowed usize;
    _27 <- any usize;
    goto BB7
  }
  BB7 {
    assume { resolve1 _24 };
    assume { resolve1 _23 };
    l <- _21;
    _21 <- any usize;
    _31 <- ([#"../list_reversal_lasso.rs" 140 16 140 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _31;
    _31 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { resolve0 self };
    assert { [@expl:assertion] [#"../list_reversal_lasso.rs" 143 8 145 54] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner s) -> Seq.get (Seq.(++) (Seq.singleton (index_logic0 s 0)) (Reverse.reverse (SeqExt.subsequence (Ghost.inner s) 1 (Seq.length (Ghost.inner s))))) i = (if i = 0 then
      index_logic0 s 0
    else
      Seq.get (Reverse.reverse (Ghost.inner s)) (i - 1)
    ) };
    _0 <- r;
    return _0
  }
  
end
module ListReversalLasso_Impl4_ListReversalLasso
  use prelude.UIntSize
  use seq.Seq
  predicate invariant3 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Seq.seq usize) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Seq.seq usize)
  val inv3 (_x : Seq.seq usize) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv3 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv3 (shallow_model0 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  predicate invariant1 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : usize)
  val inv1 (_x : usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : usize . inv1 x = true
  use prelude.Borrow
  predicate invariant0 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed usize) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed usize)
  val inv0 (_x : borrowed usize) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : borrowed usize . inv0 x = true
  use seq.Seq
  function index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic3 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic2 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic3 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic2 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic2 self i }
    
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> nonnull_ptr0 self (Seq.get s i) /\ index_logic2 self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg0 self first s last l h }
    
  predicate lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 152 8 158 9] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0 /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2 -> Seq.get s1 i <> Seq.get s2 j) /\ list_seg0 self first s1 mid 0 (Seq.length s1) /\ list_seg0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  val lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso0 self first s1 s2 }
    
  use prelude.Ghost
  use prelude.Int
  predicate resolve1 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed usize) : bool
    ensures { result = resolve1 self }
    
  val replace0 (dest : borrowed usize) (src : usize) : usize
    requires {inv0 dest}
    requires {inv1 src}
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 7 22 7 34]  ^ dest = src }
    ensures { [#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 37] result =  * dest }
    ensures { inv1 result }
    
  val index_mut0 [#"../list_reversal_lasso.rs" 41 4 41 47] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (i : usize) : borrowed usize
    requires {[#"../list_reversal_lasso.rs" 36 15 36 34] nonnull_ptr0 ( * self) i}
    ensures { [#"../list_reversal_lasso.rs" 37 14 37 47]  * result = index_logic2 ( * self) i }
    ensures { [#"../list_reversal_lasso.rs" 38 14 38 47]  ^ result = index_logic2 ( ^ self) i }
    ensures { [#"../list_reversal_lasso.rs" 39 14 39 47] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( * self))) = Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 ( ^ self))) }
    ensures { [#"../list_reversal_lasso.rs" 40 4 40 113] forall j : usize . nonnull_ptr0 ( * self) j /\ i <> j -> index_logic2 ( ^ self) j = index_logic2 ( * self) j }
    
  predicate resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) : bool
    ensures { result = resolve0 self }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  use seq.Reverse
  use prelude.Ghost
  function index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq usize)) (ix : int) : usize =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33] Seq.get (Ghost.inner self) ix
  val index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq usize)) (ix : int) : usize
    ensures { result = index_logic0 self ix }
    
  use prelude.Ghost
  use prelude.Ghost
  let rec cfg list_reversal_lasso [#"../list_reversal_lasso.rs" 163 4 168 12] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (ListReversalLasso_Memory_Type.t_memory)) (l : usize) (s1 : Ghost.ghost_ty (Seq.seq usize)) (s2 : Ghost.ghost_ty (Seq.seq usize)) : usize
    requires {[#"../list_reversal_lasso.rs" 161 15 161 38] lasso0 ( * self) l (Ghost.inner s1) (Ghost.inner s2)}
    ensures { [#"../list_reversal_lasso.rs" 162 14 162 54] lasso0 ( ^ self) result (Ghost.inner s1) (Reverse.reverse (Ghost.inner s2)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self : borrowed (ListReversalLasso_Memory_Type.t_memory) = self;
  var l : usize = l;
  var s1 : Ghost.ghost_ty (Seq.seq usize) = s1;
  var s2 : Ghost.ghost_ty (Seq.seq usize) = s2;
  var r : usize;
  var n : Ghost.ghost_ty int;
  var _19 : usize;
  var _20 : borrowed usize;
  var _21 : borrowed usize;
  var _22 : borrowed usize;
  var _23 : borrowed (ListReversalLasso_Memory_Type.t_memory);
  var _25 : usize;
  var _26 : borrowed usize;
  var _27 : borrowed usize;
  var _29 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    r <- ([#"../list_reversal_lasso.rs" 169 20 169 24] [#"../list_reversal_lasso.rs" 169 20 169 24] (18446744073709551615 : usize));
    n <- ([#"../list_reversal_lasso.rs" 170 20 170 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    invariant { [#"../list_reversal_lasso.rs" 172 20 172 58] 0 <= Ghost.inner n /\ Ghost.inner n <= 2 * Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] let mid = if Seq.length (Ghost.inner s2) = 0 then
      index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)
    else
      index_logic0 s2 0
     in Ghost.inner n <= Seq.length (Ghost.inner s1) -> list_seg0 ( * self) l (Ghost.inner s1) mid (Ghost.inner n) (Seq.length (Ghost.inner s1)) /\ list_seg0 ( * self) mid (Ghost.inner s2) (index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)) 0 (Seq.length (Ghost.inner s2)) /\ list_seg0 ( * self) r (Reverse.reverse (Ghost.inner s1)) null0 (Seq.length (Ghost.inner s1) - Ghost.inner n) (Seq.length (Ghost.inner s1)) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] Seq.length (Ghost.inner s1) < Ghost.inner n /\ Ghost.inner n <= Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) -> list_seg0 ( * self) l (Ghost.inner s2) (index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)) (Ghost.inner n - Seq.length (Ghost.inner s1)) (Seq.length (Ghost.inner s2)) /\ list_seg0 ( * self) r (Reverse.reverse (Ghost.inner s2)) (index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)) (Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) - Ghost.inner n) (Seq.length (Ghost.inner s2)) /\ list_seg0 ( * self) (index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)) (Reverse.reverse (Ghost.inner s1)) null0 0 (Seq.length (Ghost.inner s1)) };
    invariant { [#"../list_reversal_lasso.rs" 172 8 172 60] let mid = if Seq.length (Ghost.inner s2) = 0 then
      index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)
    else
      index_logic0 s2 (Seq.length (Ghost.inner s2) - 1)
     in Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) < Ghost.inner n -> list_seg0 ( * self) l (Reverse.reverse (Ghost.inner s1)) null0 (Ghost.inner n - Seq.length (Ghost.inner s1) - Seq.length (Ghost.inner s2)) (Seq.length (Ghost.inner s1)) /\ list_seg0 ( * self) r (Ghost.inner s1) mid (2 * Seq.length (Ghost.inner s1) + Seq.length (Ghost.inner s2) - Ghost.inner n) (Seq.length (Ghost.inner s1)) /\ list_seg0 ( * self) mid (Reverse.reverse (Ghost.inner s2)) (index_logic0 s1 (Seq.length (Ghost.inner s1) - 1)) 0 (Seq.length (Ghost.inner s2)) };
    goto BB3
  }
  BB3 {
    switch ([#"../list_reversal_lasso.rs" 190 14 190 23] l <> ([#"../list_reversal_lasso.rs" 190 19 190 23] [#"../list_reversal_lasso.rs" 190 19 190 23] (18446744073709551615 : usize)))
      | False -> goto BB9
      | True -> goto BB4
      end
  }
  BB4 {
    _23 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _23) };
    _22 <- ([#"../list_reversal_lasso.rs" 191 39 191 46] index_mut0 _23 l);
    _23 <- any borrowed (ListReversalLasso_Memory_Type.t_memory);
    goto BB5
  }
  BB5 {
    _21 <- Borrow.borrow_mut ( * _22);
    _22 <- { _22 with current = ( ^ _21) };
    _20 <- Borrow.borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    _27 <- Borrow.borrow_mut r;
    r <-  ^ _27;
    _26 <- Borrow.borrow_mut ( * _27);
    _27 <- { _27 with current = ( ^ _26) };
    _25 <- ([#"../list_reversal_lasso.rs" 191 48 191 76] replace0 _26 l);
    _26 <- any borrowed usize;
    goto BB6
  }
  BB6 {
    assume { resolve1 _27 };
    _19 <- ([#"../list_reversal_lasso.rs" 191 16 191 77] replace0 _20 _25);
    _20 <- any borrowed usize;
    _25 <- any usize;
    goto BB7
  }
  BB7 {
    assume { resolve1 _22 };
    assume { resolve1 _21 };
    l <- _19;
    _19 <- any usize;
    _29 <- ([#"../list_reversal_lasso.rs" 192 16 192 30] Ghost.new (Ghost.inner n + 1));
    goto BB8
  }
  BB8 {
    n <- _29;
    _29 <- any Ghost.ghost_ty int;
    goto BB2
  }
  BB9 {
    assume { resolve0 self };
    _0 <- r;
    return _0
  }
  
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module ListReversalLasso_Impl4_FindPtrInSeq_Impl
  use prelude.UIntSize
  use seq.Seq
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  use prelude.Int
  let rec ghost function find_ptr_in_seq [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { [#"../list_reversal_lasso.rs" 199 14 202 5] match (result) with
      | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
      | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
      end }
    variant {[#"../list_reversal_lasso.rs" 203 14 203 25] Seq.length s - i}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 205 8 209 9] if pure {i = Seq.length s} then
      Core_Option_Option_Type.C_None
    else
      if pure {UIntSize.to_int (Seq.get s i) = p} then Core_Option_Option_Type.C_Some i else find_ptr_in_seq s (i + 1) p
    
end
module ListReversalLasso_Impl4_Pigeon_Impl
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.UIntSize
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  use prelude.Int
  function find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq0 s i p = ([#"../list_reversal_lasso.rs" 205 8 209 9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq0 s (i + 1) p
  )
  val find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { result = find_ptr_in_seq0 s i p }
    
  axiom find_ptr_in_seq0_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 199 14 202 5] match (find_ptr_in_seq0 s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  use seq.Seq
  use seq_ext.SeqExt
  let rec ghost function pigeon [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { [#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n }
    ensures { [#"../list_reversal_lasso.rs" 217 14 217 20] result }
    variant {[#"../list_reversal_lasso.rs" 218 14 218 15] n}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 220 8 232 9] if pure {n = 0} then
      true
    else
      match (find_ptr_in_seq0 s 0 (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon s (n - 1)
        | Core_Option_Option_Type.C_Some i -> match (find_ptr_in_seq0 s (i + 1) (n - 1)) with
          | Core_Option_Option_Type.C_None -> pigeon (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
          | Core_Option_Option_Type.C_Some _ -> true
          end
        end
    
end
module ListReversalLasso_Impl4_FindLassoAux_Impl
  use prelude.UIntSize
  use seq.Seq
  predicate invariant1 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Seq.seq usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Seq.seq usize)
  val inv1 (_x : Seq.seq usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv1 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv1 (shallow_model0 self)
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use prelude.Int
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq0 s i p = ([#"../list_reversal_lasso.rs" 205 8 209 9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq0 s (i + 1) p
  )
  val find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { result = find_ptr_in_seq0 s i p }
    
  axiom find_ptr_in_seq0_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 199 14 202 5] match (find_ptr_in_seq0 s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  use seq_ext.SeqExt
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic2 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic2 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic0 self i }
    
  use seq.Seq
  function pigeon0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
  axiom pigeon0_def : forall s : Seq.seq usize, n : int . pigeon0 s n = ([#"../list_reversal_lasso.rs" 220 8 232 9] if n = 0 then
    true
  else
    match (find_ptr_in_seq0 s 0 (n - 1)) with
      | Core_Option_Option_Type.C_None -> pigeon0 s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match (find_ptr_in_seq0 s (i + 1) (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon0 (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  val pigeon0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { result = pigeon0 s n }
    
  axiom pigeon0_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 217 14 217 20] pigeon0 s n) && ([#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n)
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> nonnull_ptr0 self (Seq.get s i) /\ index_logic0 self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg0 self first s last l h }
    
  predicate lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 152 8 158 9] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0 /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2 -> Seq.get s1 i <> Seq.get s2 j) /\ list_seg0 self first s1 mid 0 (Seq.length s1) /\ list_seg0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  val lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso0 self first s1 s2 }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  predicate list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 93 12 93 53] list_seg0 self first s null0 0 (Seq.length s)
  val list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list0 self first s }
    
  predicate mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [#"../list_reversal_lasso.rs" 56 8 58 9] forall i : usize . nonnull_ptr0 self i -> index_logic0 self i = null0 \/ nonnull_ptr0 self (index_logic0 self i)
  val mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed0 self }
    
  let rec ghost function find_lasso_aux [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 236 15 236 40] mem_is_well_formed0 self}
    requires {[#"../list_reversal_lasso.rs" 237 15 237 53] last = null0 \/ nonnull_ptr0 self last}
    requires {[#"../list_reversal_lasso.rs" 238 15 238 56] list_seg0 self first s last 0 (Seq.length s)}
    ensures { [#"../list_reversal_lasso.rs" 239 14 242 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> list0 self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> lasso0 self first s1 s2
      end }
    variant {[#"../list_reversal_lasso.rs" 243 4 243 39] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) - Seq.length s}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 245 8 259 9] if pure {last = null0} then
      (s, Core_Option_Option_Type.C_None)
    else
      match (find_ptr_in_seq0 s 0 (UIntSize.to_int last)) with
        | Core_Option_Option_Type.C_None -> if let b' = let a' = shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self) in Seq.length a' in pigeon0 s b' then
          let c' = index_logic0 self last in find_lasso_aux self first c' (Seq.snoc s last)
        else
          (s, Core_Option_Option_Type.C_None)
        
        | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
        end
    
end
module ListReversalLasso_Impl4_FindLasso_Impl
  use prelude.UIntSize
  use seq.Seq
  predicate invariant1 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Seq.seq usize) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Seq.seq usize)
  val inv1 (_x : Seq.seq usize) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Seq.seq usize . inv1 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  function shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self}
    ensures { result = shallow_model0 self }
    
  axiom shallow_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv1 (shallow_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model0 self) <= UIntSize.to_int max0)
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv1 (shallow_model0 self)
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : [#"../list_reversal_lasso.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use prelude.Int
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  function find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    
  axiom find_ptr_in_seq0_def : forall s : Seq.seq usize, i : int, p : int . find_ptr_in_seq0 s i p = ([#"../list_reversal_lasso.rs" 205 8 209 9] if i = Seq.length s then
    Core_Option_Option_Type.C_None
  else
    if UIntSize.to_int (Seq.get s i) = p then Core_Option_Option_Type.C_Some i else find_ptr_in_seq0 s (i + 1) p
  )
  val find_ptr_in_seq0 [#"../list_reversal_lasso.rs" 204 4 204 66] (s : Seq.seq usize) (i : int) (p : int) : Core_Option_Option_Type.t_option int
    requires {[#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s}
    ensures { result = find_ptr_in_seq0 s i p }
    
  axiom find_ptr_in_seq0_spec : forall s : Seq.seq usize, i : int, p : int . ([#"../list_reversal_lasso.rs" 198 15 198 37] 0 <= i /\ i <= Seq.length s) -> ([#"../list_reversal_lasso.rs" 199 14 202 5] match (find_ptr_in_seq0 s i p) with
    | Core_Option_Option_Type.C_None -> forall j : int . i <= j /\ j < Seq.length s -> UIntSize.to_int (Seq.get s j) <> p
    | Core_Option_Option_Type.C_Some j -> i <= j /\ j < Seq.length s /\ UIntSize.to_int (Seq.get s j) = p
    end)
  use seq_ext.SeqExt
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 31 8 31 32] Seq.get (shallow_model0 self) (UIntSize.to_int ix)
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : usize) : usize
    ensures { result = index_logic2 self ix }
    
  use ListReversalLasso_Memory_Type as ListReversalLasso_Memory_Type
  function index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    
   =
    [#"../list_reversal_lasso.rs" 21 8 21 31] index_logic2 (ListReversalLasso_Memory_Type.memory_0 self) i
  val index_logic0 [#"../list_reversal_lasso.rs" 20 4 20 39] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : usize
    ensures { result = index_logic0 self i }
    
  use seq.Seq
  function pigeon0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
  axiom pigeon0_def : forall s : Seq.seq usize, n : int . pigeon0 s n = ([#"../list_reversal_lasso.rs" 220 8 232 9] if n = 0 then
    true
  else
    match (find_ptr_in_seq0 s 0 (n - 1)) with
      | Core_Option_Option_Type.C_None -> pigeon0 s (n - 1)
      | Core_Option_Option_Type.C_Some i -> match (find_ptr_in_seq0 s (i + 1) (n - 1)) with
        | Core_Option_Option_Type.C_None -> pigeon0 (Seq.(++) (SeqExt.subsequence s 0 i) (SeqExt.subsequence s (i + 1) (Seq.length s))) (n - 1)
        | Core_Option_Option_Type.C_Some _ -> true
        end
      end
  )
  val pigeon0 [#"../list_reversal_lasso.rs" 219 4 219 42] (s : Seq.seq usize) (n : int) : bool
    requires {[#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n}
    requires {[#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n}
    requires {[#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j}
    ensures { result = pigeon0 s n }
    
  axiom pigeon0_spec : forall s : Seq.seq usize, n : int . ([#"../list_reversal_lasso.rs" 213 15 213 21] 0 <= n) -> ([#"../list_reversal_lasso.rs" 214 4 214 67] forall i : int . 0 <= i /\ i < Seq.length s -> UIntSize.to_int (Seq.get s i) < n) -> ([#"../list_reversal_lasso.rs" 215 4 215 113] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j) -> ([#"../list_reversal_lasso.rs" 217 14 217 20] pigeon0 s n) && ([#"../list_reversal_lasso.rs" 216 14 216 26] Seq.length s <= n)
  predicate nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize)
    
   =
    [#"../list_reversal_lasso.rs" 50 20 50 70] Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self)) <= UIntSize.to_int max0 /\ UIntSize.to_int i < Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))
  val nonnull_ptr0 [#"../list_reversal_lasso.rs" 49 4 49 44] (self : ListReversalLasso_Memory_Type.t_memory) (i : usize) : bool
    ensures { result = nonnull_ptr0 self i }
    
  predicate list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int)
    
   =
    [#"../list_reversal_lasso.rs" 83 12 85 98] first = (if h = l then
      last
    else
      Seq.get s l
    ) /\ (forall i : int . l <= i /\ i < h -> nonnull_ptr0 self (Seq.get s i) /\ index_logic0 self (Seq.get s i) = (if i = h - 1 then
      last
    else
      Seq.get s (i + 1)
    )) /\ (forall j : int . forall i : int . l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  val list_seg0 [#"../list_reversal_lasso.rs" 81 4 81 81] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) (last : usize) (l : int) (h : int) : bool
    ensures { result = list_seg0 self first s last l h }
    
  predicate lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 152 8 158 9] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0 /\ (forall j : int . forall i : int . 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2 -> Seq.get s1 i <> Seq.get s2 j) /\ list_seg0 self first s1 mid 0 (Seq.length s1) /\ list_seg0 self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  val lasso0 [#"../list_reversal_lasso.rs" 151 4 151 70] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s1 : Seq.seq usize) (s2 : Seq.seq usize) : bool
    ensures { result = lasso0 self first s1 s2 }
    
  let constant null0 [#"../list_reversal_lasso.rs" 13 0 13 15]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 13 0 13 15] [#"../list_reversal_lasso.rs" 13 0 13 15] (18446744073709551615 : usize)
  predicate list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize)
    
   =
    [#"../list_reversal_lasso.rs" 93 12 93 53] list_seg0 self first s null0 0 (Seq.length s)
  val list0 [#"../list_reversal_lasso.rs" 91 4 91 54] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (s : Seq.seq usize) : bool
    ensures { result = list0 self first s }
    
  predicate mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory)
    
   =
    [#"../list_reversal_lasso.rs" 56 8 58 9] forall i : usize . nonnull_ptr0 self i -> index_logic0 self i = null0 \/ nonnull_ptr0 self (index_logic0 self i)
  val mem_is_well_formed0 [#"../list_reversal_lasso.rs" 55 4 55 43] (self : ListReversalLasso_Memory_Type.t_memory) : bool
    ensures { result = mem_is_well_formed0 self }
    
  function find_lasso_aux0 [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    
  axiom find_lasso_aux0_def : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . find_lasso_aux0 self first last s = ([#"../list_reversal_lasso.rs" 245 8 259 9] if last = null0 then
    (s, Core_Option_Option_Type.C_None)
  else
    match (find_ptr_in_seq0 s 0 (UIntSize.to_int last)) with
      | Core_Option_Option_Type.C_None -> if pigeon0 s (Seq.length (shallow_model0 (ListReversalLasso_Memory_Type.memory_0 self))) then
        find_lasso_aux0 self first (index_logic0 self last) (Seq.snoc s last)
      else
        (s, Core_Option_Option_Type.C_None)
      
      | Core_Option_Option_Type.C_Some i -> (SeqExt.subsequence s 0 (i + 1), Core_Option_Option_Type.C_Some (SeqExt.subsequence s (i + 1) (Seq.length s)))
      end
  )
  val find_lasso_aux0 [#"../list_reversal_lasso.rs" 244 4 244 95] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) (last : usize) (s : Seq.seq usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 236 15 236 40] mem_is_well_formed0 self}
    requires {[#"../list_reversal_lasso.rs" 237 15 237 53] last = null0 \/ nonnull_ptr0 self last}
    requires {[#"../list_reversal_lasso.rs" 238 15 238 56] list_seg0 self first s last 0 (Seq.length s)}
    ensures { result = find_lasso_aux0 self first last s }
    
  axiom find_lasso_aux0_spec : forall self : ListReversalLasso_Memory_Type.t_memory, first : usize, last : usize, s : Seq.seq usize . ([#"../list_reversal_lasso.rs" 236 15 236 40] mem_is_well_formed0 self) -> ([#"../list_reversal_lasso.rs" 237 15 237 53] last = null0 \/ nonnull_ptr0 self last) -> ([#"../list_reversal_lasso.rs" 238 15 238 56] list_seg0 self first s last 0 (Seq.length s)) -> ([#"../list_reversal_lasso.rs" 239 14 242 5] match (find_lasso_aux0 self first last s) with
    | (s, Core_Option_Option_Type.C_None) -> list0 self first s
    | (s1, Core_Option_Option_Type.C_Some s2) -> lasso0 self first s1 s2
    end)
  use seq.Seq
  let rec ghost function find_lasso [#"../list_reversal_lasso.rs" 270 4 270 71] (self : ListReversalLasso_Memory_Type.t_memory) (first : usize) : (Seq.seq usize, Core_Option_Option_Type.t_option (Seq.seq usize))
    requires {[#"../list_reversal_lasso.rs" 264 15 264 40] mem_is_well_formed0 self}
    requires {[#"../list_reversal_lasso.rs" 265 15 265 55] first = null0 \/ nonnull_ptr0 self first}
    ensures { [#"../list_reversal_lasso.rs" 266 14 269 5] match (result) with
      | (s, Core_Option_Option_Type.C_None) -> list0 self first s
      | (s1, Core_Option_Option_Type.C_Some s2) -> lasso0 self first s1 s2
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../list_reversal_lasso.rs" 272 13 272 65] find_lasso_aux0 self first first (Seq.empty )
end
module ListReversalLasso_Impl0
  
end
module ListReversalLasso_Impl1
  goal index_refn : [#"../list_reversal_lasso.rs" 30 4 30 35] true
end
module ListReversalLasso_Impl2
  goal index_mut_refn : [#"../list_reversal_lasso.rs" 41 4 41 47] true
end
