module M_such_that__foo [#"such_that.rs" 4 0 4 12]
  let%span ssuch_that0 = "such_that.rs" 5 12 5 54
  let%span ssuch_that1 = "such_that.rs" 6 18 6 26
  let%span ssuch_that2 = "such_that.rs" 8 12 8 18
  let%span ssuch_that3 = "such_that.rs" 10 18 10 44
  let%span ssuch_that4 = "such_that.rs" 11 20 11 59
  let%span ssuch_that5 = "such_that.rs" 12 4 12 37
  let%span ssuch_that6 = "such_that.rs" 13 12 13 44
  let%span ssuch_that7 = "such_that.rs" 14 18 14 34
  let%span sutil8 = "../../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil9 = "../../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span ssuch_that10 = "such_that.rs" 17 10 17 26
  let%span smapping11 = "../../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use prelude.prelude.Int
  
  use prelude.prelude.Mapping
  
  use map.Map
  
  use map.Map
  
  function index_logic'1 (self : Map.map int bool) (a : int) : bool =
    [%#smapping11] Map.get self a
  
  function such_that'0 (p : Map.map int bool) : int
  
  axiom such_that'0_spec : forall p : Map.map int bool . ([%#sutil8] exists x : int . index_logic'1 p x)
   -> ([%#sutil9] index_logic'1 p (such_that'0 p))
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int32
  
  let rec even'0 (_1:()) (return'  (ret:int32))= any
    [ return' (result:int32)-> {[%#ssuch_that10] mod (Int32.to_int result) 2 = 0} (! return' {result}) ]
    
  
  use prelude.prelude.Mapping
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  function index_logic'0 (self : Map.map int int) (a : int) : int =
    [%#smapping11] Map.get self a
  
  use prelude.prelude.Mapping
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec foo'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &x <- [%#ssuch_that0] Snapshot.new (such_that'0 (Mapping.from_fn (fun (x : int) -> x + 1 = 42))) ] s1
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#ssuch_that1] Snapshot.inner x = 41} s1
      | s1 = even'0 {[%#ssuch_that2] ()} (fun (_ret':int32) ->  [ &y <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &mapping <- [%#ssuch_that3] Snapshot.new (Mapping.from_fn (fun (x : int) -> x + Int32.to_int y)) ] s1
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = 
        [ &predicate' <- [%#ssuch_that4] Snapshot.new (Mapping.from_fn (fun (x : int) -> index_logic'0 (Snapshot.inner mapping) x
        + 1
        = 0)) ]
        
        s1
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#ssuch_that5] index_logic'1 (Snapshot.inner predicate') (- Int32.to_int y - 1)} s1
      | s1 =  [ &x1 <- [%#ssuch_that6] Snapshot.new (such_that'0 (Snapshot.inner predicate')) ] s2
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#ssuch_that7] Snapshot.inner x1 + Int32.to_int y + 1 = 0} s1 | s1 = return' {_0} ]
       ]
    )
    [ & _0 : () = any_l ()
    | & x : Snapshot.snap_ty int = any_l ()
    | & y : int32 = any_l ()
    | & mapping : Snapshot.snap_ty (Map.map int int) = any_l ()
    | & predicate' : Snapshot.snap_ty (Map.map int bool) = any_l ()
    | & x1 : Snapshot.snap_ty int = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_such_that__even [#"such_that.rs" 18 0 18 16]
  let%span ssuch_that0 = "such_that.rs" 19 4 19 5
  let%span ssuch_that1 = "such_that.rs" 17 10 17 26
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  meta "compute_max_steps" 1000000
  
  let rec even'0 (_1:()) (return'  (ret:int32))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#ssuch_that0] (2 : int32) ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : int32 = any_l () ] 
    [ return' (result:int32)-> {[@expl:even ensures] [%#ssuch_that1] mod (Int32.to_int result) 2 = 0}
      (! return' {result}) ]
    
end
