
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../../creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../../creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub
  type t
  type s
  use prelude.Int
  function index_logic [@inline:trivial] (self : s) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Interface
  type t
  type s
  use prelude.Int
  function index_logic [@inline:trivial] (self : s) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic
  type t
  type s
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = s,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function index_logic [@inline:trivial] (self : s) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 16 8 16 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : s) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val new (_1' : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 55 26 55 44] Seq.length (ShallowModel0.shallow_model result) = 0 }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 54 8 54 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val push (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (value : t) : ()
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 65 26 65 51] ShallowModel0.shallow_model ( ^ self) = Seq.snoc (ShallowModel1.shallow_model self) value }
    
end
module IndexRange_CreateArr_Interface
  use seq.Seq
  use prelude.Int32
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val create_arr [#"../index_range.rs" 14 0 14 27] (_1' : ()) : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../index_range.rs" 7 4 12 22] Seq.length (ShallowModel0.shallow_model result) = 5 /\ Int32.to_int (IndexLogic0.index_logic result 0) = 0 /\ Int32.to_int (IndexLogic0.index_logic result 1) = 1 /\ Int32.to_int (IndexLogic0.index_logic result 2) = 2 /\ Int32.to_int (IndexLogic0.index_logic result 3) = 3 /\ Int32.to_int (IndexLogic0.index_logic result 4) = 4 }
    
end
module IndexRange_CreateArr
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  let rec cfg create_arr [#"../index_range.rs" 14 0 14 27] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../index_range.rs" 7 4 12 22] Seq.length (ShallowModel0.shallow_model result) = 5 /\ Int32.to_int (IndexLogic0.index_logic result 0) = 0 /\ Int32.to_int (IndexLogic0.index_logic result 1) = 1 /\ Int32.to_int (IndexLogic0.index_logic result 2) = 2 /\ Int32.to_int (IndexLogic0.index_logic result 3) = 3 /\ Int32.to_int (IndexLogic0.index_logic result 4) = 4 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var arr_2 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _3 : ();
  var _4 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _5 : ();
  var _6 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _7 : ();
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _9 : ();
  var _10 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _11 : ();
  var _12 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    arr_2 <- ([#"../index_range.rs" 15 18 15 28] New0.new ());
    goto BB1
  }
  BB1 {
    _4 <- borrow_mut arr_2;
    arr_2 <-  ^ _4;
    _3 <- ([#"../index_range.rs" 17 4 17 15] Push0.push _4 ([#"../index_range.rs" 17 13 17 14] (0 : int32)));
    goto BB2
  }
  BB2 {
    _6 <- borrow_mut arr_2;
    arr_2 <-  ^ _6;
    _5 <- ([#"../index_range.rs" 18 4 18 15] Push0.push _6 ([#"../index_range.rs" 18 13 18 14] (1 : int32)));
    goto BB3
  }
  BB3 {
    _8 <- borrow_mut arr_2;
    arr_2 <-  ^ _8;
    _7 <- ([#"../index_range.rs" 19 4 19 15] Push0.push _8 ([#"../index_range.rs" 19 13 19 14] (2 : int32)));
    goto BB4
  }
  BB4 {
    _10 <- borrow_mut arr_2;
    arr_2 <-  ^ _10;
    _9 <- ([#"../index_range.rs" 20 4 20 15] Push0.push _10 ([#"../index_range.rs" 20 13 20 14] (3 : int32)));
    goto BB5
  }
  BB5 {
    _12 <- borrow_mut arr_2;
    arr_2 <-  ^ _12;
    _11 <- ([#"../index_range.rs" 21 4 21 15] Push0.push _12 ([#"../index_range.rs" 21 13 21 14] (4 : int32)));
    goto BB6
  }
  BB6 {
    _0 <- arr_2;
    arr_2 <- any Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Stub
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Interface
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
end
module CreusotContracts_Std1_Vec_Impl10_Resolve
  type t
  use prelude.Int
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 47 8 47 85] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> Resolve0.resolve (IndexLogic0.index_logic self i)
  val resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 23 20 23 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 38 8 38 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl13_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 127 27 127 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 128 26 128 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    
end
module Core_Slice_Impl0_Len_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Slice
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val len (self : slice t) : usize
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 208 0 301 1] Seq.length (ShallowModel0.shallow_model self) = UIntSize.to_int result }
    
end
module Alloc_Vec_Impl9_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val deref (self : Alloc_Vec_Vec_Type.t_vec t a) : slice t
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 133 26 133 42] ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val get (self : slice t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 218 8 218 102] InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 219 18 219 55] InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    
end
module Core_Option_Impl0_IsNone_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  val is_none (self : Core_Option_Option_Type.t_option t) : bool
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 23 26 23 51] result = (self = Core_Option_Option_Type.C_None) }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl14_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 118 27 118 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 119 26 119 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 120 26 120 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 121 26 121 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 122 26 122 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val len (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 62 26 62 48] UIntSize.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_Impl6_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 121 20 121 70] UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self) <= UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) /\ UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  axiom shallow_model_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl6_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl6_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl6_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 126 20 126 67] SeqExt.subsequence seq (UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self)) (UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self)) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 33 8 33 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 131 8 134 9] forall i : int . 0 <= i /\ (i < UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self) \/ UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) <= i) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 102 20 102 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 108 20 108 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module IndexRange_TestRange_Interface
  val test_range [#"../index_range.rs" 27 0 27 19] (_1' : ()) : ()
end
module IndexRange_TestRange
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel4 with
    type t = int32,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Slice_Impl6_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl6_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl6_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate HasValue0.has_value = HasValue1.has_value,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice int32
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = slice int32,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl9_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range [#"../index_range.rs" 27 0 27 19] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s_2 : slice int32;
  var _3 : slice int32;
  var _4 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _5 : Core_Ops_Range_Range_Type.t_range usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : slice int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var s_24 : slice int32;
  var _25 : slice int32;
  var _26 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _27 : Core_Ops_Range_Range_Type.t_range usize;
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : bool;
  var _32 : bool;
  var _33 : usize;
  var _34 : slice int32;
  var _35 : bool;
  var _36 : int32;
  var _37 : usize;
  var _38 : usize;
  var _39 : bool;
  var _40 : bool;
  var _41 : int32;
  var _42 : usize;
  var _43 : usize;
  var _44 : bool;
  var _45 : ();
  var _46 : ();
  var _47 : bool;
  var _48 : bool;
  var _49 : usize;
  var _50 : slice int32;
  var _51 : slice int32;
  var _52 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _53 : Core_Ops_Range_Range_Type.t_range usize;
  var _54 : ();
  var _55 : ();
  var _56 : bool;
  var _57 : bool;
  var _58 : usize;
  var _59 : slice int32;
  var _60 : slice int32;
  var _61 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _62 : Core_Ops_Range_Range_Type.t_range usize;
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : Core_Option_Option_Type.t_option (slice int32);
  var _68 : Core_Option_Option_Type.t_option (slice int32);
  var _69 : slice int32;
  var _70 : slice int32;
  var _71 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _72 : Core_Ops_Range_Range_Type.t_range usize;
  var _73 : ();
  var _74 : ();
  var _75 : bool;
  var _76 : bool;
  var _77 : Core_Option_Option_Type.t_option (slice int32);
  var _78 : Core_Option_Option_Type.t_option (slice int32);
  var _79 : slice int32;
  var _80 : slice int32;
  var _81 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _82 : Core_Ops_Range_Range_Type.t_range usize;
  var _83 : ();
  var _84 : ();
  var _85 : bool;
  var _86 : bool;
  var _87 : Core_Option_Option_Type.t_option (slice int32);
  var _88 : Core_Option_Option_Type.t_option (slice int32);
  var _89 : slice int32;
  var _90 : slice int32;
  var _91 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _92 : Core_Ops_Range_Range_Type.t_range usize;
  var _93 : ();
  var _94 : ();
  var _95 : bool;
  var _96 : bool;
  var _97 : Core_Option_Option_Type.t_option (slice int32);
  var _98 : Core_Option_Option_Type.t_option (slice int32);
  var _99 : slice int32;
  var _100 : slice int32;
  var _101 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _102 : Core_Ops_Range_Range_Type.t_range usize;
  var _103 : ();
  var s_104 : borrowed (slice int32);
  var _105 : borrowed (slice int32);
  var _106 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _107 : Core_Ops_Range_Range_Type.t_range usize;
  var _108 : ();
  var _109 : bool;
  var _110 : bool;
  var _111 : usize;
  var _112 : slice int32;
  var _113 : ();
  var _114 : usize;
  var _115 : usize;
  var _116 : bool;
  var _117 : usize;
  var _118 : usize;
  var _119 : bool;
  var _120 : ();
  var _121 : bool;
  var _122 : bool;
  var _123 : int32;
  var _124 : usize;
  var _125 : usize;
  var _126 : bool;
  var _127 : ();
  var _128 : ();
  var _129 : bool;
  var _130 : bool;
  var _131 : usize;
  var _132 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _133 : ();
  var _134 : ();
  var _135 : bool;
  var _136 : bool;
  var _137 : int32;
  var _138 : int32;
  var _139 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _140 : ();
  var _141 : ();
  var _142 : bool;
  var _143 : bool;
  var _144 : int32;
  var _145 : int32;
  var _146 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _147 : ();
  var _148 : ();
  var _149 : bool;
  var _150 : bool;
  var _151 : int32;
  var _152 : int32;
  var _153 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _154 : ();
  var _155 : ();
  var _156 : bool;
  var _157 : bool;
  var _158 : int32;
  var _159 : int32;
  var _160 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _161 : ();
  var _162 : ();
  var _163 : bool;
  var _164 : bool;
  var _165 : int32;
  var _166 : int32;
  var _167 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _168 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 29 18 29 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 34 17 34 18] (0 : usize)) ([#"../index_range.rs" 34 20 34 21] (2 : usize));
    _3 <- ([#"../index_range.rs" 34 13 34 22] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 35 12 35 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 35 12 35 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 35 43 35 44] (1 : usize));
    _21 <- Slice.length s_2;
    _22 <- ([#"../index_range.rs" 35 41 35 45] _20 < _21);
    assert { [@expl:index in bounds] [#"../index_range.rs" 35 41 35 45] _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 35 12 35 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 35 30 35 31] (0 : usize));
    _16 <- Slice.length s_2;
    _17 <- ([#"../index_range.rs" 35 28 35 32] _15 < _16);
    assert { [@expl:index in bounds] [#"../index_range.rs" 35 28 35 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 35 12 35 24] _11 = ([#"../index_range.rs" 35 23 35 24] (2 : usize)));
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _14 <- Slice.get s_2 _15;
    _13 <- ([#"../index_range.rs" 35 28 35 37] _14 = ([#"../index_range.rs" 35 36 35 37] (0 : int32)));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Slice.get s_2 _20;
    _18 <- ([#"../index_range.rs" 35 41 35 50] _19 = ([#"../index_range.rs" 35 49 35 50] (1 : int32)));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB13 {
    _6 <- ();
    _26 <- arr_1;
    _27 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 37 17 37 18] (3 : usize)) ([#"../index_range.rs" 37 20 37 21] (5 : usize));
    _25 <- ([#"../index_range.rs" 37 13 37 22] Index0.index _26 _27);
    goto BB14
  }
  BB14 {
    s_24 <- _25;
    _34 <- s_24;
    _33 <- ([#"../index_range.rs" 38 12 38 19] Len0.len _34);
    goto BB21
  }
  BB15 {
    _30 <- ([#"../index_range.rs" 38 12 38 50] false);
    goto BB17
  }
  BB16 {
    _42 <- ([#"../index_range.rs" 38 43 38 44] (1 : usize));
    _43 <- Slice.length s_24;
    _44 <- ([#"../index_range.rs" 38 41 38 45] _42 < _43);
    assert { [@expl:index in bounds] [#"../index_range.rs" 38 41 38 45] _44 };
    goto BB23
  }
  BB17 {
    _29 <- not _30;
    switch (_29)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB18 {
    _31 <- ([#"../index_range.rs" 38 12 38 37] false);
    goto BB20
  }
  BB19 {
    _37 <- ([#"../index_range.rs" 38 30 38 31] (0 : usize));
    _38 <- Slice.length s_24;
    _39 <- ([#"../index_range.rs" 38 28 38 32] _37 < _38);
    assert { [@expl:index in bounds] [#"../index_range.rs" 38 28 38 32] _39 };
    goto BB22
  }
  BB20 {
    switch (_31)
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB21 {
    _32 <- ([#"../index_range.rs" 38 12 38 24] _33 = ([#"../index_range.rs" 38 23 38 24] (2 : usize)));
    switch (_32)
      | False -> goto BB18
      | True -> goto BB19
      end
  }
  BB22 {
    _36 <- Slice.get s_24 _37;
    _35 <- ([#"../index_range.rs" 38 28 38 37] _36 = ([#"../index_range.rs" 38 36 38 37] (3 : int32)));
    _31 <- _35;
    _35 <- any bool;
    goto BB20
  }
  BB23 {
    _41 <- Slice.get s_24 _42;
    _40 <- ([#"../index_range.rs" 38 41 38 50] _41 = ([#"../index_range.rs" 38 49 38 50] (4 : int32)));
    _30 <- _40;
    _40 <- any bool;
    goto BB17
  }
  BB24 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB25 {
    _28 <- ();
    _52 <- arr_1;
    _53 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 43 16 43 17] (2 : usize)) ([#"../index_range.rs" 43 19 43 20] (2 : usize));
    _51 <- ([#"../index_range.rs" 43 12 43 21] Index0.index _52 _53);
    goto BB26
  }
  BB26 {
    _50 <- _51;
    _49 <- ([#"../index_range.rs" 43 12 43 27] Len0.len _50);
    goto BB27
  }
  BB27 {
    _48 <- ([#"../index_range.rs" 43 12 43 32] _49 = ([#"../index_range.rs" 43 31 43 32] (0 : usize)));
    _47 <- not _48;
    switch (_47)
      | False -> goto BB29
      | True -> goto BB28
      end
  }
  BB28 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB29 {
    _46 <- ();
    _61 <- arr_1;
    _62 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 45 16 45 17] (5 : usize)) ([#"../index_range.rs" 45 19 45 20] (5 : usize));
    _60 <- ([#"../index_range.rs" 45 12 45 21] Index0.index _61 _62);
    goto BB30
  }
  BB30 {
    _59 <- _60;
    _58 <- ([#"../index_range.rs" 45 12 45 27] Len0.len _59);
    goto BB31
  }
  BB31 {
    _57 <- ([#"../index_range.rs" 45 12 45 32] _58 = ([#"../index_range.rs" 45 31 45 32] (0 : usize)));
    _56 <- not _57;
    switch (_56)
      | False -> goto BB33
      | True -> goto BB32
      end
  }
  BB32 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB33 {
    _55 <- ();
    _71 <- arr_1;
    _70 <- ([#"../index_range.rs" 50 12 50 25] Deref0.deref _71);
    goto BB34
  }
  BB34 {
    _69 <- _70;
    _72 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 50 20 50 21] (2 : usize)) ([#"../index_range.rs" 50 23 50 24] (6 : usize));
    _68 <- ([#"../index_range.rs" 50 12 50 25] Get0.get _69 _72);
    goto BB35
  }
  BB35 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 50 12 50 35] IsNone0.is_none _67);
    goto BB36
  }
  BB36 {
    _65 <- not _66;
    switch (_65)
      | False -> goto BB38
      | True -> goto BB37
      end
  }
  BB37 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB38 {
    _64 <- ();
    _81 <- arr_1;
    _80 <- ([#"../index_range.rs" 52 12 52 25] Deref0.deref _81);
    goto BB39
  }
  BB39 {
    _79 <- _80;
    _82 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 52 20 52 21] (2 : usize)) ([#"../index_range.rs" 52 23 52 24] (1 : usize));
    _78 <- ([#"../index_range.rs" 52 12 52 25] Get0.get _79 _82);
    goto BB40
  }
  BB40 {
    _77 <- _78;
    _76 <- ([#"../index_range.rs" 52 12 52 35] IsNone0.is_none _77);
    goto BB41
  }
  BB41 {
    _75 <- not _76;
    switch (_75)
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB43 {
    _74 <- ();
    _91 <- arr_1;
    _90 <- ([#"../index_range.rs" 54 12 54 25] Deref0.deref _91);
    goto BB44
  }
  BB44 {
    _89 <- _90;
    _92 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 54 20 54 21] (6 : usize)) ([#"../index_range.rs" 54 23 54 24] (6 : usize));
    _88 <- ([#"../index_range.rs" 54 12 54 25] Get0.get _89 _92);
    goto BB45
  }
  BB45 {
    _87 <- _88;
    _86 <- ([#"../index_range.rs" 54 12 54 35] IsNone0.is_none _87);
    goto BB46
  }
  BB46 {
    _85 <- not _86;
    switch (_85)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB48 {
    _84 <- ();
    _101 <- arr_1;
    _100 <- ([#"../index_range.rs" 56 12 56 27] Deref0.deref _101);
    goto BB49
  }
  BB49 {
    _99 <- _100;
    _102 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 56 20 56 22] (10 : usize)) ([#"../index_range.rs" 56 24 56 26] (10 : usize));
    _98 <- ([#"../index_range.rs" 56 12 56 27] Get0.get _99 _102);
    goto BB50
  }
  BB50 {
    _97 <- _98;
    _96 <- ([#"../index_range.rs" 56 12 56 37] IsNone0.is_none _97);
    goto BB51
  }
  BB51 {
    _95 <- not _96;
    switch (_95)
      | False -> goto BB53
      | True -> goto BB52
      end
  }
  BB52 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB53 {
    _94 <- ();
    _106 <- borrow_mut arr_1;
    arr_1 <-  ^ _106;
    _107 <- Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 59 21 59 22] (1 : usize)) ([#"../index_range.rs" 59 24 59 25] (4 : usize));
    _105 <- ([#"../index_range.rs" 59 17 59 26] IndexMut0.index_mut _106 _107);
    goto BB54
  }
  BB54 {
    s_104 <- borrow_mut ( * _105);
    _105 <- { _105 with current = ( ^ s_104) };
    _112 <-  * s_104;
    _111 <- ([#"../index_range.rs" 60 12 60 19] Len0.len _112);
    goto BB55
  }
  BB55 {
    _110 <- ([#"../index_range.rs" 60 12 60 24] _111 = ([#"../index_range.rs" 60 23 60 24] (3 : usize)));
    _109 <- not _110;
    switch (_109)
      | False -> goto BB57
      | True -> goto BB56
      end
  }
  BB56 {
    assume { Resolve1.resolve s_104 };
    assume { Resolve0.resolve arr_1 };
    assume { Resolve1.resolve _105 };
    absurd
  }
  BB57 {
    _108 <- ();
    _114 <- ([#"../index_range.rs" 61 6 61 7] (0 : usize));
    _115 <- Slice.length ( * s_104);
    _116 <- ([#"../index_range.rs" 61 4 61 8] _114 < _115);
    assert { [@expl:index in bounds] [#"../index_range.rs" 61 4 61 8] _116 };
    goto BB58
  }
  BB58 {
    s_104 <- { s_104 with current = Slice.set ( * s_104) _114 ([#"../index_range.rs" 61 11 61 13] (-1 : int32)) };
    _117 <- ([#"../index_range.rs" 62 6 62 7] (1 : usize));
    _118 <- Slice.length ( * s_104);
    _119 <- ([#"../index_range.rs" 62 4 62 8] _117 < _118);
    assert { [@expl:index in bounds] [#"../index_range.rs" 62 4 62 8] _119 };
    goto BB59
  }
  BB59 {
    s_104 <- { s_104 with current = Slice.set ( * s_104) _117 ([#"../index_range.rs" 62 11 62 13] (-1 : int32)) };
    _124 <- ([#"../index_range.rs" 67 14 67 15] (2 : usize));
    _125 <- Slice.length ( * s_104);
    _126 <- ([#"../index_range.rs" 67 12 67 16] _124 < _125);
    assert { [@expl:index in bounds] [#"../index_range.rs" 67 12 67 16] _126 };
    goto BB60
  }
  BB60 {
    _123 <- Slice.get ( * s_104) _124;
    assume { Resolve1.resolve s_104 };
    _122 <- ([#"../index_range.rs" 67 12 67 21] _123 = ([#"../index_range.rs" 67 20 67 21] (3 : int32)));
    assume { Resolve1.resolve _105 };
    _121 <- not _122;
    switch (_121)
      | False -> goto BB62
      | True -> goto BB61
      end
  }
  BB61 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB62 {
    _120 <- ();
    _132 <- arr_1;
    _131 <- ([#"../index_range.rs" 69 12 69 21] Len1.len _132);
    goto BB63
  }
  BB63 {
    _130 <- ([#"../index_range.rs" 69 12 69 26] _131 = ([#"../index_range.rs" 69 25 69 26] (5 : usize)));
    _129 <- not _130;
    switch (_129)
      | False -> goto BB65
      | True -> goto BB64
      end
  }
  BB64 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB65 {
    _128 <- ();
    _139 <- arr_1;
    _138 <- ([#"../index_range.rs" 70 12 70 18] Index1.index _139 ([#"../index_range.rs" 70 16 70 17] (0 : usize)));
    goto BB66
  }
  BB66 {
    _137 <- _138;
    _136 <- ([#"../index_range.rs" 70 12 70 23] _137 = ([#"../index_range.rs" 70 22 70 23] (0 : int32)));
    _135 <- not _136;
    switch (_135)
      | False -> goto BB68
      | True -> goto BB67
      end
  }
  BB67 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB68 {
    _134 <- ();
    _146 <- arr_1;
    _145 <- ([#"../index_range.rs" 71 12 71 18] Index1.index _146 ([#"../index_range.rs" 71 16 71 17] (1 : usize)));
    goto BB69
  }
  BB69 {
    _144 <- _145;
    _143 <- ([#"../index_range.rs" 71 12 71 24] _144 = ([#"../index_range.rs" 71 22 71 24] (-1 : int32)));
    _142 <- not _143;
    switch (_142)
      | False -> goto BB71
      | True -> goto BB70
      end
  }
  BB70 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB71 {
    _141 <- ();
    _153 <- arr_1;
    _152 <- ([#"../index_range.rs" 72 12 72 18] Index1.index _153 ([#"../index_range.rs" 72 16 72 17] (2 : usize)));
    goto BB72
  }
  BB72 {
    _151 <- _152;
    _150 <- ([#"../index_range.rs" 72 12 72 24] _151 = ([#"../index_range.rs" 72 22 72 24] (-1 : int32)));
    _149 <- not _150;
    switch (_149)
      | False -> goto BB74
      | True -> goto BB73
      end
  }
  BB73 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB74 {
    _148 <- ();
    _160 <- arr_1;
    _159 <- ([#"../index_range.rs" 73 12 73 18] Index1.index _160 ([#"../index_range.rs" 73 16 73 17] (3 : usize)));
    goto BB75
  }
  BB75 {
    _158 <- _159;
    _157 <- ([#"../index_range.rs" 73 12 73 23] _158 = ([#"../index_range.rs" 73 22 73 23] (3 : int32)));
    _156 <- not _157;
    switch (_156)
      | False -> goto BB77
      | True -> goto BB76
      end
  }
  BB76 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB77 {
    _155 <- ();
    _167 <- arr_1;
    _166 <- ([#"../index_range.rs" 74 12 74 18] Index1.index _167 ([#"../index_range.rs" 74 16 74 17] (4 : usize)));
    goto BB78
  }
  BB78 {
    _165 <- _166;
    assume { Resolve0.resolve arr_1 };
    _164 <- ([#"../index_range.rs" 74 12 74 23] _165 = ([#"../index_range.rs" 74 22 74 23] (4 : int32)));
    _163 <- not _164;
    switch (_163)
      | False -> goto BB80
      | True -> goto BB79
      end
  }
  BB79 {
    absurd
  }
  BB80 {
    _162 <- ();
    _0 <- ();
    goto BB81
  }
  BB81 {
    return _0
  }
  
end
module Core_Ops_Range_RangeTo_Type
  type t_rangeto 'idx =
    | C_RangeTo 'idx
    
  let function rangeto_end (self : t_rangeto 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeTo a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl7_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 141 20 141 42] UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl7_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl7_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl7_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 146 20 146 57] SeqExt.subsequence seq 0 (UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self)) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 151 8 151 90] forall i : int . UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self) <= i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeTo_Interface
  val test_range_to [#"../index_range.rs" 78 0 78 22] (_1' : ()) : ()
end
module IndexRange_TestRangeTo
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel4 with
    type t = int32,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  clone CreusotContracts_Std1_Slice_Impl7_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl7_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl7_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate HasValue0.has_value = HasValue1.has_value,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice int32
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = slice int32,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl9_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_to [#"../index_range.rs" 78 0 78 22] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s_2 : slice int32;
  var _3 : slice int32;
  var _4 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _5 : Core_Ops_Range_RangeTo_Type.t_rangeto usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : slice int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : usize;
  var _28 : slice int32;
  var _29 : slice int32;
  var _30 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _31 : Core_Ops_Range_RangeTo_Type.t_rangeto usize;
  var _32 : ();
  var _33 : ();
  var _34 : bool;
  var _35 : bool;
  var _36 : Core_Option_Option_Type.t_option (slice int32);
  var _37 : Core_Option_Option_Type.t_option (slice int32);
  var _38 : slice int32;
  var _39 : slice int32;
  var _40 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _41 : Core_Ops_Range_RangeTo_Type.t_rangeto usize;
  var _42 : ();
  var s_43 : borrowed (slice int32);
  var _44 : borrowed (slice int32);
  var _45 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _46 : Core_Ops_Range_RangeTo_Type.t_rangeto usize;
  var _47 : ();
  var _48 : bool;
  var _49 : bool;
  var _50 : usize;
  var _51 : slice int32;
  var _52 : ();
  var _53 : usize;
  var _54 : usize;
  var _55 : bool;
  var _56 : usize;
  var _57 : usize;
  var _58 : bool;
  var _59 : ();
  var _60 : bool;
  var _61 : bool;
  var _62 : int32;
  var _63 : usize;
  var _64 : usize;
  var _65 : bool;
  var _66 : ();
  var _67 : ();
  var _68 : bool;
  var _69 : bool;
  var _70 : usize;
  var _71 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _72 : ();
  var _73 : ();
  var _74 : bool;
  var _75 : bool;
  var _76 : int32;
  var _77 : int32;
  var _78 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _79 : ();
  var _80 : ();
  var _81 : bool;
  var _82 : bool;
  var _83 : int32;
  var _84 : int32;
  var _85 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _86 : ();
  var _87 : ();
  var _88 : bool;
  var _89 : bool;
  var _90 : int32;
  var _91 : int32;
  var _92 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _93 : ();
  var _94 : ();
  var _95 : bool;
  var _96 : bool;
  var _97 : int32;
  var _98 : int32;
  var _99 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _100 : ();
  var _101 : ();
  var _102 : bool;
  var _103 : bool;
  var _104 : int32;
  var _105 : int32;
  var _106 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _107 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 80 18 80 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 85 19 85 20] (2 : usize));
    _3 <- ([#"../index_range.rs" 85 13 85 21] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 86 12 86 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 86 12 86 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 86 43 86 44] (1 : usize));
    _21 <- Slice.length s_2;
    _22 <- ([#"../index_range.rs" 86 41 86 45] _20 < _21);
    assert { [@expl:index in bounds] [#"../index_range.rs" 86 41 86 45] _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 86 12 86 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 86 30 86 31] (0 : usize));
    _16 <- Slice.length s_2;
    _17 <- ([#"../index_range.rs" 86 28 86 32] _15 < _16);
    assert { [@expl:index in bounds] [#"../index_range.rs" 86 28 86 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 86 12 86 24] _11 = ([#"../index_range.rs" 86 23 86 24] (2 : usize)));
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _14 <- Slice.get s_2 _15;
    _13 <- ([#"../index_range.rs" 86 28 86 37] _14 = ([#"../index_range.rs" 86 36 86 37] (0 : int32)));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Slice.get s_2 _20;
    _18 <- ([#"../index_range.rs" 86 41 86 50] _19 = ([#"../index_range.rs" 86 49 86 50] (1 : int32)));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB13 {
    _6 <- ();
    _30 <- arr_1;
    _31 <- Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 91 18 91 19] (0 : usize));
    _29 <- ([#"../index_range.rs" 91 12 91 20] Index0.index _30 _31);
    goto BB14
  }
  BB14 {
    _28 <- _29;
    _27 <- ([#"../index_range.rs" 91 12 91 26] Len0.len _28);
    goto BB15
  }
  BB15 {
    _26 <- ([#"../index_range.rs" 91 12 91 31] _27 = ([#"../index_range.rs" 91 30 91 31] (0 : usize)));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB17 {
    _24 <- ();
    _40 <- arr_1;
    _39 <- ([#"../index_range.rs" 96 12 96 24] Deref0.deref _40);
    goto BB18
  }
  BB18 {
    _38 <- _39;
    _41 <- Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 96 22 96 23] (6 : usize));
    _37 <- ([#"../index_range.rs" 96 12 96 24] Get0.get _38 _41);
    goto BB19
  }
  BB19 {
    _36 <- _37;
    _35 <- ([#"../index_range.rs" 96 12 96 34] IsNone0.is_none _36);
    goto BB20
  }
  BB20 {
    _34 <- not _35;
    switch (_34)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB22 {
    _33 <- ();
    _45 <- borrow_mut arr_1;
    arr_1 <-  ^ _45;
    _46 <- Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 99 23 99 24] (3 : usize));
    _44 <- ([#"../index_range.rs" 99 17 99 25] IndexMut0.index_mut _45 _46);
    goto BB23
  }
  BB23 {
    s_43 <- borrow_mut ( * _44);
    _44 <- { _44 with current = ( ^ s_43) };
    _51 <-  * s_43;
    _50 <- ([#"../index_range.rs" 100 12 100 19] Len0.len _51);
    goto BB24
  }
  BB24 {
    _49 <- ([#"../index_range.rs" 100 12 100 24] _50 = ([#"../index_range.rs" 100 23 100 24] (3 : usize)));
    _48 <- not _49;
    switch (_48)
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    assume { Resolve1.resolve s_43 };
    assume { Resolve0.resolve arr_1 };
    assume { Resolve1.resolve _44 };
    absurd
  }
  BB26 {
    _47 <- ();
    _53 <- ([#"../index_range.rs" 101 6 101 7] (0 : usize));
    _54 <- Slice.length ( * s_43);
    _55 <- ([#"../index_range.rs" 101 4 101 8] _53 < _54);
    assert { [@expl:index in bounds] [#"../index_range.rs" 101 4 101 8] _55 };
    goto BB27
  }
  BB27 {
    s_43 <- { s_43 with current = Slice.set ( * s_43) _53 ([#"../index_range.rs" 101 11 101 13] (-1 : int32)) };
    _56 <- ([#"../index_range.rs" 102 6 102 7] (2 : usize));
    _57 <- Slice.length ( * s_43);
    _58 <- ([#"../index_range.rs" 102 4 102 8] _56 < _57);
    assert { [@expl:index in bounds] [#"../index_range.rs" 102 4 102 8] _58 };
    goto BB28
  }
  BB28 {
    s_43 <- { s_43 with current = Slice.set ( * s_43) _56 ([#"../index_range.rs" 102 11 102 13] (-1 : int32)) };
    _63 <- ([#"../index_range.rs" 104 14 104 15] (1 : usize));
    _64 <- Slice.length ( * s_43);
    _65 <- ([#"../index_range.rs" 104 12 104 16] _63 < _64);
    assert { [@expl:index in bounds] [#"../index_range.rs" 104 12 104 16] _65 };
    goto BB29
  }
  BB29 {
    _62 <- Slice.get ( * s_43) _63;
    assume { Resolve1.resolve s_43 };
    _61 <- ([#"../index_range.rs" 104 12 104 21] _62 = ([#"../index_range.rs" 104 20 104 21] (1 : int32)));
    assume { Resolve1.resolve _44 };
    _60 <- not _61;
    switch (_60)
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB31 {
    _59 <- ();
    _71 <- arr_1;
    _70 <- ([#"../index_range.rs" 106 12 106 21] Len1.len _71);
    goto BB32
  }
  BB32 {
    _69 <- ([#"../index_range.rs" 106 12 106 26] _70 = ([#"../index_range.rs" 106 25 106 26] (5 : usize)));
    _68 <- not _69;
    switch (_68)
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB34 {
    _67 <- ();
    _78 <- arr_1;
    _77 <- ([#"../index_range.rs" 107 12 107 18] Index1.index _78 ([#"../index_range.rs" 107 16 107 17] (0 : usize)));
    goto BB35
  }
  BB35 {
    _76 <- _77;
    _75 <- ([#"../index_range.rs" 107 12 107 24] _76 = ([#"../index_range.rs" 107 22 107 24] (-1 : int32)));
    _74 <- not _75;
    switch (_74)
      | False -> goto BB37
      | True -> goto BB36
      end
  }
  BB36 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB37 {
    _73 <- ();
    _85 <- arr_1;
    _84 <- ([#"../index_range.rs" 108 12 108 18] Index1.index _85 ([#"../index_range.rs" 108 16 108 17] (1 : usize)));
    goto BB38
  }
  BB38 {
    _83 <- _84;
    _82 <- ([#"../index_range.rs" 108 12 108 23] _83 = ([#"../index_range.rs" 108 22 108 23] (1 : int32)));
    _81 <- not _82;
    switch (_81)
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB40 {
    _80 <- ();
    _92 <- arr_1;
    _91 <- ([#"../index_range.rs" 109 12 109 18] Index1.index _92 ([#"../index_range.rs" 109 16 109 17] (2 : usize)));
    goto BB41
  }
  BB41 {
    _90 <- _91;
    _89 <- ([#"../index_range.rs" 109 12 109 24] _90 = ([#"../index_range.rs" 109 22 109 24] (-1 : int32)));
    _88 <- not _89;
    switch (_88)
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB43 {
    _87 <- ();
    _99 <- arr_1;
    _98 <- ([#"../index_range.rs" 110 12 110 18] Index1.index _99 ([#"../index_range.rs" 110 16 110 17] (3 : usize)));
    goto BB44
  }
  BB44 {
    _97 <- _98;
    _96 <- ([#"../index_range.rs" 110 12 110 23] _97 = ([#"../index_range.rs" 110 22 110 23] (3 : int32)));
    _95 <- not _96;
    switch (_95)
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB46 {
    _94 <- ();
    _106 <- arr_1;
    _105 <- ([#"../index_range.rs" 111 12 111 18] Index1.index _106 ([#"../index_range.rs" 111 16 111 17] (4 : usize)));
    goto BB47
  }
  BB47 {
    _104 <- _105;
    assume { Resolve0.resolve arr_1 };
    _103 <- ([#"../index_range.rs" 111 12 111 23] _104 = ([#"../index_range.rs" 111 22 111 23] (4 : int32)));
    _102 <- not _103;
    switch (_102)
      | False -> goto BB49
      | True -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _101 <- ();
    _0 <- ();
    goto BB50
  }
  BB50 {
    return _0
  }
  
end
module Core_Ops_Range_RangeFrom_Type
  type t_rangefrom 'idx =
    | C_RangeFrom 'idx
    
  let function rangefrom_start (self : t_rangefrom 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeFrom a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl8_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl8_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl8_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 158 20 158 44] UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl8_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl8_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl8_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 163 20 163 67] SeqExt.subsequence seq (UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self)) (Seq.length seq) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 168 8 170 9] forall i : int . 0 <= i /\ i < UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeFrom_Interface
  val test_range_from [#"../index_range.rs" 115 0 115 24] (_1' : ()) : ()
end
module IndexRange_TestRangeFrom
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel4 with
    type t = int32,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  clone CreusotContracts_Std1_Slice_Impl8_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl8_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl8_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate HasValue0.has_value = HasValue1.has_value,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice int32
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = slice int32,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl9_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_from [#"../index_range.rs" 115 0 115 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s_2 : slice int32;
  var _3 : slice int32;
  var _4 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _5 : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : slice int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : usize;
  var _28 : slice int32;
  var _29 : slice int32;
  var _30 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _31 : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize;
  var _32 : ();
  var _33 : ();
  var _34 : bool;
  var _35 : bool;
  var _36 : Core_Option_Option_Type.t_option (slice int32);
  var _37 : Core_Option_Option_Type.t_option (slice int32);
  var _38 : slice int32;
  var _39 : slice int32;
  var _40 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _41 : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize;
  var _42 : ();
  var _43 : ();
  var _44 : bool;
  var _45 : bool;
  var _46 : Core_Option_Option_Type.t_option (slice int32);
  var _47 : Core_Option_Option_Type.t_option (slice int32);
  var _48 : slice int32;
  var _49 : slice int32;
  var _50 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _51 : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize;
  var _52 : ();
  var s_53 : borrowed (slice int32);
  var _54 : borrowed (slice int32);
  var _55 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _56 : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize;
  var _57 : ();
  var _58 : bool;
  var _59 : bool;
  var _60 : usize;
  var _61 : slice int32;
  var _62 : ();
  var _63 : usize;
  var _64 : usize;
  var _65 : bool;
  var _66 : usize;
  var _67 : usize;
  var _68 : bool;
  var _69 : ();
  var _70 : bool;
  var _71 : bool;
  var _72 : int32;
  var _73 : usize;
  var _74 : usize;
  var _75 : bool;
  var _76 : ();
  var _77 : ();
  var _78 : bool;
  var _79 : bool;
  var _80 : usize;
  var _81 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _82 : ();
  var _83 : ();
  var _84 : bool;
  var _85 : bool;
  var _86 : int32;
  var _87 : int32;
  var _88 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _89 : ();
  var _90 : ();
  var _91 : bool;
  var _92 : bool;
  var _93 : int32;
  var _94 : int32;
  var _95 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _96 : ();
  var _97 : ();
  var _98 : bool;
  var _99 : bool;
  var _100 : int32;
  var _101 : int32;
  var _102 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _103 : ();
  var _104 : ();
  var _105 : bool;
  var _106 : bool;
  var _107 : int32;
  var _108 : int32;
  var _109 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _110 : ();
  var _111 : ();
  var _112 : bool;
  var _113 : bool;
  var _114 : int32;
  var _115 : int32;
  var _116 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _117 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 117 18 117 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 122 17 122 18] (3 : usize));
    _3 <- ([#"../index_range.rs" 122 13 122 21] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 123 12 123 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 123 12 123 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 123 43 123 44] (1 : usize));
    _21 <- Slice.length s_2;
    _22 <- ([#"../index_range.rs" 123 41 123 45] _20 < _21);
    assert { [@expl:index in bounds] [#"../index_range.rs" 123 41 123 45] _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 123 12 123 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 123 30 123 31] (0 : usize));
    _16 <- Slice.length s_2;
    _17 <- ([#"../index_range.rs" 123 28 123 32] _15 < _16);
    assert { [@expl:index in bounds] [#"../index_range.rs" 123 28 123 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 123 12 123 24] _11 = ([#"../index_range.rs" 123 23 123 24] (2 : usize)));
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _14 <- Slice.get s_2 _15;
    _13 <- ([#"../index_range.rs" 123 28 123 37] _14 = ([#"../index_range.rs" 123 36 123 37] (3 : int32)));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Slice.get s_2 _20;
    _18 <- ([#"../index_range.rs" 123 41 123 50] _19 = ([#"../index_range.rs" 123 49 123 50] (4 : int32)));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB13 {
    _6 <- ();
    _30 <- arr_1;
    _31 <- Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 128 16 128 17] (5 : usize));
    _29 <- ([#"../index_range.rs" 128 12 128 20] Index0.index _30 _31);
    goto BB14
  }
  BB14 {
    _28 <- _29;
    _27 <- ([#"../index_range.rs" 128 12 128 26] Len0.len _28);
    goto BB15
  }
  BB15 {
    _26 <- ([#"../index_range.rs" 128 12 128 31] _27 = ([#"../index_range.rs" 128 30 128 31] (0 : usize)));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB17 {
    _24 <- ();
    _40 <- arr_1;
    _39 <- ([#"../index_range.rs" 133 12 133 24] Deref0.deref _40);
    goto BB18
  }
  BB18 {
    _38 <- _39;
    _41 <- Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 133 20 133 21] (6 : usize));
    _37 <- ([#"../index_range.rs" 133 12 133 24] Get0.get _38 _41);
    goto BB19
  }
  BB19 {
    _36 <- _37;
    _35 <- ([#"../index_range.rs" 133 12 133 34] IsNone0.is_none _36);
    goto BB20
  }
  BB20 {
    _34 <- not _35;
    switch (_34)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB22 {
    _33 <- ();
    _50 <- arr_1;
    _49 <- ([#"../index_range.rs" 135 12 135 25] Deref0.deref _50);
    goto BB23
  }
  BB23 {
    _48 <- _49;
    _51 <- Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 135 20 135 22] (10 : usize));
    _47 <- ([#"../index_range.rs" 135 12 135 25] Get0.get _48 _51);
    goto BB24
  }
  BB24 {
    _46 <- _47;
    _45 <- ([#"../index_range.rs" 135 12 135 35] IsNone0.is_none _46);
    goto BB25
  }
  BB25 {
    _44 <- not _45;
    switch (_44)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB27 {
    _43 <- ();
    _55 <- borrow_mut arr_1;
    arr_1 <-  ^ _55;
    _56 <- Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 138 21 138 22] (2 : usize));
    _54 <- ([#"../index_range.rs" 138 17 138 25] IndexMut0.index_mut _55 _56);
    goto BB28
  }
  BB28 {
    s_53 <- borrow_mut ( * _54);
    _54 <- { _54 with current = ( ^ s_53) };
    _61 <-  * s_53;
    _60 <- ([#"../index_range.rs" 139 12 139 19] Len0.len _61);
    goto BB29
  }
  BB29 {
    _59 <- ([#"../index_range.rs" 139 12 139 24] _60 = ([#"../index_range.rs" 139 23 139 24] (3 : usize)));
    _58 <- not _59;
    switch (_58)
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    assume { Resolve1.resolve s_53 };
    assume { Resolve0.resolve arr_1 };
    assume { Resolve1.resolve _54 };
    absurd
  }
  BB31 {
    _57 <- ();
    _63 <- ([#"../index_range.rs" 140 6 140 7] (0 : usize));
    _64 <- Slice.length ( * s_53);
    _65 <- ([#"../index_range.rs" 140 4 140 8] _63 < _64);
    assert { [@expl:index in bounds] [#"../index_range.rs" 140 4 140 8] _65 };
    goto BB32
  }
  BB32 {
    s_53 <- { s_53 with current = Slice.set ( * s_53) _63 ([#"../index_range.rs" 140 11 140 13] (-1 : int32)) };
    _66 <- ([#"../index_range.rs" 141 6 141 7] (1 : usize));
    _67 <- Slice.length ( * s_53);
    _68 <- ([#"../index_range.rs" 141 4 141 8] _66 < _67);
    assert { [@expl:index in bounds] [#"../index_range.rs" 141 4 141 8] _68 };
    goto BB33
  }
  BB33 {
    s_53 <- { s_53 with current = Slice.set ( * s_53) _66 ([#"../index_range.rs" 141 11 141 13] (-1 : int32)) };
    _73 <- ([#"../index_range.rs" 143 14 143 15] (2 : usize));
    _74 <- Slice.length ( * s_53);
    _75 <- ([#"../index_range.rs" 143 12 143 16] _73 < _74);
    assert { [@expl:index in bounds] [#"../index_range.rs" 143 12 143 16] _75 };
    goto BB34
  }
  BB34 {
    _72 <- Slice.get ( * s_53) _73;
    assume { Resolve1.resolve s_53 };
    _71 <- ([#"../index_range.rs" 143 12 143 21] _72 = ([#"../index_range.rs" 143 20 143 21] (4 : int32)));
    assume { Resolve1.resolve _54 };
    _70 <- not _71;
    switch (_70)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB36 {
    _69 <- ();
    _81 <- arr_1;
    _80 <- ([#"../index_range.rs" 145 12 145 21] Len1.len _81);
    goto BB37
  }
  BB37 {
    _79 <- ([#"../index_range.rs" 145 12 145 26] _80 = ([#"../index_range.rs" 145 25 145 26] (5 : usize)));
    _78 <- not _79;
    switch (_78)
      | False -> goto BB39
      | True -> goto BB38
      end
  }
  BB38 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB39 {
    _77 <- ();
    _88 <- arr_1;
    _87 <- ([#"../index_range.rs" 146 12 146 18] Index1.index _88 ([#"../index_range.rs" 146 16 146 17] (0 : usize)));
    goto BB40
  }
  BB40 {
    _86 <- _87;
    _85 <- ([#"../index_range.rs" 146 12 146 23] _86 = ([#"../index_range.rs" 146 22 146 23] (0 : int32)));
    _84 <- not _85;
    switch (_84)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB42 {
    _83 <- ();
    _95 <- arr_1;
    _94 <- ([#"../index_range.rs" 147 12 147 18] Index1.index _95 ([#"../index_range.rs" 147 16 147 17] (1 : usize)));
    goto BB43
  }
  BB43 {
    _93 <- _94;
    _92 <- ([#"../index_range.rs" 147 12 147 23] _93 = ([#"../index_range.rs" 147 22 147 23] (1 : int32)));
    _91 <- not _92;
    switch (_91)
      | False -> goto BB45
      | True -> goto BB44
      end
  }
  BB44 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB45 {
    _90 <- ();
    _102 <- arr_1;
    _101 <- ([#"../index_range.rs" 148 12 148 18] Index1.index _102 ([#"../index_range.rs" 148 16 148 17] (2 : usize)));
    goto BB46
  }
  BB46 {
    _100 <- _101;
    _99 <- ([#"../index_range.rs" 148 12 148 24] _100 = ([#"../index_range.rs" 148 22 148 24] (-1 : int32)));
    _98 <- not _99;
    switch (_98)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB48 {
    _97 <- ();
    _109 <- arr_1;
    _108 <- ([#"../index_range.rs" 149 12 149 18] Index1.index _109 ([#"../index_range.rs" 149 16 149 17] (3 : usize)));
    goto BB49
  }
  BB49 {
    _107 <- _108;
    _106 <- ([#"../index_range.rs" 149 12 149 24] _107 = ([#"../index_range.rs" 149 22 149 24] (-1 : int32)));
    _105 <- not _106;
    switch (_105)
      | False -> goto BB51
      | True -> goto BB50
      end
  }
  BB50 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB51 {
    _104 <- ();
    _116 <- arr_1;
    _115 <- ([#"../index_range.rs" 150 12 150 18] Index1.index _116 ([#"../index_range.rs" 150 16 150 17] (4 : usize)));
    goto BB52
  }
  BB52 {
    _114 <- _115;
    assume { Resolve0.resolve arr_1 };
    _113 <- ([#"../index_range.rs" 150 12 150 23] _114 = ([#"../index_range.rs" 150 22 150 23] (4 : int32)));
    _112 <- not _113;
    switch (_112)
      | False -> goto BB54
      | True -> goto BB53
      end
  }
  BB53 {
    absurd
  }
  BB54 {
    _111 <- ();
    _0 <- ();
    goto BB55
  }
  BB55 {
    return _0
  }
  
end
module Core_Ops_Range_RangeFull_Type
  type t_rangefull  =
    | C_RangeFull
    
end
module CreusotContracts_Std1_Slice_Impl9_InBounds_Stub
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_InBounds_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_InBounds
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 177 20 177 24] true
  val in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t) : bool
    ensures { result = in_bounds self _seq }
    
end
module CreusotContracts_Std1_Slice_Impl9_HasValue_Stub
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl9_HasValue_Interface
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl9_HasValue
  type t
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 182 20 182 31] seq = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere_Stub
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 187 20 187 24] true
  val resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self _old _fin }
    
end
module IndexRange_TestRangeFull_Interface
  val test_range_full [#"../index_range.rs" 154 0 154 24] (_1' : ()) : ()
end
module IndexRange_TestRangeFull
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel4 with
    type t = int32,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  clone CreusotContracts_Std1_Slice_Impl9_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl9_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl9_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate HasValue0.has_value = HasValue1.has_value,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice int32
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFull_Type.t_rangefull,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = slice int32,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFull_Type.t_rangefull,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_full [#"../index_range.rs" 154 0 154 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s_2 : slice int32;
  var _3 : slice int32;
  var _4 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _5 : Core_Ops_Range_RangeFull_Type.t_rangefull;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : bool;
  var _12 : bool;
  var _13 : bool;
  var _14 : usize;
  var _15 : slice int32;
  var _16 : bool;
  var _17 : int32;
  var _18 : usize;
  var _19 : usize;
  var _20 : bool;
  var _21 : bool;
  var _22 : int32;
  var _23 : usize;
  var _24 : usize;
  var _25 : bool;
  var _26 : bool;
  var _27 : int32;
  var _28 : usize;
  var _29 : usize;
  var _30 : bool;
  var _31 : bool;
  var _32 : int32;
  var _33 : usize;
  var _34 : usize;
  var _35 : bool;
  var _36 : bool;
  var _37 : int32;
  var _38 : usize;
  var _39 : usize;
  var _40 : bool;
  var _41 : ();
  var s_42 : borrowed (slice int32);
  var _43 : borrowed (slice int32);
  var _44 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _45 : Core_Ops_Range_RangeFull_Type.t_rangefull;
  var _46 : ();
  var _47 : bool;
  var _48 : bool;
  var _49 : usize;
  var _50 : slice int32;
  var _51 : ();
  var _52 : usize;
  var _53 : usize;
  var _54 : bool;
  var _55 : usize;
  var _56 : usize;
  var _57 : bool;
  var _58 : ();
  var _59 : bool;
  var _60 : bool;
  var _61 : usize;
  var _62 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : int32;
  var _68 : int32;
  var _69 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _70 : ();
  var _71 : ();
  var _72 : bool;
  var _73 : bool;
  var _74 : int32;
  var _75 : int32;
  var _76 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _77 : ();
  var _78 : ();
  var _79 : bool;
  var _80 : bool;
  var _81 : int32;
  var _82 : int32;
  var _83 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _84 : ();
  var _85 : ();
  var _86 : bool;
  var _87 : bool;
  var _88 : int32;
  var _89 : int32;
  var _90 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _91 : ();
  var _92 : ();
  var _93 : bool;
  var _94 : bool;
  var _95 : int32;
  var _96 : int32;
  var _97 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _98 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 156 18 156 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeFull_Type.C_RangeFull;
    _3 <- ([#"../index_range.rs" 161 13 161 20] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _15 <- s_2;
    _14 <- ([#"../index_range.rs" 162 12 162 19] Len0.len _15);
    goto BB18
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 162 12 162 89] false);
    goto BB5
  }
  BB4 {
    _38 <- ([#"../index_range.rs" 162 82 162 83] (4 : usize));
    _39 <- Slice.length s_2;
    _40 <- ([#"../index_range.rs" 162 80 162 84] _38 < _39);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 80 162 84] _40 };
    goto BB23
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 162 12 162 76] false);
    goto BB8
  }
  BB7 {
    _33 <- ([#"../index_range.rs" 162 69 162 70] (3 : usize));
    _34 <- Slice.length s_2;
    _35 <- ([#"../index_range.rs" 162 67 162 71] _33 < _34);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 67 162 71] _35 };
    goto BB22
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 162 12 162 63] false);
    goto BB11
  }
  BB10 {
    _28 <- ([#"../index_range.rs" 162 56 162 57] (2 : usize));
    _29 <- Slice.length s_2;
    _30 <- ([#"../index_range.rs" 162 54 162 58] _28 < _29);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 54 162 58] _30 };
    goto BB21
  }
  BB11 {
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB12 {
    _11 <- ([#"../index_range.rs" 162 12 162 50] false);
    goto BB14
  }
  BB13 {
    _23 <- ([#"../index_range.rs" 162 43 162 44] (1 : usize));
    _24 <- Slice.length s_2;
    _25 <- ([#"../index_range.rs" 162 41 162 45] _23 < _24);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 41 162 45] _25 };
    goto BB20
  }
  BB14 {
    switch (_11)
      | False -> goto BB9
      | True -> goto BB10
      end
  }
  BB15 {
    _12 <- ([#"../index_range.rs" 162 12 162 37] false);
    goto BB17
  }
  BB16 {
    _18 <- ([#"../index_range.rs" 162 30 162 31] (0 : usize));
    _19 <- Slice.length s_2;
    _20 <- ([#"../index_range.rs" 162 28 162 32] _18 < _19);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 28 162 32] _20 };
    goto BB19
  }
  BB17 {
    switch (_12)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB18 {
    _13 <- ([#"../index_range.rs" 162 12 162 24] _14 = ([#"../index_range.rs" 162 23 162 24] (5 : usize)));
    switch (_13)
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB19 {
    _17 <- Slice.get s_2 _18;
    _16 <- ([#"../index_range.rs" 162 28 162 37] _17 = ([#"../index_range.rs" 162 36 162 37] (0 : int32)));
    _12 <- _16;
    _16 <- any bool;
    goto BB17
  }
  BB20 {
    _22 <- Slice.get s_2 _23;
    _21 <- ([#"../index_range.rs" 162 41 162 50] _22 = ([#"../index_range.rs" 162 49 162 50] (1 : int32)));
    _11 <- _21;
    _21 <- any bool;
    goto BB14
  }
  BB21 {
    _27 <- Slice.get s_2 _28;
    _26 <- ([#"../index_range.rs" 162 54 162 63] _27 = ([#"../index_range.rs" 162 62 162 63] (2 : int32)));
    _10 <- _26;
    _26 <- any bool;
    goto BB11
  }
  BB22 {
    _32 <- Slice.get s_2 _33;
    _31 <- ([#"../index_range.rs" 162 67 162 76] _32 = ([#"../index_range.rs" 162 75 162 76] (3 : int32)));
    _9 <- _31;
    _31 <- any bool;
    goto BB8
  }
  BB23 {
    _37 <- Slice.get s_2 _38;
    _36 <- ([#"../index_range.rs" 162 80 162 89] _37 = ([#"../index_range.rs" 162 88 162 89] (4 : int32)));
    _8 <- _36;
    _36 <- any bool;
    goto BB5
  }
  BB24 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB25 {
    _6 <- ();
    _44 <- borrow_mut arr_1;
    arr_1 <-  ^ _44;
    _45 <- Core_Ops_Range_RangeFull_Type.C_RangeFull;
    _43 <- ([#"../index_range.rs" 165 17 165 24] IndexMut0.index_mut _44 _45);
    goto BB26
  }
  BB26 {
    s_42 <- borrow_mut ( * _43);
    _43 <- { _43 with current = ( ^ s_42) };
    _50 <-  * s_42;
    _49 <- ([#"../index_range.rs" 166 12 166 19] Len0.len _50);
    goto BB27
  }
  BB27 {
    _48 <- ([#"../index_range.rs" 166 12 166 24] _49 = ([#"../index_range.rs" 166 23 166 24] (5 : usize)));
    _47 <- not _48;
    switch (_47)
      | False -> goto BB29
      | True -> goto BB28
      end
  }
  BB28 {
    assume { Resolve1.resolve s_42 };
    assume { Resolve0.resolve arr_1 };
    assume { Resolve1.resolve _43 };
    absurd
  }
  BB29 {
    _46 <- ();
    _52 <- ([#"../index_range.rs" 167 6 167 7] (1 : usize));
    _53 <- Slice.length ( * s_42);
    _54 <- ([#"../index_range.rs" 167 4 167 8] _52 < _53);
    assert { [@expl:index in bounds] [#"../index_range.rs" 167 4 167 8] _54 };
    goto BB30
  }
  BB30 {
    s_42 <- { s_42 with current = Slice.set ( * s_42) _52 ([#"../index_range.rs" 167 11 167 13] (-1 : int32)) };
    _55 <- ([#"../index_range.rs" 168 6 168 7] (3 : usize));
    _56 <- Slice.length ( * s_42);
    _57 <- ([#"../index_range.rs" 168 4 168 8] _55 < _56);
    assert { [@expl:index in bounds] [#"../index_range.rs" 168 4 168 8] _57 };
    goto BB31
  }
  BB31 {
    s_42 <- { s_42 with current = Slice.set ( * s_42) _55 ([#"../index_range.rs" 168 11 168 13] (-1 : int32)) };
    assume { Resolve1.resolve s_42 };
    assume { Resolve1.resolve _43 };
    _62 <- arr_1;
    _61 <- ([#"../index_range.rs" 170 12 170 21] Len1.len _62);
    goto BB32
  }
  BB32 {
    _60 <- ([#"../index_range.rs" 170 12 170 26] _61 = ([#"../index_range.rs" 170 25 170 26] (5 : usize)));
    _59 <- not _60;
    switch (_59)
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB34 {
    _58 <- ();
    _69 <- arr_1;
    _68 <- ([#"../index_range.rs" 171 12 171 18] Index1.index _69 ([#"../index_range.rs" 171 16 171 17] (0 : usize)));
    goto BB35
  }
  BB35 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 171 12 171 23] _67 = ([#"../index_range.rs" 171 22 171 23] (0 : int32)));
    _65 <- not _66;
    switch (_65)
      | False -> goto BB37
      | True -> goto BB36
      end
  }
  BB36 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB37 {
    _64 <- ();
    _76 <- arr_1;
    _75 <- ([#"../index_range.rs" 172 12 172 18] Index1.index _76 ([#"../index_range.rs" 172 16 172 17] (1 : usize)));
    goto BB38
  }
  BB38 {
    _74 <- _75;
    _73 <- ([#"../index_range.rs" 172 12 172 24] _74 = ([#"../index_range.rs" 172 22 172 24] (-1 : int32)));
    _72 <- not _73;
    switch (_72)
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB40 {
    _71 <- ();
    _83 <- arr_1;
    _82 <- ([#"../index_range.rs" 173 12 173 18] Index1.index _83 ([#"../index_range.rs" 173 16 173 17] (2 : usize)));
    goto BB41
  }
  BB41 {
    _81 <- _82;
    _80 <- ([#"../index_range.rs" 173 12 173 23] _81 = ([#"../index_range.rs" 173 22 173 23] (2 : int32)));
    _79 <- not _80;
    switch (_79)
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB43 {
    _78 <- ();
    _90 <- arr_1;
    _89 <- ([#"../index_range.rs" 174 12 174 18] Index1.index _90 ([#"../index_range.rs" 174 16 174 17] (3 : usize)));
    goto BB44
  }
  BB44 {
    _88 <- _89;
    _87 <- ([#"../index_range.rs" 174 12 174 24] _88 = ([#"../index_range.rs" 174 22 174 24] (-1 : int32)));
    _86 <- not _87;
    switch (_86)
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB46 {
    _85 <- ();
    _97 <- arr_1;
    _96 <- ([#"../index_range.rs" 175 12 175 18] Index1.index _97 ([#"../index_range.rs" 175 16 175 17] (4 : usize)));
    goto BB47
  }
  BB47 {
    _95 <- _96;
    assume { Resolve0.resolve arr_1 };
    _94 <- ([#"../index_range.rs" 175 12 175 23] _95 = ([#"../index_range.rs" 175 22 175 23] (4 : int32)));
    _93 <- not _94;
    switch (_93)
      | False -> goto BB49
      | True -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _92 <- ();
    _0 <- ();
    goto BB50
  }
  BB50 {
    return _0
  }
  
end
module Core_Ops_Range_RangeToInclusive_Type
  type t_rangetoinclusive 'idx =
    | C_RangeToInclusive 'idx
    
  let function rangetoinclusive_end (self : t_rangetoinclusive 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeToInclusive a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl10_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl10_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl10_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 194 20 194 41] UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) < Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 199 20 199 61] SeqExt.subsequence seq 0 (UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) + 1) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 204 8 204 89] forall i : int . UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) < i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeToInclusive_Interface
  val test_range_to_inclusive [#"../index_range.rs" 179 0 179 32] (_1' : ()) : ()
end
module IndexRange_TestRangeToInclusive
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use prelude.UIntSize
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel4 with
    type t = int32,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  clone CreusotContracts_Std1_Slice_Impl10_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl10_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl10_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type s = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate HasValue0.has_value = HasValue1.has_value,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice int32
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = slice int32,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl9_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_to_inclusive [#"../index_range.rs" 179 0 179 32] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s_2 : slice int32;
  var _3 : slice int32;
  var _4 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _5 : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : slice int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : Core_Option_Option_Type.t_option (slice int32);
  var _28 : Core_Option_Option_Type.t_option (slice int32);
  var _29 : slice int32;
  var _30 : slice int32;
  var _31 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _32 : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize;
  var _33 : ();
  var s_34 : borrowed (slice int32);
  var _35 : borrowed (slice int32);
  var _36 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _37 : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize;
  var _38 : ();
  var _39 : bool;
  var _40 : bool;
  var _41 : usize;
  var _42 : slice int32;
  var _43 : ();
  var _44 : usize;
  var _45 : usize;
  var _46 : bool;
  var _47 : usize;
  var _48 : usize;
  var _49 : bool;
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : int32;
  var _54 : usize;
  var _55 : usize;
  var _56 : bool;
  var _57 : ();
  var _58 : ();
  var _59 : bool;
  var _60 : bool;
  var _61 : usize;
  var _62 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : int32;
  var _68 : int32;
  var _69 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _70 : ();
  var _71 : ();
  var _72 : bool;
  var _73 : bool;
  var _74 : int32;
  var _75 : int32;
  var _76 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _77 : ();
  var _78 : ();
  var _79 : bool;
  var _80 : bool;
  var _81 : int32;
  var _82 : int32;
  var _83 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _84 : ();
  var _85 : ();
  var _86 : bool;
  var _87 : bool;
  var _88 : int32;
  var _89 : int32;
  var _90 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _91 : ();
  var _92 : ();
  var _93 : bool;
  var _94 : bool;
  var _95 : int32;
  var _96 : int32;
  var _97 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _98 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 181 18 181 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 186 20 186 21] (1 : usize));
    _3 <- ([#"../index_range.rs" 186 13 186 22] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 187 12 187 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 187 12 187 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 187 43 187 44] (1 : usize));
    _21 <- Slice.length s_2;
    _22 <- ([#"../index_range.rs" 187 41 187 45] _20 < _21);
    assert { [@expl:index in bounds] [#"../index_range.rs" 187 41 187 45] _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 187 12 187 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 187 30 187 31] (0 : usize));
    _16 <- Slice.length s_2;
    _17 <- ([#"../index_range.rs" 187 28 187 32] _15 < _16);
    assert { [@expl:index in bounds] [#"../index_range.rs" 187 28 187 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 187 12 187 24] _11 = ([#"../index_range.rs" 187 23 187 24] (2 : usize)));
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _14 <- Slice.get s_2 _15;
    _13 <- ([#"../index_range.rs" 187 28 187 37] _14 = ([#"../index_range.rs" 187 36 187 37] (0 : int32)));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Slice.get s_2 _20;
    _18 <- ([#"../index_range.rs" 187 41 187 50] _19 = ([#"../index_range.rs" 187 49 187 50] (1 : int32)));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB13 {
    _6 <- ();
    _31 <- arr_1;
    _30 <- ([#"../index_range.rs" 192 12 192 25] Deref0.deref _31);
    goto BB14
  }
  BB14 {
    _29 <- _30;
    _32 <- Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 192 23 192 24] (5 : usize));
    _28 <- ([#"../index_range.rs" 192 12 192 25] Get0.get _29 _32);
    goto BB15
  }
  BB15 {
    _27 <- _28;
    _26 <- ([#"../index_range.rs" 192 12 192 35] IsNone0.is_none _27);
    goto BB16
  }
  BB16 {
    _25 <- not _26;
    switch (_25)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB18 {
    _24 <- ();
    _36 <- borrow_mut arr_1;
    arr_1 <-  ^ _36;
    _37 <- Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 195 24 195 25] (2 : usize));
    _35 <- ([#"../index_range.rs" 195 17 195 26] IndexMut0.index_mut _36 _37);
    goto BB19
  }
  BB19 {
    s_34 <- borrow_mut ( * _35);
    _35 <- { _35 with current = ( ^ s_34) };
    _42 <-  * s_34;
    _41 <- ([#"../index_range.rs" 196 12 196 19] Len0.len _42);
    goto BB20
  }
  BB20 {
    _40 <- ([#"../index_range.rs" 196 12 196 24] _41 = ([#"../index_range.rs" 196 23 196 24] (3 : usize)));
    _39 <- not _40;
    switch (_39)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve1.resolve s_34 };
    assume { Resolve0.resolve arr_1 };
    assume { Resolve1.resolve _35 };
    absurd
  }
  BB22 {
    _38 <- ();
    _44 <- ([#"../index_range.rs" 197 6 197 7] (0 : usize));
    _45 <- Slice.length ( * s_34);
    _46 <- ([#"../index_range.rs" 197 4 197 8] _44 < _45);
    assert { [@expl:index in bounds] [#"../index_range.rs" 197 4 197 8] _46 };
    goto BB23
  }
  BB23 {
    s_34 <- { s_34 with current = Slice.set ( * s_34) _44 ([#"../index_range.rs" 197 11 197 13] (-1 : int32)) };
    _47 <- ([#"../index_range.rs" 198 6 198 7] (2 : usize));
    _48 <- Slice.length ( * s_34);
    _49 <- ([#"../index_range.rs" 198 4 198 8] _47 < _48);
    assert { [@expl:index in bounds] [#"../index_range.rs" 198 4 198 8] _49 };
    goto BB24
  }
  BB24 {
    s_34 <- { s_34 with current = Slice.set ( * s_34) _47 ([#"../index_range.rs" 198 11 198 13] (-1 : int32)) };
    _54 <- ([#"../index_range.rs" 200 14 200 15] (1 : usize));
    _55 <- Slice.length ( * s_34);
    _56 <- ([#"../index_range.rs" 200 12 200 16] _54 < _55);
    assert { [@expl:index in bounds] [#"../index_range.rs" 200 12 200 16] _56 };
    goto BB25
  }
  BB25 {
    _53 <- Slice.get ( * s_34) _54;
    assume { Resolve1.resolve s_34 };
    _52 <- ([#"../index_range.rs" 200 12 200 21] _53 = ([#"../index_range.rs" 200 20 200 21] (1 : int32)));
    assume { Resolve1.resolve _35 };
    _51 <- not _52;
    switch (_51)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB27 {
    _50 <- ();
    _62 <- arr_1;
    _61 <- ([#"../index_range.rs" 202 12 202 21] Len1.len _62);
    goto BB28
  }
  BB28 {
    _60 <- ([#"../index_range.rs" 202 12 202 26] _61 = ([#"../index_range.rs" 202 25 202 26] (5 : usize)));
    _59 <- not _60;
    switch (_59)
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB30 {
    _58 <- ();
    _69 <- arr_1;
    _68 <- ([#"../index_range.rs" 203 12 203 18] Index1.index _69 ([#"../index_range.rs" 203 16 203 17] (0 : usize)));
    goto BB31
  }
  BB31 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 203 12 203 24] _67 = ([#"../index_range.rs" 203 22 203 24] (-1 : int32)));
    _65 <- not _66;
    switch (_65)
      | False -> goto BB33
      | True -> goto BB32
      end
  }
  BB32 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB33 {
    _64 <- ();
    _76 <- arr_1;
    _75 <- ([#"../index_range.rs" 204 12 204 18] Index1.index _76 ([#"../index_range.rs" 204 16 204 17] (1 : usize)));
    goto BB34
  }
  BB34 {
    _74 <- _75;
    _73 <- ([#"../index_range.rs" 204 12 204 23] _74 = ([#"../index_range.rs" 204 22 204 23] (1 : int32)));
    _72 <- not _73;
    switch (_72)
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB36 {
    _71 <- ();
    _83 <- arr_1;
    _82 <- ([#"../index_range.rs" 205 12 205 18] Index1.index _83 ([#"../index_range.rs" 205 16 205 17] (2 : usize)));
    goto BB37
  }
  BB37 {
    _81 <- _82;
    _80 <- ([#"../index_range.rs" 205 12 205 24] _81 = ([#"../index_range.rs" 205 22 205 24] (-1 : int32)));
    _79 <- not _80;
    switch (_79)
      | False -> goto BB39
      | True -> goto BB38
      end
  }
  BB38 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB39 {
    _78 <- ();
    _90 <- arr_1;
    _89 <- ([#"../index_range.rs" 206 12 206 18] Index1.index _90 ([#"../index_range.rs" 206 16 206 17] (3 : usize)));
    goto BB40
  }
  BB40 {
    _88 <- _89;
    _87 <- ([#"../index_range.rs" 206 12 206 23] _88 = ([#"../index_range.rs" 206 22 206 23] (3 : int32)));
    _86 <- not _87;
    switch (_86)
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assume { Resolve0.resolve arr_1 };
    absurd
  }
  BB42 {
    _85 <- ();
    _97 <- arr_1;
    _96 <- ([#"../index_range.rs" 207 12 207 18] Index1.index _97 ([#"../index_range.rs" 207 16 207 17] (4 : usize)));
    goto BB43
  }
  BB43 {
    _95 <- _96;
    assume { Resolve0.resolve arr_1 };
    _94 <- ([#"../index_range.rs" 207 12 207 23] _95 = ([#"../index_range.rs" 207 22 207 23] (4 : int32)));
    _93 <- not _94;
    switch (_93)
      | False -> goto BB45
      | True -> goto BB44
      end
  }
  BB44 {
    absurd
  }
  BB45 {
    _92 <- ();
    _0 <- ();
    goto BB46
  }
  BB46 {
    return _0
  }
  
end
