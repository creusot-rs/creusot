
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type core_ptr_nonnull_nonnull_type 't =
    | Core_Ptr_NonNull_NonNull_Type opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type core_marker_phantomdata_type 't =
    | Core_Marker_PhantomData_Type
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type
  type core_ptr_unique_unique_type 't =
    | Core_Ptr_Unique_Unique_Type (Core_Ptr_NonNull_NonNull_Type.core_ptr_nonnull_nonnull_type 't) (Core_Marker_PhantomData_Type.core_marker_phantomdata_type 't)
    
end
module Alloc_RawVec_RawVec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type
  type alloc_rawvec_rawvec_type 't 'a =
    | Alloc_RawVec_RawVec_Type (Core_Ptr_Unique_Unique_Type.core_ptr_unique_unique_type 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type
  type alloc_vec_vec_type 't 'a =
    | Alloc_Vec_Vec_Type (Alloc_RawVec_RawVec_Type.alloc_rawvec_rawvec_type 't 'a) usize
    
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  function model (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  function model (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : Seq.seq t
  axiom model_spec : forall self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a . Seq.length (model self) <= 18446744073709551615
end
module Alloc_Alloc_Global_Type
  type alloc_alloc_global_type  =
    | Alloc_Alloc_Global_Type
    
end
module CreusotContracts_Std1_Vec_Impl0
  type t
  type a
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  val new [@cfg:stackify] (_ : ()) : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module Alloc_Vec_Impl0_New
  type t
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  val new [@cfg:stackify] (_ : ()) : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val push [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (value : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model0.model ( * self)) value }
    
end
module Alloc_Vec_Impl1_Push
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val push [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (value : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model0.model ( * self)) value }
    
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Std1_Vec_Impl3_Resolve_Interface
  type t
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type))
end
module CreusotContracts_Std1_Vec_Impl3_Resolve
  type t
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  predicate resolve (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t (Alloc_Alloc_Global_Type.alloc_alloc_global_type)) =
    forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model self) -> Resolve0.resolve (Seq.get (Model0.model self) i)
end
module CreusotContracts_Std1_Vec_Impl3
  type t
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
end
module CreusotContracts_Logic_Resolve_Impl2
  type t
end
module IndexRange_CreateArr_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  val create_arr [@cfg:stackify] (_ : ()) : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
    ensures { [#"../index_range.rs" 7 4 12 25] Seq.length (Model0.model result) = 5 /\ Int32.to_int (Seq.get (Model0.model result) 0) = 0 /\ Int32.to_int (Seq.get (Model0.model result) 1) = 1 /\ Int32.to_int (Seq.get (Model0.model result) 2) = 2 /\ Int32.to_int (Seq.get (Model0.model result) 3) = 3 /\ Int32.to_int (Seq.get (Model0.model result) 4) = 4 }
    
end
module IndexRange_CreateArr
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  use prelude.Borrow
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = int32
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve0 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve1.resolve
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone Alloc_Vec_Impl0_New_Interface as New0 with type t = int32, function Model0.model = Model0.model
  let rec cfg create_arr [@cfg:stackify] [#"../index_range.rs" 14 0 14 27] (_ : ()) : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type)
    ensures { [#"../index_range.rs" 7 4 12 25] Seq.length (Model0.model result) = 5 /\ Int32.to_int (Seq.get (Model0.model result) 0) = 0 /\ Int32.to_int (Seq.get (Model0.model result) 1) = 1 /\ Int32.to_int (Seq.get (Model0.model result) 2) = 2 /\ Int32.to_int (Seq.get (Model0.model result) 3) = 3 /\ Int32.to_int (Seq.get (Model0.model result) 4) = 4 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var arr_2 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _3 : ();
  var _4 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _5 : ();
  var _6 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _7 : ();
  var _8 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _9 : ();
  var _10 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _11 : ();
  var _12 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  {
    goto BB0
  }
  BB0 {
    arr_2 <- ([#"../index_range.rs" 15 18 15 28] New0.new ());
    goto BB1
  }
  BB1 {
    _4 <- borrow_mut arr_2;
    arr_2 <-  ^ _4;
    _3 <- ([#"../index_range.rs" 17 4 17 15] Push0.push _4 (0 : int32));
    goto BB2
  }
  BB2 {
    _6 <- borrow_mut arr_2;
    arr_2 <-  ^ _6;
    _5 <- ([#"../index_range.rs" 18 4 18 15] Push0.push _6 (1 : int32));
    goto BB3
  }
  BB3 {
    _8 <- borrow_mut arr_2;
    arr_2 <-  ^ _8;
    _7 <- ([#"../index_range.rs" 19 4 19 15] Push0.push _8 (2 : int32));
    goto BB4
  }
  BB4 {
    _10 <- borrow_mut arr_2;
    arr_2 <-  ^ _10;
    _9 <- ([#"../index_range.rs" 20 4 20 15] Push0.push _10 (3 : int32));
    goto BB5
  }
  BB5 {
    _12 <- borrow_mut arr_2;
    arr_2 <-  ^ _12;
    _11 <- ([#"../index_range.rs" 21 4 21 15] Push0.push _12 (4 : int32));
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve _0 };
    _0 <- arr_2;
    arr_2 <- any Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Core_Ops_Range_Range_Type
  type core_ops_range_range_type 'idx =
    | Core_Ops_Range_Range_Type 'idx 'idx
    
  let function core_ops_range_range_type_Range_start (self : core_ops_range_range_type 'idx) : 'idx
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Ops_Range_Range_Type a _ -> a
      end
  let function core_ops_range_range_type_Range_end (self : core_ops_range_range_type 'idx) : 'idx
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Ops_Range_Range_Type _ a -> a
      end
end
module CreusotContracts_Logic_Model_Model_ModelTy_Type
  type self
  type modelTy
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate in_bounds (self : self) (seq : ModelTy0.modelTy)
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate in_bounds (self : self) (seq : ModelTy0.modelTy)
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = self, type t = t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate has_value (self : self) (seq : ModelTy0.modelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = self, type t = t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate has_value (self : self) (seq : ModelTy0.modelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_Impl0_ModelTy_Type
  type t
  use seq.Seq
  type modelTy  =
    Seq.seq t
end
module Alloc_Vec_Impl16_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val index [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) (index : i) : Output0.output
    requires {InBounds0.in_bounds index (Model0.model self)}
    ensures { HasValue0.has_value index (Model0.model self) result }
    
end
module Alloc_Vec_Impl16_Index
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val index [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) (index : i) : Output0.output
    requires {InBounds0.in_bounds index (Model0.model self)}
    ensures { HasValue0.has_value index (Model0.model self) result }
    
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model
  type t
  use prelude.Borrow
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy =
    Model0.model self
end
module Core_Slice_Impl0_Len_Interface
  type t
  use seq.Seq
  use mach.int.UInt64
  use prelude.Borrow
  use prelude.Slice
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : seq t) : usize
    ensures { Seq.length (Model0.model self) = UInt64.to_int result }
    
end
module Core_Slice_Impl0_Len
  type t
  use seq.Seq
  use mach.int.UInt64
  use prelude.Borrow
  use prelude.Slice
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : seq t) : usize
    ensures { Seq.length (Model0.model self) = UInt64.to_int result }
    
end
module CreusotContracts_Std1_Slice_Impl0_Model_Interface
  type t
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Slice
  function model (self : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_Model
  type t
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Slice
  function model (self : seq t) : Seq.seq t
  axiom model_spec : forall self : seq t . model self = Slice.id self && Seq.length (model self) <= 18446744073709551615
end
module Alloc_Vec_Impl10_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  val deref [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : seq t
    ensures { Model0.model result = Model1.model self }
    
end
module Alloc_Vec_Impl10_Deref
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  val deref [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : seq t
    ensures { Model0.model result = Model1.model self }
    
end
module Core_Option_Option_Type
  type core_option_option_type 't =
    | Core_Option_Option_None_Type
    | Core_Option_Option_Some_Type 't
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  val get [@cfg:stackify] (self : seq t) (index : i) : Core_Option_Option_Type.core_option_option_type Output0.output
    ensures { InBounds0.in_bounds index (Model0.model self) -> (exists r : (Output0.output) . result = Core_Option_Option_Type.Core_Option_Option_Some_Type r /\ HasValue0.has_value index (Model0.model self) r) }
    ensures { InBounds0.in_bounds index (Model0.model self) \/ result = Core_Option_Option_Type.Core_Option_Option_None_Type }
    
end
module Core_Slice_Impl0_Get
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  val get [@cfg:stackify] (self : seq t) (index : i) : Core_Option_Option_Type.core_option_option_type Output0.output
    ensures { InBounds0.in_bounds index (Model0.model self) -> (exists r : (Output0.output) . result = Core_Option_Option_Type.Core_Option_Option_Some_Type r /\ HasValue0.has_value index (Model0.model self) r) }
    ensures { InBounds0.in_bounds index (Model0.model self) \/ result = Core_Option_Option_Type.Core_Option_Option_None_Type }
    
end
module Core_Option_Impl0_IsNone_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type
  val is_none [@cfg:stackify] (self : Core_Option_Option_Type.core_option_option_type t) : bool
    ensures { result = (self = Core_Option_Option_Type.Core_Option_Option_None_Type) }
    
end
module Core_Option_Impl0_IsNone
  type t
  use prelude.Borrow
  use Core_Option_Option_Type
  val is_none [@cfg:stackify] (self : Core_Option_Option_Type.core_option_option_type t) : bool
    ensures { result = (self = Core_Option_Option_Type.Core_Option_Option_None_Type) }
    
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate resolve_elswhere (self : self) (old' : ModelTy0.modelTy) (fin : ModelTy0.modelTy)
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy_Type as ModelTy0 with type self = t
  predicate resolve_elswhere (self : self) (old' : ModelTy0.modelTy) (fin : ModelTy0.modelTy)
end
module Alloc_Vec_Impl17_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_ResolveElswhere_Interface as ResolveElswhere0 with type self = i,
  type t = seq t, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val index_mut [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (Model0.model ( * self))}
    ensures { HasValue0.has_value index (Model0.model ( * self)) ( * result) }
    ensures { HasValue0.has_value index (Model0.model ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (Model0.model ( * self)) (Model0.model ( ^ self)) }
    ensures { Seq.length (Model0.model ( ^ self)) = Seq.length (Model0.model ( * self)) }
    
end
module Alloc_Vec_Impl17_IndexMut
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with type self = i, type t = seq t
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_ResolveElswhere_Interface as ResolveElswhere0 with type self = i,
  type t = seq t, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val index_mut [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (Model0.model ( * self))}
    ensures { HasValue0.has_value index (Model0.model ( * self)) ( * result) }
    ensures { HasValue0.has_value index (Model0.model ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (Model0.model ( * self)) (Model0.model ( ^ self)) }
    ensures { Seq.length (Model0.model ( ^ self)) = Seq.length (Model0.model ( * self)) }
    
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val len [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module Alloc_Vec_Impl1_Len
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val len [@cfg:stackify] (self : Alloc_Vec_Vec_Type.alloc_vec_vec_type t a) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module Alloc_Vec_Impl16
  type t
  type i
  type a
end
module Alloc_Vec_Impl10
  type t
  type a
end
module Alloc_Vec_Impl17
  type t
  type i
  type a
end
module CreusotContracts_Logic_Resolve_Impl1
  type t
end
module CreusotContracts_Std1_Slice_Impl4_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl4_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type
  use mach.int.UInt64
  predicate in_bounds (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (seq : Seq.seq t) =
    UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_start self) <= UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_end self) /\ UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_end self) <= Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl4
  type t
end
module CreusotContracts_Std1_Slice_Impl4_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (seq : Seq.seq t) (out : seq t)
end
module CreusotContracts_Std1_Slice_Impl4_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type
  use mach.int.UInt64
  use seq_ext.SeqExt
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  predicate has_value (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (seq : Seq.seq t) (out : seq t)
   =
    SeqExt.subsequence seq (UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_start self)) (UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_end self)) = Model0.model out
end
module Core_Slice_Index_Impl3_Output_Type
  type t
  use prelude.Slice
  use seq.Seq
  type output  =
    seq t
end
module Core_Slice_Index_Impl3
  type t
end
module CreusotContracts_Std1_Slice_Impl0
  type t
end
module CreusotContracts_Logic_Model_Impl0
  type t
end
module CreusotContracts_Std1_Slice_Impl4_ResolveElswhere_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl4_ResolveElswhere
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type
  use mach.int.Int32
  use mach.int.UInt64
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.core_ops_range_range_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    forall i : (int) . 0 <= i /\ (i < UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_start self) \/ UInt64.to_int (Core_Ops_Range_Range_Type.core_ops_range_range_type_Range_end self) <= i) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
end
module CreusotContracts_Std1_Slice_Impl3_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl3_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use mach.int.UInt64
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    UInt64.to_int self < Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl3
  type t
end
module CreusotContracts_Std1_Slice_Impl3_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl3_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use mach.int.UInt64
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    Seq.get seq (UInt64.to_int self) = out
end
module Core_Slice_Index_Impl2_Output_Type
  type t
  type output  =
    t
end
module Core_Slice_Index_Impl2
  type t
end
module IndexRange_TestRange_Interface
  val test_range [@cfg:stackify] (_ : ()) : ()
end
module IndexRange_TestRange
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = int32
  clone Core_Slice_Index_Impl2_Output_Type as Output1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_HasValue as HasValue1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_InBounds as InBounds1 with type t = int32
  use Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Slice_Impl4_ResolveElswhere as ResolveElswhere0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl0_Model as Model2 with type t = int32, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = int32
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = seq int32,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone Core_Slice_Index_Impl3_Output_Type as Output0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl4_HasValue as HasValue0 with type t = int32,
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Slice_Impl4_InBounds as InBounds0 with type t = int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve1 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl16_Index_Interface as Index1 with type t = int32, type i = usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds1.in_bounds, predicate HasValue0.has_value = HasValue1.has_value,
  type Output0.output = Output1.output
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = seq int32
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with type t = int32,
  type i = Core_Ops_Range_Range_Type.core_ops_range_range_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere, type Output0.output = Output0.output
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with type t = seq int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with type t = int32,
  type i = Core_Ops_Range_Range_Type.core_ops_range_range_type usize, function Model0.model = Model2.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, type Output0.output = Output0.output,
  predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model,
  function Model1.model = Model0.model
  clone Core_Slice_Impl0_Len_Interface as Len0 with type t = int32, function Model0.model = Model1.model
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with type t = int32,
  type i = Core_Ops_Range_Range_Type.core_ops_range_range_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  type Output0.output = Output0.output
  clone IndexRange_CreateArr_Interface as CreateArr0 with function Model0.model = Model0.model
  let rec cfg test_range [@cfg:stackify] [#"../index_range.rs" 27 0 27 19] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var s_2 : seq int32;
  var _3 : seq int32;
  var _4 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _5 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : seq int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var s_24 : seq int32;
  var _25 : seq int32;
  var _26 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _27 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _28 : ();
  var _29 : bool;
  var _30 : bool;
  var _31 : bool;
  var _32 : bool;
  var _33 : usize;
  var _34 : seq int32;
  var _35 : bool;
  var _36 : int32;
  var _37 : usize;
  var _38 : usize;
  var _39 : bool;
  var _40 : bool;
  var _41 : int32;
  var _42 : usize;
  var _43 : usize;
  var _44 : bool;
  var _45 : ();
  var _46 : ();
  var _47 : bool;
  var _48 : bool;
  var _49 : usize;
  var _50 : seq int32;
  var _51 : seq int32;
  var _52 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _53 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _54 : ();
  var _55 : ();
  var _56 : bool;
  var _57 : bool;
  var _58 : usize;
  var _59 : seq int32;
  var _60 : seq int32;
  var _61 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _62 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _68 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _69 : seq int32;
  var _70 : seq int32;
  var _71 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _72 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _73 : ();
  var _74 : ();
  var _75 : bool;
  var _76 : bool;
  var _77 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _78 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _79 : seq int32;
  var _80 : seq int32;
  var _81 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _82 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _83 : ();
  var _84 : ();
  var _85 : bool;
  var _86 : bool;
  var _87 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _88 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _89 : seq int32;
  var _90 : seq int32;
  var _91 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _92 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _93 : ();
  var _94 : ();
  var _95 : bool;
  var _96 : bool;
  var _97 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _98 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _99 : seq int32;
  var _100 : seq int32;
  var _101 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _102 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _103 : ();
  var s_104 : borrowed (seq int32);
  var _105 : borrowed (seq int32);
  var _106 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _107 : Core_Ops_Range_Range_Type.core_ops_range_range_type usize;
  var _108 : ();
  var _109 : bool;
  var _110 : bool;
  var _111 : usize;
  var _112 : seq int32;
  var _113 : ();
  var _114 : usize;
  var _115 : usize;
  var _116 : bool;
  var _117 : usize;
  var _118 : usize;
  var _119 : bool;
  var _120 : ();
  var _121 : bool;
  var _122 : bool;
  var _123 : int32;
  var _124 : usize;
  var _125 : usize;
  var _126 : bool;
  var _127 : ();
  var _128 : ();
  var _129 : bool;
  var _130 : bool;
  var _131 : usize;
  var _132 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _133 : ();
  var _134 : ();
  var _135 : bool;
  var _136 : bool;
  var _137 : int32;
  var _138 : int32;
  var _139 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _140 : ();
  var _141 : ();
  var _142 : bool;
  var _143 : bool;
  var _144 : int32;
  var _145 : int32;
  var _146 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _147 : ();
  var _148 : ();
  var _149 : bool;
  var _150 : bool;
  var _151 : int32;
  var _152 : int32;
  var _153 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _154 : ();
  var _155 : ();
  var _156 : bool;
  var _157 : bool;
  var _158 : int32;
  var _159 : int32;
  var _160 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _161 : ();
  var _162 : ();
  var _163 : bool;
  var _164 : bool;
  var _165 : int32;
  var _166 : int32;
  var _167 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _168 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 29 18 29 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (0 : usize) (2 : usize);
    _3 <- ([#"../index_range.rs" 34 13 34 22] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 35 12 35 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- false;
    goto BB5
  }
  BB4 {
    _20 <- (1 : usize);
    _21 <- UIntSize.of_int (Seq.length s_2);
    _22 <- ([#"../index_range.rs" 35 41 35 45] _20 < _21);
    assert { _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | _ -> goto BB12
      end
  }
  BB6 {
    _9 <- false;
    goto BB8
  }
  BB7 {
    _15 <- (0 : usize);
    _16 <- UIntSize.of_int (Seq.length s_2);
    _17 <- ([#"../index_range.rs" 35 28 35 32] _15 < _16);
    assert { _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | _ -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 35 12 35 24] _11 = (2 : usize));
    switch (_10)
      | False -> goto BB6
      | _ -> goto BB7
      end
  }
  BB10 {
    _14 <- Seq.get s_2 (UIntSize.to_int _15);
    _13 <- ([#"../index_range.rs" 35 28 35 37] _14 = (0 : int32));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Seq.get s_2 (UIntSize.to_int _20);
    _18 <- ([#"../index_range.rs" 35 41 35 50] _19 = (1 : int32));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    absurd
  }
  BB13 {
    _6 <- ();
    _26 <- arr_1;
    _27 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (3 : usize) (5 : usize);
    _25 <- ([#"../index_range.rs" 37 13 37 22] Index0.index _26 _27);
    goto BB14
  }
  BB14 {
    s_24 <- _25;
    _34 <- s_24;
    _33 <- ([#"../index_range.rs" 38 12 38 19] Len0.len _34);
    goto BB21
  }
  BB15 {
    _30 <- false;
    goto BB17
  }
  BB16 {
    _42 <- (1 : usize);
    _43 <- UIntSize.of_int (Seq.length s_24);
    _44 <- ([#"../index_range.rs" 38 41 38 45] _42 < _43);
    assert { _44 };
    goto BB23
  }
  BB17 {
    _29 <- not _30;
    switch (_29)
      | False -> goto BB25
      | _ -> goto BB24
      end
  }
  BB18 {
    _31 <- false;
    goto BB20
  }
  BB19 {
    _37 <- (0 : usize);
    _38 <- UIntSize.of_int (Seq.length s_24);
    _39 <- ([#"../index_range.rs" 38 28 38 32] _37 < _38);
    assert { _39 };
    goto BB22
  }
  BB20 {
    switch (_31)
      | False -> goto BB15
      | _ -> goto BB16
      end
  }
  BB21 {
    _32 <- ([#"../index_range.rs" 38 12 38 24] _33 = (2 : usize));
    switch (_32)
      | False -> goto BB18
      | _ -> goto BB19
      end
  }
  BB22 {
    _36 <- Seq.get s_24 (UIntSize.to_int _37);
    _35 <- ([#"../index_range.rs" 38 28 38 37] _36 = (3 : int32));
    _31 <- _35;
    _35 <- any bool;
    goto BB20
  }
  BB23 {
    _41 <- Seq.get s_24 (UIntSize.to_int _42);
    _40 <- ([#"../index_range.rs" 38 41 38 50] _41 = (4 : int32));
    _30 <- _40;
    _40 <- any bool;
    goto BB17
  }
  BB24 {
    absurd
  }
  BB25 {
    _28 <- ();
    _52 <- arr_1;
    _53 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (2 : usize) (2 : usize);
    _51 <- ([#"../index_range.rs" 43 12 43 21] Index0.index _52 _53);
    goto BB26
  }
  BB26 {
    _50 <- _51;
    _49 <- ([#"../index_range.rs" 43 12 43 27] Len0.len _50);
    goto BB27
  }
  BB27 {
    _48 <- ([#"../index_range.rs" 43 12 43 32] _49 = (0 : usize));
    _47 <- not _48;
    switch (_47)
      | False -> goto BB29
      | _ -> goto BB28
      end
  }
  BB28 {
    absurd
  }
  BB29 {
    _46 <- ();
    _61 <- arr_1;
    _62 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (5 : usize) (5 : usize);
    _60 <- ([#"../index_range.rs" 45 12 45 21] Index0.index _61 _62);
    goto BB30
  }
  BB30 {
    _59 <- _60;
    _58 <- ([#"../index_range.rs" 45 12 45 27] Len0.len _59);
    goto BB31
  }
  BB31 {
    _57 <- ([#"../index_range.rs" 45 12 45 32] _58 = (0 : usize));
    _56 <- not _57;
    switch (_56)
      | False -> goto BB33
      | _ -> goto BB32
      end
  }
  BB32 {
    absurd
  }
  BB33 {
    _55 <- ();
    _71 <- arr_1;
    _70 <- ([#"../index_range.rs" 50 12 50 25] Deref0.deref _71);
    goto BB34
  }
  BB34 {
    _69 <- _70;
    _72 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (2 : usize) (6 : usize);
    _68 <- ([#"../index_range.rs" 50 12 50 25] Get0.get _69 _72);
    goto BB35
  }
  BB35 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 50 12 50 35] IsNone0.is_none _67);
    goto BB36
  }
  BB36 {
    _65 <- not _66;
    switch (_65)
      | False -> goto BB38
      | _ -> goto BB37
      end
  }
  BB37 {
    absurd
  }
  BB38 {
    _64 <- ();
    _81 <- arr_1;
    _80 <- ([#"../index_range.rs" 52 12 52 25] Deref0.deref _81);
    goto BB39
  }
  BB39 {
    _79 <- _80;
    _82 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (2 : usize) (1 : usize);
    _78 <- ([#"../index_range.rs" 52 12 52 25] Get0.get _79 _82);
    goto BB40
  }
  BB40 {
    _77 <- _78;
    _76 <- ([#"../index_range.rs" 52 12 52 35] IsNone0.is_none _77);
    goto BB41
  }
  BB41 {
    _75 <- not _76;
    switch (_75)
      | False -> goto BB43
      | _ -> goto BB42
      end
  }
  BB42 {
    absurd
  }
  BB43 {
    _74 <- ();
    _91 <- arr_1;
    _90 <- ([#"../index_range.rs" 54 12 54 25] Deref0.deref _91);
    goto BB44
  }
  BB44 {
    _89 <- _90;
    _92 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (6 : usize) (6 : usize);
    _88 <- ([#"../index_range.rs" 54 12 54 25] Get0.get _89 _92);
    goto BB45
  }
  BB45 {
    _87 <- _88;
    _86 <- ([#"../index_range.rs" 54 12 54 35] IsNone0.is_none _87);
    goto BB46
  }
  BB46 {
    _85 <- not _86;
    switch (_85)
      | False -> goto BB48
      | _ -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _84 <- ();
    _101 <- arr_1;
    _100 <- ([#"../index_range.rs" 56 12 56 27] Deref0.deref _101);
    goto BB49
  }
  BB49 {
    _99 <- _100;
    _102 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (10 : usize) (10 : usize);
    _98 <- ([#"../index_range.rs" 56 12 56 27] Get0.get _99 _102);
    goto BB50
  }
  BB50 {
    _97 <- _98;
    _96 <- ([#"../index_range.rs" 56 12 56 37] IsNone0.is_none _97);
    goto BB51
  }
  BB51 {
    _95 <- not _96;
    switch (_95)
      | False -> goto BB53
      | _ -> goto BB52
      end
  }
  BB52 {
    absurd
  }
  BB53 {
    _94 <- ();
    _106 <- borrow_mut arr_1;
    arr_1 <-  ^ _106;
    _107 <- Core_Ops_Range_Range_Type.Core_Ops_Range_Range_Type (1 : usize) (4 : usize);
    _105 <- ([#"../index_range.rs" 59 17 59 26] IndexMut0.index_mut _106 _107);
    goto BB54
  }
  BB54 {
    s_104 <- borrow_mut ( * _105);
    _105 <- { _105 with current = ( ^ s_104) };
    assume { Resolve0.resolve _105 };
    _112 <-  * s_104;
    _111 <- ([#"../index_range.rs" 60 12 60 19] Len0.len _112);
    goto BB55
  }
  BB55 {
    _110 <- ([#"../index_range.rs" 60 12 60 24] _111 = (3 : usize));
    _109 <- not _110;
    switch (_109)
      | False -> goto BB57
      | _ -> goto BB56
      end
  }
  BB56 {
    assume { Resolve0.resolve s_104 };
    absurd
  }
  BB57 {
    _108 <- ();
    _114 <- (0 : usize);
    _115 <- UIntSize.of_int (Seq.length ( * s_104));
    _116 <- ([#"../index_range.rs" 61 4 61 8] _114 < _115);
    assert { _116 };
    goto BB58
  }
  BB58 {
    s_104 <- { s_104 with current = Seq.set ( * s_104) (UIntSize.to_int _114) (-1 : int32) };
    _117 <- (1 : usize);
    _118 <- UIntSize.of_int (Seq.length ( * s_104));
    _119 <- ([#"../index_range.rs" 62 4 62 8] _117 < _118);
    assert { _119 };
    goto BB59
  }
  BB59 {
    s_104 <- { s_104 with current = Seq.set ( * s_104) (UIntSize.to_int _117) (-1 : int32) };
    _124 <- (2 : usize);
    _125 <- UIntSize.of_int (Seq.length ( * s_104));
    _126 <- ([#"../index_range.rs" 67 12 67 16] _124 < _125);
    assert { _126 };
    goto BB60
  }
  BB60 {
    _123 <- Seq.get ( * s_104) (UIntSize.to_int _124);
    assume { Resolve0.resolve s_104 };
    _122 <- ([#"../index_range.rs" 67 12 67 21] _123 = (3 : int32));
    _121 <- not _122;
    switch (_121)
      | False -> goto BB62
      | _ -> goto BB61
      end
  }
  BB61 {
    absurd
  }
  BB62 {
    _120 <- ();
    _132 <- arr_1;
    _131 <- ([#"../index_range.rs" 69 12 69 21] Len1.len _132);
    goto BB63
  }
  BB63 {
    _130 <- ([#"../index_range.rs" 69 12 69 26] _131 = (5 : usize));
    _129 <- not _130;
    switch (_129)
      | False -> goto BB65
      | _ -> goto BB64
      end
  }
  BB64 {
    absurd
  }
  BB65 {
    _128 <- ();
    _139 <- arr_1;
    _138 <- ([#"../index_range.rs" 70 12 70 18] Index1.index _139 (0 : usize));
    goto BB66
  }
  BB66 {
    _137 <- _138;
    _136 <- ([#"../index_range.rs" 70 12 70 23] _137 = (0 : int32));
    _135 <- not _136;
    switch (_135)
      | False -> goto BB68
      | _ -> goto BB67
      end
  }
  BB67 {
    absurd
  }
  BB68 {
    _134 <- ();
    _146 <- arr_1;
    _145 <- ([#"../index_range.rs" 71 12 71 18] Index1.index _146 (1 : usize));
    goto BB69
  }
  BB69 {
    _144 <- _145;
    _143 <- ([#"../index_range.rs" 71 12 71 24] _144 = (-1 : int32));
    _142 <- not _143;
    switch (_142)
      | False -> goto BB71
      | _ -> goto BB70
      end
  }
  BB70 {
    absurd
  }
  BB71 {
    _141 <- ();
    _153 <- arr_1;
    _152 <- ([#"../index_range.rs" 72 12 72 18] Index1.index _153 (2 : usize));
    goto BB72
  }
  BB72 {
    _151 <- _152;
    _150 <- ([#"../index_range.rs" 72 12 72 24] _151 = (-1 : int32));
    _149 <- not _150;
    switch (_149)
      | False -> goto BB74
      | _ -> goto BB73
      end
  }
  BB73 {
    absurd
  }
  BB74 {
    _148 <- ();
    _160 <- arr_1;
    _159 <- ([#"../index_range.rs" 73 12 73 18] Index1.index _160 (3 : usize));
    goto BB75
  }
  BB75 {
    _158 <- _159;
    _157 <- ([#"../index_range.rs" 73 12 73 23] _158 = (3 : int32));
    _156 <- not _157;
    switch (_156)
      | False -> goto BB77
      | _ -> goto BB76
      end
  }
  BB76 {
    absurd
  }
  BB77 {
    _155 <- ();
    _167 <- arr_1;
    _166 <- ([#"../index_range.rs" 74 12 74 18] Index1.index _167 (4 : usize));
    goto BB78
  }
  BB78 {
    _165 <- _166;
    _164 <- ([#"../index_range.rs" 74 12 74 23] _165 = (4 : int32));
    _163 <- not _164;
    switch (_163)
      | False -> goto BB80
      | _ -> goto BB79
      end
  }
  BB79 {
    absurd
  }
  BB80 {
    _162 <- ();
    _0 <- ();
    goto BB81
  }
  BB81 {
    assume { Resolve1.resolve arr_1 };
    return _0
  }
  
end
module Core_Ops_Range_RangeTo_Type
  type core_ops_range_rangeto_type 'idx =
    | Core_Ops_Range_RangeTo_Type 'idx
    
  let function core_ops_range_rangeto_type_RangeTo_end (self : core_ops_range_rangeto_type 'idx) : 'idx
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Ops_Range_RangeTo_Type a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type
  use mach.int.UInt64
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (seq : Seq.seq t) =
    UInt64.to_int (Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type_RangeTo_end self) <= Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl5
  type t
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (seq : Seq.seq t) (out : seq t)
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type
  use mach.int.Int32
  use mach.int.UInt64
  use seq_ext.SeqExt
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (seq : Seq.seq t) (out : seq t)
    
   =
    SeqExt.subsequence seq 0 (UInt64.to_int (Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type_RangeTo_end self)) = Model0.model out
end
module Core_Slice_Index_Impl4_Output_Type
  type t
  use prelude.Slice
  use seq.Seq
  type output  =
    seq t
end
module Core_Slice_Index_Impl4
  type t
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type
  use mach.int.UInt64
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    forall i : (int) . UInt64.to_int (Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type_RangeTo_end self) <= i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
end
module IndexRange_TestRangeTo_Interface
  val test_range_to [@cfg:stackify] (_ : ()) : ()
end
module IndexRange_TestRangeTo
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = int32
  clone Core_Slice_Index_Impl2_Output_Type as Output1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_HasValue as HasValue1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_InBounds as InBounds1 with type t = int32
  use Core_Ops_Range_RangeTo_Type
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl0_Model as Model2 with type t = int32, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = int32
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = seq int32,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone Core_Slice_Index_Impl4_Output_Type as Output0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with type t = int32,
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with type t = int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve1 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl16_Index_Interface as Index1 with type t = int32, type i = usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds1.in_bounds, predicate HasValue0.has_value = HasValue1.has_value,
  type Output0.output = Output1.output
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = seq int32
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with type t = int32,
  type i = Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere, type Output0.output = Output0.output
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with type t = seq int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with type t = int32,
  type i = Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize, function Model0.model = Model2.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, type Output0.output = Output0.output,
  predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model,
  function Model1.model = Model0.model
  clone Core_Slice_Impl0_Len_Interface as Len0 with type t = int32, function Model0.model = Model1.model
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with type t = int32,
  type i = Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  type Output0.output = Output0.output
  clone IndexRange_CreateArr_Interface as CreateArr0 with function Model0.model = Model0.model
  let rec cfg test_range_to [@cfg:stackify] [#"../index_range.rs" 78 0 78 22] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var s_2 : seq int32;
  var _3 : seq int32;
  var _4 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _5 : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : seq int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : usize;
  var _28 : seq int32;
  var _29 : seq int32;
  var _30 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _31 : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize;
  var _32 : ();
  var _33 : ();
  var _34 : bool;
  var _35 : bool;
  var _36 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _37 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _38 : seq int32;
  var _39 : seq int32;
  var _40 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _41 : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize;
  var _42 : ();
  var s_43 : borrowed (seq int32);
  var _44 : borrowed (seq int32);
  var _45 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _46 : Core_Ops_Range_RangeTo_Type.core_ops_range_rangeto_type usize;
  var _47 : ();
  var _48 : bool;
  var _49 : bool;
  var _50 : usize;
  var _51 : seq int32;
  var _52 : ();
  var _53 : usize;
  var _54 : usize;
  var _55 : bool;
  var _56 : usize;
  var _57 : usize;
  var _58 : bool;
  var _59 : ();
  var _60 : bool;
  var _61 : bool;
  var _62 : int32;
  var _63 : usize;
  var _64 : usize;
  var _65 : bool;
  var _66 : ();
  var _67 : ();
  var _68 : bool;
  var _69 : bool;
  var _70 : usize;
  var _71 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _72 : ();
  var _73 : ();
  var _74 : bool;
  var _75 : bool;
  var _76 : int32;
  var _77 : int32;
  var _78 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _79 : ();
  var _80 : ();
  var _81 : bool;
  var _82 : bool;
  var _83 : int32;
  var _84 : int32;
  var _85 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _86 : ();
  var _87 : ();
  var _88 : bool;
  var _89 : bool;
  var _90 : int32;
  var _91 : int32;
  var _92 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _93 : ();
  var _94 : ();
  var _95 : bool;
  var _96 : bool;
  var _97 : int32;
  var _98 : int32;
  var _99 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _100 : ();
  var _101 : ();
  var _102 : bool;
  var _103 : bool;
  var _104 : int32;
  var _105 : int32;
  var _106 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _107 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 80 18 80 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeTo_Type.Core_Ops_Range_RangeTo_Type (2 : usize);
    _3 <- ([#"../index_range.rs" 85 13 85 21] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 86 12 86 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- false;
    goto BB5
  }
  BB4 {
    _20 <- (1 : usize);
    _21 <- UIntSize.of_int (Seq.length s_2);
    _22 <- ([#"../index_range.rs" 86 41 86 45] _20 < _21);
    assert { _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | _ -> goto BB12
      end
  }
  BB6 {
    _9 <- false;
    goto BB8
  }
  BB7 {
    _15 <- (0 : usize);
    _16 <- UIntSize.of_int (Seq.length s_2);
    _17 <- ([#"../index_range.rs" 86 28 86 32] _15 < _16);
    assert { _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | _ -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 86 12 86 24] _11 = (2 : usize));
    switch (_10)
      | False -> goto BB6
      | _ -> goto BB7
      end
  }
  BB10 {
    _14 <- Seq.get s_2 (UIntSize.to_int _15);
    _13 <- ([#"../index_range.rs" 86 28 86 37] _14 = (0 : int32));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Seq.get s_2 (UIntSize.to_int _20);
    _18 <- ([#"../index_range.rs" 86 41 86 50] _19 = (1 : int32));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    absurd
  }
  BB13 {
    _6 <- ();
    _30 <- arr_1;
    _31 <- Core_Ops_Range_RangeTo_Type.Core_Ops_Range_RangeTo_Type (0 : usize);
    _29 <- ([#"../index_range.rs" 91 12 91 20] Index0.index _30 _31);
    goto BB14
  }
  BB14 {
    _28 <- _29;
    _27 <- ([#"../index_range.rs" 91 12 91 26] Len0.len _28);
    goto BB15
  }
  BB15 {
    _26 <- ([#"../index_range.rs" 91 12 91 31] _27 = (0 : usize));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB17
      | _ -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _24 <- ();
    _40 <- arr_1;
    _39 <- ([#"../index_range.rs" 96 12 96 24] Deref0.deref _40);
    goto BB18
  }
  BB18 {
    _38 <- _39;
    _41 <- Core_Ops_Range_RangeTo_Type.Core_Ops_Range_RangeTo_Type (6 : usize);
    _37 <- ([#"../index_range.rs" 96 12 96 24] Get0.get _38 _41);
    goto BB19
  }
  BB19 {
    _36 <- _37;
    _35 <- ([#"../index_range.rs" 96 12 96 34] IsNone0.is_none _36);
    goto BB20
  }
  BB20 {
    _34 <- not _35;
    switch (_34)
      | False -> goto BB22
      | _ -> goto BB21
      end
  }
  BB21 {
    absurd
  }
  BB22 {
    _33 <- ();
    _45 <- borrow_mut arr_1;
    arr_1 <-  ^ _45;
    _46 <- Core_Ops_Range_RangeTo_Type.Core_Ops_Range_RangeTo_Type (3 : usize);
    _44 <- ([#"../index_range.rs" 99 17 99 25] IndexMut0.index_mut _45 _46);
    goto BB23
  }
  BB23 {
    s_43 <- borrow_mut ( * _44);
    _44 <- { _44 with current = ( ^ s_43) };
    assume { Resolve0.resolve _44 };
    _51 <-  * s_43;
    _50 <- ([#"../index_range.rs" 100 12 100 19] Len0.len _51);
    goto BB24
  }
  BB24 {
    _49 <- ([#"../index_range.rs" 100 12 100 24] _50 = (3 : usize));
    _48 <- not _49;
    switch (_48)
      | False -> goto BB26
      | _ -> goto BB25
      end
  }
  BB25 {
    assume { Resolve0.resolve s_43 };
    absurd
  }
  BB26 {
    _47 <- ();
    _53 <- (0 : usize);
    _54 <- UIntSize.of_int (Seq.length ( * s_43));
    _55 <- ([#"../index_range.rs" 101 4 101 8] _53 < _54);
    assert { _55 };
    goto BB27
  }
  BB27 {
    s_43 <- { s_43 with current = Seq.set ( * s_43) (UIntSize.to_int _53) (-1 : int32) };
    _56 <- (2 : usize);
    _57 <- UIntSize.of_int (Seq.length ( * s_43));
    _58 <- ([#"../index_range.rs" 102 4 102 8] _56 < _57);
    assert { _58 };
    goto BB28
  }
  BB28 {
    s_43 <- { s_43 with current = Seq.set ( * s_43) (UIntSize.to_int _56) (-1 : int32) };
    _63 <- (1 : usize);
    _64 <- UIntSize.of_int (Seq.length ( * s_43));
    _65 <- ([#"../index_range.rs" 104 12 104 16] _63 < _64);
    assert { _65 };
    goto BB29
  }
  BB29 {
    _62 <- Seq.get ( * s_43) (UIntSize.to_int _63);
    assume { Resolve0.resolve s_43 };
    _61 <- ([#"../index_range.rs" 104 12 104 21] _62 = (1 : int32));
    _60 <- not _61;
    switch (_60)
      | False -> goto BB31
      | _ -> goto BB30
      end
  }
  BB30 {
    absurd
  }
  BB31 {
    _59 <- ();
    _71 <- arr_1;
    _70 <- ([#"../index_range.rs" 106 12 106 21] Len1.len _71);
    goto BB32
  }
  BB32 {
    _69 <- ([#"../index_range.rs" 106 12 106 26] _70 = (5 : usize));
    _68 <- not _69;
    switch (_68)
      | False -> goto BB34
      | _ -> goto BB33
      end
  }
  BB33 {
    absurd
  }
  BB34 {
    _67 <- ();
    _78 <- arr_1;
    _77 <- ([#"../index_range.rs" 107 12 107 18] Index1.index _78 (0 : usize));
    goto BB35
  }
  BB35 {
    _76 <- _77;
    _75 <- ([#"../index_range.rs" 107 12 107 24] _76 = (-1 : int32));
    _74 <- not _75;
    switch (_74)
      | False -> goto BB37
      | _ -> goto BB36
      end
  }
  BB36 {
    absurd
  }
  BB37 {
    _73 <- ();
    _85 <- arr_1;
    _84 <- ([#"../index_range.rs" 108 12 108 18] Index1.index _85 (1 : usize));
    goto BB38
  }
  BB38 {
    _83 <- _84;
    _82 <- ([#"../index_range.rs" 108 12 108 23] _83 = (1 : int32));
    _81 <- not _82;
    switch (_81)
      | False -> goto BB40
      | _ -> goto BB39
      end
  }
  BB39 {
    absurd
  }
  BB40 {
    _80 <- ();
    _92 <- arr_1;
    _91 <- ([#"../index_range.rs" 109 12 109 18] Index1.index _92 (2 : usize));
    goto BB41
  }
  BB41 {
    _90 <- _91;
    _89 <- ([#"../index_range.rs" 109 12 109 24] _90 = (-1 : int32));
    _88 <- not _89;
    switch (_88)
      | False -> goto BB43
      | _ -> goto BB42
      end
  }
  BB42 {
    absurd
  }
  BB43 {
    _87 <- ();
    _99 <- arr_1;
    _98 <- ([#"../index_range.rs" 110 12 110 18] Index1.index _99 (3 : usize));
    goto BB44
  }
  BB44 {
    _97 <- _98;
    _96 <- ([#"../index_range.rs" 110 12 110 23] _97 = (3 : int32));
    _95 <- not _96;
    switch (_95)
      | False -> goto BB46
      | _ -> goto BB45
      end
  }
  BB45 {
    absurd
  }
  BB46 {
    _94 <- ();
    _106 <- arr_1;
    _105 <- ([#"../index_range.rs" 111 12 111 18] Index1.index _106 (4 : usize));
    goto BB47
  }
  BB47 {
    _104 <- _105;
    _103 <- ([#"../index_range.rs" 111 12 111 23] _104 = (4 : int32));
    _102 <- not _103;
    switch (_102)
      | False -> goto BB49
      | _ -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _101 <- ();
    _0 <- ();
    goto BB50
  }
  BB50 {
    assume { Resolve1.resolve arr_1 };
    return _0
  }
  
end
module Core_Ops_Range_RangeFrom_Type
  type core_ops_range_rangefrom_type 'idx =
    | Core_Ops_Range_RangeFrom_Type 'idx
    
  let function core_ops_range_rangefrom_type_RangeFrom_start (self : core_ops_range_rangefrom_type 'idx) : 'idx
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Ops_Range_RangeFrom_Type a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl6_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type
  use mach.int.UInt64
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (seq : Seq.seq t) =
    UInt64.to_int (Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type_RangeFrom_start self) <= Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl6
  type t
end
module CreusotContracts_Std1_Slice_Impl6_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (seq : Seq.seq t) (out : seq t)
    
end
module CreusotContracts_Std1_Slice_Impl6_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type
  use mach.int.UInt64
  use seq_ext.SeqExt
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (seq : Seq.seq t) (out : seq t)
    
   =
    SeqExt.subsequence seq (UInt64.to_int (Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type_RangeFrom_start self)) (Seq.length seq) = Model0.model out
end
module Core_Slice_Index_Impl5_Output_Type
  type t
  use prelude.Slice
  use seq.Seq
  type output  =
    seq t
end
module Core_Slice_Index_Impl5
  type t
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type
  use mach.int.Int32
  use mach.int.UInt64
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    forall i : (int) . 0 <= i /\ i < UInt64.to_int (Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type_RangeFrom_start self) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
end
module IndexRange_TestRangeFrom_Interface
  val test_range_from [@cfg:stackify] (_ : ()) : ()
end
module IndexRange_TestRangeFrom
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = int32
  clone Core_Slice_Index_Impl2_Output_Type as Output1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_HasValue as HasValue1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_InBounds as InBounds1 with type t = int32
  use Core_Ops_Range_RangeFrom_Type
  clone CreusotContracts_Std1_Slice_Impl6_ResolveElswhere as ResolveElswhere0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl0_Model as Model2 with type t = int32, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = int32
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = seq int32,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone Core_Slice_Index_Impl5_Output_Type as Output0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl6_HasValue as HasValue0 with type t = int32,
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Slice_Impl6_InBounds as InBounds0 with type t = int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve1 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl16_Index_Interface as Index1 with type t = int32, type i = usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds1.in_bounds, predicate HasValue0.has_value = HasValue1.has_value,
  type Output0.output = Output1.output
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = seq int32
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with type t = int32,
  type i = Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere, type Output0.output = Output0.output
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with type t = seq int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with type t = int32,
  type i = Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize, function Model0.model = Model2.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, type Output0.output = Output0.output,
  predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model,
  function Model1.model = Model0.model
  clone Core_Slice_Impl0_Len_Interface as Len0 with type t = int32, function Model0.model = Model1.model
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with type t = int32,
  type i = Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  type Output0.output = Output0.output
  clone IndexRange_CreateArr_Interface as CreateArr0 with function Model0.model = Model0.model
  let rec cfg test_range_from [@cfg:stackify] [#"../index_range.rs" 115 0 115 24] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var s_2 : seq int32;
  var _3 : seq int32;
  var _4 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _5 : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : seq int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : usize;
  var _28 : seq int32;
  var _29 : seq int32;
  var _30 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _31 : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize;
  var _32 : ();
  var _33 : ();
  var _34 : bool;
  var _35 : bool;
  var _36 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _37 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _38 : seq int32;
  var _39 : seq int32;
  var _40 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _41 : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize;
  var _42 : ();
  var _43 : ();
  var _44 : bool;
  var _45 : bool;
  var _46 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _47 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _48 : seq int32;
  var _49 : seq int32;
  var _50 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _51 : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize;
  var _52 : ();
  var s_53 : borrowed (seq int32);
  var _54 : borrowed (seq int32);
  var _55 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _56 : Core_Ops_Range_RangeFrom_Type.core_ops_range_rangefrom_type usize;
  var _57 : ();
  var _58 : bool;
  var _59 : bool;
  var _60 : usize;
  var _61 : seq int32;
  var _62 : ();
  var _63 : usize;
  var _64 : usize;
  var _65 : bool;
  var _66 : usize;
  var _67 : usize;
  var _68 : bool;
  var _69 : ();
  var _70 : bool;
  var _71 : bool;
  var _72 : int32;
  var _73 : usize;
  var _74 : usize;
  var _75 : bool;
  var _76 : ();
  var _77 : ();
  var _78 : bool;
  var _79 : bool;
  var _80 : usize;
  var _81 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _82 : ();
  var _83 : ();
  var _84 : bool;
  var _85 : bool;
  var _86 : int32;
  var _87 : int32;
  var _88 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _89 : ();
  var _90 : ();
  var _91 : bool;
  var _92 : bool;
  var _93 : int32;
  var _94 : int32;
  var _95 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _96 : ();
  var _97 : ();
  var _98 : bool;
  var _99 : bool;
  var _100 : int32;
  var _101 : int32;
  var _102 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _103 : ();
  var _104 : ();
  var _105 : bool;
  var _106 : bool;
  var _107 : int32;
  var _108 : int32;
  var _109 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _110 : ();
  var _111 : ();
  var _112 : bool;
  var _113 : bool;
  var _114 : int32;
  var _115 : int32;
  var _116 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _117 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 117 18 117 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeFrom_Type.Core_Ops_Range_RangeFrom_Type (3 : usize);
    _3 <- ([#"../index_range.rs" 122 13 122 21] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 123 12 123 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- false;
    goto BB5
  }
  BB4 {
    _20 <- (1 : usize);
    _21 <- UIntSize.of_int (Seq.length s_2);
    _22 <- ([#"../index_range.rs" 123 41 123 45] _20 < _21);
    assert { _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | _ -> goto BB12
      end
  }
  BB6 {
    _9 <- false;
    goto BB8
  }
  BB7 {
    _15 <- (0 : usize);
    _16 <- UIntSize.of_int (Seq.length s_2);
    _17 <- ([#"../index_range.rs" 123 28 123 32] _15 < _16);
    assert { _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | _ -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 123 12 123 24] _11 = (2 : usize));
    switch (_10)
      | False -> goto BB6
      | _ -> goto BB7
      end
  }
  BB10 {
    _14 <- Seq.get s_2 (UIntSize.to_int _15);
    _13 <- ([#"../index_range.rs" 123 28 123 37] _14 = (3 : int32));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Seq.get s_2 (UIntSize.to_int _20);
    _18 <- ([#"../index_range.rs" 123 41 123 50] _19 = (4 : int32));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    absurd
  }
  BB13 {
    _6 <- ();
    _30 <- arr_1;
    _31 <- Core_Ops_Range_RangeFrom_Type.Core_Ops_Range_RangeFrom_Type (5 : usize);
    _29 <- ([#"../index_range.rs" 128 12 128 20] Index0.index _30 _31);
    goto BB14
  }
  BB14 {
    _28 <- _29;
    _27 <- ([#"../index_range.rs" 128 12 128 26] Len0.len _28);
    goto BB15
  }
  BB15 {
    _26 <- ([#"../index_range.rs" 128 12 128 31] _27 = (0 : usize));
    _25 <- not _26;
    switch (_25)
      | False -> goto BB17
      | _ -> goto BB16
      end
  }
  BB16 {
    absurd
  }
  BB17 {
    _24 <- ();
    _40 <- arr_1;
    _39 <- ([#"../index_range.rs" 133 12 133 24] Deref0.deref _40);
    goto BB18
  }
  BB18 {
    _38 <- _39;
    _41 <- Core_Ops_Range_RangeFrom_Type.Core_Ops_Range_RangeFrom_Type (6 : usize);
    _37 <- ([#"../index_range.rs" 133 12 133 24] Get0.get _38 _41);
    goto BB19
  }
  BB19 {
    _36 <- _37;
    _35 <- ([#"../index_range.rs" 133 12 133 34] IsNone0.is_none _36);
    goto BB20
  }
  BB20 {
    _34 <- not _35;
    switch (_34)
      | False -> goto BB22
      | _ -> goto BB21
      end
  }
  BB21 {
    absurd
  }
  BB22 {
    _33 <- ();
    _50 <- arr_1;
    _49 <- ([#"../index_range.rs" 135 12 135 25] Deref0.deref _50);
    goto BB23
  }
  BB23 {
    _48 <- _49;
    _51 <- Core_Ops_Range_RangeFrom_Type.Core_Ops_Range_RangeFrom_Type (10 : usize);
    _47 <- ([#"../index_range.rs" 135 12 135 25] Get0.get _48 _51);
    goto BB24
  }
  BB24 {
    _46 <- _47;
    _45 <- ([#"../index_range.rs" 135 12 135 35] IsNone0.is_none _46);
    goto BB25
  }
  BB25 {
    _44 <- not _45;
    switch (_44)
      | False -> goto BB27
      | _ -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _43 <- ();
    _55 <- borrow_mut arr_1;
    arr_1 <-  ^ _55;
    _56 <- Core_Ops_Range_RangeFrom_Type.Core_Ops_Range_RangeFrom_Type (2 : usize);
    _54 <- ([#"../index_range.rs" 138 17 138 25] IndexMut0.index_mut _55 _56);
    goto BB28
  }
  BB28 {
    s_53 <- borrow_mut ( * _54);
    _54 <- { _54 with current = ( ^ s_53) };
    assume { Resolve0.resolve _54 };
    _61 <-  * s_53;
    _60 <- ([#"../index_range.rs" 139 12 139 19] Len0.len _61);
    goto BB29
  }
  BB29 {
    _59 <- ([#"../index_range.rs" 139 12 139 24] _60 = (3 : usize));
    _58 <- not _59;
    switch (_58)
      | False -> goto BB31
      | _ -> goto BB30
      end
  }
  BB30 {
    assume { Resolve0.resolve s_53 };
    absurd
  }
  BB31 {
    _57 <- ();
    _63 <- (0 : usize);
    _64 <- UIntSize.of_int (Seq.length ( * s_53));
    _65 <- ([#"../index_range.rs" 140 4 140 8] _63 < _64);
    assert { _65 };
    goto BB32
  }
  BB32 {
    s_53 <- { s_53 with current = Seq.set ( * s_53) (UIntSize.to_int _63) (-1 : int32) };
    _66 <- (1 : usize);
    _67 <- UIntSize.of_int (Seq.length ( * s_53));
    _68 <- ([#"../index_range.rs" 141 4 141 8] _66 < _67);
    assert { _68 };
    goto BB33
  }
  BB33 {
    s_53 <- { s_53 with current = Seq.set ( * s_53) (UIntSize.to_int _66) (-1 : int32) };
    _73 <- (2 : usize);
    _74 <- UIntSize.of_int (Seq.length ( * s_53));
    _75 <- ([#"../index_range.rs" 143 12 143 16] _73 < _74);
    assert { _75 };
    goto BB34
  }
  BB34 {
    _72 <- Seq.get ( * s_53) (UIntSize.to_int _73);
    assume { Resolve0.resolve s_53 };
    _71 <- ([#"../index_range.rs" 143 12 143 21] _72 = (4 : int32));
    _70 <- not _71;
    switch (_70)
      | False -> goto BB36
      | _ -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    _69 <- ();
    _81 <- arr_1;
    _80 <- ([#"../index_range.rs" 145 12 145 21] Len1.len _81);
    goto BB37
  }
  BB37 {
    _79 <- ([#"../index_range.rs" 145 12 145 26] _80 = (5 : usize));
    _78 <- not _79;
    switch (_78)
      | False -> goto BB39
      | _ -> goto BB38
      end
  }
  BB38 {
    absurd
  }
  BB39 {
    _77 <- ();
    _88 <- arr_1;
    _87 <- ([#"../index_range.rs" 146 12 146 18] Index1.index _88 (0 : usize));
    goto BB40
  }
  BB40 {
    _86 <- _87;
    _85 <- ([#"../index_range.rs" 146 12 146 23] _86 = (0 : int32));
    _84 <- not _85;
    switch (_84)
      | False -> goto BB42
      | _ -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    _83 <- ();
    _95 <- arr_1;
    _94 <- ([#"../index_range.rs" 147 12 147 18] Index1.index _95 (1 : usize));
    goto BB43
  }
  BB43 {
    _93 <- _94;
    _92 <- ([#"../index_range.rs" 147 12 147 23] _93 = (1 : int32));
    _91 <- not _92;
    switch (_91)
      | False -> goto BB45
      | _ -> goto BB44
      end
  }
  BB44 {
    absurd
  }
  BB45 {
    _90 <- ();
    _102 <- arr_1;
    _101 <- ([#"../index_range.rs" 148 12 148 18] Index1.index _102 (2 : usize));
    goto BB46
  }
  BB46 {
    _100 <- _101;
    _99 <- ([#"../index_range.rs" 148 12 148 24] _100 = (-1 : int32));
    _98 <- not _99;
    switch (_98)
      | False -> goto BB48
      | _ -> goto BB47
      end
  }
  BB47 {
    absurd
  }
  BB48 {
    _97 <- ();
    _109 <- arr_1;
    _108 <- ([#"../index_range.rs" 149 12 149 18] Index1.index _109 (3 : usize));
    goto BB49
  }
  BB49 {
    _107 <- _108;
    _106 <- ([#"../index_range.rs" 149 12 149 24] _107 = (-1 : int32));
    _105 <- not _106;
    switch (_105)
      | False -> goto BB51
      | _ -> goto BB50
      end
  }
  BB50 {
    absurd
  }
  BB51 {
    _104 <- ();
    _116 <- arr_1;
    _115 <- ([#"../index_range.rs" 150 12 150 18] Index1.index _116 (4 : usize));
    goto BB52
  }
  BB52 {
    _114 <- _115;
    _113 <- ([#"../index_range.rs" 150 12 150 23] _114 = (4 : int32));
    _112 <- not _113;
    switch (_112)
      | False -> goto BB54
      | _ -> goto BB53
      end
  }
  BB53 {
    absurd
  }
  BB54 {
    _111 <- ();
    _0 <- ();
    goto BB55
  }
  BB55 {
    assume { Resolve1.resolve arr_1 };
    return _0
  }
  
end
module Core_Ops_Range_RangeFull_Type
  type core_ops_range_rangefull_type  =
    | Core_Ops_Range_RangeFull_Type
    
end
module CreusotContracts_Std1_Slice_Impl7_InBounds_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (_seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_InBounds
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (_seq : Seq.seq t) =
    true
end
module CreusotContracts_Std1_Slice_Impl7
  type t
end
module CreusotContracts_Std1_Slice_Impl7_HasValue_Interface
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (seq : Seq.seq t) (out : seq t)
    
end
module CreusotContracts_Std1_Slice_Impl7_HasValue
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (seq : Seq.seq t) (out : seq t)
    
   =
    seq = Model0.model out
end
module Core_Slice_Index_Impl6_Output_Type
  type t
  use prelude.Slice
  use seq.Seq
  type output  =
    seq t
end
module Core_Slice_Index_Impl6
  type t
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (_old : Seq.seq t) (_fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type) (_old : Seq.seq t) (_fin : Seq.seq t)
    
   =
    true
end
module IndexRange_TestRangeFull_Interface
  val test_range_full [@cfg:stackify] (_ : ()) : ()
end
module IndexRange_TestRangeFull
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_Model as Model2 with type t = int32, axiom .
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = int32
  clone Core_Slice_Index_Impl2_Output_Type as Output1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_HasValue as HasValue1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_InBounds as InBounds1 with type t = int32
  use Core_Ops_Range_RangeFull_Type
  clone CreusotContracts_Std1_Slice_Impl7_ResolveElswhere as ResolveElswhere0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = int32
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = seq int32,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone Core_Slice_Index_Impl6_Output_Type as Output0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl7_HasValue as HasValue0 with type t = int32,
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Slice_Impl7_InBounds as InBounds0 with type t = int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve1 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl16_Index_Interface as Index1 with type t = int32, type i = usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds1.in_bounds, predicate HasValue0.has_value = HasValue1.has_value,
  type Output0.output = Output1.output
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = seq int32
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with type t = int32,
  type i = Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere, type Output0.output = Output0.output
  clone Core_Slice_Impl0_Len_Interface as Len0 with type t = int32, function Model0.model = Model1.model
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with type t = int32,
  type i = Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  type Output0.output = Output0.output
  clone IndexRange_CreateArr_Interface as CreateArr0 with function Model0.model = Model0.model
  let rec cfg test_range_full [@cfg:stackify] [#"../index_range.rs" 154 0 154 24] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var s_2 : seq int32;
  var _3 : seq int32;
  var _4 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _5 : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : bool;
  var _12 : bool;
  var _13 : bool;
  var _14 : usize;
  var _15 : seq int32;
  var _16 : bool;
  var _17 : int32;
  var _18 : usize;
  var _19 : usize;
  var _20 : bool;
  var _21 : bool;
  var _22 : int32;
  var _23 : usize;
  var _24 : usize;
  var _25 : bool;
  var _26 : bool;
  var _27 : int32;
  var _28 : usize;
  var _29 : usize;
  var _30 : bool;
  var _31 : bool;
  var _32 : int32;
  var _33 : usize;
  var _34 : usize;
  var _35 : bool;
  var _36 : bool;
  var _37 : int32;
  var _38 : usize;
  var _39 : usize;
  var _40 : bool;
  var _41 : ();
  var s_42 : borrowed (seq int32);
  var _43 : borrowed (seq int32);
  var _44 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _45 : Core_Ops_Range_RangeFull_Type.core_ops_range_rangefull_type;
  var _46 : ();
  var _47 : bool;
  var _48 : bool;
  var _49 : usize;
  var _50 : seq int32;
  var _51 : ();
  var _52 : usize;
  var _53 : usize;
  var _54 : bool;
  var _55 : usize;
  var _56 : usize;
  var _57 : bool;
  var _58 : ();
  var _59 : bool;
  var _60 : bool;
  var _61 : usize;
  var _62 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : int32;
  var _68 : int32;
  var _69 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _70 : ();
  var _71 : ();
  var _72 : bool;
  var _73 : bool;
  var _74 : int32;
  var _75 : int32;
  var _76 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _77 : ();
  var _78 : ();
  var _79 : bool;
  var _80 : bool;
  var _81 : int32;
  var _82 : int32;
  var _83 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _84 : ();
  var _85 : ();
  var _86 : bool;
  var _87 : bool;
  var _88 : int32;
  var _89 : int32;
  var _90 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _91 : ();
  var _92 : ();
  var _93 : bool;
  var _94 : bool;
  var _95 : int32;
  var _96 : int32;
  var _97 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _98 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 156 18 156 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeFull_Type.Core_Ops_Range_RangeFull_Type;
    _3 <- ([#"../index_range.rs" 161 13 161 20] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _15 <- s_2;
    _14 <- ([#"../index_range.rs" 162 12 162 19] Len0.len _15);
    goto BB18
  }
  BB3 {
    _8 <- false;
    goto BB5
  }
  BB4 {
    _38 <- (4 : usize);
    _39 <- UIntSize.of_int (Seq.length s_2);
    _40 <- ([#"../index_range.rs" 162 80 162 84] _38 < _39);
    assert { _40 };
    goto BB23
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB25
      | _ -> goto BB24
      end
  }
  BB6 {
    _9 <- false;
    goto BB8
  }
  BB7 {
    _33 <- (3 : usize);
    _34 <- UIntSize.of_int (Seq.length s_2);
    _35 <- ([#"../index_range.rs" 162 67 162 71] _33 < _34);
    assert { _35 };
    goto BB22
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | _ -> goto BB4
      end
  }
  BB9 {
    _10 <- false;
    goto BB11
  }
  BB10 {
    _28 <- (2 : usize);
    _29 <- UIntSize.of_int (Seq.length s_2);
    _30 <- ([#"../index_range.rs" 162 54 162 58] _28 < _29);
    assert { _30 };
    goto BB21
  }
  BB11 {
    switch (_10)
      | False -> goto BB6
      | _ -> goto BB7
      end
  }
  BB12 {
    _11 <- false;
    goto BB14
  }
  BB13 {
    _23 <- (1 : usize);
    _24 <- UIntSize.of_int (Seq.length s_2);
    _25 <- ([#"../index_range.rs" 162 41 162 45] _23 < _24);
    assert { _25 };
    goto BB20
  }
  BB14 {
    switch (_11)
      | False -> goto BB9
      | _ -> goto BB10
      end
  }
  BB15 {
    _12 <- false;
    goto BB17
  }
  BB16 {
    _18 <- (0 : usize);
    _19 <- UIntSize.of_int (Seq.length s_2);
    _20 <- ([#"../index_range.rs" 162 28 162 32] _18 < _19);
    assert { _20 };
    goto BB19
  }
  BB17 {
    switch (_12)
      | False -> goto BB12
      | _ -> goto BB13
      end
  }
  BB18 {
    _13 <- ([#"../index_range.rs" 162 12 162 24] _14 = (5 : usize));
    switch (_13)
      | False -> goto BB15
      | _ -> goto BB16
      end
  }
  BB19 {
    _17 <- Seq.get s_2 (UIntSize.to_int _18);
    _16 <- ([#"../index_range.rs" 162 28 162 37] _17 = (0 : int32));
    _12 <- _16;
    _16 <- any bool;
    goto BB17
  }
  BB20 {
    _22 <- Seq.get s_2 (UIntSize.to_int _23);
    _21 <- ([#"../index_range.rs" 162 41 162 50] _22 = (1 : int32));
    _11 <- _21;
    _21 <- any bool;
    goto BB14
  }
  BB21 {
    _27 <- Seq.get s_2 (UIntSize.to_int _28);
    _26 <- ([#"../index_range.rs" 162 54 162 63] _27 = (2 : int32));
    _10 <- _26;
    _26 <- any bool;
    goto BB11
  }
  BB22 {
    _32 <- Seq.get s_2 (UIntSize.to_int _33);
    _31 <- ([#"../index_range.rs" 162 67 162 76] _32 = (3 : int32));
    _9 <- _31;
    _31 <- any bool;
    goto BB8
  }
  BB23 {
    _37 <- Seq.get s_2 (UIntSize.to_int _38);
    _36 <- ([#"../index_range.rs" 162 80 162 89] _37 = (4 : int32));
    _8 <- _36;
    _36 <- any bool;
    goto BB5
  }
  BB24 {
    absurd
  }
  BB25 {
    _6 <- ();
    _44 <- borrow_mut arr_1;
    arr_1 <-  ^ _44;
    _45 <- Core_Ops_Range_RangeFull_Type.Core_Ops_Range_RangeFull_Type;
    _43 <- ([#"../index_range.rs" 165 17 165 24] IndexMut0.index_mut _44 _45);
    goto BB26
  }
  BB26 {
    s_42 <- borrow_mut ( * _43);
    _43 <- { _43 with current = ( ^ s_42) };
    assume { Resolve0.resolve _43 };
    _50 <-  * s_42;
    _49 <- ([#"../index_range.rs" 166 12 166 19] Len0.len _50);
    goto BB27
  }
  BB27 {
    _48 <- ([#"../index_range.rs" 166 12 166 24] _49 = (5 : usize));
    _47 <- not _48;
    switch (_47)
      | False -> goto BB29
      | _ -> goto BB28
      end
  }
  BB28 {
    assume { Resolve0.resolve s_42 };
    absurd
  }
  BB29 {
    _46 <- ();
    _52 <- (1 : usize);
    _53 <- UIntSize.of_int (Seq.length ( * s_42));
    _54 <- ([#"../index_range.rs" 167 4 167 8] _52 < _53);
    assert { _54 };
    goto BB30
  }
  BB30 {
    s_42 <- { s_42 with current = Seq.set ( * s_42) (UIntSize.to_int _52) (-1 : int32) };
    _55 <- (3 : usize);
    _56 <- UIntSize.of_int (Seq.length ( * s_42));
    _57 <- ([#"../index_range.rs" 168 4 168 8] _55 < _56);
    assert { _57 };
    goto BB31
  }
  BB31 {
    s_42 <- { s_42 with current = Seq.set ( * s_42) (UIntSize.to_int _55) (-1 : int32) };
    assume { Resolve0.resolve s_42 };
    _62 <- arr_1;
    _61 <- ([#"../index_range.rs" 170 12 170 21] Len1.len _62);
    goto BB32
  }
  BB32 {
    _60 <- ([#"../index_range.rs" 170 12 170 26] _61 = (5 : usize));
    _59 <- not _60;
    switch (_59)
      | False -> goto BB34
      | _ -> goto BB33
      end
  }
  BB33 {
    absurd
  }
  BB34 {
    _58 <- ();
    _69 <- arr_1;
    _68 <- ([#"../index_range.rs" 171 12 171 18] Index1.index _69 (0 : usize));
    goto BB35
  }
  BB35 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 171 12 171 23] _67 = (0 : int32));
    _65 <- not _66;
    switch (_65)
      | False -> goto BB37
      | _ -> goto BB36
      end
  }
  BB36 {
    absurd
  }
  BB37 {
    _64 <- ();
    _76 <- arr_1;
    _75 <- ([#"../index_range.rs" 172 12 172 18] Index1.index _76 (1 : usize));
    goto BB38
  }
  BB38 {
    _74 <- _75;
    _73 <- ([#"../index_range.rs" 172 12 172 24] _74 = (-1 : int32));
    _72 <- not _73;
    switch (_72)
      | False -> goto BB40
      | _ -> goto BB39
      end
  }
  BB39 {
    absurd
  }
  BB40 {
    _71 <- ();
    _83 <- arr_1;
    _82 <- ([#"../index_range.rs" 173 12 173 18] Index1.index _83 (2 : usize));
    goto BB41
  }
  BB41 {
    _81 <- _82;
    _80 <- ([#"../index_range.rs" 173 12 173 23] _81 = (2 : int32));
    _79 <- not _80;
    switch (_79)
      | False -> goto BB43
      | _ -> goto BB42
      end
  }
  BB42 {
    absurd
  }
  BB43 {
    _78 <- ();
    _90 <- arr_1;
    _89 <- ([#"../index_range.rs" 174 12 174 18] Index1.index _90 (3 : usize));
    goto BB44
  }
  BB44 {
    _88 <- _89;
    _87 <- ([#"../index_range.rs" 174 12 174 24] _88 = (-1 : int32));
    _86 <- not _87;
    switch (_86)
      | False -> goto BB46
      | _ -> goto BB45
      end
  }
  BB45 {
    absurd
  }
  BB46 {
    _85 <- ();
    _97 <- arr_1;
    _96 <- ([#"../index_range.rs" 175 12 175 18] Index1.index _97 (4 : usize));
    goto BB47
  }
  BB47 {
    _95 <- _96;
    _94 <- ([#"../index_range.rs" 175 12 175 23] _95 = (4 : int32));
    _93 <- not _94;
    switch (_93)
      | False -> goto BB49
      | _ -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _92 <- ();
    _0 <- ();
    goto BB50
  }
  BB50 {
    assume { Resolve1.resolve arr_1 };
    return _0
  }
  
end
module Core_Ops_Range_RangeToInclusive_Type
  type core_ops_range_rangetoinclusive_type 'idx =
    | Core_Ops_Range_RangeToInclusive_Type 'idx
    
  let function core_ops_range_rangetoinclusive_type_RangeToInclusive_end (self : core_ops_range_rangetoinclusive_type 'idx) : 'idx
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Ops_Range_RangeToInclusive_Type a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl8_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (seq : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type
  use mach.int.UInt64
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (seq : Seq.seq t)
    
   =
    UInt64.to_int (Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type_RangeToInclusive_end self) < Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl8
  type t
end
module CreusotContracts_Std1_Slice_Impl8_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (seq : Seq.seq t) (out : seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type
  use mach.int.Int32
  use mach.int.UInt64
  use seq_ext.SeqExt
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (seq : Seq.seq t) (out : seq t)
    
   =
    SeqExt.subsequence seq 0 (UInt64.to_int (Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type_RangeToInclusive_end self) + 1) = Model0.model out
end
module Core_Slice_Index_Impl8_Output_Type
  type t
  use prelude.Slice
  use seq.Seq
  type output  =
    seq t
end
module Core_Slice_Index_Impl8
  type t
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type
  use mach.int.UInt64
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    forall i : (int) . UInt64.to_int (Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type_RangeToInclusive_end self) < i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
end
module IndexRange_TestRangeToInclusive_Interface
  val test_range_to_inclusive [@cfg:stackify] (_ : ()) : ()
end
module IndexRange_TestRangeToInclusive
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = int32
  clone Core_Slice_Index_Impl2_Output_Type as Output1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_HasValue as HasValue1 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl3_InBounds as InBounds1 with type t = int32
  use Core_Ops_Range_RangeToInclusive_Type
  clone CreusotContracts_Std1_Slice_Impl8_ResolveElswhere as ResolveElswhere0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl0_Model as Model2 with type t = int32, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy_Type as ModelTy0 with type t = int32
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = seq int32,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone Core_Slice_Index_Impl8_Output_Type as Output0 with type t = int32
  clone CreusotContracts_Std1_Slice_Impl8_HasValue as HasValue0 with type t = int32,
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Slice_Impl8_InBounds as InBounds0 with type t = int32
  use Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, axiom .
  use Core_Option_Option_Type
  clone CreusotContracts_Std1_Vec_Impl3_Resolve as Resolve1 with type t = int32, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl16_Index_Interface as Index1 with type t = int32, type i = usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds1.in_bounds, predicate HasValue0.has_value = HasValue1.has_value,
  type Output0.output = Output1.output
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = seq int32
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with type t = int32,
  type i = Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere, type Output0.output = Output0.output
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with type t = seq int32
  clone Core_Slice_Impl0_Get_Interface as Get0 with type t = int32,
  type i = Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize,
  function Model0.model = Model2.model, predicate InBounds0.in_bounds = InBounds0.in_bounds,
  type Output0.output = Output0.output, predicate HasValue0.has_value = HasValue0.has_value
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with type t = int32,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model2.model,
  function Model1.model = Model0.model
  clone Core_Slice_Impl0_Len_Interface as Len0 with type t = int32, function Model0.model = Model1.model
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with type t = int32,
  type i = Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize,
  type a = Alloc_Alloc_Global_Type.alloc_alloc_global_type, function Model0.model = Model0.model,
  predicate InBounds0.in_bounds = InBounds0.in_bounds, predicate HasValue0.has_value = HasValue0.has_value,
  type Output0.output = Output0.output
  clone IndexRange_CreateArr_Interface as CreateArr0 with function Model0.model = Model0.model
  let rec cfg test_range_to_inclusive [@cfg:stackify] [#"../index_range.rs" 179 0 179 32] (_ : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr_1 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var s_2 : seq int32;
  var _3 : seq int32;
  var _4 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _5 : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize;
  var _6 : ();
  var _7 : bool;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : usize;
  var _12 : seq int32;
  var _13 : bool;
  var _14 : int32;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : bool;
  var _19 : int32;
  var _20 : usize;
  var _21 : usize;
  var _22 : bool;
  var _23 : ();
  var _24 : ();
  var _25 : bool;
  var _26 : bool;
  var _27 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _28 : Core_Option_Option_Type.core_option_option_type (seq int32);
  var _29 : seq int32;
  var _30 : seq int32;
  var _31 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _32 : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize;
  var _33 : ();
  var s_34 : borrowed (seq int32);
  var _35 : borrowed (seq int32);
  var _36 : borrowed (Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type));
  var _37 : Core_Ops_Range_RangeToInclusive_Type.core_ops_range_rangetoinclusive_type usize;
  var _38 : ();
  var _39 : bool;
  var _40 : bool;
  var _41 : usize;
  var _42 : seq int32;
  var _43 : ();
  var _44 : usize;
  var _45 : usize;
  var _46 : bool;
  var _47 : usize;
  var _48 : usize;
  var _49 : bool;
  var _50 : ();
  var _51 : bool;
  var _52 : bool;
  var _53 : int32;
  var _54 : usize;
  var _55 : usize;
  var _56 : bool;
  var _57 : ();
  var _58 : ();
  var _59 : bool;
  var _60 : bool;
  var _61 : usize;
  var _62 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _63 : ();
  var _64 : ();
  var _65 : bool;
  var _66 : bool;
  var _67 : int32;
  var _68 : int32;
  var _69 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _70 : ();
  var _71 : ();
  var _72 : bool;
  var _73 : bool;
  var _74 : int32;
  var _75 : int32;
  var _76 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _77 : ();
  var _78 : ();
  var _79 : bool;
  var _80 : bool;
  var _81 : int32;
  var _82 : int32;
  var _83 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _84 : ();
  var _85 : ();
  var _86 : bool;
  var _87 : bool;
  var _88 : int32;
  var _89 : int32;
  var _90 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _91 : ();
  var _92 : ();
  var _93 : bool;
  var _94 : bool;
  var _95 : int32;
  var _96 : int32;
  var _97 : Alloc_Vec_Vec_Type.alloc_vec_vec_type int32 (Alloc_Alloc_Global_Type.alloc_alloc_global_type);
  var _98 : ();
  {
    goto BB0
  }
  BB0 {
    arr_1 <- ([#"../index_range.rs" 181 18 181 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _4 <- arr_1;
    _5 <- Core_Ops_Range_RangeToInclusive_Type.Core_Ops_Range_RangeToInclusive_Type (1 : usize);
    _3 <- ([#"../index_range.rs" 186 13 186 22] Index0.index _4 _5);
    goto BB2
  }
  BB2 {
    s_2 <- _3;
    _12 <- s_2;
    _11 <- ([#"../index_range.rs" 187 12 187 19] Len0.len _12);
    goto BB9
  }
  BB3 {
    _8 <- false;
    goto BB5
  }
  BB4 {
    _20 <- (1 : usize);
    _21 <- UIntSize.of_int (Seq.length s_2);
    _22 <- ([#"../index_range.rs" 187 41 187 45] _20 < _21);
    assert { _22 };
    goto BB11
  }
  BB5 {
    _7 <- not _8;
    switch (_7)
      | False -> goto BB13
      | _ -> goto BB12
      end
  }
  BB6 {
    _9 <- false;
    goto BB8
  }
  BB7 {
    _15 <- (0 : usize);
    _16 <- UIntSize.of_int (Seq.length s_2);
    _17 <- ([#"../index_range.rs" 187 28 187 32] _15 < _16);
    assert { _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | _ -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 187 12 187 24] _11 = (2 : usize));
    switch (_10)
      | False -> goto BB6
      | _ -> goto BB7
      end
  }
  BB10 {
    _14 <- Seq.get s_2 (UIntSize.to_int _15);
    _13 <- ([#"../index_range.rs" 187 28 187 37] _14 = (0 : int32));
    _9 <- _13;
    _13 <- any bool;
    goto BB8
  }
  BB11 {
    _19 <- Seq.get s_2 (UIntSize.to_int _20);
    _18 <- ([#"../index_range.rs" 187 41 187 50] _19 = (1 : int32));
    _8 <- _18;
    _18 <- any bool;
    goto BB5
  }
  BB12 {
    absurd
  }
  BB13 {
    _6 <- ();
    _31 <- arr_1;
    _30 <- ([#"../index_range.rs" 192 12 192 25] Deref0.deref _31);
    goto BB14
  }
  BB14 {
    _29 <- _30;
    _32 <- Core_Ops_Range_RangeToInclusive_Type.Core_Ops_Range_RangeToInclusive_Type (5 : usize);
    _28 <- ([#"../index_range.rs" 192 12 192 25] Get0.get _29 _32);
    goto BB15
  }
  BB15 {
    _27 <- _28;
    _26 <- ([#"../index_range.rs" 192 12 192 35] IsNone0.is_none _27);
    goto BB16
  }
  BB16 {
    _25 <- not _26;
    switch (_25)
      | False -> goto BB18
      | _ -> goto BB17
      end
  }
  BB17 {
    absurd
  }
  BB18 {
    _24 <- ();
    _36 <- borrow_mut arr_1;
    arr_1 <-  ^ _36;
    _37 <- Core_Ops_Range_RangeToInclusive_Type.Core_Ops_Range_RangeToInclusive_Type (2 : usize);
    _35 <- ([#"../index_range.rs" 195 17 195 26] IndexMut0.index_mut _36 _37);
    goto BB19
  }
  BB19 {
    s_34 <- borrow_mut ( * _35);
    _35 <- { _35 with current = ( ^ s_34) };
    assume { Resolve0.resolve _35 };
    _42 <-  * s_34;
    _41 <- ([#"../index_range.rs" 196 12 196 19] Len0.len _42);
    goto BB20
  }
  BB20 {
    _40 <- ([#"../index_range.rs" 196 12 196 24] _41 = (3 : usize));
    _39 <- not _40;
    switch (_39)
      | False -> goto BB22
      | _ -> goto BB21
      end
  }
  BB21 {
    assume { Resolve0.resolve s_34 };
    absurd
  }
  BB22 {
    _38 <- ();
    _44 <- (0 : usize);
    _45 <- UIntSize.of_int (Seq.length ( * s_34));
    _46 <- ([#"../index_range.rs" 197 4 197 8] _44 < _45);
    assert { _46 };
    goto BB23
  }
  BB23 {
    s_34 <- { s_34 with current = Seq.set ( * s_34) (UIntSize.to_int _44) (-1 : int32) };
    _47 <- (2 : usize);
    _48 <- UIntSize.of_int (Seq.length ( * s_34));
    _49 <- ([#"../index_range.rs" 198 4 198 8] _47 < _48);
    assert { _49 };
    goto BB24
  }
  BB24 {
    s_34 <- { s_34 with current = Seq.set ( * s_34) (UIntSize.to_int _47) (-1 : int32) };
    _54 <- (1 : usize);
    _55 <- UIntSize.of_int (Seq.length ( * s_34));
    _56 <- ([#"../index_range.rs" 200 12 200 16] _54 < _55);
    assert { _56 };
    goto BB25
  }
  BB25 {
    _53 <- Seq.get ( * s_34) (UIntSize.to_int _54);
    assume { Resolve0.resolve s_34 };
    _52 <- ([#"../index_range.rs" 200 12 200 21] _53 = (1 : int32));
    _51 <- not _52;
    switch (_51)
      | False -> goto BB27
      | _ -> goto BB26
      end
  }
  BB26 {
    absurd
  }
  BB27 {
    _50 <- ();
    _62 <- arr_1;
    _61 <- ([#"../index_range.rs" 202 12 202 21] Len1.len _62);
    goto BB28
  }
  BB28 {
    _60 <- ([#"../index_range.rs" 202 12 202 26] _61 = (5 : usize));
    _59 <- not _60;
    switch (_59)
      | False -> goto BB30
      | _ -> goto BB29
      end
  }
  BB29 {
    absurd
  }
  BB30 {
    _58 <- ();
    _69 <- arr_1;
    _68 <- ([#"../index_range.rs" 203 12 203 18] Index1.index _69 (0 : usize));
    goto BB31
  }
  BB31 {
    _67 <- _68;
    _66 <- ([#"../index_range.rs" 203 12 203 24] _67 = (-1 : int32));
    _65 <- not _66;
    switch (_65)
      | False -> goto BB33
      | _ -> goto BB32
      end
  }
  BB32 {
    absurd
  }
  BB33 {
    _64 <- ();
    _76 <- arr_1;
    _75 <- ([#"../index_range.rs" 204 12 204 18] Index1.index _76 (1 : usize));
    goto BB34
  }
  BB34 {
    _74 <- _75;
    _73 <- ([#"../index_range.rs" 204 12 204 23] _74 = (1 : int32));
    _72 <- not _73;
    switch (_72)
      | False -> goto BB36
      | _ -> goto BB35
      end
  }
  BB35 {
    absurd
  }
  BB36 {
    _71 <- ();
    _83 <- arr_1;
    _82 <- ([#"../index_range.rs" 205 12 205 18] Index1.index _83 (2 : usize));
    goto BB37
  }
  BB37 {
    _81 <- _82;
    _80 <- ([#"../index_range.rs" 205 12 205 24] _81 = (-1 : int32));
    _79 <- not _80;
    switch (_79)
      | False -> goto BB39
      | _ -> goto BB38
      end
  }
  BB38 {
    absurd
  }
  BB39 {
    _78 <- ();
    _90 <- arr_1;
    _89 <- ([#"../index_range.rs" 206 12 206 18] Index1.index _90 (3 : usize));
    goto BB40
  }
  BB40 {
    _88 <- _89;
    _87 <- ([#"../index_range.rs" 206 12 206 23] _88 = (3 : int32));
    _86 <- not _87;
    switch (_86)
      | False -> goto BB42
      | _ -> goto BB41
      end
  }
  BB41 {
    absurd
  }
  BB42 {
    _85 <- ();
    _97 <- arr_1;
    _96 <- ([#"../index_range.rs" 207 12 207 18] Index1.index _97 (4 : usize));
    goto BB43
  }
  BB43 {
    _95 <- _96;
    _94 <- ([#"../index_range.rs" 207 12 207 23] _95 = (4 : int32));
    _93 <- not _94;
    switch (_93)
      | False -> goto BB45
      | _ -> goto BB44
      end
  }
  BB44 {
    absurd
  }
  BB45 {
    _92 <- ();
    _0 <- ();
    goto BB46
  }
  BB46 {
    assume { Resolve1.resolve arr_1 };
    return _0
  }
  
end
