
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../creusot-contracts/src/invariant.rs" 27 4 27 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Interface
  type t
  type a
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic
  type t
  type a
  use prelude.Int
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  function index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 19 8 19 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t a) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val new (_1 : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 59 26 59 44] Seq.length (ShallowModel0.shallow_model result) = 0 }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 98 8 98 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv2.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  val push (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (value : t) : ()
    requires {Inv0.inv self}
    requires {Inv1.inv value}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 69 26 69 51] ShallowModel0.shallow_model ( ^ self) = Seq.snoc (ShallowModel1.shallow_model self) value }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module IndexRange_CreateArr_Interface
  use seq.Seq
  use prelude.Int32
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val create_arr [#"../index_range.rs" 14 0 14 27] (_1 : ()) : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../index_range.rs" 7 4 12 22] Seq.length (ShallowModel0.shallow_model result) = 5 /\ Int32.to_int (IndexLogic0.index_logic result 0) = 0 /\ Int32.to_int (IndexLogic0.index_logic result 1) = 1 /\ Int32.to_int (IndexLogic0.index_logic result 2) = 2 /\ Int32.to_int (IndexLogic0.index_logic result 3) = 3 /\ Int32.to_int (IndexLogic0.index_logic result 4) = 4 }
    
end
module IndexRange_CreateArr
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = int32,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv2.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg create_arr [#"../index_range.rs" 14 0 14 27] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../index_range.rs" 7 4 12 22] Seq.length (ShallowModel0.shallow_model result) = 5 /\ Int32.to_int (IndexLogic0.index_logic result 0) = 0 /\ Int32.to_int (IndexLogic0.index_logic result 1) = 1 /\ Int32.to_int (IndexLogic0.index_logic result 2) = 2 /\ Int32.to_int (IndexLogic0.index_logic result 3) = 3 /\ Int32.to_int (IndexLogic0.index_logic result 4) = 4 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var _3 : ();
  var _4 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _5 : ();
  var _6 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _7 : ();
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _9 : ();
  var _10 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _11 : ();
  var _12 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 15 18 15 28] New0.new ());
    goto BB1
  }
  BB1 {
    _4 <- Borrow.borrow_mut arr;
    arr <-  ^ _4;
    _3 <- ([#"../index_range.rs" 17 4 17 15] Push0.push _4 ([#"../index_range.rs" 17 13 17 14] (0 : int32)));
    _4 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB2
  }
  BB2 {
    _6 <- Borrow.borrow_mut arr;
    arr <-  ^ _6;
    _5 <- ([#"../index_range.rs" 18 4 18 15] Push0.push _6 ([#"../index_range.rs" 18 13 18 14] (1 : int32)));
    _6 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB3
  }
  BB3 {
    _8 <- Borrow.borrow_mut arr;
    arr <-  ^ _8;
    _7 <- ([#"../index_range.rs" 19 4 19 15] Push0.push _8 ([#"../index_range.rs" 19 13 19 14] (2 : int32)));
    _8 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB4
  }
  BB4 {
    _10 <- Borrow.borrow_mut arr;
    arr <-  ^ _10;
    _9 <- ([#"../index_range.rs" 20 4 20 15] Push0.push _10 ([#"../index_range.rs" 20 13 20 14] (3 : int32)));
    _10 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB5
  }
  BB5 {
    _12 <- Borrow.borrow_mut arr;
    arr <-  ^ _12;
    _11 <- ([#"../index_range.rs" 21 4 21 15] Push0.push _12 ([#"../index_range.rs" 21 13 21 14] (4 : int32)));
    _12 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB6
  }
  BB6 {
    _0 <- arr;
    arr <- any Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Stub
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Interface
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Vec_Impl10_Resolve
  type t
  use prelude.Int
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 51 8 51 85] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> Resolve0.resolve (IndexLogic0.index_logic self i)
  val resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve self }
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot-contracts/src/model.rs" 80 8 80 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module Alloc_Vec_Impl12_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 131 27 131 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {Inv0.inv self}
    requires {Inv1.inv index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 132 26 132 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    ensures { Inv2.inv result }
    
end
module Core_Slice_Impl0_Len_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Slice
  use prelude.Int
  use seq.Seq
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val len (self : slice t) : usize
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 232 0 324 1] Seq.length (ShallowModel0.shallow_model self) = UIntSize.to_int result }
    
end
module Alloc_Vec_Impl8_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = slice t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val deref (self : Alloc_Vec_Vec_Type.t_vec t a) : slice t
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 137 26 137 42] ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    ensures { Inv1.inv result }
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Core_Option_Option_Type.t_option Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  val get (self : slice t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    requires {Inv0.inv self}
    requires {Inv1.inv index}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 242 8 242 102] InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . Inv2.inv r /\ result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 243 18 243 55] InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    ensures { Inv3.inv result }
    
end
module Core_Option_Impl0_IsNone_Interface
  type t
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  val is_none (self : Core_Option_Option_Type.t_option t) : bool
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/option.rs" 24 26 24 51] result = (self = Core_Option_Option_Type.C_None) }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl13_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = borrowed Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    predicate Inv0.inv = Inv3.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = i
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec t a)
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 122 27 122 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    requires {Inv0.inv self}
    requires {Inv1.inv index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 123 26 123 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 124 26 124 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 125 26 125 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 126 26 126 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    ensures { Inv2.inv result }
    
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a
  val len (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    requires {Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 66 26 66 48] UIntSize.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_Impl6_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t)
  val in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl6_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 131 20 131 70] UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self) <= UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) /\ UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 20 21 20 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 19 14 19 41] result = Slice.id self }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 20 21 20 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 19 14 19 41] shallow_model self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 20 21 20 25] Inv0.inv self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] Seq.length result <= UIntSize.to_int Max0.mAX' }
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 19 14 19 41] result = Slice.id self }
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 20 21 20 25] Inv0.inv self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 19 14 19 41] shallow_model self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl6_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl6_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t)
  val has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl6_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 137 20 137 67] SeqExt.subsequence seq (UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self)) (UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self)) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_Range_Type.t_range usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t)
  val resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl6_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 143 8 146 9] forall i : int . 0 <= i /\ (i < UIntSize.to_int (Core_Ops_Range_Range_Type.range_start self) \/ UIntSize.to_int (Core_Ops_Range_Range_Type.range_end self) <= i) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_Range_Type.t_range usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 109 20 109 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 116 20 116 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module IndexRange_TestRange_Interface
  val test_range [#"../index_range.rs" 27 0 27 19] (_1 : ()) : ()
end
module IndexRange_TestRange
  use prelude.Int
  use prelude.UIntSize
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = slice int32,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = int32,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (slice int32)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (slice int32),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = slice int32,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel4 with
    type t = int32,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl6_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl6_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl6_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve1 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl12_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate HasValue0.has_value = HasValue1.has_value,
    predicate Inv2.inv = Inv9.inv,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = slice int32
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv7.inv,
    type Output0.output = slice int32,
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32,
    predicate Inv0.inv = Inv5.inv
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv1.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv4.inv
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_Range_Type.t_range usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range [#"../index_range.rs" 27 0 27 19] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s : slice int32;
  var _3 : slice int32;
  var _8 : bool;
  var _9 : bool;
  var _11 : usize;
  var _15 : usize;
  var _17 : bool;
  var _20 : usize;
  var _22 : bool;
  var s1 : slice int32;
  var _25 : slice int32;
  var _30 : bool;
  var _31 : bool;
  var _33 : usize;
  var _37 : usize;
  var _39 : bool;
  var _42 : usize;
  var _44 : bool;
  var _49 : usize;
  var _51 : slice int32;
  var _58 : usize;
  var _60 : slice int32;
  var _66 : bool;
  var _68 : Core_Option_Option_Type.t_option (slice int32);
  var _70 : slice int32;
  var _76 : bool;
  var _78 : Core_Option_Option_Type.t_option (slice int32);
  var _80 : slice int32;
  var _86 : bool;
  var _88 : Core_Option_Option_Type.t_option (slice int32);
  var _90 : slice int32;
  var _96 : bool;
  var _98 : Core_Option_Option_Type.t_option (slice int32);
  var _100 : slice int32;
  var s2 : borrowed (slice int32);
  var _105 : borrowed (slice int32);
  var _106 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _111 : usize;
  var _114 : usize;
  var _116 : bool;
  var _117 : usize;
  var _119 : bool;
  var _124 : usize;
  var _126 : bool;
  var _131 : usize;
  var _138 : int32;
  var _145 : int32;
  var _152 : int32;
  var _159 : int32;
  var _166 : int32;
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 29 18 29 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../index_range.rs" 34 13 34 22] Index0.index arr (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 34 17 34 18] (0 : usize)) ([#"../index_range.rs" 34 20 34 21] (2 : usize))));
    goto BB2
  }
  BB2 {
    s <- _3;
    _11 <- ([#"../index_range.rs" 35 12 35 19] Len0.len s);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 35 12 35 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 35 43 35 44] (1 : usize));
    _22 <- ([#"../index_range.rs" 35 41 35 45] _20 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 35 41 35 45] _22 };
    goto BB11
  }
  BB5 {
    switch (not _8)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 35 12 35 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 35 30 35 31] (0 : usize));
    _17 <- ([#"../index_range.rs" 35 28 35 32] _15 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 35 28 35 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    switch ([#"../index_range.rs" 35 12 35 24] _11 = ([#"../index_range.rs" 35 23 35 24] (2 : usize)))
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _9 <- ([#"../index_range.rs" 35 28 35 37] Slice.get s _15 = ([#"../index_range.rs" 35 36 35 37] (0 : int32)));
    goto BB8
  }
  BB11 {
    _8 <- ([#"../index_range.rs" 35 41 35 50] Slice.get s _20 = ([#"../index_range.rs" 35 49 35 50] (1 : int32)));
    goto BB5
  }
  BB12 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB13 {
    _25 <- ([#"../index_range.rs" 37 13 37 22] Index0.index arr (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 37 17 37 18] (3 : usize)) ([#"../index_range.rs" 37 20 37 21] (5 : usize))));
    goto BB14
  }
  BB14 {
    s1 <- _25;
    _33 <- ([#"../index_range.rs" 38 12 38 19] Len0.len s1);
    goto BB21
  }
  BB15 {
    _30 <- ([#"../index_range.rs" 38 12 38 50] false);
    goto BB17
  }
  BB16 {
    _42 <- ([#"../index_range.rs" 38 43 38 44] (1 : usize));
    _44 <- ([#"../index_range.rs" 38 41 38 45] _42 < Slice.length s1);
    assert { [@expl:index in bounds] [#"../index_range.rs" 38 41 38 45] _44 };
    goto BB23
  }
  BB17 {
    switch (not _30)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB18 {
    _31 <- ([#"../index_range.rs" 38 12 38 37] false);
    goto BB20
  }
  BB19 {
    _37 <- ([#"../index_range.rs" 38 30 38 31] (0 : usize));
    _39 <- ([#"../index_range.rs" 38 28 38 32] _37 < Slice.length s1);
    assert { [@expl:index in bounds] [#"../index_range.rs" 38 28 38 32] _39 };
    goto BB22
  }
  BB20 {
    switch (_31)
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB21 {
    switch ([#"../index_range.rs" 38 12 38 24] _33 = ([#"../index_range.rs" 38 23 38 24] (2 : usize)))
      | False -> goto BB18
      | True -> goto BB19
      end
  }
  BB22 {
    _31 <- ([#"../index_range.rs" 38 28 38 37] Slice.get s1 _37 = ([#"../index_range.rs" 38 36 38 37] (3 : int32)));
    goto BB20
  }
  BB23 {
    _30 <- ([#"../index_range.rs" 38 41 38 50] Slice.get s1 _42 = ([#"../index_range.rs" 38 49 38 50] (4 : int32)));
    goto BB17
  }
  BB24 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB25 {
    _51 <- ([#"../index_range.rs" 43 12 43 21] Index0.index arr (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 43 16 43 17] (2 : usize)) ([#"../index_range.rs" 43 19 43 20] (2 : usize))));
    goto BB26
  }
  BB26 {
    _49 <- ([#"../index_range.rs" 43 12 43 27] Len0.len _51);
    goto BB27
  }
  BB27 {
    switch (not ([#"../index_range.rs" 43 12 43 32] _49 = ([#"../index_range.rs" 43 31 43 32] (0 : usize))))
      | False -> goto BB29
      | True -> goto BB28
      end
  }
  BB28 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB29 {
    _60 <- ([#"../index_range.rs" 45 12 45 21] Index0.index arr (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 45 16 45 17] (5 : usize)) ([#"../index_range.rs" 45 19 45 20] (5 : usize))));
    goto BB30
  }
  BB30 {
    _58 <- ([#"../index_range.rs" 45 12 45 27] Len0.len _60);
    goto BB31
  }
  BB31 {
    switch (not ([#"../index_range.rs" 45 12 45 32] _58 = ([#"../index_range.rs" 45 31 45 32] (0 : usize))))
      | False -> goto BB33
      | True -> goto BB32
      end
  }
  BB32 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB33 {
    _70 <- ([#"../index_range.rs" 50 12 50 25] Deref0.deref arr);
    goto BB34
  }
  BB34 {
    _68 <- ([#"../index_range.rs" 50 12 50 25] Get0.get _70 (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 50 20 50 21] (2 : usize)) ([#"../index_range.rs" 50 23 50 24] (6 : usize))));
    goto BB35
  }
  BB35 {
    _66 <- ([#"../index_range.rs" 50 12 50 35] IsNone0.is_none _68);
    goto BB36
  }
  BB36 {
    switch (not _66)
      | False -> goto BB38
      | True -> goto BB37
      end
  }
  BB37 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB38 {
    _80 <- ([#"../index_range.rs" 52 12 52 25] Deref0.deref arr);
    goto BB39
  }
  BB39 {
    _78 <- ([#"../index_range.rs" 52 12 52 25] Get0.get _80 (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 52 20 52 21] (2 : usize)) ([#"../index_range.rs" 52 23 52 24] (1 : usize))));
    goto BB40
  }
  BB40 {
    _76 <- ([#"../index_range.rs" 52 12 52 35] IsNone0.is_none _78);
    goto BB41
  }
  BB41 {
    switch (not _76)
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB43 {
    _90 <- ([#"../index_range.rs" 54 12 54 25] Deref0.deref arr);
    goto BB44
  }
  BB44 {
    _88 <- ([#"../index_range.rs" 54 12 54 25] Get0.get _90 (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 54 20 54 21] (6 : usize)) ([#"../index_range.rs" 54 23 54 24] (6 : usize))));
    goto BB45
  }
  BB45 {
    _86 <- ([#"../index_range.rs" 54 12 54 35] IsNone0.is_none _88);
    goto BB46
  }
  BB46 {
    switch (not _86)
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB48 {
    _100 <- ([#"../index_range.rs" 56 12 56 27] Deref0.deref arr);
    goto BB49
  }
  BB49 {
    _98 <- ([#"../index_range.rs" 56 12 56 27] Get0.get _100 (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 56 20 56 22] (10 : usize)) ([#"../index_range.rs" 56 24 56 26] (10 : usize))));
    goto BB50
  }
  BB50 {
    _96 <- ([#"../index_range.rs" 56 12 56 37] IsNone0.is_none _98);
    goto BB51
  }
  BB51 {
    switch (not _96)
      | False -> goto BB53
      | True -> goto BB52
      end
  }
  BB52 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB53 {
    _106 <- Borrow.borrow_mut arr;
    arr <-  ^ _106;
    _105 <- ([#"../index_range.rs" 59 17 59 26] IndexMut0.index_mut _106 (Core_Ops_Range_Range_Type.C_Range ([#"../index_range.rs" 59 21 59 22] (1 : usize)) ([#"../index_range.rs" 59 24 59 25] (4 : usize))));
    _106 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB54
  }
  BB54 {
    s2 <- Borrow.borrow_mut ( * _105);
    _105 <- { _105 with current = ( ^ s2) };
    _111 <- ([#"../index_range.rs" 60 12 60 19] Len0.len ( * s2));
    goto BB55
  }
  BB55 {
    switch (not ([#"../index_range.rs" 60 12 60 24] _111 = ([#"../index_range.rs" 60 23 60 24] (3 : usize))))
      | False -> goto BB57
      | True -> goto BB56
      end
  }
  BB56 {
    assume { Resolve0.resolve s2 };
    assume { Resolve0.resolve _105 };
    assume { Resolve1.resolve arr };
    absurd
  }
  BB57 {
    _114 <- ([#"../index_range.rs" 61 6 61 7] (0 : usize));
    _116 <- ([#"../index_range.rs" 61 4 61 8] _114 < Slice.length ( * s2));
    assert { [@expl:index in bounds] [#"../index_range.rs" 61 4 61 8] _116 };
    goto BB58
  }
  BB58 {
    s2 <- { s2 with current = Slice.set ( * s2) _114 ([#"../index_range.rs" 61 11 61 13] (-1 : int32)) };
    _117 <- ([#"../index_range.rs" 62 6 62 7] (1 : usize));
    _119 <- ([#"../index_range.rs" 62 4 62 8] _117 < Slice.length ( * s2));
    assert { [@expl:index in bounds] [#"../index_range.rs" 62 4 62 8] _119 };
    goto BB59
  }
  BB59 {
    s2 <- { s2 with current = Slice.set ( * s2) _117 ([#"../index_range.rs" 62 11 62 13] (-1 : int32)) };
    _124 <- ([#"../index_range.rs" 67 14 67 15] (2 : usize));
    _126 <- ([#"../index_range.rs" 67 12 67 16] _124 < Slice.length ( * s2));
    assert { [@expl:index in bounds] [#"../index_range.rs" 67 12 67 16] _126 };
    goto BB60
  }
  BB60 {
    assume { Resolve0.resolve s2 };
    assume { Resolve0.resolve _105 };
    switch (not ([#"../index_range.rs" 67 12 67 21] Slice.get ( * s2) _124 = ([#"../index_range.rs" 67 20 67 21] (3 : int32))))
      | False -> goto BB62
      | True -> goto BB61
      end
  }
  BB61 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB62 {
    _131 <- ([#"../index_range.rs" 69 12 69 21] Len1.len arr);
    goto BB63
  }
  BB63 {
    switch (not ([#"../index_range.rs" 69 12 69 26] _131 = ([#"../index_range.rs" 69 25 69 26] (5 : usize))))
      | False -> goto BB65
      | True -> goto BB64
      end
  }
  BB64 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB65 {
    _138 <- ([#"../index_range.rs" 70 12 70 18] Index1.index arr ([#"../index_range.rs" 70 16 70 17] (0 : usize)));
    goto BB66
  }
  BB66 {
    switch (not ([#"../index_range.rs" 70 12 70 23] _138 = ([#"../index_range.rs" 70 22 70 23] (0 : int32))))
      | False -> goto BB68
      | True -> goto BB67
      end
  }
  BB67 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB68 {
    _145 <- ([#"../index_range.rs" 71 12 71 18] Index1.index arr ([#"../index_range.rs" 71 16 71 17] (1 : usize)));
    goto BB69
  }
  BB69 {
    switch (not ([#"../index_range.rs" 71 12 71 24] _145 = ([#"../index_range.rs" 71 22 71 24] (-1 : int32))))
      | False -> goto BB71
      | True -> goto BB70
      end
  }
  BB70 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB71 {
    _152 <- ([#"../index_range.rs" 72 12 72 18] Index1.index arr ([#"../index_range.rs" 72 16 72 17] (2 : usize)));
    goto BB72
  }
  BB72 {
    switch (not ([#"../index_range.rs" 72 12 72 24] _152 = ([#"../index_range.rs" 72 22 72 24] (-1 : int32))))
      | False -> goto BB74
      | True -> goto BB73
      end
  }
  BB73 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB74 {
    _159 <- ([#"../index_range.rs" 73 12 73 18] Index1.index arr ([#"../index_range.rs" 73 16 73 17] (3 : usize)));
    goto BB75
  }
  BB75 {
    switch (not ([#"../index_range.rs" 73 12 73 23] _159 = ([#"../index_range.rs" 73 22 73 23] (3 : int32))))
      | False -> goto BB77
      | True -> goto BB76
      end
  }
  BB76 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB77 {
    _166 <- ([#"../index_range.rs" 74 12 74 18] Index1.index arr ([#"../index_range.rs" 74 16 74 17] (4 : usize)));
    goto BB78
  }
  BB78 {
    assume { Resolve1.resolve arr };
    switch (not ([#"../index_range.rs" 74 12 74 23] _166 = ([#"../index_range.rs" 74 22 74 23] (4 : int32))))
      | False -> goto BB80
      | True -> goto BB79
      end
  }
  BB79 {
    absurd
  }
  BB80 {
    _0 <- ();
    goto BB81
  }
  BB81 {
    return _0
  }
  
end
module Core_Ops_Range_RangeTo_Type
  type t_rangeto 'idx =
    | C_RangeTo 'idx
    
  let function rangeto_end (self : t_rangeto 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeTo a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl7_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t)
  val in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl7_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 154 20 154 42] UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl7_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl7_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t)
  val has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl7_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 160 20 160 57] SeqExt.subsequence seq 0 (UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self)) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t)
  val resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl7_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 166 8 166 90] forall i : int . UIntSize.to_int (Core_Ops_Range_RangeTo_Type.rangeto_end self) <= i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeTo_Type.t_rangeto usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeTo_Interface
  val test_range_to [#"../index_range.rs" 78 0 78 22] (_1 : ()) : ()
end
module IndexRange_TestRangeTo
  use prelude.Int
  use prelude.UIntSize
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = slice int32,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = int32,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (slice int32)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (slice int32),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = slice int32,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel4 with
    type t = int32,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeTo_Type as Core_Ops_Range_RangeTo_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Ops_Range_RangeTo_Type.t_rangeto usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl7_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl7_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl7_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve1 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl12_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate HasValue0.has_value = HasValue1.has_value,
    predicate Inv2.inv = Inv9.inv,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = slice int32
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv7.inv,
    type Output0.output = slice int32,
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32,
    predicate Inv0.inv = Inv5.inv
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv1.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv4.inv
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeTo_Type.t_rangeto usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_to [#"../index_range.rs" 78 0 78 22] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s : slice int32;
  var _3 : slice int32;
  var _8 : bool;
  var _9 : bool;
  var _11 : usize;
  var _15 : usize;
  var _17 : bool;
  var _20 : usize;
  var _22 : bool;
  var _27 : usize;
  var _29 : slice int32;
  var _35 : bool;
  var _37 : Core_Option_Option_Type.t_option (slice int32);
  var _39 : slice int32;
  var s1 : borrowed (slice int32);
  var _44 : borrowed (slice int32);
  var _45 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _50 : usize;
  var _53 : usize;
  var _55 : bool;
  var _56 : usize;
  var _58 : bool;
  var _63 : usize;
  var _65 : bool;
  var _70 : usize;
  var _77 : int32;
  var _84 : int32;
  var _91 : int32;
  var _98 : int32;
  var _105 : int32;
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 80 18 80 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../index_range.rs" 85 13 85 21] Index0.index arr (Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 85 19 85 20] (2 : usize))));
    goto BB2
  }
  BB2 {
    s <- _3;
    _11 <- ([#"../index_range.rs" 86 12 86 19] Len0.len s);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 86 12 86 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 86 43 86 44] (1 : usize));
    _22 <- ([#"../index_range.rs" 86 41 86 45] _20 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 86 41 86 45] _22 };
    goto BB11
  }
  BB5 {
    switch (not _8)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 86 12 86 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 86 30 86 31] (0 : usize));
    _17 <- ([#"../index_range.rs" 86 28 86 32] _15 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 86 28 86 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    switch ([#"../index_range.rs" 86 12 86 24] _11 = ([#"../index_range.rs" 86 23 86 24] (2 : usize)))
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _9 <- ([#"../index_range.rs" 86 28 86 37] Slice.get s _15 = ([#"../index_range.rs" 86 36 86 37] (0 : int32)));
    goto BB8
  }
  BB11 {
    _8 <- ([#"../index_range.rs" 86 41 86 50] Slice.get s _20 = ([#"../index_range.rs" 86 49 86 50] (1 : int32)));
    goto BB5
  }
  BB12 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB13 {
    _29 <- ([#"../index_range.rs" 91 12 91 20] Index0.index arr (Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 91 18 91 19] (0 : usize))));
    goto BB14
  }
  BB14 {
    _27 <- ([#"../index_range.rs" 91 12 91 26] Len0.len _29);
    goto BB15
  }
  BB15 {
    switch (not ([#"../index_range.rs" 91 12 91 31] _27 = ([#"../index_range.rs" 91 30 91 31] (0 : usize))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB17 {
    _39 <- ([#"../index_range.rs" 96 12 96 24] Deref0.deref arr);
    goto BB18
  }
  BB18 {
    _37 <- ([#"../index_range.rs" 96 12 96 24] Get0.get _39 (Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 96 22 96 23] (6 : usize))));
    goto BB19
  }
  BB19 {
    _35 <- ([#"../index_range.rs" 96 12 96 34] IsNone0.is_none _37);
    goto BB20
  }
  BB20 {
    switch (not _35)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB22 {
    _45 <- Borrow.borrow_mut arr;
    arr <-  ^ _45;
    _44 <- ([#"../index_range.rs" 99 17 99 25] IndexMut0.index_mut _45 (Core_Ops_Range_RangeTo_Type.C_RangeTo ([#"../index_range.rs" 99 23 99 24] (3 : usize))));
    _45 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB23
  }
  BB23 {
    s1 <- Borrow.borrow_mut ( * _44);
    _44 <- { _44 with current = ( ^ s1) };
    _50 <- ([#"../index_range.rs" 100 12 100 19] Len0.len ( * s1));
    goto BB24
  }
  BB24 {
    switch (not ([#"../index_range.rs" 100 12 100 24] _50 = ([#"../index_range.rs" 100 23 100 24] (3 : usize))))
      | False -> goto BB26
      | True -> goto BB25
      end
  }
  BB25 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _44 };
    assume { Resolve1.resolve arr };
    absurd
  }
  BB26 {
    _53 <- ([#"../index_range.rs" 101 6 101 7] (0 : usize));
    _55 <- ([#"../index_range.rs" 101 4 101 8] _53 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 101 4 101 8] _55 };
    goto BB27
  }
  BB27 {
    s1 <- { s1 with current = Slice.set ( * s1) _53 ([#"../index_range.rs" 101 11 101 13] (-1 : int32)) };
    _56 <- ([#"../index_range.rs" 102 6 102 7] (2 : usize));
    _58 <- ([#"../index_range.rs" 102 4 102 8] _56 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 102 4 102 8] _58 };
    goto BB28
  }
  BB28 {
    s1 <- { s1 with current = Slice.set ( * s1) _56 ([#"../index_range.rs" 102 11 102 13] (-1 : int32)) };
    _63 <- ([#"../index_range.rs" 104 14 104 15] (1 : usize));
    _65 <- ([#"../index_range.rs" 104 12 104 16] _63 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 104 12 104 16] _65 };
    goto BB29
  }
  BB29 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _44 };
    switch (not ([#"../index_range.rs" 104 12 104 21] Slice.get ( * s1) _63 = ([#"../index_range.rs" 104 20 104 21] (1 : int32))))
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB31 {
    _70 <- ([#"../index_range.rs" 106 12 106 21] Len1.len arr);
    goto BB32
  }
  BB32 {
    switch (not ([#"../index_range.rs" 106 12 106 26] _70 = ([#"../index_range.rs" 106 25 106 26] (5 : usize))))
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB34 {
    _77 <- ([#"../index_range.rs" 107 12 107 18] Index1.index arr ([#"../index_range.rs" 107 16 107 17] (0 : usize)));
    goto BB35
  }
  BB35 {
    switch (not ([#"../index_range.rs" 107 12 107 24] _77 = ([#"../index_range.rs" 107 22 107 24] (-1 : int32))))
      | False -> goto BB37
      | True -> goto BB36
      end
  }
  BB36 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB37 {
    _84 <- ([#"../index_range.rs" 108 12 108 18] Index1.index arr ([#"../index_range.rs" 108 16 108 17] (1 : usize)));
    goto BB38
  }
  BB38 {
    switch (not ([#"../index_range.rs" 108 12 108 23] _84 = ([#"../index_range.rs" 108 22 108 23] (1 : int32))))
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB40 {
    _91 <- ([#"../index_range.rs" 109 12 109 18] Index1.index arr ([#"../index_range.rs" 109 16 109 17] (2 : usize)));
    goto BB41
  }
  BB41 {
    switch (not ([#"../index_range.rs" 109 12 109 24] _91 = ([#"../index_range.rs" 109 22 109 24] (-1 : int32))))
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB43 {
    _98 <- ([#"../index_range.rs" 110 12 110 18] Index1.index arr ([#"../index_range.rs" 110 16 110 17] (3 : usize)));
    goto BB44
  }
  BB44 {
    switch (not ([#"../index_range.rs" 110 12 110 23] _98 = ([#"../index_range.rs" 110 22 110 23] (3 : int32))))
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB46 {
    _105 <- ([#"../index_range.rs" 111 12 111 18] Index1.index arr ([#"../index_range.rs" 111 16 111 17] (4 : usize)));
    goto BB47
  }
  BB47 {
    assume { Resolve1.resolve arr };
    switch (not ([#"../index_range.rs" 111 12 111 23] _105 = ([#"../index_range.rs" 111 22 111 23] (4 : int32))))
      | False -> goto BB49
      | True -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _0 <- ();
    goto BB50
  }
  BB50 {
    return _0
  }
  
end
module Core_Ops_Range_RangeFrom_Type
  type t_rangefrom 'idx =
    | C_RangeFrom 'idx
    
  let function rangefrom_start (self : t_rangefrom 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeFrom a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl8_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl8_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t)
  val in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl8_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 174 20 174 44] UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self) <= Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl8_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl8_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t)
  val has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl8_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 180 20 180 67] SeqExt.subsequence seq (UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self)) (Seq.length seq) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
  val resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl8_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 186 8 188 9] forall i : int . 0 <= i /\ i < UIntSize.to_int (Core_Ops_Range_RangeFrom_Type.rangefrom_start self) /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeFrom_Type.t_rangefrom usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeFrom_Interface
  val test_range_from [#"../index_range.rs" 115 0 115 24] (_1 : ()) : ()
end
module IndexRange_TestRangeFrom
  use prelude.Int
  use prelude.UIntSize
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = slice int32,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = int32,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (slice int32)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (slice int32),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = slice int32,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel4 with
    type t = int32,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFrom_Type as Core_Ops_Range_RangeFrom_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl8_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl8_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl8_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve1 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl12_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate HasValue0.has_value = HasValue1.has_value,
    predicate Inv2.inv = Inv9.inv,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = slice int32
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv7.inv,
    type Output0.output = slice int32,
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32,
    predicate Inv0.inv = Inv5.inv
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv1.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv4.inv
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFrom_Type.t_rangefrom usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_from [#"../index_range.rs" 115 0 115 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s : slice int32;
  var _3 : slice int32;
  var _8 : bool;
  var _9 : bool;
  var _11 : usize;
  var _15 : usize;
  var _17 : bool;
  var _20 : usize;
  var _22 : bool;
  var _27 : usize;
  var _29 : slice int32;
  var _35 : bool;
  var _37 : Core_Option_Option_Type.t_option (slice int32);
  var _39 : slice int32;
  var _45 : bool;
  var _47 : Core_Option_Option_Type.t_option (slice int32);
  var _49 : slice int32;
  var s1 : borrowed (slice int32);
  var _54 : borrowed (slice int32);
  var _55 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _60 : usize;
  var _63 : usize;
  var _65 : bool;
  var _66 : usize;
  var _68 : bool;
  var _73 : usize;
  var _75 : bool;
  var _80 : usize;
  var _87 : int32;
  var _94 : int32;
  var _101 : int32;
  var _108 : int32;
  var _115 : int32;
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 117 18 117 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../index_range.rs" 122 13 122 21] Index0.index arr (Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 122 17 122 18] (3 : usize))));
    goto BB2
  }
  BB2 {
    s <- _3;
    _11 <- ([#"../index_range.rs" 123 12 123 19] Len0.len s);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 123 12 123 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 123 43 123 44] (1 : usize));
    _22 <- ([#"../index_range.rs" 123 41 123 45] _20 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 123 41 123 45] _22 };
    goto BB11
  }
  BB5 {
    switch (not _8)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 123 12 123 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 123 30 123 31] (0 : usize));
    _17 <- ([#"../index_range.rs" 123 28 123 32] _15 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 123 28 123 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    switch ([#"../index_range.rs" 123 12 123 24] _11 = ([#"../index_range.rs" 123 23 123 24] (2 : usize)))
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _9 <- ([#"../index_range.rs" 123 28 123 37] Slice.get s _15 = ([#"../index_range.rs" 123 36 123 37] (3 : int32)));
    goto BB8
  }
  BB11 {
    _8 <- ([#"../index_range.rs" 123 41 123 50] Slice.get s _20 = ([#"../index_range.rs" 123 49 123 50] (4 : int32)));
    goto BB5
  }
  BB12 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB13 {
    _29 <- ([#"../index_range.rs" 128 12 128 20] Index0.index arr (Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 128 16 128 17] (5 : usize))));
    goto BB14
  }
  BB14 {
    _27 <- ([#"../index_range.rs" 128 12 128 26] Len0.len _29);
    goto BB15
  }
  BB15 {
    switch (not ([#"../index_range.rs" 128 12 128 31] _27 = ([#"../index_range.rs" 128 30 128 31] (0 : usize))))
      | False -> goto BB17
      | True -> goto BB16
      end
  }
  BB16 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB17 {
    _39 <- ([#"../index_range.rs" 133 12 133 24] Deref0.deref arr);
    goto BB18
  }
  BB18 {
    _37 <- ([#"../index_range.rs" 133 12 133 24] Get0.get _39 (Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 133 20 133 21] (6 : usize))));
    goto BB19
  }
  BB19 {
    _35 <- ([#"../index_range.rs" 133 12 133 34] IsNone0.is_none _37);
    goto BB20
  }
  BB20 {
    switch (not _35)
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB22 {
    _49 <- ([#"../index_range.rs" 135 12 135 25] Deref0.deref arr);
    goto BB23
  }
  BB23 {
    _47 <- ([#"../index_range.rs" 135 12 135 25] Get0.get _49 (Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 135 20 135 22] (10 : usize))));
    goto BB24
  }
  BB24 {
    _45 <- ([#"../index_range.rs" 135 12 135 35] IsNone0.is_none _47);
    goto BB25
  }
  BB25 {
    switch (not _45)
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB27 {
    _55 <- Borrow.borrow_mut arr;
    arr <-  ^ _55;
    _54 <- ([#"../index_range.rs" 138 17 138 25] IndexMut0.index_mut _55 (Core_Ops_Range_RangeFrom_Type.C_RangeFrom ([#"../index_range.rs" 138 21 138 22] (2 : usize))));
    _55 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB28
  }
  BB28 {
    s1 <- Borrow.borrow_mut ( * _54);
    _54 <- { _54 with current = ( ^ s1) };
    _60 <- ([#"../index_range.rs" 139 12 139 19] Len0.len ( * s1));
    goto BB29
  }
  BB29 {
    switch (not ([#"../index_range.rs" 139 12 139 24] _60 = ([#"../index_range.rs" 139 23 139 24] (3 : usize))))
      | False -> goto BB31
      | True -> goto BB30
      end
  }
  BB30 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _54 };
    assume { Resolve1.resolve arr };
    absurd
  }
  BB31 {
    _63 <- ([#"../index_range.rs" 140 6 140 7] (0 : usize));
    _65 <- ([#"../index_range.rs" 140 4 140 8] _63 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 140 4 140 8] _65 };
    goto BB32
  }
  BB32 {
    s1 <- { s1 with current = Slice.set ( * s1) _63 ([#"../index_range.rs" 140 11 140 13] (-1 : int32)) };
    _66 <- ([#"../index_range.rs" 141 6 141 7] (1 : usize));
    _68 <- ([#"../index_range.rs" 141 4 141 8] _66 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 141 4 141 8] _68 };
    goto BB33
  }
  BB33 {
    s1 <- { s1 with current = Slice.set ( * s1) _66 ([#"../index_range.rs" 141 11 141 13] (-1 : int32)) };
    _73 <- ([#"../index_range.rs" 143 14 143 15] (2 : usize));
    _75 <- ([#"../index_range.rs" 143 12 143 16] _73 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 143 12 143 16] _75 };
    goto BB34
  }
  BB34 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _54 };
    switch (not ([#"../index_range.rs" 143 12 143 21] Slice.get ( * s1) _73 = ([#"../index_range.rs" 143 20 143 21] (4 : int32))))
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB36 {
    _80 <- ([#"../index_range.rs" 145 12 145 21] Len1.len arr);
    goto BB37
  }
  BB37 {
    switch (not ([#"../index_range.rs" 145 12 145 26] _80 = ([#"../index_range.rs" 145 25 145 26] (5 : usize))))
      | False -> goto BB39
      | True -> goto BB38
      end
  }
  BB38 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB39 {
    _87 <- ([#"../index_range.rs" 146 12 146 18] Index1.index arr ([#"../index_range.rs" 146 16 146 17] (0 : usize)));
    goto BB40
  }
  BB40 {
    switch (not ([#"../index_range.rs" 146 12 146 23] _87 = ([#"../index_range.rs" 146 22 146 23] (0 : int32))))
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB42 {
    _94 <- ([#"../index_range.rs" 147 12 147 18] Index1.index arr ([#"../index_range.rs" 147 16 147 17] (1 : usize)));
    goto BB43
  }
  BB43 {
    switch (not ([#"../index_range.rs" 147 12 147 23] _94 = ([#"../index_range.rs" 147 22 147 23] (1 : int32))))
      | False -> goto BB45
      | True -> goto BB44
      end
  }
  BB44 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB45 {
    _101 <- ([#"../index_range.rs" 148 12 148 18] Index1.index arr ([#"../index_range.rs" 148 16 148 17] (2 : usize)));
    goto BB46
  }
  BB46 {
    switch (not ([#"../index_range.rs" 148 12 148 24] _101 = ([#"../index_range.rs" 148 22 148 24] (-1 : int32))))
      | False -> goto BB48
      | True -> goto BB47
      end
  }
  BB47 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB48 {
    _108 <- ([#"../index_range.rs" 149 12 149 18] Index1.index arr ([#"../index_range.rs" 149 16 149 17] (3 : usize)));
    goto BB49
  }
  BB49 {
    switch (not ([#"../index_range.rs" 149 12 149 24] _108 = ([#"../index_range.rs" 149 22 149 24] (-1 : int32))))
      | False -> goto BB51
      | True -> goto BB50
      end
  }
  BB50 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB51 {
    _115 <- ([#"../index_range.rs" 150 12 150 18] Index1.index arr ([#"../index_range.rs" 150 16 150 17] (4 : usize)));
    goto BB52
  }
  BB52 {
    assume { Resolve1.resolve arr };
    switch (not ([#"../index_range.rs" 150 12 150 23] _115 = ([#"../index_range.rs" 150 22 150 23] (4 : int32))))
      | False -> goto BB54
      | True -> goto BB53
      end
  }
  BB53 {
    absurd
  }
  BB54 {
    _0 <- ();
    goto BB55
  }
  BB55 {
    return _0
  }
  
end
module Core_Ops_Range_RangeFull_Type
  type t_rangefull  =
    | C_RangeFull
    
end
module CreusotContracts_Std1_Slice_Impl9_InBounds_Stub
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_InBounds_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t)
  val in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t) : bool
    ensures { result = in_bounds self _seq }
    
end
module CreusotContracts_Std1_Slice_Impl9_InBounds
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 196 20 196 24] true
  val in_bounds (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_seq : Seq.seq t) : bool
    ensures { result = in_bounds self _seq }
    
end
module CreusotContracts_Std1_Slice_Impl9_HasValue_Stub
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t)
end
module CreusotContracts_Std1_Slice_Impl9_HasValue_Interface
  type t
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t)
  val has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl9_HasValue
  type t
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 202 20 202 31] seq = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere_Stub
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere_Interface
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t)
  val resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self _old _fin }
    
end
module CreusotContracts_Std1_Slice_Impl9_ResolveElswhere
  type t
  use seq.Seq
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 208 20 208 24] true
  val resolve_elswhere (self : Core_Ops_Range_RangeFull_Type.t_rangefull) (_old : Seq.seq t) (_fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self _old _fin }
    
end
module IndexRange_TestRangeFull_Interface
  val test_range_full [#"../index_range.rs" 154 0 154 24] (_1 : ()) : ()
end
module IndexRange_TestRangeFull
  use prelude.Int
  use prelude.UIntSize
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = slice int32,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = int32,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = usize,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (slice int32)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed (slice int32),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = slice int32,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel4 with
    type t = int32,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeFull_Type as Core_Ops_Range_RangeFull_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Ops_Range_RangeFull_Type.t_rangefull
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Ops_Range_RangeFull_Type.t_rangefull,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl9_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl9_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate Inv0.inv = Inv8.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl9_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve1 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl12_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv6.inv,
    predicate HasValue0.has_value = HasValue1.has_value,
    predicate Inv2.inv = Inv7.inv,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = slice int32
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFull_Type.t_rangefull,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv5.inv,
    type Output0.output = slice int32,
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeFull_Type.t_rangefull,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_full [#"../index_range.rs" 154 0 154 24] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s : slice int32;
  var _3 : slice int32;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : bool;
  var _12 : bool;
  var _14 : usize;
  var _18 : usize;
  var _20 : bool;
  var _23 : usize;
  var _25 : bool;
  var _28 : usize;
  var _30 : bool;
  var _33 : usize;
  var _35 : bool;
  var _38 : usize;
  var _40 : bool;
  var s1 : borrowed (slice int32);
  var _43 : borrowed (slice int32);
  var _44 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _49 : usize;
  var _52 : usize;
  var _54 : bool;
  var _55 : usize;
  var _57 : bool;
  var _61 : usize;
  var _68 : int32;
  var _75 : int32;
  var _82 : int32;
  var _89 : int32;
  var _96 : int32;
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 156 18 156 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../index_range.rs" 161 13 161 20] Index0.index arr (Core_Ops_Range_RangeFull_Type.C_RangeFull));
    goto BB2
  }
  BB2 {
    s <- _3;
    _14 <- ([#"../index_range.rs" 162 12 162 19] Len0.len s);
    goto BB18
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 162 12 162 89] false);
    goto BB5
  }
  BB4 {
    _38 <- ([#"../index_range.rs" 162 82 162 83] (4 : usize));
    _40 <- ([#"../index_range.rs" 162 80 162 84] _38 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 80 162 84] _40 };
    goto BB23
  }
  BB5 {
    switch (not _8)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 162 12 162 76] false);
    goto BB8
  }
  BB7 {
    _33 <- ([#"../index_range.rs" 162 69 162 70] (3 : usize));
    _35 <- ([#"../index_range.rs" 162 67 162 71] _33 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 67 162 71] _35 };
    goto BB22
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    _10 <- ([#"../index_range.rs" 162 12 162 63] false);
    goto BB11
  }
  BB10 {
    _28 <- ([#"../index_range.rs" 162 56 162 57] (2 : usize));
    _30 <- ([#"../index_range.rs" 162 54 162 58] _28 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 54 162 58] _30 };
    goto BB21
  }
  BB11 {
    switch (_10)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB12 {
    _11 <- ([#"../index_range.rs" 162 12 162 50] false);
    goto BB14
  }
  BB13 {
    _23 <- ([#"../index_range.rs" 162 43 162 44] (1 : usize));
    _25 <- ([#"../index_range.rs" 162 41 162 45] _23 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 41 162 45] _25 };
    goto BB20
  }
  BB14 {
    switch (_11)
      | False -> goto BB9
      | True -> goto BB10
      end
  }
  BB15 {
    _12 <- ([#"../index_range.rs" 162 12 162 37] false);
    goto BB17
  }
  BB16 {
    _18 <- ([#"../index_range.rs" 162 30 162 31] (0 : usize));
    _20 <- ([#"../index_range.rs" 162 28 162 32] _18 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 162 28 162 32] _20 };
    goto BB19
  }
  BB17 {
    switch (_12)
      | False -> goto BB12
      | True -> goto BB13
      end
  }
  BB18 {
    switch ([#"../index_range.rs" 162 12 162 24] _14 = ([#"../index_range.rs" 162 23 162 24] (5 : usize)))
      | False -> goto BB15
      | True -> goto BB16
      end
  }
  BB19 {
    _12 <- ([#"../index_range.rs" 162 28 162 37] Slice.get s _18 = ([#"../index_range.rs" 162 36 162 37] (0 : int32)));
    goto BB17
  }
  BB20 {
    _11 <- ([#"../index_range.rs" 162 41 162 50] Slice.get s _23 = ([#"../index_range.rs" 162 49 162 50] (1 : int32)));
    goto BB14
  }
  BB21 {
    _10 <- ([#"../index_range.rs" 162 54 162 63] Slice.get s _28 = ([#"../index_range.rs" 162 62 162 63] (2 : int32)));
    goto BB11
  }
  BB22 {
    _9 <- ([#"../index_range.rs" 162 67 162 76] Slice.get s _33 = ([#"../index_range.rs" 162 75 162 76] (3 : int32)));
    goto BB8
  }
  BB23 {
    _8 <- ([#"../index_range.rs" 162 80 162 89] Slice.get s _38 = ([#"../index_range.rs" 162 88 162 89] (4 : int32)));
    goto BB5
  }
  BB24 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB25 {
    _44 <- Borrow.borrow_mut arr;
    arr <-  ^ _44;
    _43 <- ([#"../index_range.rs" 165 17 165 24] IndexMut0.index_mut _44 (Core_Ops_Range_RangeFull_Type.C_RangeFull));
    _44 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB26
  }
  BB26 {
    s1 <- Borrow.borrow_mut ( * _43);
    _43 <- { _43 with current = ( ^ s1) };
    _49 <- ([#"../index_range.rs" 166 12 166 19] Len0.len ( * s1));
    goto BB27
  }
  BB27 {
    switch (not ([#"../index_range.rs" 166 12 166 24] _49 = ([#"../index_range.rs" 166 23 166 24] (5 : usize))))
      | False -> goto BB29
      | True -> goto BB28
      end
  }
  BB28 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _43 };
    assume { Resolve1.resolve arr };
    absurd
  }
  BB29 {
    _52 <- ([#"../index_range.rs" 167 6 167 7] (1 : usize));
    _54 <- ([#"../index_range.rs" 167 4 167 8] _52 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 167 4 167 8] _54 };
    goto BB30
  }
  BB30 {
    s1 <- { s1 with current = Slice.set ( * s1) _52 ([#"../index_range.rs" 167 11 167 13] (-1 : int32)) };
    _55 <- ([#"../index_range.rs" 168 6 168 7] (3 : usize));
    _57 <- ([#"../index_range.rs" 168 4 168 8] _55 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 168 4 168 8] _57 };
    goto BB31
  }
  BB31 {
    s1 <- { s1 with current = Slice.set ( * s1) _55 ([#"../index_range.rs" 168 11 168 13] (-1 : int32)) };
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _43 };
    _61 <- ([#"../index_range.rs" 170 12 170 21] Len1.len arr);
    goto BB32
  }
  BB32 {
    switch (not ([#"../index_range.rs" 170 12 170 26] _61 = ([#"../index_range.rs" 170 25 170 26] (5 : usize))))
      | False -> goto BB34
      | True -> goto BB33
      end
  }
  BB33 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB34 {
    _68 <- ([#"../index_range.rs" 171 12 171 18] Index1.index arr ([#"../index_range.rs" 171 16 171 17] (0 : usize)));
    goto BB35
  }
  BB35 {
    switch (not ([#"../index_range.rs" 171 12 171 23] _68 = ([#"../index_range.rs" 171 22 171 23] (0 : int32))))
      | False -> goto BB37
      | True -> goto BB36
      end
  }
  BB36 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB37 {
    _75 <- ([#"../index_range.rs" 172 12 172 18] Index1.index arr ([#"../index_range.rs" 172 16 172 17] (1 : usize)));
    goto BB38
  }
  BB38 {
    switch (not ([#"../index_range.rs" 172 12 172 24] _75 = ([#"../index_range.rs" 172 22 172 24] (-1 : int32))))
      | False -> goto BB40
      | True -> goto BB39
      end
  }
  BB39 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB40 {
    _82 <- ([#"../index_range.rs" 173 12 173 18] Index1.index arr ([#"../index_range.rs" 173 16 173 17] (2 : usize)));
    goto BB41
  }
  BB41 {
    switch (not ([#"../index_range.rs" 173 12 173 23] _82 = ([#"../index_range.rs" 173 22 173 23] (2 : int32))))
      | False -> goto BB43
      | True -> goto BB42
      end
  }
  BB42 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB43 {
    _89 <- ([#"../index_range.rs" 174 12 174 18] Index1.index arr ([#"../index_range.rs" 174 16 174 17] (3 : usize)));
    goto BB44
  }
  BB44 {
    switch (not ([#"../index_range.rs" 174 12 174 24] _89 = ([#"../index_range.rs" 174 22 174 24] (-1 : int32))))
      | False -> goto BB46
      | True -> goto BB45
      end
  }
  BB45 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB46 {
    _96 <- ([#"../index_range.rs" 175 12 175 18] Index1.index arr ([#"../index_range.rs" 175 16 175 17] (4 : usize)));
    goto BB47
  }
  BB47 {
    assume { Resolve1.resolve arr };
    switch (not ([#"../index_range.rs" 175 12 175 23] _96 = ([#"../index_range.rs" 175 22 175 23] (4 : int32))))
      | False -> goto BB49
      | True -> goto BB48
      end
  }
  BB48 {
    absurd
  }
  BB49 {
    _0 <- ();
    goto BB50
  }
  BB50 {
    return _0
  }
  
end
module Core_Ops_Range_RangeToInclusive_Type
  type t_rangetoinclusive 'idx =
    | C_RangeToInclusive 'idx
    
  let function rangetoinclusive_end (self : t_rangetoinclusive 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_RangeToInclusive a -> a
      end
end
module CreusotContracts_Std1_Slice_Impl10_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl10_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t)
  val in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl10_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 216 20 216 41] UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) < Seq.length seq
  val in_bounds (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
  val has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl10_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Slice
  use seq_ext.SeqExt
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = slice t
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 222 20 222 61] SeqExt.subsequence seq 0 (UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) + 1) = ShallowModel0.shallow_model out
  val has_value (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (seq : Seq.seq t) (out : slice t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
  val resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module CreusotContracts_Std1_Slice_Impl10_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  predicate resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 228 8 228 89] forall i : int . UIntSize.to_int (Core_Ops_Range_RangeToInclusive_Type.rangetoinclusive_end self) < i /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere (self : Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module IndexRange_TestRangeToInclusive_Interface
  val test_range_to_inclusive [#"../index_range.rs" 179 0 179 32] (_1 : ()) : ()
end
module IndexRange_TestRangeToInclusive
  use prelude.Int
  use prelude.UIntSize
  use prelude.Int32
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = slice int32,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = int32,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = usize
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = usize,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (slice int32)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (slice int32),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (slice int32)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (slice int32),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = slice int32
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = slice int32,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface as ShallowModel4 with
    type t = int32,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Ops_Range_RangeToInclusive_Type as Core_Ops_Range_RangeToInclusive_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds1 with
    type t = int32
  clone CreusotContracts_Std1_Slice_Impl10_ResolveElswhere as ResolveElswhere0 with
    type t = int32
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel2 with
    type t = slice int32,
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Std1_Slice_Impl10_HasValue as HasValue0 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    predicate Inv0.inv = Inv10.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Slice_Impl10_InBounds as InBounds0 with
    type t = int32
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve1 with
    type t = int32,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl12_Index_Interface as Index1 with
    type t = int32,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds1.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate HasValue0.has_value = HasValue1.has_value,
    predicate Inv2.inv = Inv9.inv,
    type Output0.output = int32
  clone Alloc_Vec_Impl1_Len_Interface as Len1 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = slice int32
  clone Alloc_Vec_Impl13_IndexMut_Interface as IndexMut0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    predicate Inv2.inv = Inv7.inv,
    type Output0.output = slice int32,
    predicate Inv3.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  clone Core_Option_Impl0_IsNone_Interface as IsNone0 with
    type t = slice int32,
    predicate Inv0.inv = Inv5.inv
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv1.inv = Inv2.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = slice int32,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv3.inv = Inv4.inv
  clone Alloc_Vec_Impl8_Deref_Interface as Deref0 with
    type t = int32,
    type a = Alloc_Alloc_Global_Type.t_global,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    predicate Inv1.inv = Inv3.inv
  clone Core_Slice_Impl0_Len_Interface as Len0 with
    type t = int32,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Alloc_Vec_Impl12_Index_Interface as Index0 with
    type t = int32,
    type i = Core_Ops_Range_RangeToInclusive_Type.t_rangetoinclusive usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate HasValue0.has_value = HasValue0.has_value,
    predicate Inv2.inv = Inv3.inv,
    type Output0.output = slice int32
  clone IndexRange_CreateArr_Interface as CreateArr0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test_range_to_inclusive [#"../index_range.rs" 179 0 179 32] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var arr : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global);
  var s : slice int32;
  var _3 : slice int32;
  var _8 : bool;
  var _9 : bool;
  var _11 : usize;
  var _15 : usize;
  var _17 : bool;
  var _20 : usize;
  var _22 : bool;
  var _26 : bool;
  var _28 : Core_Option_Option_Type.t_option (slice int32);
  var _30 : slice int32;
  var s1 : borrowed (slice int32);
  var _35 : borrowed (slice int32);
  var _36 : borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
  var _41 : usize;
  var _44 : usize;
  var _46 : bool;
  var _47 : usize;
  var _49 : bool;
  var _54 : usize;
  var _56 : bool;
  var _61 : usize;
  var _68 : int32;
  var _75 : int32;
  var _82 : int32;
  var _89 : int32;
  var _96 : int32;
  {
    goto BB0
  }
  BB0 {
    arr <- ([#"../index_range.rs" 181 18 181 30] CreateArr0.create_arr ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../index_range.rs" 186 13 186 22] Index0.index arr (Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 186 20 186 21] (1 : usize))));
    goto BB2
  }
  BB2 {
    s <- _3;
    _11 <- ([#"../index_range.rs" 187 12 187 19] Len0.len s);
    goto BB9
  }
  BB3 {
    _8 <- ([#"../index_range.rs" 187 12 187 50] false);
    goto BB5
  }
  BB4 {
    _20 <- ([#"../index_range.rs" 187 43 187 44] (1 : usize));
    _22 <- ([#"../index_range.rs" 187 41 187 45] _20 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 187 41 187 45] _22 };
    goto BB11
  }
  BB5 {
    switch (not _8)
      | False -> goto BB13
      | True -> goto BB12
      end
  }
  BB6 {
    _9 <- ([#"../index_range.rs" 187 12 187 37] false);
    goto BB8
  }
  BB7 {
    _15 <- ([#"../index_range.rs" 187 30 187 31] (0 : usize));
    _17 <- ([#"../index_range.rs" 187 28 187 32] _15 < Slice.length s);
    assert { [@expl:index in bounds] [#"../index_range.rs" 187 28 187 32] _17 };
    goto BB10
  }
  BB8 {
    switch (_9)
      | False -> goto BB3
      | True -> goto BB4
      end
  }
  BB9 {
    switch ([#"../index_range.rs" 187 12 187 24] _11 = ([#"../index_range.rs" 187 23 187 24] (2 : usize)))
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB10 {
    _9 <- ([#"../index_range.rs" 187 28 187 37] Slice.get s _15 = ([#"../index_range.rs" 187 36 187 37] (0 : int32)));
    goto BB8
  }
  BB11 {
    _8 <- ([#"../index_range.rs" 187 41 187 50] Slice.get s _20 = ([#"../index_range.rs" 187 49 187 50] (1 : int32)));
    goto BB5
  }
  BB12 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB13 {
    _30 <- ([#"../index_range.rs" 192 12 192 25] Deref0.deref arr);
    goto BB14
  }
  BB14 {
    _28 <- ([#"../index_range.rs" 192 12 192 25] Get0.get _30 (Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 192 23 192 24] (5 : usize))));
    goto BB15
  }
  BB15 {
    _26 <- ([#"../index_range.rs" 192 12 192 35] IsNone0.is_none _28);
    goto BB16
  }
  BB16 {
    switch (not _26)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB17 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB18 {
    _36 <- Borrow.borrow_mut arr;
    arr <-  ^ _36;
    _35 <- ([#"../index_range.rs" 195 17 195 26] IndexMut0.index_mut _36 (Core_Ops_Range_RangeToInclusive_Type.C_RangeToInclusive ([#"../index_range.rs" 195 24 195 25] (2 : usize))));
    _36 <- any borrowed (Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global));
    goto BB19
  }
  BB19 {
    s1 <- Borrow.borrow_mut ( * _35);
    _35 <- { _35 with current = ( ^ s1) };
    _41 <- ([#"../index_range.rs" 196 12 196 19] Len0.len ( * s1));
    goto BB20
  }
  BB20 {
    switch (not ([#"../index_range.rs" 196 12 196 24] _41 = ([#"../index_range.rs" 196 23 196 24] (3 : usize))))
      | False -> goto BB22
      | True -> goto BB21
      end
  }
  BB21 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _35 };
    assume { Resolve1.resolve arr };
    absurd
  }
  BB22 {
    _44 <- ([#"../index_range.rs" 197 6 197 7] (0 : usize));
    _46 <- ([#"../index_range.rs" 197 4 197 8] _44 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 197 4 197 8] _46 };
    goto BB23
  }
  BB23 {
    s1 <- { s1 with current = Slice.set ( * s1) _44 ([#"../index_range.rs" 197 11 197 13] (-1 : int32)) };
    _47 <- ([#"../index_range.rs" 198 6 198 7] (2 : usize));
    _49 <- ([#"../index_range.rs" 198 4 198 8] _47 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 198 4 198 8] _49 };
    goto BB24
  }
  BB24 {
    s1 <- { s1 with current = Slice.set ( * s1) _47 ([#"../index_range.rs" 198 11 198 13] (-1 : int32)) };
    _54 <- ([#"../index_range.rs" 200 14 200 15] (1 : usize));
    _56 <- ([#"../index_range.rs" 200 12 200 16] _54 < Slice.length ( * s1));
    assert { [@expl:index in bounds] [#"../index_range.rs" 200 12 200 16] _56 };
    goto BB25
  }
  BB25 {
    assume { Resolve0.resolve s1 };
    assume { Resolve0.resolve _35 };
    switch (not ([#"../index_range.rs" 200 12 200 21] Slice.get ( * s1) _54 = ([#"../index_range.rs" 200 20 200 21] (1 : int32))))
      | False -> goto BB27
      | True -> goto BB26
      end
  }
  BB26 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB27 {
    _61 <- ([#"../index_range.rs" 202 12 202 21] Len1.len arr);
    goto BB28
  }
  BB28 {
    switch (not ([#"../index_range.rs" 202 12 202 26] _61 = ([#"../index_range.rs" 202 25 202 26] (5 : usize))))
      | False -> goto BB30
      | True -> goto BB29
      end
  }
  BB29 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB30 {
    _68 <- ([#"../index_range.rs" 203 12 203 18] Index1.index arr ([#"../index_range.rs" 203 16 203 17] (0 : usize)));
    goto BB31
  }
  BB31 {
    switch (not ([#"../index_range.rs" 203 12 203 24] _68 = ([#"../index_range.rs" 203 22 203 24] (-1 : int32))))
      | False -> goto BB33
      | True -> goto BB32
      end
  }
  BB32 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB33 {
    _75 <- ([#"../index_range.rs" 204 12 204 18] Index1.index arr ([#"../index_range.rs" 204 16 204 17] (1 : usize)));
    goto BB34
  }
  BB34 {
    switch (not ([#"../index_range.rs" 204 12 204 23] _75 = ([#"../index_range.rs" 204 22 204 23] (1 : int32))))
      | False -> goto BB36
      | True -> goto BB35
      end
  }
  BB35 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB36 {
    _82 <- ([#"../index_range.rs" 205 12 205 18] Index1.index arr ([#"../index_range.rs" 205 16 205 17] (2 : usize)));
    goto BB37
  }
  BB37 {
    switch (not ([#"../index_range.rs" 205 12 205 24] _82 = ([#"../index_range.rs" 205 22 205 24] (-1 : int32))))
      | False -> goto BB39
      | True -> goto BB38
      end
  }
  BB38 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB39 {
    _89 <- ([#"../index_range.rs" 206 12 206 18] Index1.index arr ([#"../index_range.rs" 206 16 206 17] (3 : usize)));
    goto BB40
  }
  BB40 {
    switch (not ([#"../index_range.rs" 206 12 206 23] _89 = ([#"../index_range.rs" 206 22 206 23] (3 : int32))))
      | False -> goto BB42
      | True -> goto BB41
      end
  }
  BB41 {
    assume { Resolve1.resolve arr };
    absurd
  }
  BB42 {
    _96 <- ([#"../index_range.rs" 207 12 207 18] Index1.index arr ([#"../index_range.rs" 207 16 207 17] (4 : usize)));
    goto BB43
  }
  BB43 {
    assume { Resolve1.resolve arr };
    switch (not ([#"../index_range.rs" 207 12 207 23] _96 = ([#"../index_range.rs" 207 22 207 23] (4 : int32))))
      | False -> goto BB45
      | True -> goto BB44
      end
  }
  BB44 {
    absurd
  }
  BB45 {
    _0 <- ();
    goto BB46
  }
  BB46 {
    return _0
  }
  
end
