module M_991__qyi6256438357931963096__love_and_hope [#"991.rs" 22 4 22 27] (* Formula *)
  let%span s9910 = "991.rs" 21 14 21 28
  let%span smodel1 = "../../../../creusot-contracts/src/model.rs" 88 8 88 22
  let%span s9912 = "991.rs" 16 8 16 33
  let%span svec3 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_Cap'0  =
    { t_Cap__0'0: usize }
  
  type t_RawVec'0  =
    { t_RawVec__ptr'0: t_Unique'0; t_RawVec__cap'0: t_Cap'0; t_RawVec__alloc'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  type t_Formula'0  =
    { t_Formula__vec'0: t_Vec'0; t_Formula__b'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : usize = (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  function view'2 (self : t_Vec'0) : Seq.seq usize
  
  axiom view'2_spec : forall self : t_Vec'0 . [%#svec3] Seq.length (view'2 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  function view'1 [#"991.rs" 15 4 15 33] (self : t_Formula'0) : (Seq.seq usize, bool) =
    [%#s9912] (view'2 self.t_Formula__vec'0, self.t_Formula__b'0)
  
  function view'0 (self : t_Formula'0) : (Seq.seq usize, bool) =
    [%#smodel1] view'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec love_and_hope'0 (self:t_Formula'0) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> {[@expl:love_and_hope ensures] [%#s9910] view'0 self = view'0 self} (! return' {result}) ] 
end
