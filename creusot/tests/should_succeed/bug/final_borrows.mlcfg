
module FinalBorrows_ReborrowId
  type t
  use prelude.Borrow
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg reborrow_id [#"../final_borrows.rs" 5 0 5 42] [@cfg:stackify] [@cfg:subregion_analysis] (r : borrowed t) : borrowed t
    requires {[#"../final_borrows.rs" 5 22 5 23] inv1 r}
    ensures { [#"../final_borrows.rs" 4 10 4 21] result = r }
    ensures { [#"../final_borrows.rs" 5 36 5 42] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var r : borrowed t = r;
  var _2 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 6 4 6 5] _2 <- Borrow.borrow_final ( * r) (Borrow.get_id r);
    [#"../final_borrows.rs" 6 4 6 5] r <- { r with current = ( ^ _2) ; };
    assume { inv0 ( ^ _2) };
    [#"../final_borrows.rs" 6 4 6 5] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 6 4 6 5] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv0 ( ^ _0) };
    assert { [@expl:type invariant] inv1 _2 };
    assume { resolve0 _2 };
    assert { [@expl:type invariant] inv1 r };
    assume { resolve0 r };
    return _0
  }
  
end
module FinalBorrows_Select
  type t
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : t . inv1 x = true
  use prelude.Borrow
  predicate invariant0 (self : borrowed t)
  val invariant0 (self : borrowed t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed t)
  val inv0 (_x : borrowed t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed t . inv0 x = true
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg select [#"../final_borrows.rs" 10 0 10 72] [@cfg:stackify] [@cfg:subregion_analysis] (b : bool) (r1 : borrowed t) (r2 : borrowed t) : borrowed t
    requires {[#"../final_borrows.rs" 10 30 10 32] inv0 r1}
    requires {[#"../final_borrows.rs" 10 45 10 47] inv0 r2}
    ensures { [#"../final_borrows.rs" 9 0 9 55] if b then result = r1 else result = r2 }
    ensures { [#"../final_borrows.rs" 10 63 10 72] inv0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var b : bool = b;
  var r1 : borrowed t = r1;
  var r2 : borrowed t = r2;
  var _4 : borrowed t;
  var _6 : borrowed t;
  var _8 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    switch ([#"../final_borrows.rs" 11 7 11 8] b)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assert { [@expl:type invariant] inv0 r2 };
    assume { resolve0 r2 };
    [#"../final_borrows.rs" 12 8 12 10] _8 <- Borrow.borrow_final ( * r1) (Borrow.get_id r1);
    [#"../final_borrows.rs" 12 8 12 10] r1 <- { r1 with current = ( ^ _8) ; };
    assume { inv1 ( ^ _8) };
    [#"../final_borrows.rs" 12 8 12 10] _6 <- Borrow.borrow_final ( * _8) (Borrow.get_id _8);
    [#"../final_borrows.rs" 12 8 12 10] _8 <- { _8 with current = ( ^ _6) ; };
    assume { inv1 ( ^ _6) };
    assert { [@expl:type invariant] inv0 _8 };
    assume { resolve0 _8 };
    goto BB3
  }
  BB2 {
    assert { [@expl:type invariant] inv0 r1 };
    assume { resolve0 r1 };
    [#"../final_borrows.rs" 14 8 14 10] _6 <- Borrow.borrow_final ( * r2) (Borrow.get_id r2);
    [#"../final_borrows.rs" 14 8 14 10] r2 <- { r2 with current = ( ^ _6) ; };
    assume { inv1 ( ^ _6) };
    goto BB3
  }
  BB3 {
    [#"../final_borrows.rs" 11 4 15 5] _4 <- Borrow.borrow_final ( * _6) (Borrow.get_id _6);
    [#"../final_borrows.rs" 11 4 15 5] _6 <- { _6 with current = ( ^ _4) ; };
    assume { inv1 ( ^ _4) };
    [#"../final_borrows.rs" 11 4 15 5] _0 <- Borrow.borrow_final ( * _4) (Borrow.get_id _4);
    [#"../final_borrows.rs" 11 4 15 5] _4 <- { _4 with current = ( ^ _0) ; };
    assume { inv1 ( ^ _0) };
    assert { [@expl:type invariant] inv0 _6 };
    assume { resolve0 _6 };
    assert { [@expl:type invariant] inv0 _4 };
    assume { resolve0 _4 };
    assert { [@expl:type invariant] inv0 r2 };
    assume { resolve0 r2 };
    assert { [@expl:type invariant] inv0 r1 };
    assume { resolve0 r1 };
    return _0
  }
  
end
module FinalBorrows_ReborrowField
  type t
  use prelude.Borrow
  predicate invariant2 (self : borrowed (t, t))
  val invariant2 (self : borrowed (t, t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed (t, t))
  val inv2 (_x : borrowed (t, t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed (t, t) . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve1 (self : borrowed (t, t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (t, t)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg reborrow_field [#"../final_borrows.rs" 19 0 19 50] [@cfg:stackify] [@cfg:subregion_analysis] (r : borrowed (t, t)) : borrowed t
    requires {[#"../final_borrows.rs" 19 25 19 26] inv2 r}
    ensures { [#"../final_borrows.rs" 18 10 18 28] result = Borrow.borrow_logic (let (a, _) =  * r in a) (let (a, _) =  ^ r in a) (Borrow.inherit_id (Borrow.get_id r) 1) }
    ensures { [#"../final_borrows.rs" 19 44 19 50] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var r : borrowed (t, t) = r;
  var _2 : borrowed t;
  var _4 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 20 4 20 12] _4 <- Borrow.borrow_final (let (a, _) =  * r in a) (Borrow.inherit_id (Borrow.get_id r) 1);
    [#"../final_borrows.rs" 20 4 20 12] r <- { r with current = (let (x0, x1) =  * r in ( ^ _4, x1)) ; };
    assume { inv0 ( ^ _4) };
    [#"../final_borrows.rs" 20 4 20 12] _2 <- Borrow.borrow_final ( * _4) (Borrow.get_id _4);
    [#"../final_borrows.rs" 20 4 20 12] _4 <- { _4 with current = ( ^ _2) ; };
    assume { inv0 ( ^ _2) };
    [#"../final_borrows.rs" 20 4 20 12] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 20 4 20 12] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv0 ( ^ _0) };
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    assert { [@expl:type invariant] inv1 _2 };
    assume { resolve0 _2 };
    assert { [@expl:type invariant] inv2 r };
    assume { resolve1 r };
    return _0
  }
  
end
module FinalBorrows_NestedFields
  type t
  use prelude.Borrow
  predicate invariant4 (self : borrowed ((t, t), t))
  val invariant4 (self : borrowed ((t, t), t)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed ((t, t), t))
  val inv4 (_x : borrowed ((t, t), t)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed ((t, t), t) . inv4 x = true
  predicate invariant3 (self : borrowed t)
  val invariant3 (self : borrowed t) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : borrowed t)
  val inv3 (_x : borrowed t) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : borrowed t . inv3 x = true
  predicate invariant2 (self : borrowed (t, t))
  val invariant2 (self : borrowed (t, t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed (t, t))
  val inv2 (_x : borrowed (t, t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed (t, t) . inv2 x = true
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : t . inv1 x = true
  predicate invariant0 (self : (t, t))
  val invariant0 (self : (t, t)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (t, t))
  val inv0 (_x : (t, t)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (t, t) . inv0 x = true
  predicate resolve2 (self : borrowed ((t, t), t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed ((t, t), t)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed (t, t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (t, t)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg nested_fields [#"../final_borrows.rs" 24 0 24 54] [@cfg:stackify] [@cfg:subregion_analysis] (r : borrowed ((t, t), t)) : borrowed t
    requires {[#"../final_borrows.rs" 24 24 24 25] inv4 r}
    ensures { [#"../final_borrows.rs" 23 0 23 32] result = Borrow.borrow_logic (let (_, a) = let (a, _) =  * r in a in a) (let (_, a) = let (a, _) =  ^ r in a in a) (Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id r) 1) 2) }
    ensures { [#"../final_borrows.rs" 24 48 24 54] inv3 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var r : borrowed ((t, t), t) = r;
  var _2 : borrowed t;
  var borrow1 : borrowed (t, t);
  var _5 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 25 18 25 26] borrow1 <- Borrow.borrow_final (let (a, _) =  * r in a) (Borrow.inherit_id (Borrow.get_id r) 1);
    [#"../final_borrows.rs" 25 18 25 26] r <- { r with current = (let (x0, x1) =  * r in ( ^ borrow1, x1)) ; };
    assume { inv0 ( ^ borrow1) };
    [#"../final_borrows.rs" 26 4 26 18] _5 <- Borrow.borrow_final (let (_, a) =  * borrow1 in a) (Borrow.inherit_id (Borrow.get_id borrow1) 2);
    [#"../final_borrows.rs" 26 4 26 18] borrow1 <- { borrow1 with current = (let (x0, x1) =  * borrow1 in (x0,  ^ _5)) ; };
    assume { inv1 ( ^ _5) };
    [#"../final_borrows.rs" 26 4 26 18] _2 <- Borrow.borrow_final ( * _5) (Borrow.get_id _5);
    [#"../final_borrows.rs" 26 4 26 18] _5 <- { _5 with current = ( ^ _2) ; };
    assume { inv1 ( ^ _2) };
    assert { [@expl:type invariant] inv2 borrow1 };
    assume { resolve0 borrow1 };
    [#"../final_borrows.rs" 26 4 26 18] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 26 4 26 18] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv1 ( ^ _0) };
    assert { [@expl:type invariant] inv3 _5 };
    assume { resolve1 _5 };
    assert { [@expl:type invariant] inv3 _2 };
    assume { resolve1 _2 };
    assert { [@expl:type invariant] inv4 r };
    assume { resolve2 r };
    return _0
  }
  
end
module FinalBorrows_ReallyNestedFields
  type t
  use prelude.Borrow
  predicate invariant2 (self : (borrowed (t, t), t))
  val invariant2 (self : (borrowed (t, t), t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : (borrowed (t, t), t))
  val inv2 (_x : (borrowed (t, t), t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : (borrowed (t, t), t) . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve3 (self : t)
  val resolve3 (self : t) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : borrowed (t, t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed (t, t)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : (borrowed (t, t), t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve2 (let (a, _) = self in a) /\ resolve3 (let (_, a) = self in a)
  val resolve1 (self : (borrowed (t, t), t)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg really_nested_fields [#"../final_borrows.rs" 30 0 30 61] [@cfg:stackify] [@cfg:subregion_analysis] (x : (borrowed (t, t), t)) : borrowed t
    requires {[#"../final_borrows.rs" 30 31 30 32] inv2 x}
    ensures { [#"../final_borrows.rs" 29 10 29 33] result = Borrow.borrow_logic (let (_, a) =  * (let (a, _) = x in a) in a) (let (_, a) =  ^ (let (a, _) = x in a) in a) (Borrow.inherit_id (Borrow.get_id (let (a, _) = x in a)) 2) }
    ensures { [#"../final_borrows.rs" 30 55 30 61] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var x : (borrowed (t, t), t) = x;
  var _2 : borrowed t;
  var borrow : borrowed t;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../final_borrows.rs" 31 17 31 30] borrow <- Borrow.borrow_final (let (_, a) =  * (let (a, _) = x in a) in a) (Borrow.inherit_id (Borrow.get_id (let (a, _) = x in a)) 2);
    [#"../final_borrows.rs" 31 17 31 30] x <- (let (x0, x1) = x in ({ (let (a, _) = x in a) with current = (let (x0, x1) =  * (let (a, _) = x in a) in (x0,  ^ borrow)) ; }, x1));
    assume { inv0 ( ^ borrow) };
    [#"../final_borrows.rs" 32 4 32 10] _2 <- Borrow.borrow_final ( * borrow) (Borrow.get_id borrow);
    [#"../final_borrows.rs" 32 4 32 10] borrow <- { borrow with current = ( ^ _2) ; };
    assume { inv0 ( ^ _2) };
    assert { [@expl:type invariant] inv1 borrow };
    assume { resolve0 borrow };
    [#"../final_borrows.rs" 32 4 32 10] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 32 4 32 10] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv0 ( ^ _0) };
    assert { [@expl:type invariant] inv1 _2 };
    assume { resolve0 _2 };
    goto BB2
  }
  BB2 {
    assert { [@expl:type invariant] inv2 x };
    assume { resolve1 x };
    return _0
  }
  
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module FinalBorrows_SelectField
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Borrow
  predicate invariant4 (self : borrowed (Core_Option_Option_Type.t_option t, t))
  val invariant4 (self : borrowed (Core_Option_Option_Type.t_option t, t)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Core_Option_Option_Type.t_option t, t))
  val inv4 (_x : borrowed (Core_Option_Option_Type.t_option t, t)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed (Core_Option_Option_Type.t_option t, t) . inv4 x = true
  predicate invariant3 (self : borrowed t)
  val invariant3 (self : borrowed t) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : borrowed t)
  val inv3 (_x : borrowed t) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : borrowed t . inv3 x = true
  predicate invariant2 (self : t)
  val invariant2 (self : t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : t)
  val inv2 (_x : t) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : t . inv2 x = true
  predicate invariant1 (self : borrowed (Core_Option_Option_Type.t_option t))
  val invariant1 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed (Core_Option_Option_Type.t_option t))
  val inv1 (_x : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Core_Option_Option_Type.t_option t) . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option t)
  val invariant0 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option t)
  val inv0 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option t . inv0 x = true
  predicate resolve2 (self : borrowed (Core_Option_Option_Type.t_option t, t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed (Core_Option_Option_Type.t_option t, t)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg select_field [#"../final_borrows.rs" 39 0 39 56] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Core_Option_Option_Type.t_option t, t)) : borrowed t
    requires {[#"../final_borrows.rs" 39 23 39 24] inv4 x}
    ensures { [#"../final_borrows.rs" 35 10 38 1] match let (a, _) =  * x in a with
      | Core_Option_Option_Type.C_None -> result = Borrow.borrow_logic (let (_, a) =  * x in a) (let (_, a) =  ^ x in a) (Borrow.inherit_id (Borrow.get_id x) 2)
      | Core_Option_Option_Type.C_Some _ -> exists r : borrowed t . inv3 r /\ result = r /\ (let (a, _) =  * x in a) = Core_Option_Option_Type.C_Some ( * r) /\ (let (a, _) =  ^ x in a) = Core_Option_Option_Type.C_Some ( ^ r)
      end }
    ensures { [#"../final_borrows.rs" 39 50 39 56] inv3 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var x : borrowed (Core_Option_Option_Type.t_option t, t) = x;
  var _4 : borrowed (Core_Option_Option_Type.t_option t);
  var r : borrowed t;
  var _8 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 40 10 40 18] _4 <- Borrow.borrow_final (let (a, _) =  * x in a) (Borrow.inherit_id (Borrow.get_id x) 1);
    [#"../final_borrows.rs" 40 10 40 18] x <- { x with current = (let (x0, x1) =  * x in ( ^ _4, x1)) ; };
    assume { inv0 ( ^ _4) };
    switch ( * _4)
      | Core_Option_Option_Type.C_None -> goto BB1
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      end
  }
  BB1 {
    goto BB4
  }
  BB2 {
    [#"../final_borrows.rs" 42 13 42 14] r <- Borrow.borrow_final (Core_Option_Option_Type.some_0 ( * _4)) (Borrow.inherit_id (Borrow.get_id _4) 1);
    [#"../final_borrows.rs" 42 13 42 14] _4 <- { _4 with current = (let Core_Option_Option_Type.C_Some x0 =  * _4 in Core_Option_Option_Type.C_Some ( ^ r)) ; };
    assume { inv2 ( ^ r) };
    [#"../final_borrows.rs" 42 26 42 27] _0 <- Borrow.borrow_final ( * r) (Borrow.get_id r);
    [#"../final_borrows.rs" 42 26 42 27] r <- { r with current = ( ^ _0) ; };
    assume { inv2 ( ^ _0) };
    assert { [@expl:type invariant] inv3 r };
    assume { resolve1 r };
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    goto BB5
  }
  BB3 {
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    assert { [@expl:type invariant] inv4 x };
    assume { resolve2 x };
    assert { [#"../final_borrows.rs" 40 10 40 18] false };
    absurd
  }
  BB4 {
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    [#"../final_borrows.rs" 44 4 44 12] _8 <- Borrow.borrow_final (let (_, a) =  * x in a) (Borrow.inherit_id (Borrow.get_id x) 2);
    [#"../final_borrows.rs" 44 4 44 12] x <- { x with current = (let (x0, x1) =  * x in (x0,  ^ _8)) ; };
    assume { inv2 ( ^ _8) };
    [#"../final_borrows.rs" 44 4 44 12] _0 <- Borrow.borrow_final ( * _8) (Borrow.get_id _8);
    [#"../final_borrows.rs" 44 4 44 12] _8 <- { _8 with current = ( ^ _0) ; };
    assume { inv2 ( ^ _0) };
    assert { [@expl:type invariant] inv3 _8 };
    assume { resolve1 _8 };
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] inv4 x };
    assume { resolve2 x };
    return _0
  }
  
end
module FinalBorrows_Set7
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let rec cfg set_7 [#"../final_borrows.rs" 48 0 48 21] [@cfg:stackify] [@cfg:subregion_analysis] (r : borrowed int32) : ()
    ensures { [#"../final_borrows.rs" 47 10 47 20] Int32.to_int ( ^ r) = 7 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var r : borrowed int32 = r;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 49 4 49 10] r <- { r with current = ([#"../final_borrows.rs" 49 4 49 10] [#"../final_borrows.rs" 49 9 49 10] (7 : int32)) ; };
    assume { resolve0 r };
    [#"../final_borrows.rs" 48 22 50 1] _0 <- ([#"../final_borrows.rs" 48 22 50 1] ());
    return _0
  }
  
end
module FinalBorrows_NotFinalBorrowWorks
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  val set_70 [#"../final_borrows.rs" 48 0 48 21] (r : borrowed int32) : ()
    ensures { [#"../final_borrows.rs" 47 10 47 20] Int32.to_int ( ^ r) = 7 }
    
  let rec cfg not_final_borrow_works [#"../final_borrows.rs" 53 0 53 38] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : int32
    ensures { [#"../final_borrows.rs" 52 10 52 22] Int32.to_int result = 9 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var x : int32;
  var r : borrowed int32;
  var r1 : borrowed int32;
  var _6 : ();
  var _7 : borrowed int32;
  var y : int32;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 54 16 54 20] x <- ([#"../final_borrows.rs" 54 16 54 20] [#"../final_borrows.rs" 54 16 54 20] (1 : int32));
    [#"../final_borrows.rs" 55 12 55 18] r <- Borrow.borrow_mut x;
    [#"../final_borrows.rs" 55 12 55 18] x <-  ^ r;
    [#"../final_borrows.rs" 56 13 56 20] r1 <- Borrow.borrow_final ( * r) (Borrow.get_id r);
    [#"../final_borrows.rs" 56 13 56 20] r <- { r with current = ( ^ r1) ; };
    [#"../final_borrows.rs" 57 10 57 12] _7 <- Borrow.borrow_final ( * r1) (Borrow.get_id r1);
    [#"../final_borrows.rs" 57 10 57 12] r1 <- { r1 with current = ( ^ _7) ; };
    [#"../final_borrows.rs" 57 4 57 13] _6 <- ([#"../final_borrows.rs" 57 4 57 13] set_70 _7);
    _7 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve0 r1 };
    [#"../final_borrows.rs" 58 12 58 14] y <- ([#"../final_borrows.rs" 58 12 58 14]  * r);
    [#"../final_borrows.rs" 59 4 59 10] r <- { r with current = ([#"../final_borrows.rs" 59 4 59 10] [#"../final_borrows.rs" 59 9 59 10] (2 : int32)) ; };
    assume { resolve0 r };
    [#"../final_borrows.rs" 60 11 60 16] _0 <- ([#"../final_borrows.rs" 60 11 60 16] ([#"../final_borrows.rs" 60 11 60 12] x) + ([#"../final_borrows.rs" 60 15 60 16] y));
    return _0
  }
  
end
module FinalBorrows_Branching
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  let rec cfg branching [#"../final_borrows.rs" 64 0 64 32] [@cfg:stackify] [@cfg:subregion_analysis] (b : bool) : int32
    ensures { [#"../final_borrows.rs" 63 10 63 22] Int32.to_int result = 3 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var b : bool = b;
  var x : int32;
  var y : int32;
  var r1 : borrowed int32;
  var r2 : borrowed int32;
  var _8 : ();
  var _10 : borrowed int32;
  var _11 : borrowed int32;
  var r21 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 65 16 65 17] x <- ([#"../final_borrows.rs" 65 16 65 17] [#"../final_borrows.rs" 65 16 65 17] (3 : int32));
    [#"../final_borrows.rs" 67 17 67 23] r1 <- Borrow.borrow_mut x;
    [#"../final_borrows.rs" 67 17 67 23] x <-  ^ r1;
    [#"../final_borrows.rs" 69 13 69 21] r2 <- Borrow.borrow_mut ( * r1);
    [#"../final_borrows.rs" 69 13 69 21] r1 <- { r1 with current = ( ^ r2) ; };
    assume { resolve0 r2 };
    [#"../final_borrows.rs" 70 4 70 11] y <- ([#"../final_borrows.rs" 70 8 70 11]  * r2);
    switch ([#"../final_borrows.rs" 71 7 71 8] b)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { resolve0 r1 };
    [#"../final_borrows.rs" 73 13 73 19] _11 <- Borrow.borrow_mut y;
    [#"../final_borrows.rs" 73 13 73 19] y <-  ^ _11;
    [#"../final_borrows.rs" 73 13 73 19] _10 <- Borrow.borrow_final ( * _11) (Borrow.get_id _11);
    [#"../final_borrows.rs" 73 13 73 19] _11 <- { _11 with current = ( ^ _10) ; };
    [#"../final_borrows.rs" 73 8 73 19] r1 <- ([#"../final_borrows.rs" 73 8 73 19] _10);
    [#"../final_borrows.rs" 73 8 73 19] _10 <- any borrowed int32;
    assume { resolve0 _11 };
    assume { resolve0 r1 };
    [#"../final_borrows.rs" 74 8 74 15] y <- ([#"../final_borrows.rs" 74 12 74 15]  * r1);
    [#"../final_borrows.rs" 71 9 75 5] _8 <- ([#"../final_borrows.rs" 71 9 75 5] ());
    goto BB3
  }
  BB2 {
    [#"../final_borrows.rs" 77 17 77 25] r21 <- Borrow.borrow_final ( * r1) (Borrow.get_id r1);
    [#"../final_borrows.rs" 77 17 77 25] r1 <- { r1 with current = ( ^ r21) ; };
    assume { resolve0 r21 };
    [#"../final_borrows.rs" 78 8 78 15] y <- ([#"../final_borrows.rs" 78 12 78 15]  * r21);
    assume { resolve0 r1 };
    [#"../final_borrows.rs" 75 11 79 5] _8 <- ([#"../final_borrows.rs" 75 11 79 5] ());
    goto BB3
  }
  BB3 {
    [#"../final_borrows.rs" 80 4 80 5] _0 <- ([#"../final_borrows.rs" 80 4 80 5] y);
    return _0
  }
  
end
module FinalBorrows_UnnestingNonExtensional
  type t
  use prelude.Borrow
  predicate invariant2 (self : borrowed (borrowed t))
  val invariant2 (self : borrowed (borrowed t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed (borrowed t))
  val inv2 (_x : borrowed (borrowed t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed (borrowed t) . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve1 (self : borrowed (borrowed t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (borrowed t)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg unnesting_non_extensional [#"../final_borrows.rs" 85 0 85 82] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (borrowed t)) : borrowed t
    requires {[#"../final_borrows.rs" 85 48 85 49] inv2 x}
    ensures { [#"../final_borrows.rs" 83 10 83 24]  * result =  *  * x }
    ensures { [#"../final_borrows.rs" 84 10 84 24]  ^ result =  *  ^ x }
    ensures { [#"../final_borrows.rs" 85 73 85 82] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var x : borrowed (borrowed t) = x;
  var _2 : borrowed t;
  var _5 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 86 4 86 12] _5 <- Borrow.borrow_mut ( *  * x);
    [#"../final_borrows.rs" 86 4 86 12] x <- { x with current = { ( * x) with current = ( ^ _5) ; } ; };
    assume { inv0 ( ^ _5) };
    [#"../final_borrows.rs" 86 4 86 12] _2 <- Borrow.borrow_final ( * _5) (Borrow.get_id _5);
    [#"../final_borrows.rs" 86 4 86 12] _5 <- { _5 with current = ( ^ _2) ; };
    assume { inv0 ( ^ _2) };
    [#"../final_borrows.rs" 86 4 86 12] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 86 4 86 12] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv0 ( ^ _0) };
    assert { [@expl:type invariant] inv1 _5 };
    assume { resolve0 _5 };
    assert { [@expl:type invariant] inv1 _2 };
    assume { resolve0 _2 };
    assert { [@expl:type invariant] inv2 x };
    assume { resolve1 x };
    return _0
  }
  
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module FinalBorrows_BoxDeref
  type t
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve1 (self : t)
  val resolve1 (self : t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 34 8 34 31] resolve1 self
  val resolve0 (self : t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg box_deref [#"../final_borrows.rs" 94 0 94 35] [@cfg:stackify] [@cfg:subregion_analysis] (x : t) : t
    requires {[#"../final_borrows.rs" 94 20 94 21] inv0 x}
    ensures { [#"../final_borrows.rs" 93 10 93 22] result = x }
    ensures { [#"../final_borrows.rs" 94 34 94 35] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var x : t = x;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../final_borrows.rs" 95 4 95 6] _0 <- ([#"../final_borrows.rs" 95 4 95 6] x);
    [#"../final_borrows.rs" 95 4 95 6] x <- any t;
    assert { [@expl:type invariant] inv0 x };
    assume { resolve0 x };
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module FinalBorrows_BoxReborrowDirect
  type t
  predicate invariant2 (self : t)
  val invariant2 (self : t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : t)
  val inv2 (_x : t) : bool
    ensures { result = inv2 _x }
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv2 : forall x : t . inv2 x = true
  use prelude.Borrow
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve2 (self : t)
  val resolve2 (self : t) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 34 8 34 31] resolve2 self
  val resolve1 (self : t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg box_reborrow_direct [#"../final_borrows.rs" 99 0 99 44] [@cfg:stackify] [@cfg:subregion_analysis] (x : t) : ()
    requires {[#"../final_borrows.rs" 99 34 99 35] inv2 x}
    ensures { [#"../final_borrows.rs" 98 10 98 14] true }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : t = x;
  var borrow : borrowed t;
  var _4 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 100 25 100 32] _4 <- Borrow.borrow_mut x;
    [#"../final_borrows.rs" 100 25 100 32] x <-  ^ _4;
    assume { inv0 ( ^ _4) };
    [#"../final_borrows.rs" 100 25 100 32] borrow <- Borrow.borrow_final ( * _4) (Borrow.get_id _4);
    [#"../final_borrows.rs" 100 25 100 32] _4 <- { _4 with current = ( ^ borrow) ; };
    assume { inv0 ( ^ borrow) };
    assert { [@expl:type invariant] inv1 borrow };
    assume { resolve0 borrow };
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    assert { [@expl:type invariant] inv2 x };
    assume { resolve1 x };
    assert { [@expl:assertion] [#"../final_borrows.rs" 102 8 102 21]  * borrow = x };
    goto BB1
  }
  BB1 {
    [#"../final_borrows.rs" 101 4 103 5] _0 <- ([#"../final_borrows.rs" 101 4 103 5] ());
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module FinalBorrows_BoxReborrowIndirect
  type t
  use prelude.Borrow
  predicate invariant2 (self : borrowed t)
  val invariant2 (self : borrowed t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed t)
  val inv2 (_x : borrowed t) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed t . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve1 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg box_reborrow_indirect [#"../final_borrows.rs" 107 0 107 58] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed t) : t
    requires {[#"../final_borrows.rs" 107 38 107 39] inv2 x}
    ensures { [#"../final_borrows.rs" 106 10 106 25] result =  * x }
    ensures { [#"../final_borrows.rs" 107 57 107 58] inv0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var x : borrowed t = x;
  var borrow : borrowed t;
  var _4 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 108 25 108 33] _4 <- Borrow.borrow_mut ( * x);
    [#"../final_borrows.rs" 108 25 108 33] x <- { x with current = ( ^ _4) ; };
    assume { inv0 ( ^ _4) };
    [#"../final_borrows.rs" 108 25 108 33] borrow <- Borrow.borrow_final ( * _4) (Borrow.get_id _4);
    [#"../final_borrows.rs" 108 25 108 33] _4 <- { _4 with current = ( ^ borrow) ; };
    assume { inv0 ( ^ borrow) };
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    [#"../final_borrows.rs" 109 4 109 11] _0 <- ([#"../final_borrows.rs" 109 4 109 11]  * borrow);
    assert { [@expl:type invariant] inv1 borrow };
    assume { resolve0 borrow };
    assert { [@expl:type invariant] inv2 x };
    assume { resolve1 x };
    return _0
  }
  
end
module FinalBorrows_BoxReborrowInStruct
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  predicate resolve1 (self : borrowed (int32, borrowed int32)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (int32, borrowed int32)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  let rec cfg box_reborrow_in_struct [#"../final_borrows.rs" 114 0 114 66] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (int32, borrowed int32)) : int32
    requires {[#"../final_borrows.rs" 112 11 112 29] Int32.to_int ( * (let (_, a) =  * x in a)) = 3}
    ensures { [#"../final_borrows.rs" 113 10 113 22] Int32.to_int result = 3 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var x : borrowed (int32, borrowed int32) = x;
  var borrow : borrowed int32;
  var _5 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 115 27 115 37] _5 <- Borrow.borrow_mut ( * (let (_, a) =  * x in a));
    [#"../final_borrows.rs" 115 27 115 37] x <- { x with current = (let (x0, x1) =  * x in (x0, { (let (_, a) =  * x in a) with current = ( ^ _5) ; })) ; };
    [#"../final_borrows.rs" 115 27 115 37] borrow <- Borrow.borrow_final ( * _5) (Borrow.get_id _5);
    [#"../final_borrows.rs" 115 27 115 37] _5 <- { _5 with current = ( ^ borrow) ; };
    assume { resolve0 _5 };
    [#"../final_borrows.rs" 116 4 116 11] _0 <- ([#"../final_borrows.rs" 116 4 116 11]  * borrow);
    assume { resolve0 borrow };
    assume { resolve1 x };
    return _0
  }
  
end
module FinalBorrows_BorrowInBox
  type t
  use prelude.Borrow
  predicate invariant2 (self : borrowed t)
  val invariant2 (self : borrowed t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed t)
  val inv2 (_x : borrowed t) : bool
    ensures { result = inv2 _x }
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv2 : forall x : borrowed t . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  predicate resolve1 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 34 8 34 31] resolve0 self
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  let rec cfg borrow_in_box [#"../final_borrows.rs" 120 0 120 49] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed t) : borrowed t
    requires {[#"../final_borrows.rs" 120 24 120 25] inv2 x}
    ensures { [#"../final_borrows.rs" 119 10 119 22] result = x }
    ensures { [#"../final_borrows.rs" 120 43 120 49] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed t;
  var x : borrowed t = x;
  var _2 : borrowed t;
  var _4 : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 121 4 121 12] _4 <- Borrow.borrow_final ( * x) (Borrow.get_id x);
    [#"../final_borrows.rs" 121 4 121 12] x <- { x with current = ( ^ _4) ; };
    assume { inv0 ( ^ _4) };
    [#"../final_borrows.rs" 121 4 121 12] _2 <- Borrow.borrow_final ( * _4) (Borrow.get_id _4);
    [#"../final_borrows.rs" 121 4 121 12] _4 <- { _4 with current = ( ^ _2) ; };
    assume { inv0 ( ^ _2) };
    [#"../final_borrows.rs" 121 4 121 12] _0 <- Borrow.borrow_final ( * _2) (Borrow.get_id _2);
    [#"../final_borrows.rs" 121 4 121 12] _2 <- { _2 with current = ( ^ _0) ; };
    assume { inv0 ( ^ _0) };
    assert { [@expl:type invariant] inv1 _4 };
    assume { resolve0 _4 };
    assert { [@expl:type invariant] inv1 _2 };
    assume { resolve0 _2 };
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv2 x };
    assume { resolve1 x };
    return _0
  }
  
end
module FinalBorrows_BorrowInBoxTuple1
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  predicate resolve3 (self : int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve3 (self : int32) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : (int32, borrowed int32)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve3 (let (a, _) = self in a) /\ resolve0 (let (_, a) = self in a)
  val resolve2 (self : (int32, borrowed int32)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : (int32, borrowed int32)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 34 8 34 31] resolve2 self
  val resolve1 (self : (int32, borrowed int32)) : bool
    ensures { result = resolve1 self }
    
  let rec cfg borrow_in_box_tuple_1 [#"../final_borrows.rs" 126 0 126 60] [@cfg:stackify] [@cfg:subregion_analysis] (x : (int32, borrowed int32)) : int32
    requires {[#"../final_borrows.rs" 124 11 124 26] Int32.to_int ( * (let (_, a) = x in a)) = 2}
    ensures { [#"../final_borrows.rs" 125 10 125 22] Int32.to_int result = 2 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var x : (int32, borrowed int32) = x;
  var borrow : borrowed int32;
  var _5 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../final_borrows.rs" 127 27 127 39] _5 <- Borrow.borrow_final ( * (let (_, a) = x in a)) (Borrow.get_id (let (_, a) = x in a));
    [#"../final_borrows.rs" 127 27 127 39] x <- (let (x0, x1) = x in (x0, { (let (_, a) = x in a) with current = ( ^ _5) ; }));
    [#"../final_borrows.rs" 127 27 127 39] borrow <- Borrow.borrow_final ( * _5) (Borrow.get_id _5);
    [#"../final_borrows.rs" 127 27 127 39] _5 <- { _5 with current = ( ^ borrow) ; };
    assume { resolve0 _5 };
    [#"../final_borrows.rs" 128 4 128 11] _0 <- ([#"../final_borrows.rs" 128 4 128 11]  * borrow);
    assume { resolve0 borrow };
    assume { resolve1 x };
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module FinalBorrows_BorrowInBoxTuple2
  use prelude.Int32
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  predicate resolve3 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 34 8 34 31] resolve0 self
  val resolve3 (self : borrowed int32) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : int32) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : (int32, borrowed int32)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve2 (let (a, _) = self in a) /\ resolve3 (let (_, a) = self in a)
  val resolve1 (self : (int32, borrowed int32)) : bool
    ensures { result = resolve1 self }
    
  let rec cfg borrow_in_box_tuple_2 [#"../final_borrows.rs" 133 0 133 60] [@cfg:stackify] [@cfg:subregion_analysis] (x : (int32, borrowed int32)) : int32
    requires {[#"../final_borrows.rs" 131 11 131 26] Int32.to_int ( * (let (_, a) = x in a)) = 2}
    ensures { [#"../final_borrows.rs" 132 10 132 22] Int32.to_int result = 2 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : int32;
  var x : (int32, borrowed int32) = x;
  var borrow : borrowed int32;
  var _5 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../final_borrows.rs" 134 27 134 39] _5 <- Borrow.borrow_final ( * (let (_, a) = x in a)) (Borrow.get_id (let (_, a) = x in a));
    [#"../final_borrows.rs" 134 27 134 39] x <- (let (x0, x1) = x in (x0, { (let (_, a) = x in a) with current = ( ^ _5) ; }));
    [#"../final_borrows.rs" 134 27 134 39] borrow <- Borrow.borrow_final ( * _5) (Borrow.get_id _5);
    [#"../final_borrows.rs" 134 27 134 39] _5 <- { _5 with current = ( ^ borrow) ; };
    assume { resolve0 _5 };
    [#"../final_borrows.rs" 135 4 135 11] _0 <- ([#"../final_borrows.rs" 135 4 135 11]  * borrow);
    assume { resolve0 borrow };
    assume { resolve1 x };
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module FinalBorrows_SharedBorrowNoGen
  type t
  use prelude.Borrow
  predicate invariant2 (self : borrowed t)
  val invariant2 (self : borrowed t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed t)
  val inv2 (_x : borrowed t) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed t . inv2 x = true
  predicate invariant1 (self : borrowed t)
  val invariant1 (self : borrowed t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed t)
  val inv1 (_x : borrowed t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed t . inv1 x = true
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  predicate resolve1 (self : borrowed t)
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg shared_borrow_no_gen [#"../final_borrows.rs" 149 0 149 43] [@cfg:stackify] [@cfg:subregion_analysis] (bor : borrowed t) : ()
    requires {[#"../final_borrows.rs" 149 31 149 34] inv1 bor}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var bor : borrowed t = bor;
  var b1 : borrowed t;
  var _shared : borrowed t;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 150 13 150 22] b1 <- Borrow.borrow_final ( * bor) (Borrow.get_id bor);
    [#"../final_borrows.rs" 150 13 150 22] bor <- { bor with current = ( ^ b1) ; };
    assume { inv0 ( ^ b1) };
    assert { [@expl:type invariant] inv1 b1 };
    assume { resolve0 b1 };
    [#"../final_borrows.rs" 151 18 151 22] _shared <- ([#"../final_borrows.rs" 151 18 151 22] bor);
    assert { [@expl:type invariant] inv2 _shared };
    assume { resolve1 _shared };
    assert { [@expl:type invariant] inv1 bor };
    assume { resolve0 bor };
    assert { [@expl:assertion] [#"../final_borrows.rs" 152 18 152 27] b1 = bor };
    [#"../final_borrows.rs" 149 44 153 1] _0 <- ([#"../final_borrows.rs" 149 44 153 1] ());
    return _0
  }
  
end
module FinalBorrows_InspectNoGen
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Core_Option_Option_Type.t_option t))
  val invariant1 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed (Core_Option_Option_Type.t_option t))
  val inv1 (_x : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Core_Option_Option_Type.t_option t) . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option t)
  val invariant0 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option t)
  val inv0 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option t . inv0 x = true
  predicate resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg inspect_no_gen [#"../final_borrows.rs" 155 0 155 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Core_Option_Option_Type.t_option t)) : ()
    requires {[#"../final_borrows.rs" 155 25 155 26] inv1 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Core_Option_Option_Type.t_option t) = x;
  var r : borrowed (Core_Option_Option_Type.t_option t);
  var _4 : bool;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 156 12 156 19] r <- Borrow.borrow_final ( * x) (Borrow.get_id x);
    [#"../final_borrows.rs" 156 12 156 19] x <- { x with current = ( ^ r) ; };
    assume { inv0 ( ^ r) };
    assert { [@expl:type invariant] inv1 r };
    assume { resolve0 r };
    assert { [@expl:type invariant] inv1 x };
    assume { resolve0 x };
    switch ( * x)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB1
      end
  }
  BB1 {
    _4 <- false;
    goto BB4
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _4 <- true;
    goto BB4
  }
  BB4 {
    switch (_4)
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB5 {
    [#"../final_borrows.rs" 159 8 159 14] _0 <- ([#"../final_borrows.rs" 159 8 159 14] ());
    goto BB7
  }
  BB6 {
    assert { [@expl:assertion] [#"../final_borrows.rs" 161 18 161 24] r = x };
    [#"../final_borrows.rs" 155 44 162 1] _0 <- ([#"../final_borrows.rs" 155 44 162 1] ());
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module FinalBorrows_PlaceMentionNoGen
  type t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Core_Option_Option_Type.t_option t))
  val invariant1 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed (Core_Option_Option_Type.t_option t))
  val inv1 (_x : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Core_Option_Option_Type.t_option t) . inv1 x = true
  predicate invariant0 (self : Core_Option_Option_Type.t_option t)
  val invariant0 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Option_Option_Type.t_option t)
  val inv0 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Core_Option_Option_Type.t_option t . inv0 x = true
  predicate resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Core_Option_Option_Type.t_option t)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg place_mention_no_gen [#"../final_borrows.rs" 164 0 164 49] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Core_Option_Option_Type.t_option t)) : ()
    requires {[#"../final_borrows.rs" 164 31 164 32] inv1 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Core_Option_Option_Type.t_option t) = x;
  var _r : borrowed (Core_Option_Option_Type.t_option t);
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 165 13 165 20] _r <- Borrow.borrow_final ( * x) (Borrow.get_id x);
    [#"../final_borrows.rs" 165 13 165 20] x <- { x with current = ( ^ _r) ; };
    assume { inv0 ( ^ _r) };
    assert { [@expl:type invariant] inv1 _r };
    assume { resolve0 _r };
    assert { [@expl:type invariant] inv1 x };
    assume { resolve0 x };
    assert { [@expl:assertion] [#"../final_borrows.rs" 167 18 167 25] _r = x };
    [#"../final_borrows.rs" 164 50 168 1] _0 <- ([#"../final_borrows.rs" 164 50 168 1] ());
    return _0
  }
  
end
module FinalBorrows_ShallowBorrowNoGen
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate resolve0 (self : borrowed (Core_Option_Option_Type.t_option int32)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Core_Option_Option_Type.t_option int32)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg shallow_borrow_no_gen [#"../final_borrows.rs" 170 0 170 49] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Core_Option_Option_Type.t_option int32)) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Core_Option_Option_Type.t_option int32) = x;
  var _r : borrowed (Core_Option_Option_Type.t_option int32);
  var inner : int32;
  var inner1 : int32;
  {
    goto BB0
  }
  BB0 {
    [#"../final_borrows.rs" 171 13 171 20] _r <- Borrow.borrow_final ( * x) (Borrow.get_id x);
    [#"../final_borrows.rs" 171 13 171 20] x <- { x with current = ( ^ _r) ; };
    assume { resolve0 _r };
    switch ( * x)
      | Core_Option_Option_Type.C_Some _ -> goto BB2
      | _ -> goto BB7
      end
  }
  BB1 {
    [#"../final_borrows.rs" 177 13 177 15] _0 <- ([#"../final_borrows.rs" 177 13 177 15] ());
    goto BB6
  }
  BB2 {
    goto BB3
  }
  BB3 {
    [#"../final_borrows.rs" 174 13 174 22] inner <- ([#"../final_borrows.rs" 174 13 174 22] Core_Option_Option_Type.some_0 ( * x));
    [#"../final_borrows.rs" 174 13 174 22] inner1 <- ([#"../final_borrows.rs" 174 13 174 22] inner);
    switch ([#"../final_borrows.rs" 174 27 174 38] ([#"../final_borrows.rs" 174 27 174 33] inner1) = ([#"../final_borrows.rs" 174 37 174 38] [#"../final_borrows.rs" 174 37 174 38] (2 : int32)))
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    assume { resolve0 x };
    assert { [@expl:assertion] [#"../final_borrows.rs" 175 26 175 33] _r = x };
    [#"../final_borrows.rs" 174 42 176 9] _0 <- ([#"../final_borrows.rs" 174 42 176 9] ());
    goto BB6
  }
  BB5 {
    assume { resolve0 x };
    goto BB1
  }
  BB6 {
    return _0
  }
  BB7 {
    assume { resolve0 x };
    goto BB1
  }
  BB8 {
    assume { resolve0 x };
    goto BB1
  }
  
end
