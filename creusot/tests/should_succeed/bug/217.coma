
module CreusotContracts_Logic_Seq2_Seq_Type
  use seq.Seq
  
  type t_seq 't =
    | C_Seq (Seq.seq 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_seq < 't > (input:t_seq 't) (ret  (field_0:Seq.seq 't))= any
    [ good (field_0:Seq.seq 't)-> {C_Seq field_0 = input} (! ret {field_0})
    | bad (field_0:Seq.seq 't)-> {C_Seq field_0 <> input} {false} any ]
    
  
  function seq_0 [@inline:trivial] (self : t_seq 't) : Seq.seq 't =
    match self with
      | C_Seq a -> a
      end
end
module C217_Ex_Impl
  let%span s2170 = "../217.rs" 10 10 10 17
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq22 = "../../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span span3 = "../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span4 = "../../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span5 = "../../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span6 = "../../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  let%span span7 = "../../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span span8 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span span9 = "../../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span span10 = "../../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span span11 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span12 = "../../../../../creusot-contracts/src/logic/seq2.rs" 66 8 66 39
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'0 (self : Seq'0.t_seq int) =
    [%#span3] true
  
  predicate inv'0 (_x : Seq'0.t_seq int)
  
  axiom inv'0 : forall x : Seq'0.t_seq int . inv'0 x = true
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . ([%#sseq21] inv'0 self)  -> ([%#sseq22] len'0 self >= 0)
  
  constant empty'0 : Seq'0.t_seq int = [%#span4] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span6] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span5] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  use prelude.seq_ext.SeqExt
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq int) (x : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#span7] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#span8] inv'0 self)
   -> ([%#span11] inv'0 (subsequence'0 self n m))
  && ([%#span10] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#span9] len'0 (subsequence'0 self n m) = m - n)
  
  function tail'0 [@inline:trivial] (self : Seq'0.t_seq int) : Seq'0.t_seq int =
    [%#span12] subsequence'0 self 1 (len'0 self)
  
  constant c  : Seq'0.t_seq int
  
  constant a  : int
  
  function ex [#"../217.rs" 11 0 11 37] (c : Seq'0.t_seq int) (a : int) : int
  
  goal vc_ex : ([%#sseq21] inv'0 c)
  /\ (([%#sseq22] len'0 c >= 0)
   -> match len'0 c = 0 with
    | True -> true
    | False -> 0 <= ([%#s2170] len'0 c) /\ ([%#s2170] len'0 (tail'0 c)) < ([%#s2170] len'0 c)
    end)
end
