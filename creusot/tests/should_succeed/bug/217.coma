
module CreusotContracts_Logic_Seq2_Seq_Type
  type t_seq 't
end
module C217_Ex_Impl
  let%span s2170 = "../217.rs" 10 10 10 17
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 68 14 68 25
  
  let%span span2 = "../../../../../creusot-contracts/src/logic/seq2.rs" 16 14 16 36
  
  let%span span3 = "../../../../../creusot-contracts/src/logic/seq2.rs" 42 15 42 50
  
  let%span span4 = "../../../../../creusot-contracts/src/logic/seq2.rs" 43 14 43 35
  
  let%span span5 = "../../../../../creusot-contracts/src/logic/seq2.rs" 44 4 44 87
  
  let%span span6 = "../../../../../creusot-contracts/src/logic/seq2.rs" 62 8 62 39
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . [%#sseq21] len'0 self >= 0
  
  constant empty'0 : Seq'0.t_seq int
  
  function empty_len'0 (_1 : ()) : ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span2] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  function index_logic'0 (self : Seq'0.t_seq int) (_2 : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#span3] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#span5] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#span4] len'0 (subsequence'0 self n m) = m - n)
  
  function tail'0 [@inline:trivial] (self : Seq'0.t_seq int) : Seq'0.t_seq int =
    [%#span6] subsequence'0 self 1 (len'0 self)
  
  constant c  : Seq'0.t_seq int
  
  constant a  : int
  
  function ex [#"../217.rs" 11 0 11 37] (c : Seq'0.t_seq int) (a : int) : int
  
  goal vc_ex : ([%#sseq21] len'0 c >= 0)
   -> match len'0 c = 0 with
    | True -> true
    | False -> 0 <= ([%#s2170] len'0 c) /\ ([%#s2170] len'0 (tail'0 c)) < ([%#s2170] len'0 c)
    end
end
