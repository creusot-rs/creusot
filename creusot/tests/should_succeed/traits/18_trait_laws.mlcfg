
module C18TraitLaws_Symmetric_Op_Stub
  type self
  val ghost function op (self : self) (_2' : self) : self
end
module C18TraitLaws_Symmetric_Op_Interface
  type self
  val ghost function op (self : self) (_2' : self) : self
end
module C18TraitLaws_Symmetric_Op
  type self
  val ghost function op [#"../18_trait_laws.rs" 6 4 6 33] (self : self) (_2' : self) : self
end
module C18TraitLaws_Symmetric_Reflexive_Stub
  type self
  clone C18TraitLaws_Symmetric_Op_Stub as Op0 with type self = self
  val ghost function reflexive (a : self) (b : self) : ()
end
module C18TraitLaws_Symmetric_Reflexive_Interface
  type self
  clone C18TraitLaws_Symmetric_Op_Stub as Op0 with type self = self
  val ghost function reflexive (a : self) (b : self) : ()
    ensures { [#"../18_trait_laws.rs" 9 14 9 32] Op0.op a b = Op0.op b a }
    
end
module C18TraitLaws_Symmetric_Reflexive
  type self
  clone C18TraitLaws_Symmetric_Op_Stub as Op0 with type self = self
  val ghost function reflexive [#"../18_trait_laws.rs" 10 4 10 35] (a : self) (b : self) : ()
  axiom reflexive_spec : forall a : self, b : self . [#"../18_trait_laws.rs" 9 14 9 32] Op0.op a b = Op0.op b a
end
module C18TraitLaws_UsesOp_Stub
  type t
  val ghost function uses_op (x : t) (y : t) : bool
end
module C18TraitLaws_UsesOp_Interface
  type t
  val ghost function uses_op (x : t) (y : t) : bool
    ensures { [#"../18_trait_laws.rs" 14 10 14 24] result = true }
    
end
module C18TraitLaws_UsesOp
  type t
  clone C18TraitLaws_Symmetric_Op_Stub as Op0 with type self = t
  let rec ghost function uses_op [#"../18_trait_laws.rs" 15 0 15 48] (x : t) (y : t) : bool
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 16 16 16 34] let b = Op0.op y x in let a = Op0.op x y in pure {a = b}
  axiom uses_op_spec : forall x : t, y : t . [#"../18_trait_laws.rs" 14 10 14 24] uses_op x y = true
end
module C18TraitLaws_UsesOp_Impl
  type t
  clone C18TraitLaws_Symmetric_Op_Interface as Op0 with type self = t
  clone C18TraitLaws_Symmetric_Reflexive as Reflexive0 with type self = t, val Op0.op = Op0.op, axiom .
  let rec ghost function uses_op (x : t) (y : t) : bool
    ensures { [#"../18_trait_laws.rs" 14 10 14 24] result = true }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 16 16 16 34] let b = Op0.op y x in let a = Op0.op x y in pure {a = b}
end
module C18TraitLaws_Impl0_Op_Stub
  val ghost function op (self : ()) (_2' : ()) : ()
end
module C18TraitLaws_Impl0_Op_Interface
  val ghost function op (self : ()) (_2' : ()) : ()
end
module C18TraitLaws_Impl0_Op
  let rec ghost function op [#"../18_trait_laws.rs" 21 4 21 32] (self : ()) (_2' : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 22 8 22 10] ()
end
module C18TraitLaws_Impl0_Reflexive_Stub
  val ghost function reflexive (_1' : ()) (_2' : ()) : ()
end
module C18TraitLaws_Impl0_Reflexive_Interface
  val ghost function reflexive (_1' : ()) (_2' : ()) : ()
end
module C18TraitLaws_Impl0_Reflexive
  let rec ghost function reflexive [#"../18_trait_laws.rs" 26 4 26 34] (_1' : ()) (_2' : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 25 4 25 10] ()
end
module C18TraitLaws_ImplLaws_Stub
  val ghost function impl_laws (_ : ()) : bool
end
module C18TraitLaws_ImplLaws_Interface
  val ghost function impl_laws (_ : ()) : bool
    ensures { [#"../18_trait_laws.rs" 30 10 30 24] result = true }
    
end
module C18TraitLaws_ImplLaws
  clone C18TraitLaws_Impl0_Op_Stub as Op0
  let rec ghost function impl_laws [#"../18_trait_laws.rs" 31 0 31 26] (_ : ()) : bool
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 32 16 32 38] let b = Op0.op () () in let a = Op0.op () () in pure {a = b}
  axiom impl_laws_spec : [#"../18_trait_laws.rs" 30 10 30 24] impl_laws () = true
end
module C18TraitLaws_ImplLaws_Impl
  clone C18TraitLaws_Impl0_Reflexive as Reflexive0
  clone C18TraitLaws_Impl0_Op as Op0
  let rec ghost function impl_laws (_ : ()) : bool
    ensures { [#"../18_trait_laws.rs" 30 10 30 24] result = true }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../18_trait_laws.rs" 32 16 32 38] let b = Op0.op () () in let a = Op0.op () () in pure {a = b}
end
module C18TraitLaws_Impl0
  clone C18TraitLaws_Impl0_Op as Op0
  clone C18TraitLaws_Impl0_Reflexive as Reflexive0
  clone C18TraitLaws_Symmetric_Reflexive_Interface as Reflexive1 with type self = (),
    val reflexive = Reflexive0.reflexive, val Op0.op = Op0.op, axiom .
  clone C18TraitLaws_Symmetric_Op_Interface as Op1 with type self = (), val op = Op0.op
  goal reflexive_spec : forall a : (), b : () . forall result : () . [#"../18_trait_laws.rs" 9 14 9 32] Op0.op a b = Op0.op b a
end
