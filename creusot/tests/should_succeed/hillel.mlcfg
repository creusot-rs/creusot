
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.UIntSize
  use prelude.Int
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Core_Num_Impl11_Max_Stub
  use prelude.UIntSize
  use prelude.Int
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.UIntSize
  use prelude.Int
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Hillel_RightPad
  type t
  use seq.Seq
  predicate invariant5 (self : Seq.seq t)
  val invariant5 (self : Seq.seq t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Seq.seq t)
  val inv5 (_x : Seq.seq t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv5 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val invariant4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv4 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv4 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self}
    ensures { result = shallow_model3 self }
    
  axiom shallow_model3_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv5 (shallow_model3 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model3 self) <= UIntSize.to_int max0)
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv5 (shallow_model3 self)
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  use prelude.Borrow
  predicate invariant2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv2 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv2 x = true
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv1 x = true
  use prelude.Ghost
  predicate invariant0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
    
  val invariant0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
  val inv0 (_x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) . inv0 x = true
  use seq.Seq
  function shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model3 ( * self)
  val shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model1 self }
    
  val push0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (value : t) : ()
    requires {inv2 self}
    requires {inv1 value}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 78 26 78 51] shallow_model3 ( ^ self) = Seq.snoc (shallow_model1 self) value }
    
  predicate resolve2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : t)
  val resolve1 (self : t) : bool
    ensures { result = resolve1 self }
    
  function shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    ensures { result = shallow_model5 self }
    
  val len1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : usize
    requires {inv4 self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 75 26 75 48] UIntSize.to_int result = Seq.length (shallow_model5 self) }
    
  use prelude.Ghost
  use seq.Seq
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model3 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic0 self ix }
    
  function shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model4 self }
    
  function shallow_model0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    
   =
    [#"../../../../creusot-contracts/src/ghost.rs" 27 20 27 48] shallow_model4 (Ghost.inner self)
  val shallow_model0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    ensures { result = shallow_model0 self }
    
  predicate resolve0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
  val resolve0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = resolve0 self }
    
  use prelude.Ghost
  let rec cfg right_pad [#"../hillel.rs" 16 0 16 59] [@cfg:stackify] [@cfg:subregion_analysis] (str : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (len : usize) (pad : t) : ()
    requires {[#"../hillel.rs" 16 22 16 25] inv2 str}
    requires {[#"../hillel.rs" 16 52 16 55] inv1 pad}
    ensures { [#"../hillel.rs" 10 10 10 62] Seq.length (shallow_model3 ( ^ str)) >= UIntSize.to_int len /\ Seq.length (shallow_model3 ( ^ str)) >= Seq.length (shallow_model1 str) }
    ensures { [#"../hillel.rs" 11 10 11 62] Seq.length (shallow_model3 ( ^ str)) = UIntSize.to_int len \/ Seq.length (shallow_model3 ( ^ str)) = Seq.length (shallow_model1 str) }
    ensures { [#"../hillel.rs" 12 0 12 62] UIntSize.to_int len <= Seq.length (shallow_model1 str) -> Seq.length (shallow_model3 ( ^ str)) = Seq.length (shallow_model1 str) }
    ensures { [#"../hillel.rs" 13 0 13 55] UIntSize.to_int len > Seq.length (shallow_model1 str) -> Seq.length (shallow_model3 ( ^ str)) = UIntSize.to_int len }
    ensures { [#"../hillel.rs" 14 0 14 75] forall i : int . 0 <= i /\ i < Seq.length (shallow_model1 str) -> index_logic0 ( ^ str) i = index_logic0 ( * str) i }
    ensures { [#"../hillel.rs" 15 0 15 75] forall i : int . Seq.length (shallow_model1 str) <= i /\ i < UIntSize.to_int len -> index_logic0 ( ^ str) i = pad }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var str : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) = str;
  var len : usize = len;
  var pad : t = pad;
  var old_str : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)));
  var _19 : usize;
  var _22 : ();
  var _23 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    old_str <- ([#"../hillel.rs" 17 18 17 29] Ghost.new str);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv0 old_str };
    assume { resolve0 old_str };
    goto BB2
  }
  BB2 {
    invariant { [#"../hillel.rs" 19 16 19 44] Seq.length (shallow_model0 old_str) <= Seq.length (shallow_model1 str) };
    invariant { [#"../hillel.rs" 19 4 19 46] Seq.length (shallow_model0 old_str) < UIntSize.to_int len -> Seq.length (shallow_model1 str) <= UIntSize.to_int len };
    invariant { [#"../hillel.rs" 19 4 19 46] Seq.length (shallow_model1 str) > UIntSize.to_int len -> Seq.length (shallow_model1 str) = Seq.length (shallow_model0 old_str) };
    invariant { [#"../hillel.rs" 19 4 19 46] forall i : int . 0 <= i /\ i < Seq.length (shallow_model0 old_str) -> index_logic0 ( * str) i = index_logic0 ( * Ghost.inner old_str) i };
    invariant { [#"../hillel.rs" 19 4 19 46] forall i : int . Seq.length (shallow_model0 old_str) <= i /\ i < Seq.length (shallow_model1 str) -> index_logic0 ( * str) i = pad };
    goto BB3
  }
  BB3 {
    _19 <- ([#"../hillel.rs" 24 10 24 19] len1 ([#"../hillel.rs" 24 10 24 19]  * str));
    goto BB4
  }
  BB4 {
    switch ([#"../hillel.rs" 24 10 24 25] _19 < len)
      | False -> goto BB7
      | True -> goto BB5
      end
  }
  BB5 {
    _23 <- Borrow.borrow_mut ( * str);
    str <- { str with current = ( ^ _23) };
    assume { inv3 ( ^ _23) };
    _22 <- ([#"../hillel.rs" 25 8 25 21] push0 _23 pad);
    _23 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    goto BB6
  }
  BB6 {
    goto BB2
  }
  BB7 {
    assert { [@expl:type invariant] inv1 pad };
    assume { resolve1 pad };
    assert { [@expl:type invariant] inv2 str };
    assume { resolve2 str };
    _0 <- ([#"../hillel.rs" 24 4 26 5] ());
    return _0
  }
  
end
module Hillel_LeftPad
  type t
  use seq.Seq
  predicate invariant5 (self : Seq.seq t)
  val invariant5 (self : Seq.seq t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Seq.seq t)
  val inv5 (_x : Seq.seq t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv5 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val invariant4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv4 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv4 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  function shallow_model4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self}
    ensures { result = shallow_model4 self }
    
  axiom shallow_model4_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv3 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv5 (shallow_model4 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model4 self) <= UIntSize.to_int max0)
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv5 (shallow_model4 self)
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  axiom inv3 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  use prelude.Borrow
  predicate invariant2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv2 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv2 x = true
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv1 x = true
  use prelude.Ghost
  predicate invariant0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
    
  val invariant0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
  val inv0 (_x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) . inv0 x = true
  use prelude.Ghost
  use seq.Seq
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model4 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic0 self ix }
    
  function shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model4 ( * self)
  val shallow_model1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model1 self }
    
  val insert0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (index : usize) (element : t) : ()
    requires {inv2 self}
    requires {inv1 element}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 95 26 95 59] Seq.length (shallow_model4 ( ^ self)) = Seq.length (shallow_model1 self) + 1 }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 96 16 96 89] forall i : int . 0 <= i /\ i < UIntSize.to_int index -> index_logic0 ( ^ self) i = index_logic0 ( * self) i }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 97 26 97 52] index_logic0 ( ^ self) (UIntSize.to_int index) = element }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 98 16 98 105] forall i : int . UIntSize.to_int index < i /\ i < Seq.length (shallow_model4 ( ^ self)) -> index_logic0 ( ^ self) i = index_logic0 ( * self) (i - 1) }
    
  predicate resolve2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : t)
  val resolve1 (self : t) : bool
    ensures { result = resolve1 self }
    
  function shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    ensures { result = shallow_model7 self }
    
  val len1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : usize
    requires {inv4 self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 75 26 75 48] UIntSize.to_int result = Seq.length (shallow_model7 self) }
    
  use prelude.Ghost
  use prelude.Int
  function shallow_model6 (self : usize) : int =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] UIntSize.to_int self
  val shallow_model6 (self : usize) : int
    ensures { result = shallow_model6 self }
    
  function shallow_model3 (self : Ghost.ghost_ty usize) : int =
    [#"../../../../creusot-contracts/src/ghost.rs" 27 20 27 48] shallow_model6 (Ghost.inner self)
  val shallow_model3 (self : Ghost.ghost_ty usize) : int
    ensures { result = shallow_model3 self }
    
  function shallow_model5 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model1 self
  val shallow_model5 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model5 self }
    
  function shallow_model0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    
   =
    [#"../../../../creusot-contracts/src/ghost.rs" 27 20 27 48] shallow_model5 (Ghost.inner self)
  val shallow_model0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : Seq.seq t
    ensures { result = shallow_model0 self }
    
  use prelude.Ghost
  predicate resolve0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))))
  val resolve0 (self : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))) : bool
    ensures { result = resolve0 self }
    
  use prelude.Ghost
  let rec cfg left_pad [#"../hillel.rs" 33 0 33 58] [@cfg:stackify] [@cfg:subregion_analysis] (str : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (len : usize) (pad : t) : ()
    requires {[#"../hillel.rs" 33 21 33 24] inv2 str}
    requires {[#"../hillel.rs" 33 51 33 54] inv1 pad}
    ensures { [#"../hillel.rs" 29 10 29 62] Seq.length (shallow_model4 ( ^ str)) >= UIntSize.to_int len /\ Seq.length (shallow_model4 ( ^ str)) >= Seq.length (shallow_model1 str) }
    ensures { [#"../hillel.rs" 30 10 30 62] Seq.length (shallow_model4 ( ^ str)) = UIntSize.to_int len \/ Seq.length (shallow_model4 ( ^ str)) = Seq.length (shallow_model1 str) }
    ensures { [#"../hillel.rs" 31 0 31 90] forall i : int . 0 <= i /\ i < Seq.length (shallow_model4 ( ^ str)) - Seq.length (shallow_model1 str) -> index_logic0 ( ^ str) i = pad }
    ensures { [#"../hillel.rs" 32 0 32 106] forall i : int . 0 <= i /\ i < Seq.length (shallow_model1 str) -> index_logic0 ( ^ str) (i + (Seq.length (shallow_model4 ( ^ str)) - Seq.length (shallow_model1 str))) = index_logic0 ( * str) i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var str : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) = str;
  var len : usize = len;
  var pad : t = pad;
  var old_str : Ghost.ghost_ty (borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)));
  var c : Ghost.ghost_ty usize;
  var _20 : usize;
  var _23 : ();
  var _24 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  var _26 : Ghost.ghost_ty usize;
  {
    goto BB0
  }
  BB0 {
    old_str <- ([#"../hillel.rs" 34 18 34 29] Ghost.new str);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] inv0 old_str };
    assume { resolve0 old_str };
    c <- ([#"../hillel.rs" 35 30 35 44] Ghost.new (0 : usize));
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    invariant { [#"../hillel.rs" 37 16 37 44] Seq.length (shallow_model0 old_str) <= Seq.length (shallow_model1 str) };
    invariant { [#"../hillel.rs" 37 4 37 46] Seq.length (shallow_model0 old_str) < UIntSize.to_int len -> Seq.length (shallow_model1 str) <= UIntSize.to_int len };
    invariant { [#"../hillel.rs" 37 4 37 46] Seq.length (shallow_model1 str) > UIntSize.to_int len -> Seq.length (shallow_model1 str) = Seq.length (shallow_model0 old_str) };
    invariant { [#"../hillel.rs" 40 16 40 49] shallow_model3 c = Seq.length (shallow_model1 str) - Seq.length (shallow_model0 old_str) };
    invariant { [#"../hillel.rs" 37 4 37 46] forall i : int . shallow_model3 c <= i /\ i < Seq.length (shallow_model1 str) -> index_logic0 ( * str) i = index_logic0 ( * Ghost.inner old_str) (i - shallow_model3 c) };
    invariant { [#"../hillel.rs" 37 4 37 46] forall i : int . 0 <= i /\ i < shallow_model3 c -> index_logic0 ( * str) i = pad };
    goto BB4
  }
  BB4 {
    _20 <- ([#"../hillel.rs" 43 10 43 19] len1 ([#"../hillel.rs" 43 10 43 19]  * str));
    goto BB5
  }
  BB5 {
    switch ([#"../hillel.rs" 43 10 43 25] _20 < len)
      | False -> goto BB9
      | True -> goto BB6
      end
  }
  BB6 {
    _24 <- Borrow.borrow_mut ( * str);
    str <- { str with current = ( ^ _24) };
    assume { inv3 ( ^ _24) };
    _23 <- ([#"../hillel.rs" 44 8 44 26] insert0 _24 ([#"../hillel.rs" 44 19 44 20] [#"../hillel.rs" 44 19 44 20] (0 : usize)) pad);
    _24 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    goto BB7
  }
  BB7 {
    _26 <- ([#"../hillel.rs" 45 12 45 31] Ghost.new ((1 : usize) + Ghost.inner c));
    goto BB8
  }
  BB8 {
    c <- _26;
    _26 <- any Ghost.ghost_ty usize;
    goto BB3
  }
  BB9 {
    assert { [@expl:type invariant] inv1 pad };
    assume { resolve1 pad };
    assert { [@expl:type invariant] inv2 str };
    assume { resolve2 str };
    _0 <- ([#"../hillel.rs" 43 4 46 5] ());
    return _0
  }
  
end
module Hillel_SubsetPush_Impl
  type t
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv1 x = true
  use seq.Seq
  predicate invariant0 (self : Seq.seq t)
  val invariant0 (self : Seq.seq t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Seq.seq t)
  val inv0 (_x : Seq.seq t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv0 x = true
  use seq.Seq
  use seq.Seq
  use prelude.Int
  predicate contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq t) (elem : t) =
    [#"../hillel.rs" 58 4 60 5] exists i : int . 0 <= i /\ i < Seq.length seq /\ Seq.get seq i = elem
  val contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq t) (elem : t) : bool
    ensures { result = contains0 seq elem }
    
  predicate is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq t) (sup : Seq.seq t) =
    [#"../hillel.rs" 65 4 67 5] forall i : int . 0 <= i /\ i < Seq.length sub -> contains0 sup (Seq.get sub i)
  val is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq t) (sup : Seq.seq t) : bool
    ensures { result = is_subset0 sub sup }
    
  use seq.Seq
  let rec ghost function subset_push [#"../hillel.rs" 72 0 72 37] (s : Seq.seq t) (elem : t) : ()
    requires {[#"../hillel.rs" 72 18 72 19] inv0 s}
    requires {[#"../hillel.rs" 72 29 72 33] inv1 elem}
    ensures { [#"../hillel.rs" 71 10 71 36] is_subset0 s (Seq.snoc s elem) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../hillel.rs" 70 0 70 8] ()
end
module Core_Slice_Iter_Iter_Type
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use prelude.Opaque
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_iter 't =
    | C_Iter (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) opaque_ptr (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module Hillel_InsertUnique
  type t
  use prelude.Slice
  predicate invariant15 (self : slice t)
  val invariant15 (self : slice t) : bool
    ensures { result = invariant15 self }
    
  predicate inv15 (_x : slice t)
  val inv15 (_x : slice t) : bool
    ensures { result = inv15 _x }
    
  axiom inv15 : [#"../hillel.rs" 1 0 1 0] forall x : slice t . inv15 x = true
  use seq.Seq
  predicate invariant14 (self : Seq.seq t)
  val invariant14 (self : Seq.seq t) : bool
    ensures { result = invariant14 self }
    
  predicate inv14 (_x : Seq.seq t)
  val inv14 (_x : Seq.seq t) : bool
    ensures { result = inv14 _x }
    
  axiom inv14 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv14 x = true
  predicate invariant13 (self : Seq.seq t)
  val invariant13 (self : Seq.seq t) : bool
    ensures { result = invariant13 self }
    
  predicate inv13 (_x : Seq.seq t)
  val inv13 (_x : Seq.seq t) : bool
    ensures { result = inv13 _x }
    
  axiom inv13 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv13 x = true
  predicate invariant12 (self : t)
  val invariant12 (self : t) : bool
    ensures { result = invariant12 self }
    
  predicate inv12 (_x : t)
  val inv12 (_x : t) : bool
    ensures { result = inv12 _x }
    
  axiom inv12 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv12 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant11 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val invariant11 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant11 self }
    
  predicate inv11 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv11 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv11 _x }
    
  axiom inv11 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv11 x = true
  type deep_model_ty0
  predicate invariant10 (self : deep_model_ty0)
  val invariant10 (self : deep_model_ty0) : bool
    ensures { result = invariant10 self }
    
  predicate inv10 (_x : deep_model_ty0)
  val inv10 (_x : deep_model_ty0) : bool
    ensures { result = inv10 _x }
    
  axiom inv10 : [#"../hillel.rs" 1 0 1 0] forall x : deep_model_ty0 . inv10 x = true
  predicate invariant9 (self : Seq.seq deep_model_ty0)
  val invariant9 (self : Seq.seq deep_model_ty0) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : Seq.seq deep_model_ty0)
  val inv9 (_x : Seq.seq deep_model_ty0) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq deep_model_ty0 . inv9 x = true
  use prelude.UIntSize
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv8 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv8 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv8 _x }
    
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv8 self}
    ensures { result = shallow_model3 self }
    
  axiom shallow_model3_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv8 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv14 (shallow_model3 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model3 self) <= UIntSize.to_int max0)
  predicate invariant8 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv14 (shallow_model3 self)
  val invariant8 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant8 self }
    
  axiom inv8 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv8 x = true
  use prelude.Borrow
  predicate invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant7 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv7 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv7 x = true
  predicate invariant6 (self : t)
  val invariant6 (self : t) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : t)
  val inv6 (_x : t) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv6 x = true
  predicate invariant5 (self : t)
  val invariant5 (self : t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : t)
  val inv5 (_x : t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv5 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant4 (self : Core_Option_Option_Type.t_option t)
  val invariant4 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Core_Option_Option_Type.t_option t)
  val inv4 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Option_Option_Type.t_option t . inv4 x = true
  use Core_Slice_Iter_Iter_Type as Core_Slice_Iter_Iter_Type
  use seq.Seq
  use seq.Seq
  use prelude.Slice
  function shallow_model5 (self : slice t) : Seq.seq t
  val shallow_model5 (self : slice t) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv15 self}
    ensures { result = shallow_model5 self }
    
  axiom shallow_model5_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv15 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 19 4 19 50] inv14 (shallow_model5 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model5 self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model5 self) <= UIntSize.to_int max0)
  function index_logic5 [@inline:trivial] (self : slice t) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 43 8 43 31] Seq.get (shallow_model5 self) ix
  val index_logic5 [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic5 self ix }
    
  use seq.Seq
  function shallow_model0 (self : slice t) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model5 self
  val shallow_model0 (self : slice t) : Seq.seq t
    ensures { result = shallow_model0 self }
    
  use seq.Seq
  predicate inv1 (_x : slice t)
  val inv1 (_x : slice t) : bool
    ensures { result = inv1 _x }
    
  function to_ref_seq0 (self : slice t) : Seq.seq t
  val to_ref_seq0 (self : slice t) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 91 19 91 23] inv1 self}
    ensures { result = to_ref_seq0 self }
    
  axiom to_ref_seq0_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 91 19 91 23] inv1 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 91 4 91 35] inv13 (to_ref_seq0 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 90 4 90 82] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq0 self) -> Seq.get (to_ref_seq0 self) i = index_logic5 self i) && ([#"../../../../creusot-contracts/src/std/slice.rs" 89 14 89 41] Seq.length (to_ref_seq0 self) = Seq.length (shallow_model0 self))
  function shallow_model2 (self : Core_Slice_Iter_Iter_Type.t_iter t) : slice t
  val shallow_model2 (self : Core_Slice_Iter_Iter_Type.t_iter t) : slice t
    ensures { result = shallow_model2 self }
    
  predicate produces0 (self : Core_Slice_Iter_Iter_Type.t_iter t) (visited : Seq.seq t) (tl : Core_Slice_Iter_Iter_Type.t_iter t)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 386 12 386 66] to_ref_seq0 (shallow_model2 self) = Seq.(++) visited (to_ref_seq0 (shallow_model2 tl))
  val produces0 (self : Core_Slice_Iter_Iter_Type.t_iter t) (visited : Seq.seq t) (tl : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = produces0 self visited tl }
    
  function produces_trans0 (a : Core_Slice_Iter_Iter_Type.t_iter t) (ab : Seq.seq t) (b : Core_Slice_Iter_Iter_Type.t_iter t) (bc : Seq.seq t) (c : Core_Slice_Iter_Iter_Type.t_iter t) : ()
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 395 4 395 10] ()
  val produces_trans0 (a : Core_Slice_Iter_Iter_Type.t_iter t) (ab : Seq.seq t) (b : Core_Slice_Iter_Iter_Type.t_iter t) (bc : Seq.seq t) (c : Core_Slice_Iter_Iter_Type.t_iter t) : ()
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 397 15 397 32] produces0 a ab b}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 398 15 398 32] produces0 b bc c}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 400 31 400 33] inv13 ab}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 400 61 400 63] inv13 bc}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : Core_Slice_Iter_Iter_Type.t_iter t, ab : Seq.seq t, b : Core_Slice_Iter_Iter_Type.t_iter t, bc : Seq.seq t, c : Core_Slice_Iter_Iter_Type.t_iter t . ([#"../../../../creusot-contracts/src/std/slice.rs" 397 15 397 32] produces0 a ab b) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 398 15 398 32] produces0 b bc c) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 400 31 400 33] inv13 ab) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 400 61 400 63] inv13 bc) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 399 14 399 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (a : Core_Slice_Iter_Iter_Type.t_iter t) : () =
    [#"../../../../creusot-contracts/src/std/slice.rs" 390 4 390 10] ()
  val produces_refl0 (a : Core_Slice_Iter_Iter_Type.t_iter t) : ()
    ensures { result = produces_refl0 a }
    
  axiom produces_refl0_spec : forall a : Core_Slice_Iter_Iter_Type.t_iter t . [#"../../../../creusot-contracts/src/std/slice.rs" 392 14 392 39] produces0 a (Seq.empty ) a
  predicate invariant3 (self : Core_Slice_Iter_Iter_Type.t_iter t)
  val invariant3 (self : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Core_Slice_Iter_Iter_Type.t_iter t)
  val inv3 (_x : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Slice_Iter_Iter_Type.t_iter t . inv3 x = true
  use prelude.Ghost
  predicate invariant2 (self : Ghost.ghost_ty (Seq.seq t))
  val invariant2 (self : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Ghost.ghost_ty (Seq.seq t))
  val inv2 (_x : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../hillel.rs" 1 0 1 0] forall x : Ghost.ghost_ty (Seq.seq t) . inv2 x = true
  predicate invariant1 (self : slice t)
  val invariant1 (self : slice t) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : slice t . inv1 x = true
  predicate invariant0 (self : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant0 (self : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv0 (_x : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv0 x = true
  function deep_model1 (self : t) : deep_model_ty0
  val deep_model1 (self : t) : deep_model_ty0
    ensures { result = deep_model1 self }
    
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model3 self) ix
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic1 self ix }
    
  use seq.Seq
  use seq.Seq
  function deep_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq deep_model_ty0
  val deep_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq deep_model_ty0
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 33 18 33 22] inv8 self}
    ensures { result = deep_model3 self }
    
  axiom deep_model3_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 33 18 33 22] inv8 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 33 4 33 44] inv9 (deep_model3 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 31 4 32 53] forall i : int . 0 <= i /\ i < Seq.length (shallow_model3 self) -> Seq.get (deep_model3 self) i = deep_model1 (index_logic1 self i)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 30 14 30 56] Seq.length (shallow_model3 self) = Seq.length (deep_model3 self))
  use seq.Seq
  function shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model3 ( * self)
  val shallow_model4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model4 self }
    
  val push1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (value : t) : ()
    requires {inv7 self}
    requires {inv6 value}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 78 26 78 51] shallow_model3 ( ^ self) = Seq.snoc (shallow_model4 self) value }
    
  predicate is_unique0 [#"../hillel.rs" 50 0 50 34] (s : Seq.seq deep_model_ty0) =
    [#"../hillel.rs" 51 4 53 5] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s -> Seq.get s i = Seq.get s j -> i = j
  val is_unique0 [#"../hillel.rs" 50 0 50 34] (s : Seq.seq deep_model_ty0) : bool
    ensures { result = is_unique0 s }
    
  predicate contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq deep_model_ty0) (elem : deep_model_ty0) =
    [#"../hillel.rs" 58 4 60 5] exists i : int . 0 <= i /\ i < Seq.length seq /\ Seq.get seq i = elem
  val contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq deep_model_ty0) (elem : deep_model_ty0) : bool
    ensures { result = contains0 seq elem }
    
  predicate resolve10 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve10 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve10 self }
    
  predicate resolve9 (self : t)
  val resolve9 (self : t) : bool
    ensures { result = resolve9 self }
    
  predicate resolve8 (self : Core_Slice_Iter_Iter_Type.t_iter t)
  val resolve8 (self : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = resolve8 self }
    
  function deep_model2 (self : t) : deep_model_ty0 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model1 self
  val deep_model2 (self : t) : deep_model_ty0
    ensures { result = deep_model2 self }
    
  function deep_model4 (self : t) : deep_model_ty0 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model2 self
  val deep_model4 (self : t) : deep_model_ty0
    ensures { result = deep_model4 self }
    
  val eq0 (self : t) (other : t) : bool
    requires {inv12 self}
    requires {inv12 other}
    ensures { [#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75] result = (deep_model4 self = deep_model4 other) }
    
  use prelude.Ghost
  predicate resolve7 (self : t)
  val resolve7 (self : t) : bool
    ensures { result = resolve7 self }
    
  use seq.Seq
  predicate resolve6 (self : Core_Option_Option_Type.t_option t)
  val resolve6 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = resolve6 self }
    
  predicate resolve5 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve5 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) : bool
    ensures { result = resolve5 self }
    
  use seq.Seq
  function shallow_model6 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) : slice t =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model2 ( * self)
  val shallow_model6 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) : slice t
    ensures { result = shallow_model6 self }
    
  predicate completed0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 379 20 379 61] resolve5 self /\ shallow_model5 (shallow_model6 self) = Seq.empty 
  val completed0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) : bool
    ensures { result = completed0 self }
    
  val next0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> completed0 self
      | Core_Option_Option_Type.C_Some v -> produces0 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv4 result }
    
  use prelude.Ghost
  function index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 87 8 87 33] Seq.get (Ghost.inner self) ix
  val index_logic0 [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic0 self ix }
    
  use prelude.Ghost
  use prelude.Ghost
  predicate resolve4 (self : Ghost.ghost_ty (Seq.seq t))
  val resolve4 (self : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = resolve4 self }
    
  use prelude.Ghost
  predicate resolve3 (self : Ghost.ghost_ty (Core_Slice_Iter_Iter_Type.t_iter t))
  val resolve3 (self : Ghost.ghost_ty (Core_Slice_Iter_Iter_Type.t_iter t)) : bool
    ensures { result = resolve3 self }
    
  use prelude.Ghost
  predicate into_iter_post0 (self : Core_Slice_Iter_Iter_Type.t_iter t) (res : Core_Slice_Iter_Iter_Type.t_iter t) =
    [#"../../../../creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post0 (self : Core_Slice_Iter_Iter_Type.t_iter t) (res : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : Core_Slice_Iter_Iter_Type.t_iter t) =
    [#"../../../../creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre0 (self : Core_Slice_Iter_Iter_Type.t_iter t) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : Core_Slice_Iter_Iter_Type.t_iter t) : Core_Slice_Iter_Iter_Type.t_iter t
    requires {[#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv3 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    ensures { inv3 result }
    
  val iter0 (self : slice t) : Core_Slice_Iter_Iter_Type.t_iter t
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 238 0 334 1] shallow_model2 result = self }
    
  predicate resolve2 (self : slice t)
  val resolve2 (self : slice t) : bool
    ensures { result = resolve2 self }
    
  function shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    ensures { result = shallow_model1 self }
    
  val deref0 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : slice t
    requires {inv11 self}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 147 26 147 42] shallow_model0 result = shallow_model1 self }
    ensures { inv1 result }
    
  predicate resolve1 (self : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val resolve1 (self : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve1 self }
    
  use prelude.Ghost
  predicate is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq deep_model_ty0) (sup : Seq.seq deep_model_ty0) =
    [#"../hillel.rs" 65 4 67 5] forall i : int . 0 <= i /\ i < Seq.length sub -> contains0 sup (Seq.get sub i)
  val is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq deep_model_ty0) (sup : Seq.seq deep_model_ty0) : bool
    ensures { result = is_subset0 sub sup }
    
  use seq.Seq
  function deep_model0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq deep_model_ty0
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 92 8 92 28] deep_model3 ( * self)
  val deep_model0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq deep_model_ty0
    ensures { result = deep_model0 self }
    
  predicate resolve0 (self : Ghost.ghost_ty ())
  val resolve0 (self : Ghost.ghost_ty ()) : bool
    ensures { result = resolve0 self }
    
  use prelude.Ghost
  function subset_push0 [#"../hillel.rs" 72 0 72 37] (s : Seq.seq deep_model_ty0) (elem : deep_model_ty0) : () =
    [#"../hillel.rs" 70 0 70 8] ()
  val subset_push0 [#"../hillel.rs" 72 0 72 37] (s : Seq.seq deep_model_ty0) (elem : deep_model_ty0) : ()
    requires {[#"../hillel.rs" 72 18 72 19] inv9 s}
    requires {[#"../hillel.rs" 72 29 72 33] inv10 elem}
    ensures { result = subset_push0 s elem }
    
  axiom subset_push0_spec : forall s : Seq.seq deep_model_ty0, elem : deep_model_ty0 . ([#"../hillel.rs" 72 18 72 19] inv9 s) -> ([#"../hillel.rs" 72 29 72 33] inv10 elem) -> ([#"../hillel.rs" 71 10 71 36] is_subset0 s (Seq.snoc s elem))
  let rec cfg insert_unique [#"../hillel.rs" 79 0 79 62] [@cfg:stackify] [@cfg:subregion_analysis] (vec : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (elem : t) : ()
    requires {[#"../hillel.rs" 74 11 74 38] is_unique0 (deep_model0 vec)}
    requires {[#"../hillel.rs" 79 36 79 39] inv7 vec}
    requires {[#"../hillel.rs" 79 54 79 58] inv6 elem}
    ensures { [#"../hillel.rs" 75 10 75 40] is_unique0 (deep_model3 ( ^ vec)) }
    ensures { [#"../hillel.rs" 76 10 76 58] is_subset0 (deep_model0 vec) (deep_model3 ( ^ vec)) }
    ensures { [#"../hillel.rs" 77 10 77 82] is_subset0 (deep_model3 ( ^ vec)) (Seq.snoc (deep_model0 vec) (deep_model1 elem)) }
    ensures { [#"../hillel.rs" 78 10 78 58] contains0 (deep_model3 ( ^ vec)) (deep_model1 elem) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var vec : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) = vec;
  var elem : t = elem;
  var _8 : Ghost.ghost_ty ();
  var ghost_vec : Ghost.ghost_ty (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  var iter : Core_Slice_Iter_Iter_Type.t_iter t;
  var _16 : Core_Slice_Iter_Iter_Type.t_iter t;
  var _18 : slice t;
  var iter_old : Ghost.ghost_ty (Core_Slice_Iter_Iter_Type.t_iter t);
  var produced : Ghost.ghost_ty (Seq.seq t);
  var _28 : Core_Option_Option_Type.t_option t;
  var _29 : borrowed (Core_Slice_Iter_Iter_Type.t_iter t);
  var _30 : borrowed (Core_Slice_Iter_Iter_Type.t_iter t);
  var __creusot_proc_iter_elem : t;
  var _33 : Ghost.ghost_ty (Seq.seq t);
  var e : t;
  var _38 : bool;
  var _41 : t;
  var _48 : ();
  var _49 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    _8 <- ([#"../hillel.rs" 80 4 80 41] Ghost.new ());
    goto BB3
  }
  BB3 {
    assume { resolve0 _8 };
    assert { [@expl:assertion] [#"../hillel.rs" 81 20 81 89] is_subset0 (deep_model0 vec) (Seq.snoc (deep_model0 vec) (deep_model1 elem)) };
    goto BB4
  }
  BB4 {
    ghost_vec <- ([#"../hillel.rs" 82 20 82 32] Ghost.new ( * vec));
    goto BB5
  }
  BB5 {
    assert { [@expl:type invariant] inv0 ghost_vec };
    assume { resolve1 ghost_vec };
    _18 <- ([#"../hillel.rs" 85 13 85 23] deref0 ([#"../hillel.rs" 85 13 85 23]  * vec));
    goto BB6
  }
  BB6 {
    assert { [@expl:type invariant] inv1 _18 };
    assume { resolve2 _18 };
    _16 <- ([#"../hillel.rs" 85 13 85 23] iter0 ([#"../hillel.rs" 85 13 85 23] _18));
    goto BB7
  }
  BB7 {
    iter <- ([#"../hillel.rs" 84 4 84 111] into_iter0 _16);
    _16 <- any Core_Slice_Iter_Iter_Type.t_iter t;
    goto BB8
  }
  BB8 {
    iter_old <- ([#"../hillel.rs" 84 4 84 111] Ghost.new iter);
    goto BB9
  }
  BB9 {
    assume { resolve3 iter_old };
    produced <- ([#"../hillel.rs" 84 4 84 111] Ghost.new (Seq.empty ));
    goto BB10
  }
  BB10 {
    assert { [@expl:type invariant] inv2 produced };
    assume { resolve4 produced };
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    invariant { [#"../hillel.rs" 84 4 84 111] inv3 iter };
    invariant { [#"../hillel.rs" 84 4 84 111] produces0 (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"../hillel.rs" 84 4 84 111] forall j : int . 0 <= j /\ j < Seq.length (Ghost.inner produced) -> deep_model2 (index_logic0 produced j) <> deep_model1 elem };
    goto BB13
  }
  BB13 {
    _30 <- Borrow.borrow_mut iter;
    iter <-  ^ _30;
    _29 <- Borrow.borrow_mut ( * _30);
    _30 <- { _30 with current = ( ^ _29) };
    _28 <- ([#"../hillel.rs" 84 4 84 111] next0 _29);
    _29 <- any borrowed (Core_Slice_Iter_Iter_Type.t_iter t);
    goto BB14
  }
  BB14 {
    assume { resolve5 _30 };
    switch (_28)
      | Core_Option_Option_Type.C_None -> goto BB15
      | Core_Option_Option_Type.C_Some _ -> goto BB16
      end
  }
  BB15 {
    assert { [@expl:type invariant] inv4 _28 };
    assume { resolve6 _28 };
    assume { resolve8 iter };
    assert { [@expl:assertion] [#"../hillel.rs" 93 20 93 71] is_unique0 (Seq.snoc (deep_model0 vec) (deep_model1 elem)) };
    goto BB24
  }
  BB16 {
    goto BB18
  }
  BB17 {
    assert { [@expl:type invariant] inv4 _28 };
    assume { resolve6 _28 };
    assume { resolve8 iter };
    assert { [@expl:type invariant] inv6 elem };
    assume { resolve9 elem };
    assert { [@expl:type invariant] inv7 vec };
    assume { resolve10 vec };
    absurd
  }
  BB18 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _28;
    assert { [@expl:type invariant] inv4 _28 };
    assume { resolve6 _28 };
    _33 <- ([#"../hillel.rs" 84 4 84 111] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB19
  }
  BB19 {
    produced <- _33;
    _33 <- any Ghost.ghost_ty (Seq.seq t);
    assert { [@expl:type invariant] inv2 produced };
    assume { resolve4 produced };
    e <- __creusot_proc_iter_elem;
    assert { [@expl:type invariant] inv5 __creusot_proc_iter_elem };
    assume { resolve7 __creusot_proc_iter_elem };
    assert { [@expl:assertion] [#"../hillel.rs" 86 24 86 57] e = index_logic1 (Ghost.inner ghost_vec) (Seq.length (Ghost.inner produced) - 1) };
    _41 <- ([#"../hillel.rs" 87 16 87 21] elem);
    _38 <- ([#"../hillel.rs" 87 11 87 21] eq0 ([#"../hillel.rs" 87 11 87 12] e) ([#"../hillel.rs" 87 16 87 21] _41));
    goto BB20
  }
  BB20 {
    assert { [@expl:type invariant] inv5 _41 };
    assume { resolve7 _41 };
    assert { [@expl:type invariant] inv5 e };
    assume { resolve7 e };
    switch (_38)
      | False -> goto BB23
      | True -> goto BB21
      end
  }
  BB21 {
    assume { resolve8 iter };
    assert { [@expl:type invariant] inv6 elem };
    assume { resolve9 elem };
    assert { [@expl:type invariant] inv7 vec };
    assume { resolve10 vec };
    assert { [@expl:assertion] [#"../hillel.rs" 88 28 88 73] contains0 (deep_model0 vec) (deep_model1 elem) };
    goto BB22
  }
  BB22 {
    _0 <- ([#"../hillel.rs" 89 12 89 18] ());
    goto BB26
  }
  BB23 {
    goto BB12
  }
  BB24 {
    _49 <- Borrow.borrow_mut ( * vec);
    vec <- { vec with current = ( ^ _49) };
    assume { inv8 ( ^ _49) };
    _48 <- ([#"../hillel.rs" 94 4 94 18] push1 _49 elem);
    _49 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    elem <- any t;
    goto BB25
  }
  BB25 {
    assert { [@expl:type invariant] inv7 vec };
    assume { resolve10 vec };
    _0 <- ([#"../hillel.rs" 79 63 95 1] ());
    goto BB26
  }
  BB26 {
    return _0
  }
  
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
end
module Hillel_Unique
  type t
  use prelude.Slice
  predicate invariant11 (self : slice t)
  val invariant11 (self : slice t) : bool
    ensures { result = invariant11 self }
    
  predicate inv11 (_x : slice t)
  val inv11 (_x : slice t) : bool
    ensures { result = inv11 _x }
    
  axiom inv11 : [#"../hillel.rs" 1 0 1 0] forall x : slice t . inv11 x = true
  use prelude.UIntSize
  use seq.Seq
  predicate invariant10 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant10 (self : Seq.seq usize) : bool
    ensures { result = invariant10 self }
    
  predicate inv10 (_x : Seq.seq usize)
  val inv10 (_x : Seq.seq usize) : bool
    ensures { result = inv10 _x }
    
  axiom inv10 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq usize . inv10 x = true
  predicate invariant9 (self : Seq.seq t)
  val invariant9 (self : Seq.seq t) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : Seq.seq t)
  val inv9 (_x : Seq.seq t) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq t . inv9 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant8 (self : Core_Option_Option_Type.t_option usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant8 (self : Core_Option_Option_Type.t_option usize) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : Core_Option_Option_Type.t_option usize)
  val inv8 (_x : Core_Option_Option_Type.t_option usize) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Option_Option_Type.t_option usize . inv8 x = true
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  use prelude.Borrow
  predicate invariant7 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant7 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : borrowed (Core_Ops_Range_Range_Type.t_range usize))
  val inv7 (_x : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Core_Ops_Range_Range_Type.t_range usize) . inv7 x = true
  type deep_model_ty0
  predicate invariant6 (self : Seq.seq deep_model_ty0)
  val invariant6 (self : Seq.seq deep_model_ty0) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Seq.seq deep_model_ty0)
  val inv6 (_x : Seq.seq deep_model_ty0) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq deep_model_ty0 . inv6 x = true
  predicate invariant5 (self : slice t)
  val invariant5 (self : slice t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : slice t)
  val inv5 (_x : slice t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : [#"../hillel.rs" 1 0 1 0] forall x : slice t . inv5 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv4 x = true
  predicate invariant3 (self : t)
  val invariant3 (self : t) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : t)
  val inv3 (_x : t) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../hillel.rs" 1 0 1 0] forall x : t . inv3 x = true
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model1 self }
    
  axiom shallow_model1_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv9 (shallow_model1 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model1 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv9 (shallow_model1 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : [#"../hillel.rs" 1 0 1 0] forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  use seq.Seq
  predicate inv1 (_x : Core_Ops_Range_Range_Type.t_range usize)
  val inv1 (_x : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = inv1 _x }
    
  use prelude.Int
  use seq.Seq
  use seq.Seq
  function deep_model2 (self : usize) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  val deep_model2 (self : usize) : int
    ensures { result = deep_model2 self }
    
  predicate produces0 (self : Core_Ops_Range_Range_Type.t_range usize) (visited : Seq.seq usize) (o : Core_Ops_Range_Range_Type.t_range usize)
    
   =
    [#"../../../../creusot-contracts/src/std/iter/range.rs" 21 8 27 9] Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ deep_model2 (Core_Ops_Range_Range_Type.range_start self) <= deep_model2 (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> deep_model2 (Core_Ops_Range_Range_Type.range_start o) <= deep_model2 (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = deep_model2 (Core_Ops_Range_Range_Type.range_start o) - deep_model2 (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> deep_model2 (Seq.get visited i) = deep_model2 (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces0 (self : Core_Ops_Range_Range_Type.t_range usize) (visited : Seq.seq usize) (o : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = produces0 self visited o }
    
  function produces_trans0 (a : Core_Ops_Range_Range_Type.t_range usize) (ab : Seq.seq usize) (b : Core_Ops_Range_Range_Type.t_range usize) (bc : Seq.seq usize) (c : Core_Ops_Range_Range_Type.t_range usize) : ()
    
  val produces_trans0 (a : Core_Ops_Range_Range_Type.t_range usize) (ab : Seq.seq usize) (b : Core_Ops_Range_Range_Type.t_range usize) (bc : Seq.seq usize) (c : Core_Ops_Range_Range_Type.t_range usize) : ()
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 37 15 37 32] produces0 a ab b}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32] produces0 b bc c}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 22 40 23] inv1 a}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 31 40 33] inv10 ab}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 52 40 53] inv1 b}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 61 40 63] inv10 bc}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 82 40 83] inv1 c}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : Core_Ops_Range_Range_Type.t_range usize, ab : Seq.seq usize, b : Core_Ops_Range_Range_Type.t_range usize, bc : Seq.seq usize, c : Core_Ops_Range_Range_Type.t_range usize . ([#"../../../../creusot-contracts/src/std/iter/range.rs" 37 15 37 32] produces0 a ab b) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32] produces0 b bc c) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 22 40 23] inv1 a) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 31 40 33] inv10 ab) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 52 40 53] inv1 b) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 61 40 63] inv10 bc) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 82 40 83] inv1 c) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 39 14 39 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (a : Core_Ops_Range_Range_Type.t_range usize) : ()
  val produces_refl0 (a : Core_Ops_Range_Range_Type.t_range usize) : ()
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 33 21 33 22] inv1 a}
    ensures { result = produces_refl0 a }
    
  axiom produces_refl0_spec : forall a : Core_Ops_Range_Range_Type.t_range usize . ([#"../../../../creusot-contracts/src/std/iter/range.rs" 33 21 33 22] inv1 a) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 32 14 32 39] produces0 a (Seq.empty ) a)
  predicate invariant1 (self : Core_Ops_Range_Range_Type.t_range usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Ops_Range_Range_Type.t_range usize . inv1 x = true
  use prelude.Ghost
  predicate invariant0 (self : Ghost.ghost_ty (Seq.seq t))
  val invariant0 (self : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Ghost.ghost_ty (Seq.seq t))
  val inv0 (_x : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Ghost.ghost_ty (Seq.seq t) . inv0 x = true
  predicate resolve2 (self : t)
  val resolve2 (self : t) : bool
    ensures { result = resolve2 self }
    
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model1 self) ix
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic2 self ix }
    
  predicate resolve5 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 51 8 51 85] forall i : int . 0 <= i /\ i < Seq.length (shallow_model1 self) -> resolve2 (index_logic2 self i)
  val resolve5 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve5 self }
    
  use seq.Seq
  use prelude.Slice
  function shallow_model3 (self : slice t) : Seq.seq t
  val shallow_model3 (self : slice t) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv11 self}
    ensures { result = shallow_model3 self }
    
  axiom shallow_model3_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv11 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 19 4 19 50] inv9 (shallow_model3 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model3 self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model3 self) <= UIntSize.to_int max0)
  function shallow_model0 (self : slice t) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model3 self
  val shallow_model0 (self : slice t) : Seq.seq t
    ensures { result = shallow_model0 self }
    
  predicate resolve4 (self : slice t)
  val resolve4 (self : slice t) : bool
    ensures { result = resolve4 self }
    
  use seq.Seq
  use prelude.Ghost
  predicate resolve3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = resolve3 self }
    
  use seq.Seq
  use seq.Seq
  predicate contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq deep_model_ty0) (elem : deep_model_ty0) =
    [#"../hillel.rs" 58 4 60 5] exists i : int . 0 <= i /\ i < Seq.length seq /\ Seq.get seq i = elem
  val contains0 [#"../hillel.rs" 57 0 57 44] (seq : Seq.seq deep_model_ty0) (elem : deep_model_ty0) : bool
    ensures { result = contains0 seq elem }
    
  use seq.Seq
  function deep_model3 (self : t) : deep_model_ty0
  val deep_model3 (self : t) : deep_model_ty0
    ensures { result = deep_model3 self }
    
  predicate is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq deep_model_ty0) (sup : Seq.seq deep_model_ty0) =
    [#"../hillel.rs" 65 4 67 5] forall i : int . 0 <= i /\ i < Seq.length sub -> contains0 sup (Seq.get sub i)
  val is_subset0 [#"../hillel.rs" 64 0 64 49] (sub : Seq.seq deep_model_ty0) (sup : Seq.seq deep_model_ty0) : bool
    ensures { result = is_subset0 sub sup }
    
  function deep_model0 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq deep_model_ty0
  val deep_model0 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq deep_model_ty0
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 33 18 33 22] inv2 self}
    ensures { result = deep_model0 self }
    
  axiom deep_model0_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 33 18 33 22] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 33 4 33 44] inv6 (deep_model0 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 31 4 32 53] forall i : int . 0 <= i /\ i < Seq.length (shallow_model1 self) -> Seq.get (deep_model0 self) i = deep_model3 (index_logic2 self i)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 30 14 30 56] Seq.length (shallow_model1 self) = Seq.length (deep_model0 self))
  predicate is_unique0 [#"../hillel.rs" 50 0 50 34] (s : Seq.seq deep_model_ty0) =
    [#"../hillel.rs" 51 4 53 5] forall j : int . forall i : int . 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s -> Seq.get s i = Seq.get s j -> i = j
  val is_unique0 [#"../hillel.rs" 50 0 50 34] (s : Seq.seq deep_model_ty0) : bool
    ensures { result = is_unique0 s }
    
  function deep_model5 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq deep_model_ty0
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 92 8 92 28] deep_model0 ( * self)
  val deep_model5 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq deep_model_ty0
    ensures { result = deep_model5 self }
    
  val insert_unique0 [#"../hillel.rs" 79 0 79 62] (vec : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (elem : t) : ()
    requires {[#"../hillel.rs" 74 11 74 38] is_unique0 (deep_model5 vec)}
    requires {[#"../hillel.rs" 79 36 79 39] inv4 vec}
    requires {[#"../hillel.rs" 79 54 79 58] inv3 elem}
    ensures { [#"../hillel.rs" 75 10 75 40] is_unique0 (deep_model0 ( ^ vec)) }
    ensures { [#"../hillel.rs" 76 10 76 58] is_subset0 (deep_model5 vec) (deep_model0 ( ^ vec)) }
    ensures { [#"../hillel.rs" 77 10 77 82] is_subset0 (deep_model0 ( ^ vec)) (Seq.snoc (deep_model5 vec) (deep_model3 elem)) }
    ensures { [#"../hillel.rs" 78 10 78 58] contains0 (deep_model0 ( ^ vec)) (deep_model3 elem) }
    
  use seq.Seq
  predicate resolve1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = resolve1 self }
    
  predicate completed0 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/std/iter/range.rs" 14 12 14 78] resolve1 self /\ deep_model2 (Core_Ops_Range_Range_Type.range_start ( * self)) >= deep_model2 (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed0 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = completed0 self }
    
  val next0 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : Core_Option_Option_Type.t_option usize
    requires {inv7 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> completed0 self
      | Core_Option_Option_Type.C_Some v -> produces0 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv8 result }
    
  use seq_ext.SeqExt
  use prelude.Ghost
  function index_logic4 [@inline:trivial] (self : slice t) (ix : int) : t =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 43 8 43 31] Seq.get (shallow_model3 self) ix
  val index_logic4 [@inline:trivial] (self : slice t) (ix : int) : t
    ensures { result = index_logic4 self ix }
    
  function deep_model4 (self : slice t) : Seq.seq deep_model_ty0
  val deep_model4 (self : slice t) : Seq.seq deep_model_ty0
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 32 18 32 22] inv11 self}
    ensures { result = deep_model4 self }
    
  axiom deep_model4_spec : forall self : slice t . ([#"../../../../creusot-contracts/src/std/slice.rs" 32 18 32 22] inv11 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 32 4 32 44] inv6 (deep_model4 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 31 4 31 95] forall i : int . 0 <= i /\ i < Seq.length (deep_model4 self) -> Seq.get (deep_model4 self) i = deep_model3 (index_logic4 self i)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 30 14 30 41] Seq.length (shallow_model3 self) = Seq.length (deep_model4 self))
  function deep_model1 (self : slice t) : Seq.seq deep_model_ty0 =
    [#"../../../../creusot-contracts/src/model.rs" 74 8 74 28] deep_model4 self
  val deep_model1 (self : slice t) : Seq.seq deep_model_ty0
    ensures { result = deep_model1 self }
    
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  predicate into_iter_post0 (self : Core_Ops_Range_Range_Type.t_range usize) (res : Core_Ops_Range_Range_Type.t_range usize)
    
   =
    [#"../../../../creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post0 (self : Core_Ops_Range_Range_Type.t_range usize) (res : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : Core_Ops_Range_Range_Type.t_range usize) =
    [#"../../../../creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre0 (self : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : Core_Ops_Range_Range_Type.t_range usize) : Core_Ops_Range_Range_Type.t_range usize
    requires {[#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    ensures { inv1 result }
    
  val len0 (self : slice t) : usize
    requires {inv5 self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 238 0 334 1] Seq.length (shallow_model0 self) = UIntSize.to_int result }
    
  predicate resolve0 (self : Ghost.ghost_ty (Seq.seq t))
  val resolve0 (self : Ghost.ghost_ty (Seq.seq t)) : bool
    ensures { result = resolve0 self }
    
  use prelude.Ghost
  use seq.Seq
  val new0 (_1 : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 68 26 68 44] Seq.length (shallow_model1 result) = 0 }
    ensures { inv2 result }
    
  let rec cfg unique [#"../hillel.rs" 100 0 100 56] [@cfg:stackify] [@cfg:subregion_analysis] (str : slice t) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    requires {[#"../hillel.rs" 100 36 100 39] inv5 str}
    ensures { [#"../hillel.rs" 97 10 97 40] is_unique0 (deep_model0 result) }
    ensures { [#"../hillel.rs" 98 10 98 58] is_subset0 (deep_model0 result) (deep_model1 str) }
    ensures { [#"../hillel.rs" 99 10 99 58] is_subset0 (deep_model1 str) (deep_model0 result) }
    ensures { [#"../hillel.rs" 100 50 100 56] inv2 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global);
  var str : slice t = str;
  var unique : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global);
  var sub_str : Ghost.ghost_ty (Seq.seq t);
  var iter : Core_Ops_Range_Range_Type.t_range usize;
  var _11 : usize;
  var iter_old : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced : Ghost.ghost_ty (Seq.seq usize);
  var _23 : Core_Option_Option_Type.t_option usize;
  var _24 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _25 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem : usize;
  var _28 : Ghost.ghost_ty (Seq.seq usize);
  var i : usize;
  var elem : t;
  var _32 : usize;
  var _34 : bool;
  var _35 : ();
  var _36 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  var _37 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  var _39 : Ghost.ghost_ty (Seq.seq t);
  {
    goto BB0
  }
  BB0 {
    unique <- ([#"../hillel.rs" 101 21 101 31] new0 ());
    goto BB1
  }
  BB1 {
    sub_str <- ([#"../hillel.rs" 102 37 102 55] Ghost.new (Seq.empty ));
    goto BB2
  }
  BB2 {
    assert { [@expl:type invariant] inv0 sub_str };
    assume { resolve0 sub_str };
    _11 <- ([#"../hillel.rs" 107 16 107 25] len0 ([#"../hillel.rs" 107 16 107 25] str));
    goto BB3
  }
  BB3 {
    iter <- ([#"../hillel.rs" 104 4 104 48] into_iter0 ([#"../hillel.rs" 107 13 107 25] Core_Ops_Range_Range_Type.C_Range ([#"../hillel.rs" 107 13 107 14] [#"../hillel.rs" 107 13 107 14] (0 : usize)) _11));
    _11 <- any usize;
    goto BB4
  }
  BB4 {
    iter_old <- ([#"../hillel.rs" 104 4 104 48] Ghost.new iter);
    goto BB5
  }
  BB5 {
    produced <- ([#"../hillel.rs" 104 4 104 48] Ghost.new (Seq.empty ));
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    invariant { [#"../hillel.rs" 104 4 104 48] inv1 iter };
    invariant { [#"../hillel.rs" 104 4 104 48] produces0 (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"../hillel.rs" 104 16 104 46] is_unique0 (deep_model0 unique) };
    invariant { [#"../hillel.rs" 105 16 105 64] is_subset0 (deep_model0 unique) (deep_model1 str) };
    invariant { [#"../hillel.rs" 106 16 106 95] is_subset0 (SeqExt.subsequence (deep_model1 str) 0 (Seq.length (Ghost.inner produced))) (deep_model0 unique) };
    goto BB11
  }
  BB11 {
    _25 <- Borrow.borrow_mut iter;
    iter <-  ^ _25;
    _24 <- Borrow.borrow_mut ( * _25);
    _25 <- { _25 with current = ( ^ _24) };
    _23 <- ([#"../hillel.rs" 104 4 104 48] next0 _24);
    _24 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB12
  }
  BB12 {
    assume { resolve1 _25 };
    switch (_23)
      | Core_Option_Option_Type.C_None -> goto BB13
      | Core_Option_Option_Type.C_Some _ -> goto BB14
      end
  }
  BB13 {
    assert { [@expl:type invariant] inv5 str };
    assume { resolve4 str };
    assert { [@expl:assertion] [#"../hillel.rs" 113 20 113 95] is_subset0 (SeqExt.subsequence (deep_model1 str) 0 (Seq.length (shallow_model0 str))) (deep_model0 unique) };
    goto BB21
  }
  BB14 {
    goto BB16
  }
  BB15 {
    assert { [@expl:type invariant] inv2 unique };
    assume { resolve5 unique };
    assert { [@expl:type invariant] inv5 str };
    assume { resolve4 str };
    absurd
  }
  BB16 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _23;
    _28 <- ([#"../hillel.rs" 104 4 104 48] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB17
  }
  BB17 {
    produced <- _28;
    _28 <- any Ghost.ghost_ty (Seq.seq usize);
    i <- __creusot_proc_iter_elem;
    _32 <- i;
    _34 <- ([#"../hillel.rs" 108 22 108 28] _32 < ([#"../hillel.rs" 108 22 108 28] Slice.length str));
    assert { [@expl:index in bounds] [#"../hillel.rs" 108 22 108 28] _34 };
    goto BB18
  }
  BB18 {
    elem <- Slice.get str _32;
    _37 <- Borrow.borrow_mut unique;
    unique <-  ^ _37;
    assume { inv2 ( ^ _37) };
    _36 <- Borrow.borrow_mut ( * _37);
    _37 <- { _37 with current = ( ^ _36) };
    assume { inv2 ( ^ _36) };
    assert { [@expl:type invariant] inv3 elem };
    assume { resolve2 elem };
    _35 <- ([#"../hillel.rs" 109 8 109 40] insert_unique0 _36 elem);
    _36 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    goto BB19
  }
  BB19 {
    assert { [@expl:type invariant] inv4 _37 };
    assume { resolve3 _37 };
    _39 <- ([#"../hillel.rs" 110 18 110 44] Ghost.new (Seq.snoc (Ghost.inner sub_str) elem));
    goto BB20
  }
  BB20 {
    sub_str <- _39;
    _39 <- any Ghost.ghost_ty (Seq.seq t);
    assert { [@expl:type invariant] inv0 sub_str };
    assume { resolve0 sub_str };
    goto BB10
  }
  BB21 {
    assert { [@expl:assertion] [#"../hillel.rs" 114 20 114 88] Seq.(==) (SeqExt.subsequence (deep_model1 str) 0 (Seq.length (shallow_model0 str))) (deep_model1 str) };
    _0 <- unique;
    unique <- any Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global);
    goto BB22
  }
  BB22 {
    return _0
  }
  
end
module Hillel_SumRange_Impl
  use prelude.UInt32
  use seq.Seq
  use prelude.UInt32
  use seq.Seq
  use seq.Seq
  use prelude.Int
  let rec ghost function sum_range [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
    requires {[#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq}
    ensures { [#"../hillel.rs" 121 10 121 21] result >= 0 }
    variant {[#"../hillel.rs" 119 10 119 19] to' - from}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../hillel.rs" 118 0 118 8] if pure {to' - from > 0} then
      UInt32.to_int (Seq.get seq from) + sum_range seq (from + 1) to'
    else
      0
    
end
module Hillel_SumRangeSplit_Impl
  use prelude.UInt32
  use seq.Seq
  use prelude.UInt32
  use seq.Seq
  use seq.Seq
  use prelude.Int
  function sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
  axiom sum_range0_def : forall seq : Seq.seq uint32, from : int, to' : int . sum_range0 seq from to' = ([#"../hillel.rs" 118 0 118 8] if to' - from > 0 then
    UInt32.to_int (Seq.get seq from) + sum_range0 seq (from + 1) to'
  else
    0
  )
  val sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
    requires {[#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq}
    ensures { result = sum_range0 seq from to' }
    
  axiom sum_range0_spec : forall seq : Seq.seq uint32, from : int, to' : int . ([#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq) -> ([#"../hillel.rs" 121 10 121 21] sum_range0 seq from to' >= 0)
  let rec ghost function sum_range_split [#"../hillel.rs" 134 0 134 61] (seq : Seq.seq uint32) (from : int) (to' : int) (i : int) : ()
    requires {[#"../hillel.rs" 132 11 132 63] 0 <= from /\ from <= i /\ i <= to' /\ to' <= Seq.length seq}
    ensures { [#"../hillel.rs" 133 10 133 85] sum_range0 seq from to' = sum_range0 seq from i + sum_range0 seq i to' }
    variant {[#"../hillel.rs" 131 10 131 18] i - from}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../hillel.rs" 135 4 137 5] if pure {i > from} then let _ = sum_range_split seq (from + 1) to' i in () else ()
end
module Hillel_Score_Impl
  use prelude.Int
  function abs_diff0 (self : int) (other : int) : int =
    [#"../../../../creusot-contracts/src/logic/int.rs" 50 4 50 12] if self < other then other - self else self - other
  val abs_diff0 (self : int) (other : int) : int
    ensures { result = abs_diff0 self other }
    
  use prelude.UInt32
  use seq.Seq
  use prelude.UInt32
  use seq.Seq
  use seq.Seq
  function sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
  axiom sum_range0_def : forall seq : Seq.seq uint32, from : int, to' : int . sum_range0 seq from to' = ([#"../hillel.rs" 118 0 118 8] if to' - from > 0 then
    UInt32.to_int (Seq.get seq from) + sum_range0 seq (from + 1) to'
  else
    0
  )
  val sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
    requires {[#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq}
    ensures { result = sum_range0 seq from to' }
    
  axiom sum_range0_spec : forall seq : Seq.seq uint32, from : int, to' : int . ([#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq) -> ([#"../hillel.rs" 121 10 121 21] sum_range0 seq from to' >= 0)
  function sum_range_split0 [#"../hillel.rs" 134 0 134 61] (seq : Seq.seq uint32) (from : int) (to' : int) (i : int) : ()
    
  axiom sum_range_split0_def : forall seq : Seq.seq uint32, from : int, to' : int, i : int . sum_range_split0 seq from to' i = ([#"../hillel.rs" 135 4 137 5] if i > from then
    let _ = sum_range_split0 seq (from + 1) to' i in ()
  else
    ()
  )
  val sum_range_split0 [#"../hillel.rs" 134 0 134 61] (seq : Seq.seq uint32) (from : int) (to' : int) (i : int) : ()
    requires {[#"../hillel.rs" 132 11 132 63] 0 <= from /\ from <= i /\ i <= to' /\ to' <= Seq.length seq}
    ensures { result = sum_range_split0 seq from to' i }
    
  axiom sum_range_split0_spec : forall seq : Seq.seq uint32, from : int, to' : int, i : int . ([#"../hillel.rs" 132 11 132 63] 0 <= from /\ from <= i /\ i <= to' /\ to' <= Seq.length seq) -> ([#"../hillel.rs" 133 10 133 85] sum_range0 seq from to' = sum_range0 seq from i + sum_range0 seq i to')
  let rec ghost function score [#"../hillel.rs" 144 0 144 38] (seq : Seq.seq uint32) (i : int) : int
    requires {[#"../hillel.rs" 141 11 141 35] 0 <= i /\ i <= Seq.length seq}
    ensures { [#"../hillel.rs" 142 10 142 64] 0 <= result /\ result <= sum_range0 seq 0 (Seq.length seq) }
    ensures { [#"../hillel.rs" 143 0 143 79] 0 = i \/ i = Seq.length seq -> result = sum_range0 seq 0 (Seq.length seq) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../hillel.rs" 145 4 145 41] let _ = sum_range_split0 seq 0 (Seq.length seq) i in let a' = sum_range0 seq 0 i in let b' = sum_range0 seq i (Seq.length seq) in abs_diff0 a' b'
end
module Hillel_Fulcrum
  use prelude.UIntSize
  use seq.Seq
  predicate invariant9 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant9 (self : Seq.seq usize) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : Seq.seq usize)
  val inv9 (_x : Seq.seq usize) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq usize . inv9 x = true
  use prelude.UInt32
  predicate invariant8 (self : Seq.seq uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant8 (self : Seq.seq uint32) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : Seq.seq uint32)
  val inv8 (_x : Seq.seq uint32) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq uint32 . inv8 x = true
  use prelude.Slice
  predicate invariant7 (self : slice uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant7 (self : slice uint32) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : slice uint32)
  val inv7 (_x : slice uint32) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : [#"../hillel.rs" 1 0 1 0] forall x : slice uint32 . inv7 x = true
  predicate invariant6 (self : Seq.seq uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : Seq.seq uint32) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Seq.seq uint32)
  val inv6 (_x : Seq.seq uint32) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : [#"../hillel.rs" 1 0 1 0] forall x : Seq.seq uint32 . inv6 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant5 (self : Core_Option_Option_Type.t_option usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : Core_Option_Option_Type.t_option usize) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Core_Option_Option_Type.t_option usize)
  val inv5 (_x : Core_Option_Option_Type.t_option usize) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Option_Option_Type.t_option usize . inv5 x = true
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  use prelude.Borrow
  predicate invariant4 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Core_Ops_Range_Range_Type.t_range usize))
  val inv4 (_x : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : [#"../hillel.rs" 1 0 1 0] forall x : borrowed (Core_Ops_Range_Range_Type.t_range usize) . inv4 x = true
  predicate invariant3 (self : Core_Option_Option_Type.t_option uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Core_Option_Option_Type.t_option uint32) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Core_Option_Option_Type.t_option uint32)
  val inv3 (_x : Core_Option_Option_Type.t_option uint32) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Option_Option_Type.t_option uint32 . inv3 x = true
  predicate invariant2 (self : slice uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : slice uint32) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : slice uint32)
  val inv2 (_x : slice uint32) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : [#"../hillel.rs" 1 0 1 0] forall x : slice uint32 . inv2 x = true
  use seq.Seq
  predicate inv1 (_x : Core_Ops_Range_Range_Type.t_range usize)
  val inv1 (_x : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = inv1 _x }
    
  use prelude.Int
  use seq.Seq
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  function deep_model0 (self : usize) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  val deep_model0 (self : usize) : int
    ensures { result = deep_model0 self }
    
  predicate produces1 (self : Core_Ops_Range_Range_Type.t_range usize) (visited : Seq.seq usize) (o : Core_Ops_Range_Range_Type.t_range usize)
    
   =
    [#"../../../../creusot-contracts/src/std/iter/range.rs" 21 8 27 9] Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ deep_model0 (Core_Ops_Range_Range_Type.range_start self) <= deep_model0 (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> deep_model0 (Core_Ops_Range_Range_Type.range_start o) <= deep_model0 (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = deep_model0 (Core_Ops_Range_Range_Type.range_start o) - deep_model0 (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> deep_model0 (Seq.get visited i) = deep_model0 (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces1 (self : Core_Ops_Range_Range_Type.t_range usize) (visited : Seq.seq usize) (o : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = produces1 self visited o }
    
  function produces_trans1 (a : Core_Ops_Range_Range_Type.t_range usize) (ab : Seq.seq usize) (b : Core_Ops_Range_Range_Type.t_range usize) (bc : Seq.seq usize) (c : Core_Ops_Range_Range_Type.t_range usize) : ()
    
  val produces_trans1 (a : Core_Ops_Range_Range_Type.t_range usize) (ab : Seq.seq usize) (b : Core_Ops_Range_Range_Type.t_range usize) (bc : Seq.seq usize) (c : Core_Ops_Range_Range_Type.t_range usize) : ()
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 37 15 37 32] produces1 a ab b}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32] produces1 b bc c}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 22 40 23] inv1 a}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 31 40 33] inv9 ab}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 52 40 53] inv1 b}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 61 40 63] inv9 bc}
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 40 82 40 83] inv1 c}
    ensures { result = produces_trans1 a ab b bc c }
    
  axiom produces_trans1_spec : forall a : Core_Ops_Range_Range_Type.t_range usize, ab : Seq.seq usize, b : Core_Ops_Range_Range_Type.t_range usize, bc : Seq.seq usize, c : Core_Ops_Range_Range_Type.t_range usize . ([#"../../../../creusot-contracts/src/std/iter/range.rs" 37 15 37 32] produces1 a ab b) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32] produces1 b bc c) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 22 40 23] inv1 a) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 31 40 33] inv9 ab) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 52 40 53] inv1 b) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 61 40 63] inv9 bc) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 40 82 40 83] inv1 c) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 39 14 39 42] produces1 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl1 (a : Core_Ops_Range_Range_Type.t_range usize) : ()
  val produces_refl1 (a : Core_Ops_Range_Range_Type.t_range usize) : ()
    requires {[#"../../../../creusot-contracts/src/std/iter/range.rs" 33 21 33 22] inv1 a}
    ensures { result = produces_refl1 a }
    
  axiom produces_refl1_spec : forall a : Core_Ops_Range_Range_Type.t_range usize . ([#"../../../../creusot-contracts/src/std/iter/range.rs" 33 21 33 22] inv1 a) -> ([#"../../../../creusot-contracts/src/std/iter/range.rs" 32 14 32 39] produces1 a (Seq.empty ) a)
  predicate invariant1 (self : Core_Ops_Range_Range_Type.t_range usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Ops_Range_Range_Type.t_range usize . inv1 x = true
  use Core_Slice_Iter_Iter_Type as Core_Slice_Iter_Iter_Type
  use seq.Seq
  use seq.Seq
  use prelude.Slice
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  function shallow_model4 (self : slice uint32) : Seq.seq uint32
  val shallow_model4 (self : slice uint32) : Seq.seq uint32
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv7 self}
    ensures { result = shallow_model4 self }
    
  axiom shallow_model4_spec : forall self : slice uint32 . ([#"../../../../creusot-contracts/src/std/slice.rs" 19 21 19 25] inv7 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 19 4 19 50] inv8 (shallow_model4 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model4 self = Slice.id self) && ([#"../../../../creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model4 self) <= UIntSize.to_int max0)
  function index_logic3 [@inline:trivial] (self : slice uint32) (ix : int) : uint32 =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 43 8 43 31] Seq.get (shallow_model4 self) ix
  val index_logic3 [@inline:trivial] (self : slice uint32) (ix : int) : uint32
    ensures { result = index_logic3 self ix }
    
  use seq.Seq
  function shallow_model1 (self : slice uint32) : Seq.seq uint32 =
    [#"../../../../creusot-contracts/src/model.rs" 83 8 83 31] shallow_model4 self
  val shallow_model1 (self : slice uint32) : Seq.seq uint32
    ensures { result = shallow_model1 self }
    
  use seq.Seq
  function to_ref_seq0 (self : slice uint32) : Seq.seq uint32
  val to_ref_seq0 (self : slice uint32) : Seq.seq uint32
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 91 19 91 23] inv2 self}
    ensures { result = to_ref_seq0 self }
    
  axiom to_ref_seq0_spec : forall self : slice uint32 . ([#"../../../../creusot-contracts/src/std/slice.rs" 91 19 91 23] inv2 self) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 91 4 91 35] inv6 (to_ref_seq0 self)) && ([#"../../../../creusot-contracts/src/std/slice.rs" 90 4 90 82] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq0 self) -> Seq.get (to_ref_seq0 self) i = index_logic3 self i) && ([#"../../../../creusot-contracts/src/std/slice.rs" 89 14 89 41] Seq.length (to_ref_seq0 self) = Seq.length (shallow_model1 self))
  function shallow_model3 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) : slice uint32
  val shallow_model3 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) : slice uint32
    ensures { result = shallow_model3 self }
    
  predicate produces0 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) (visited : Seq.seq uint32) (tl : Core_Slice_Iter_Iter_Type.t_iter uint32)
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 386 12 386 66] to_ref_seq0 (shallow_model3 self) = Seq.(++) visited (to_ref_seq0 (shallow_model3 tl))
  val produces0 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) (visited : Seq.seq uint32) (tl : Core_Slice_Iter_Iter_Type.t_iter uint32) : bool
    ensures { result = produces0 self visited tl }
    
  function produces_trans0 (a : Core_Slice_Iter_Iter_Type.t_iter uint32) (ab : Seq.seq uint32) (b : Core_Slice_Iter_Iter_Type.t_iter uint32) (bc : Seq.seq uint32) (c : Core_Slice_Iter_Iter_Type.t_iter uint32) : ()
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 395 4 395 10] ()
  val produces_trans0 (a : Core_Slice_Iter_Iter_Type.t_iter uint32) (ab : Seq.seq uint32) (b : Core_Slice_Iter_Iter_Type.t_iter uint32) (bc : Seq.seq uint32) (c : Core_Slice_Iter_Iter_Type.t_iter uint32) : ()
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 397 15 397 32] produces0 a ab b}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 398 15 398 32] produces0 b bc c}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 400 31 400 33] inv6 ab}
    requires {[#"../../../../creusot-contracts/src/std/slice.rs" 400 61 400 63] inv6 bc}
    ensures { result = produces_trans0 a ab b bc c }
    
  axiom produces_trans0_spec : forall a : Core_Slice_Iter_Iter_Type.t_iter uint32, ab : Seq.seq uint32, b : Core_Slice_Iter_Iter_Type.t_iter uint32, bc : Seq.seq uint32, c : Core_Slice_Iter_Iter_Type.t_iter uint32 . ([#"../../../../creusot-contracts/src/std/slice.rs" 397 15 397 32] produces0 a ab b) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 398 15 398 32] produces0 b bc c) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 400 31 400 33] inv6 ab) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 400 61 400 63] inv6 bc) -> ([#"../../../../creusot-contracts/src/std/slice.rs" 399 14 399 42] produces0 a (Seq.(++) ab bc) c)
  use seq.Seq
  function produces_refl0 (a : Core_Slice_Iter_Iter_Type.t_iter uint32) : () =
    [#"../../../../creusot-contracts/src/std/slice.rs" 390 4 390 10] ()
  val produces_refl0 (a : Core_Slice_Iter_Iter_Type.t_iter uint32) : ()
    ensures { result = produces_refl0 a }
    
  axiom produces_refl0_spec : forall a : Core_Slice_Iter_Iter_Type.t_iter uint32 . [#"../../../../creusot-contracts/src/std/slice.rs" 392 14 392 39] produces0 a (Seq.empty ) a
  predicate invariant0 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : Core_Slice_Iter_Iter_Type.t_iter uint32) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Core_Slice_Iter_Iter_Type.t_iter uint32)
  val inv0 (_x : Core_Slice_Iter_Iter_Type.t_iter uint32) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : [#"../hillel.rs" 1 0 1 0] forall x : Core_Slice_Iter_Iter_Type.t_iter uint32 . inv0 x = true
  use prelude.Ghost
  function abs_diff1 (self : int) (other : int) : int =
    [#"../../../../creusot-contracts/src/logic/int.rs" 50 4 50 12] if self < other then other - self else self - other
  val abs_diff1 (self : int) (other : int) : int
    ensures { result = abs_diff1 self other }
    
  use prelude.UInt32
  val abs_diff0 (self : uint32) (other : uint32) : uint32
    ensures { [#"../../../../creusot-contracts/src/std/num.rs" 212 26 212 59] UInt32.to_int result = abs_diff1 (UInt32.to_int self) (UInt32.to_int other) }
    
  use seq.Seq
  predicate resolve1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = resolve1 self }
    
  predicate completed1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) =
    [#"../../../../creusot-contracts/src/std/iter/range.rs" 14 12 14 78] resolve1 self /\ deep_model0 (Core_Ops_Range_Range_Type.range_start ( * self)) >= deep_model0 (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : bool
    ensures { result = completed1 self }
    
  val next1 (self : borrowed (Core_Ops_Range_Range_Type.t_range usize)) : Core_Option_Option_Type.t_option usize
    requires {inv4 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> completed1 self
      | Core_Option_Option_Type.C_Some v -> produces1 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv5 result }
    
  function sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
  axiom sum_range0_def : forall seq : Seq.seq uint32, from : int, to' : int . sum_range0 seq from to' = ([#"../hillel.rs" 118 0 118 8] if to' - from > 0 then
    UInt32.to_int (Seq.get seq from) + sum_range0 seq (from + 1) to'
  else
    0
  )
  val sum_range0 [#"../hillel.rs" 122 0 122 54] (seq : Seq.seq uint32) (from : int) (to' : int) : int
    requires {[#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq}
    ensures { result = sum_range0 seq from to' }
    
  axiom sum_range0_spec : forall seq : Seq.seq uint32, from : int, to' : int . ([#"../hillel.rs" 120 11 120 53] 0 <= from /\ from <= to' /\ to' <= Seq.length seq) -> ([#"../hillel.rs" 121 10 121 21] sum_range0 seq from to' >= 0)
  function sum_range_split0 [#"../hillel.rs" 134 0 134 61] (seq : Seq.seq uint32) (from : int) (to' : int) (i : int) : ()
    
  axiom sum_range_split0_def : forall seq : Seq.seq uint32, from : int, to' : int, i : int . sum_range_split0 seq from to' i = ([#"../hillel.rs" 135 4 137 5] if i > from then
    let _ = sum_range_split0 seq (from + 1) to' i in ()
  else
    ()
  )
  val sum_range_split0 [#"../hillel.rs" 134 0 134 61] (seq : Seq.seq uint32) (from : int) (to' : int) (i : int) : ()
    requires {[#"../hillel.rs" 132 11 132 63] 0 <= from /\ from <= i /\ i <= to' /\ to' <= Seq.length seq}
    ensures { result = sum_range_split0 seq from to' i }
    
  axiom sum_range_split0_spec : forall seq : Seq.seq uint32, from : int, to' : int, i : int . ([#"../hillel.rs" 132 11 132 63] 0 <= from /\ from <= i /\ i <= to' /\ to' <= Seq.length seq) -> ([#"../hillel.rs" 133 10 133 85] sum_range0 seq from to' = sum_range0 seq from i + sum_range0 seq i to')
  function score0 [#"../hillel.rs" 144 0 144 38] (seq : Seq.seq uint32) (i : int) : int =
    [#"../hillel.rs" 145 4 145 41] let _ = sum_range_split0 seq 0 (Seq.length seq) i in abs_diff1 (sum_range0 seq 0 i) (sum_range0 seq i (Seq.length seq))
  val score0 [#"../hillel.rs" 144 0 144 38] (seq : Seq.seq uint32) (i : int) : int
    requires {[#"../hillel.rs" 141 11 141 35] 0 <= i /\ i <= Seq.length seq}
    ensures { result = score0 seq i }
    
  axiom score0_spec : forall seq : Seq.seq uint32, i : int . ([#"../hillel.rs" 141 11 141 35] 0 <= i /\ i <= Seq.length seq) -> ([#"../hillel.rs" 143 0 143 79] 0 = i \/ i = Seq.length seq -> score0 seq i = sum_range0 seq 0 (Seq.length seq)) && ([#"../hillel.rs" 142 10 142 64] 0 <= score0 seq i /\ score0 seq i <= sum_range0 seq 0 (Seq.length seq))
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  predicate into_iter_post1 (self : Core_Ops_Range_Range_Type.t_range usize) (res : Core_Ops_Range_Range_Type.t_range usize)
    
   =
    [#"../../../../creusot-contracts/src/std/iter.rs" 80 8 80 19] self = res
  val into_iter_post1 (self : Core_Ops_Range_Range_Type.t_range usize) (res : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = into_iter_post1 self res }
    
  predicate into_iter_pre1 (self : Core_Ops_Range_Range_Type.t_range usize) =
    [#"../../../../creusot-contracts/src/std/iter.rs" 74 20 74 24] true
  val into_iter_pre1 (self : Core_Ops_Range_Range_Type.t_range usize) : bool
    ensures { result = into_iter_pre1 self }
    
  val into_iter1 (self : Core_Ops_Range_Range_Type.t_range usize) : Core_Ops_Range_Range_Type.t_range usize
    requires {[#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre1 self}
    requires {inv1 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post1 self result }
    ensures { inv1 result }
    
  val len2 (self : slice uint32) : usize
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/slice.rs" 238 0 334 1] Seq.length (shallow_model1 self) = UIntSize.to_int result }
    
  use seq.Seq
  predicate resolve0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) : bool
    ensures { result = resolve0 self }
    
  use seq.Seq
  function shallow_model5 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) : slice uint32 =
    [#"../../../../creusot-contracts/src/model.rs" 101 8 101 31] shallow_model3 ( * self)
  val shallow_model5 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) : slice uint32
    ensures { result = shallow_model5 self }
    
  predicate completed0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 379 20 379 61] resolve0 self /\ shallow_model4 (shallow_model5 self) = Seq.empty 
  val completed0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) : bool
    ensures { result = completed0 self }
    
  val next0 (self : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32)) : Core_Option_Option_Type.t_option uint32
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 95 26 98 17] match (result) with
      | Core_Option_Option_Type.C_None -> completed0 self
      | Core_Option_Option_Type.C_Some v -> produces0 ( * self) (Seq.singleton v) ( ^ self)
      end }
    ensures { inv3 result }
    
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  use prelude.Ghost
  predicate into_iter_post0 (self : slice uint32) (res : Core_Slice_Iter_Iter_Type.t_iter uint32) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 346 20 346 32] self = shallow_model3 res
  val into_iter_post0 (self : slice uint32) (res : Core_Slice_Iter_Iter_Type.t_iter uint32) : bool
    ensures { result = into_iter_post0 self res }
    
  predicate into_iter_pre0 (self : slice uint32) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 340 20 340 24] true
  val into_iter_pre0 (self : slice uint32) : bool
    ensures { result = into_iter_pre0 self }
    
  val into_iter0 (self : slice uint32) : Core_Slice_Iter_Iter_Type.t_iter uint32
    requires {[#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_pre0 self}
    requires {inv2 self}
    ensures { [#"../../../../creusot-contracts/src/std/iter.rs" 89 0 166 1] into_iter_post0 self result }
    
  let rec cfg fulcrum [#"../hillel.rs" 156 0 156 30] [@cfg:stackify] [@cfg:subregion_analysis] (s : slice uint32) : usize
    requires {[#"../hillel.rs" 152 11 152 45] sum_range0 (shallow_model1 s) 0 (Seq.length (shallow_model1 s)) <= 1000}
    requires {[#"../hillel.rs" 153 11 153 23] Seq.length (shallow_model1 s) > 0}
    ensures { [#"../hillel.rs" 154 10 154 44] 0 <= UIntSize.to_int result /\ UIntSize.to_int result < Seq.length (shallow_model1 s) }
    ensures { [#"../hillel.rs" 155 0 155 88] forall i : int . 0 <= i /\ i < Seq.length (shallow_model1 s) -> score0 (shallow_model1 s) (UIntSize.to_int result) <= score0 (shallow_model1 s) i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var s : slice uint32 = s;
  var total : uint32;
  var iter : Core_Slice_Iter_Iter_Type.t_iter uint32;
  var iter_old : Ghost.ghost_ty (Core_Slice_Iter_Iter_Type.t_iter uint32);
  var produced : Ghost.ghost_ty (Seq.seq uint32);
  var _18 : ();
  var _19 : Core_Option_Option_Type.t_option uint32;
  var _20 : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32);
  var _21 : borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32);
  var __creusot_proc_iter_elem : uint32;
  var _24 : Ghost.ghost_ty (Seq.seq uint32);
  var x : uint32;
  var min_i : usize;
  var min_dist : uint32;
  var sum : uint32;
  var iter1 : Core_Ops_Range_Range_Type.t_range usize;
  var _37 : usize;
  var iter_old1 : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var produced1 : Ghost.ghost_ty (Seq.seq usize);
  var _50 : Core_Option_Option_Type.t_option usize;
  var _51 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _52 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var __creusot_proc_iter_elem1 : usize;
  var _55 : Ghost.ghost_ty (Seq.seq usize);
  var i : usize;
  var dist : uint32;
  var _63 : ();
  var _70 : usize;
  var _72 : bool;
  {
    goto BB0
  }
  BB0 {
    total <- ([#"../hillel.rs" 157 25 157 26] [#"../hillel.rs" 157 25 157 26] (0 : uint32));
    iter <- ([#"../hillel.rs" 159 4 159 60] into_iter0 s);
    goto BB1
  }
  BB1 {
    iter_old <- ([#"../hillel.rs" 159 4 159 60] Ghost.new iter);
    goto BB2
  }
  BB2 {
    produced <- ([#"../hillel.rs" 159 4 159 60] Ghost.new (Seq.empty ));
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    invariant { [#"../hillel.rs" 159 4 159 60] inv0 iter };
    invariant { [#"../hillel.rs" 159 4 159 60] produces0 (Ghost.inner iter_old) (Ghost.inner produced) iter };
    invariant { [#"../hillel.rs" 159 16 159 58] UInt32.to_int total = sum_range0 (shallow_model1 s) 0 (Seq.length (Ghost.inner produced)) };
    invariant { [#"../hillel.rs" 160 16 160 52] UInt32.to_int total <= sum_range0 (shallow_model1 s) 0 (Seq.length (shallow_model1 s)) };
    goto BB5
  }
  BB5 {
    _21 <- Borrow.borrow_mut iter;
    iter <-  ^ _21;
    _20 <- Borrow.borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    _19 <- ([#"../hillel.rs" 159 4 159 60] next0 _20);
    _20 <- any borrowed (Core_Slice_Iter_Iter_Type.t_iter uint32);
    goto BB6
  }
  BB6 {
    assume { resolve0 _21 };
    switch (_19)
      | Core_Option_Option_Type.C_None -> goto BB7
      | Core_Option_Option_Type.C_Some _ -> goto BB8
      end
  }
  BB7 {
    assert { [@expl:assertion] [#"../hillel.rs" 165 20 165 56] UInt32.to_int total = sum_range0 (shallow_model1 s) 0 (Seq.length (shallow_model1 s)) };
    min_i <- ([#"../hillel.rs" 167 27 167 28] [#"../hillel.rs" 167 27 167 28] (0 : usize));
    min_dist <- total;
    sum <- ([#"../hillel.rs" 170 23 170 24] [#"../hillel.rs" 170 23 170 24] (0 : uint32));
    _37 <- ([#"../hillel.rs" 176 16 176 23] len2 ([#"../hillel.rs" 176 16 176 23] s));
    goto BB12
  }
  BB8 {
    goto BB10
  }
  BB9 {
    absurd
  }
  BB10 {
    __creusot_proc_iter_elem <- Core_Option_Option_Type.some_0 _19;
    _24 <- ([#"../hillel.rs" 159 4 159 60] Ghost.new (Seq.(++) (Ghost.inner produced) (Seq.singleton __creusot_proc_iter_elem)));
    goto BB11
  }
  BB11 {
    produced <- _24;
    _24 <- any Ghost.ghost_ty (Seq.seq uint32);
    x <- __creusot_proc_iter_elem;
    total <- ([#"../hillel.rs" 162 8 162 18] total + x);
    _18 <- ([#"../hillel.rs" 161 16 163 5] ());
    goto BB4
  }
  BB12 {
    iter1 <- ([#"../hillel.rs" 171 4 171 58] into_iter1 ([#"../hillel.rs" 176 13 176 23] Core_Ops_Range_Range_Type.C_Range ([#"../hillel.rs" 176 13 176 14] [#"../hillel.rs" 176 13 176 14] (0 : usize)) _37));
    _37 <- any usize;
    goto BB13
  }
  BB13 {
    iter_old1 <- ([#"../hillel.rs" 171 4 171 58] Ghost.new iter1);
    goto BB14
  }
  BB14 {
    produced1 <- ([#"../hillel.rs" 171 4 171 58] Ghost.new (Seq.empty ));
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    invariant { [#"../hillel.rs" 171 4 171 58] inv1 iter1 };
    invariant { [#"../hillel.rs" 171 4 171 58] produces1 (Ghost.inner iter_old1) (Ghost.inner produced1) iter1 };
    invariant { [#"../hillel.rs" 171 16 171 56] UInt32.to_int sum = sum_range0 (shallow_model1 s) 0 (Seq.length (Ghost.inner produced1)) };
    invariant { [#"../hillel.rs" 172 16 172 30] UInt32.to_int sum <= UInt32.to_int total };
    invariant { [#"../hillel.rs" 173 16 173 61] UIntSize.to_int min_i <= Seq.length (Ghost.inner produced1) /\ UIntSize.to_int min_i < Seq.length (shallow_model1 s) };
    invariant { [#"../hillel.rs" 174 16 174 46] UInt32.to_int min_dist = score0 (shallow_model1 s) (UIntSize.to_int min_i) };
    invariant { [#"../hillel.rs" 171 4 171 58] forall j : int . 0 <= j /\ j < Seq.length (Ghost.inner produced1) -> score0 (shallow_model1 s) (UIntSize.to_int min_i) <= score0 (shallow_model1 s) j };
    goto BB17
  }
  BB17 {
    _52 <- Borrow.borrow_mut iter1;
    iter1 <-  ^ _52;
    _51 <- Borrow.borrow_mut ( * _52);
    _52 <- { _52 with current = ( ^ _51) };
    _50 <- ([#"../hillel.rs" 171 4 171 58] next1 _51);
    _51 <- any borrowed (Core_Ops_Range_Range_Type.t_range usize);
    goto BB18
  }
  BB18 {
    assume { resolve1 _52 };
    switch (_50)
      | Core_Option_Option_Type.C_None -> goto BB19
      | Core_Option_Option_Type.C_Some _ -> goto BB20
      end
  }
  BB19 {
    _0 <- min_i;
    return _0
  }
  BB20 {
    goto BB21
  }
  BB21 {
    __creusot_proc_iter_elem1 <- Core_Option_Option_Type.some_0 _50;
    _55 <- ([#"../hillel.rs" 171 4 171 58] Ghost.new (Seq.(++) (Ghost.inner produced1) (Seq.singleton __creusot_proc_iter_elem1)));
    goto BB22
  }
  BB22 {
    produced1 <- _55;
    _55 <- any Ghost.ghost_ty (Seq.seq usize);
    i <- __creusot_proc_iter_elem1;
    dist <- ([#"../hillel.rs" 177 19 177 44] abs_diff0 sum ([#"../hillel.rs" 177 32 177 43] total - sum));
    goto BB23
  }
  BB23 {
    switch ([#"../hillel.rs" 178 11 178 26] dist < min_dist)
      | False -> goto BB25
      | True -> goto BB24
      end
  }
  BB24 {
    min_i <- i;
    min_dist <- dist;
    _63 <- ([#"../hillel.rs" 178 27 181 9] ());
    goto BB26
  }
  BB25 {
    _63 <- ([#"../hillel.rs" 181 9 181 9] ());
    goto BB26
  }
  BB26 {
    _70 <- i;
    _72 <- ([#"../hillel.rs" 183 15 183 19] _70 < ([#"../hillel.rs" 183 15 183 19] Slice.length s));
    assert { [@expl:index in bounds] [#"../hillel.rs" 183 15 183 19] _72 };
    goto BB27
  }
  BB27 {
    sum <- ([#"../hillel.rs" 183 8 183 19] sum + Slice.get s _70);
    _18 <- ([#"../hillel.rs" 176 24 184 5] ());
    goto BB16
  }
  BB29 {
    goto BB9
  }
  BB30 {
    goto BB9
  }
  
end
