module M_collections__roundtrip_hashmap_into_iter [#"collections.rs" 15 0 17 18]
  let%span scollections0 = "collections.rs" 19 14 19 30
  let%span scollections1 = "collections.rs" 22 8 25 80
  let%span scollections2 = "collections.rs" 27 20 27 79
  let%span scollections3 = "collections.rs" 14 10 14 24
  let%span siter4 = "../../../../creusot-contracts/src/std/iter.rs" 97 0 205 1
  let%span siter5 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span shash_map6 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 73 20 73 54
  let%span shash_map7 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap8 = "../../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sseq9 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span sfmap10 = "../../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span shash_map11 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 199 24
  let%span shash_map12 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 205 20 205 33
  let%span shash_map13 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map14 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 78 14 78 45
  let%span shash_map15 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 76 4 76 10
  let%span shash_map16 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 83 15 83 32
  let%span shash_map17 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 84 15 84 32
  let%span shash_map18 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 85 14 85 42
  let%span shash_map19 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 87 8 87 104
  let%span sresolve20 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel21 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap22 = "../../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap23 = "../../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap24 = "../../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap25 = "../../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap26 = "../../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap27 = "../../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap28 = "../../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap29 = "../../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap30 = "../../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  predicate inv'0 (_1 : t_HashMap'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_HashMap'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_HashMap'0) =
    [%#shash_map11] true
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: usize; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_FMap'0
  
  function view'0 (self : t_HashMap'0) : t_FMap'0
  
  function view'2 (self : t_IntoIter'0) : t_FMap'0
  
  predicate into_iter_post'0 (self : t_HashMap'0) (res : t_IntoIter'0) =
    [%#shash_map12] view'0 self = view'2 res
  
  let rec into_iter'0 (self:t_HashMap'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter4] into_iter_pre'0 self}
    any [ return' (result:t_IntoIter'0)-> {[%#siter4] into_iter_post'0 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  predicate inv'1 (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  predicate resolve'0 (_1 : t_IntoIter'0) =
    true
  
  use prelude.prelude.Int
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap23] len'0 self >= 0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0)) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  function view'3 (self : t_FMap'0) : Map.map t_DeepModelTy'0 (t_Option'1)
  
  axiom view'3_spec : forall self : t_FMap'0 . [%#sfmap30] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'3 m1 <> view'3 m2
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap24] Map.get (view'3 self) k
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 (self : t_IntoIter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_IntoIter'0) =
    [%#shash_map7] len'0 (view'2 self) = Seq.length visited + len'0 (view'2 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'2 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'2 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'2 o) k = C_Some'0 v
     -> get'0 (view'2 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'2 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'2 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  function produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq (t_K'0, t_V'0)) (b : t_IntoIter'0) (bc : Seq.seq (t_K'0, t_V'0)) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_map19] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq (t_K'0, t_V'0), b : t_IntoIter'0, bc : Seq.seq (t_K'0, t_V'0), c : t_IntoIter'0 . ([%#shash_map16] produces'0 a ab b)
   -> ([%#shash_map17] produces'0 b bc c)  -> ([%#shash_map18] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IntoIter'0) : () =
    [%#shash_map15] ()
  
  axiom produces_refl'0_spec : forall self : t_IntoIter'0 . [%#shash_map14] produces'0 self (Seq.empty  : Seq.seq (t_K'0, t_V'0)) self
  
  predicate resolve'1 (self : borrowed (t_IntoIter'0)) =
    [%#sresolve20] self.final = self.current
  
  function view'1 (self : borrowed (t_IntoIter'0)) : t_FMap'0 =
    [%#smodel21] view'2 self.current
  
  use map.Const
  
  function empty'0 (_1 : ()) : t_FMap'0
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap25] len'0 (empty'0 _1) = 0)
  && ([%#sfmap26] view'3 (empty'0 _1) = Const.const (C_None'1))
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap29] view'3 self = view'3 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap27] ext_eq'0 self other  -> self = other)
  && ([%#sfmap28] (forall k : t_DeepModelTy'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap22] ext_eq'0 self (empty'0 ())
  
  predicate completed'0 (self : borrowed (t_IntoIter'0)) =
    [%#shash_map6] resolve'1 self /\ is_empty'0 (view'1 self)
  
  predicate from_iter_post'0 (prod : Seq.seq (t_K'0, t_V'0)) (res : t_HashMap'0) =
    [%#shash_map13] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = (k1, v)
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (let (a, _) = Seq.get prod j in a) <> k))
  
  let rec collect'0 (self:t_IntoIter'0) (return'  (ret:t_HashMap'0))= {[@expl:collect 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_HashMap'0)-> {inv'0 result}
      {[%#siter5] exists done' : borrowed (t_IntoIter'0), prod : Seq.seq (t_K'0, t_V'0) . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Snapshot
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : bool =
    [%#sfmap10] get_unsized'0 self k <> C_None'1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_into_iter'0 (xs:t_HashMap'0) (return'  (ret:t_HashMap'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {xs} (fun (_ret':t_IntoIter'0) ->  [ &it <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &it0 <- [%#scollections0] Snapshot.new it ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'0) ->  [ &r <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#scollections1] exists prod : Seq.seq (t_K'0, t_V'0), it1 : borrowed (t_IntoIter'0) . completed'0 it1
        /\ produces'0 (Snapshot.inner it0) prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod (k1, v)))}
        s1
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#scollections2] forall k : t_DeepModelTy'0 . contains'1 (view'0 r) k
        = contains'1 (view'0 xs) k}
        s1
      | s1 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb7 ] 
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return' {_0} ]
    )
    [ & _0 : t_HashMap'0 = any_l ()
    | & xs : t_HashMap'0 = xs
    | & it : t_IntoIter'0 = any_l ()
    | & it0 : Snapshot.snap_ty (t_IntoIter'0) = any_l ()
    | & r : t_HashMap'0 = any_l () ]
    
    [ return' (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_into_iter ensures] [%#scollections3] view'0 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter [#"collections.rs" 32 0 32 97]
  let%span scollections0 = "collections.rs" 34 14 34 30
  let%span scollections1 = "collections.rs" 38 4 41 77
  let%span scollections2 = "collections.rs" 31 10 31 98
  let%span shash_map3 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 23 0 37 1
  let%span siter4 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span shash_map5 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 125 20 125 54
  let%span shash_map6 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap7 = "../../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel8 = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq9 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span smodel10 = "../../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span shash_map11 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map12 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 130 14 130 45
  let%span shash_map13 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 128 4 128 10
  let%span shash_map14 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 135 15 135 32
  let%span shash_map15 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 136 15 136 32
  let%span shash_map16 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 137 14 137 42
  let%span shash_map17 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 139 8 139 104
  let%span sresolve18 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel19 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap20 = "../../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap21 = "../../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap22 = "../../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap23 = "../../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap24 = "../../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap25 = "../../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap26 = "../../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap27 = "../../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap28 = "../../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'3  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashMap'1  =
    { t_HashMap__base'1: t_HashMap'3 }
  
  predicate inv'0 (_1 : t_HashMap'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_HashMap'1 [inv'0 x] . inv'0 x = true
  
  type t_FMap'1
  
  function view'4 (self : t_HashMap'1) : t_FMap'1
  
  function view'1 (self : t_HashMap'1) : t_FMap'1 =
    [%#smodel10] view'4 self
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  function view'2 (self : t_Iter'0) : t_FMap'1
  
  let rec iter'0 (self:t_HashMap'1) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'0 self}
    any [ return' (result:t_Iter'0)-> {[%#shash_map3] view'1 self = view'2 result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  predicate inv'1 (_1 : t_Iter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Iter'0 [inv'1 x] . inv'1 x = true
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'2  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'2 }
  
  predicate inv'2 (_1 : t_HashMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_HashMap'0 [inv'2 x] . inv'2 x = true
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  predicate resolve'0 (_1 : t_Iter'0) =
    true
  
  use prelude.prelude.Int
  
  function len'0 (self : t_FMap'1) : int
  
  axiom len'0_spec : forall self : t_FMap'1 . [%#sfmap21] len'0 self >= 0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0)) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel8] deep_model'1 self
  
  type t_Option'2  =
    | C_None'0
    | C_Some'1 t_V'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V'0
  
  use map.Map
  
  function view'6 (self : t_FMap'1) : Map.map t_DeepModelTy'0 (t_Option'3)
  
  axiom view'6_spec : forall self : t_FMap'1 . [%#sfmap28] forall m1 : t_FMap'1, m2 : t_FMap'1 . m1 <> m2
   -> view'6 m1 <> view'6 m2
  
  use map.Map
  
  function get_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'3 =
    [%#sfmap22] Map.get (view'6 self) k
  
  function get'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'2 =
    [%#sfmap7] match get_unsized'1 self k with
      | C_None'3 -> C_None'0
      | C_Some'3 x -> C_Some'1 x
      end
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_Iter'0) =
    [%#shash_map6] len'0 (view'2 self) = Seq.length visited + len'0 (view'2 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'1 (view'2 self) (deep_model'0 k) = C_Some'1 v /\ get'1 (view'2 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 o) k = C_Some'1 v
     -> get'1 (view'2 self) k = C_Some'1 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 self) k = C_Some'1 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v)) \/ get'1 (view'2 o) k = C_Some'1 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq (t_K'0, t_V'0)) (b : t_Iter'0) (bc : Seq.seq (t_K'0, t_V'0)) (c : t_Iter'0) : ()
  
   =
    [%#shash_map17] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq (t_K'0, t_V'0), b : t_Iter'0, bc : Seq.seq (t_K'0, t_V'0), c : t_Iter'0 . ([%#shash_map14] produces'0 a ab b)
   -> ([%#shash_map15] produces'0 b bc c)  -> ([%#shash_map16] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#shash_map13] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#shash_map12] produces'0 self (Seq.empty  : Seq.seq (t_K'0, t_V'0)) self
  
  predicate resolve'1 (self : borrowed (t_Iter'0)) =
    [%#sresolve18] self.final = self.current
  
  function view'3 (self : borrowed (t_Iter'0)) : t_FMap'1 =
    [%#smodel19] view'2 self.current
  
  use map.Const
  
  function empty'0 (_1 : ()) : t_FMap'1
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap23] len'0 (empty'0 _1) = 0)
  && ([%#sfmap24] view'6 (empty'0 _1) = Const.const (C_None'3))
  
  function ext_eq'0 (self : t_FMap'1) (other : t_FMap'1) : bool =
    [%#sfmap27] view'6 self = view'6 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'1, other : t_FMap'1 . ([%#sfmap25] ext_eq'0 self other  -> self = other)
  && ([%#sfmap26] (forall k : t_DeepModelTy'0 . get_unsized'1 self k = get_unsized'1 other k)  -> ext_eq'0 self other)
  
  function is_empty'0 (self : t_FMap'1) : bool =
    [%#sfmap20] ext_eq'0 self (empty'0 ())
  
  predicate completed'0 (self : borrowed (t_Iter'0)) =
    [%#shash_map5] resolve'1 self /\ is_empty'0 (view'3 self)
  
  type t_FMap'0
  
  function view'0 (self : t_HashMap'0) : t_FMap'0
  
  type t_Option'0  =
    | C_None'2
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'2 t_V'0
  
  use map.Map
  
  function view'5 (self : t_FMap'0) : Map.map t_DeepModelTy'0 (t_Option'1)
  
  axiom view'5_spec : forall self : t_FMap'0 . [%#sfmap28] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'5 m1 <> view'5 m2
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap22] Map.get (view'5 self) k
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap7] match get_unsized'0 self k with
      | C_None'1 -> C_None'2
      | C_Some'2 x -> C_Some'0 x
      end
  
  predicate from_iter_post'0 (prod : Seq.seq (t_K'0, t_V'0)) (res : t_HashMap'0) =
    [%#shash_map11] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = (k1, v)
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (let (a, _) = Seq.get prod j in a) <> k))
  
  let rec collect'0 (self:t_Iter'0) (return'  (ret:t_HashMap'0))= {[@expl:collect 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_HashMap'0)-> {inv'2 result}
      {[%#siter4] exists done' : borrowed (t_Iter'0), prod : Seq.seq (t_K'0, t_V'0) . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter'0 (xs:t_HashMap'1) (return'  (ret:t_HashMap'0))= (! bb0
    [ bb0 = s0 [ s0 = iter'0 {xs} (fun (_ret':t_Iter'0) ->  [ &it <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections0] Snapshot.new it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'0) ->  [ &r <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections1] exists prod : Seq.seq (t_K'0, t_V'0), it1 : borrowed (t_Iter'0) . completed'0 it1
        /\ produces'0 (Snapshot.inner it0) prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod (k1, v)))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_HashMap'0 = any_l ()
    | & xs : t_HashMap'1 = xs
    | & it : t_Iter'0 = any_l ()
    | & it0 : Snapshot.snap_ty (t_Iter'0) = any_l ()
    | & r : t_HashMap'0 = any_l () ]
    
    [ return' (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_iter ensures] [%#scollections2] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 result) k
      = C_Some'0 v)
      = (get'1 (view'1 xs) k = C_Some'1 v)}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter_mut [#"collections.rs" 48 0 50 24]
  let%span scollections0 = "collections.rs" 52 14 52 30
  let%span scollections1 = "collections.rs" 55 8 58 81
  let%span scollections2 = "collections.rs" 45 10 45 128
  let%span scollections3 = "collections.rs" 46 10 46 107
  let%span scollections4 = "collections.rs" 47 10 47 110
  let%span shash_map5 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 23 0 37 1
  let%span siter6 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span shash_map7 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 177 20 177 54
  let%span shash_map8 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap9 = "../../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel10 = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq11 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span smodel12 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap13 = "../../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap14 = "../../../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span shash_map15 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 233 20 235 112
  let%span shash_map16 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map17 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 182 14 182 45
  let%span shash_map18 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 180 4 180 10
  let%span shash_map19 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 187 15 187 32
  let%span shash_map20 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 188 15 188 32
  let%span shash_map21 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 189 14 189 42
  let%span shash_map22 = "../../../../creusot-contracts/src/std/collections/hash_map.rs" 191 8 191 104
  let%span sresolve23 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap24 = "../../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap25 = "../../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap26 = "../../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap27 = "../../../../creusot-contracts/src/logic/fmap.rs" 117 9 117 31
  let%span sfmap28 = "../../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap29 = "../../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap30 = "../../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap31 = "../../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap32 = "../../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap33 = "../../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap34 = "../../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil35 = "../../../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../../../creusot-contracts/src/util.rs" 56 10 56 28
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'2  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'2 }
  
  predicate inv'0 (_1 : borrowed (t_HashMap'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_HashMap'0) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_DeepModelTy'0
  
  type t_FMap'1
  
  function view'2 (self : t_HashMap'0) : t_FMap'1
  
  type t_V'0
  
  type t_Option'3  =
    | C_None'2
    | C_Some'3 t_V'0
  
  use map.Map
  
  function view'6 (self : t_FMap'1) : Map.map t_DeepModelTy'0 (t_Option'3)
  
  axiom view'6_spec : forall self : t_FMap'1 . [%#sfmap33] forall m1 : t_FMap'1, m2 : t_FMap'1 . m1 <> m2
   -> view'6 m1 <> view'6 m2
  
  use map.Map
  
  function get_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'3 =
    [%#sfmap26] Map.get (view'6 self) k
  
  function contains'2 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : bool =
    [%#sfmap13] get_unsized'1 self k <> C_None'2
  
  type t_FMap'0
  
  function view'4 (self : t_IterMut'0) : t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'2 (borrowed t_V'0)
  
  use map.Map
  
  function view'5 (self : t_FMap'0) : Map.map t_DeepModelTy'0 (t_Option'1)
  
  axiom view'5_spec : forall self : t_FMap'0 . [%#sfmap33] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'5 m1 <> view'5 m2
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap26] Map.get (view'5 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : bool =
    [%#sfmap13] get_unsized'0 self k <> C_None'1
  
  function unwrap'1 (op : t_Option'3) : t_V'0
  
  axiom unwrap'1_spec : forall op : t_Option'3 . ([%#sutil35] op <> C_None'2)
   -> ([%#sutil36] C_Some'3 (unwrap'1 op) = op)
  
  function lookup_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap34] unwrap'1 (get_unsized'1 self k)
  
  function lookup'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap27] lookup_unsized'1 self k
  
  function index_logic'1 [@inline:trivial] (self : t_FMap'1) (key : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap14] lookup'1 self key
  
  function unwrap'0 (op : t_Option'1) : borrowed t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil35] op <> C_None'1)
   -> ([%#sutil36] C_Some'2 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : borrowed t_V'0 =
    [%#sfmap34] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : borrowed t_V'0 =
    [%#sfmap27] lookup_unsized'0 self k
  
  function index_logic'0 [@inline:trivial] (self : t_FMap'0) (key : t_DeepModelTy'0) : borrowed t_V'0 =
    [%#sfmap14] lookup'0 self key
  
  predicate into_iter_post'0 (self : borrowed (t_HashMap'0)) (res : t_IterMut'0) =
    [%#shash_map15] forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k = contains'2 (view'2 self.final) k
    /\ (forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k = contains'1 (view'4 res) k)
    /\ (forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k
     -> index_logic'1 (view'2 self.current) k = (index_logic'0 (view'4 res) k).current
    /\ index_logic'1 (view'2 self.final) k = (index_logic'0 (view'4 res) k).final)
  
  let rec iter_mut'0 (self:borrowed (t_HashMap'0)) (return'  (ret:t_IterMut'0))= {[@expl:iter_mut 'self' type invariant] inv'0 self}
    any [ return' (result:t_IterMut'0)-> {[%#shash_map5] into_iter_post'0 self result} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  predicate inv'1 (_1 : t_IterMut'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IterMut'0 [inv'1 x] . inv'1 x = true
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'3  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashMap'1  =
    { t_HashMap__base'1: t_HashMap'3 }
  
  predicate inv'2 (_1 : t_HashMap'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_HashMap'1 [inv'2 x] . inv'2 x = true
  
  type t_K'0
  
  use seq.Seq
  
  predicate resolve'1 (_1 : t_IterMut'0) =
    true
  
  use prelude.prelude.Int
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap25] len'0 self >= 0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 (self : Seq.seq (t_K'0, borrowed t_V'0)) (x : (t_K'0, borrowed t_V'0)) =
    [%#sseq11] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (borrowed t_V'0)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap9] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'2 x -> C_Some'0 x
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel10] deep_model'1 self
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 (self : t_IterMut'0) (visited : Seq.seq (t_K'0, borrowed t_V'0)) (o : t_IterMut'0) =
    [%#shash_map8] len'0 (view'4 self) = Seq.length visited + len'0 (view'4 o)
    /\ (forall k : t_K'0, v : borrowed t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'4 self) (deep_model'1 k) = C_Some'0 v /\ get'0 (view'4 o) (deep_model'1 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : borrowed t_V'0 . get'0 (view'4 o) k = C_Some'0 v
     -> get'0 (view'4 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : borrowed t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : borrowed t_V'0 . get'0 (view'4 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'4 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  function produces_trans'0 (a : t_IterMut'0) (ab : Seq.seq (t_K'0, borrowed t_V'0)) (b : t_IterMut'0) (bc : Seq.seq (t_K'0, borrowed t_V'0)) (c : t_IterMut'0) : ()
  
   =
    [%#shash_map22] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_IterMut'0, ab : Seq.seq (t_K'0, borrowed t_V'0), b : t_IterMut'0, bc : Seq.seq (t_K'0, borrowed t_V'0), c : t_IterMut'0 . ([%#shash_map19] produces'0 a ab b)
   -> ([%#shash_map20] produces'0 b bc c)  -> ([%#shash_map21] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IterMut'0) : () =
    [%#shash_map18] ()
  
  axiom produces_refl'0_spec : forall self : t_IterMut'0 . [%#shash_map17] produces'0 self (Seq.empty  : Seq.seq (t_K'0, borrowed t_V'0)) self
  
  predicate resolve'2 (self : borrowed (t_IterMut'0)) =
    [%#sresolve23] self.final = self.current
  
  function view'3 (self : borrowed (t_IterMut'0)) : t_FMap'0 =
    [%#smodel12] view'4 self.current
  
  use map.Const
  
  function empty'0 (_1 : ()) : t_FMap'0
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap28] len'0 (empty'0 _1) = 0)
  && ([%#sfmap29] view'5 (empty'0 _1) = Const.const (C_None'1))
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap32] view'5 self = view'5 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap30] ext_eq'0 self other  -> self = other)
  && ([%#sfmap31] (forall k : t_DeepModelTy'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap24] ext_eq'0 self (empty'0 ())
  
  predicate completed'0 (self : borrowed (t_IterMut'0)) =
    [%#shash_map7] resolve'2 self /\ is_empty'0 (view'3 self)
  
  function view'0 (self : t_HashMap'1) : t_FMap'0
  
  predicate from_iter_post'0 (prod : Seq.seq (t_K'0, borrowed t_V'0)) (res : t_HashMap'1) =
    [%#shash_map16] forall k : t_DeepModelTy'0, v : borrowed t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = (k1, v)
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (let (a, _) = Seq.get prod j in a) <> k))
  
  let rec collect'0 (self:t_IterMut'0) (return'  (ret:t_HashMap'1))= {[@expl:collect 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_HashMap'1)-> {inv'2 result}
      {[%#siter6] exists done' : borrowed (t_IterMut'0), prod : Seq.seq (t_K'0, borrowed t_V'0) . resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Snapshot
  
  predicate resolve'3 (self : borrowed (t_HashMap'0)) =
    [%#sresolve23] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_HashMap'0)) =
    resolve'3 _1
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  function view'1 (self : borrowed (t_HashMap'0)) : t_FMap'1 =
    [%#smodel12] view'2 self.current
  
  type t_Option'2  =
    | C_None'3
    | C_Some'1 t_V'0
  
  function get'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'2 =
    [%#sfmap9] match get_unsized'1 self k with
      | C_None'2 -> C_None'3
      | C_Some'3 x -> C_Some'1 x
      end
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter_mut'0 (xs:borrowed (t_HashMap'0)) (return'  (ret:t_HashMap'1))= (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_final <t_HashMap'0> {xs.current} {Borrow.get_id xs}
          (fun (_ret':borrowed (t_HashMap'0)) ->  [ &_6 <- _ret' ]  [ &xs <- { xs with current = _ret'.final } ] s1)
      | s1 = iter_mut'0 {_6} (fun (_ret':t_IterMut'0) ->  [ &it <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections0] Snapshot.new it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'1) ->  [ &r <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections1] exists prod : Seq.seq (t_K'0, borrowed t_V'0), it1 : borrowed (t_IterMut'0) . completed'0 it1
        /\ produces'0 (Snapshot.inner it0) prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : borrowed t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod (k1, v)))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = -{resolve'0 xs}- s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : t_HashMap'1 = any_l ()
    | & xs : borrowed (t_HashMap'0) = xs
    | & it : t_IterMut'0 = any_l ()
    | & _6 : borrowed (t_HashMap'0) = any_l ()
    | & it0 : Snapshot.snap_ty (t_IterMut'0) = any_l ()
    | & r : t_HashMap'1 = any_l () ]
    
    [ return' (result:t_HashMap'1)-> {[@expl:roundtrip_hashmap_iter_mut ensures #0] [%#scollections2] forall k : t_DeepModelTy'0, v : borrowed t_V'0 . get'0 (view'0 result) k
      = C_Some'0 v  -> get'1 (view'1 xs) k = C_Some'1 (v.current) /\ get'1 (view'2 xs.final) k = C_Some'1 (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] [%#scollections3] forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'1 xs) k
      = C_Some'1 v  -> contains'1 (view'0 result) k /\ (index_logic'0 (view'0 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] [%#scollections4] forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 xs.final) k
      = C_Some'1 v  -> contains'1 (view'0 result) k /\ (index_logic'0 (view'0 result) k).final = v}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_into_iter [#"collections.rs" 64 0 64 90]
  let%span scollections0 = "collections.rs" 63 10 63 24
  let%span siter1 = "../../../../creusot-contracts/src/std/iter.rs" 97 0 205 1
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span shash_set3 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 157 20 157 24
  let%span shash_set4 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 163 20 163 33
  let%span shash_set5 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 96 20 96 38
  let%span shash_set6 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 90 8 90 38
  let%span shash_set7 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 185 20 185 121
  let%span shash_set8 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 101 14 101 45
  let%span shash_set9 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 99 4 99 10
  let%span shash_set10 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 106 15 106 32
  let%span shash_set11 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 107 15 107 32
  let%span shash_set12 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 108 14 108 42
  let%span shash_set13 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 110 8 110 43
  let%span smodel14 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set15 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 58 16 65 23
  let%span sfset16 = "../../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq17 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span shash_set18 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 71 11 71 33
  let%span shash_set19 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 72 11 72 33
  let%span shash_set20 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 73 10 73 43
  let%span shash_set21 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 81 4 81 31
  let%span sseq22 = "../../../../creusot-contracts/src/logic/seq.rs" 382 14 383 65
  let%span sseq23 = "../../../../creusot-contracts/src/logic/seq.rs" 381 4 381 12
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  predicate inv'0 (_1 : t_HashSet'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_HashSet'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_HashSet'0) =
    [%#shash_set3] true
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: usize; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  predicate into_iter_post'0 (self : t_HashSet'0) (res : t_IntoIter'0) =
    [%#shash_set4] view'0 self = view'1 res
  
  let rec into_iter'0 (self:t_HashSet'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter1] into_iter_pre'0 self}
    any [ return' (result:t_IntoIter'0)-> {[%#siter1] into_iter_post'0 self result} (! return' {result}) ] 
  
  predicate inv'1 (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  type t_T'0
  
  use seq.Seq
  
  predicate resolve'0 (_1 : t_IntoIter'0) =
    true
  
  use set.Fset
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset16] Fset.mem e self
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0) =
    [%#shash_set15] Fset.cardinal (view'1 start) = Seq.length visited + Fset.cardinal (view'1 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'1 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'1 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'1 start) (deep_model'0 x) /\ not contains'0 (view'1 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'1 end') x
     -> contains'0 (view'1 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  use seq.Seq
  
  function concat_contains'0 (_1 : ()) : () =
    [%#sseq23] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq22] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set21] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set18] set_produces'0 a ab b)
   -> ([%#shash_set19] set_produces'0 b bc c)  -> ([%#shash_set20] set_produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  predicate produces'0 (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0) =
    [%#shash_set6] set_produces'0 self visited o
  
  function produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set13] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set10] produces'0 a ab b)
   -> ([%#shash_set11] produces'0 b bc c)  -> ([%#shash_set12] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IntoIter'0) : () =
    [%#shash_set9] ()
  
  axiom produces_refl'0_spec : forall self : t_IntoIter'0 . [%#shash_set8] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
  
  function view'2 (self : borrowed (t_IntoIter'0)) : Fset.fset t_DeepModelTy'0 =
    [%#smodel14] view'1 self.current
  
  use set.Fset
  
  predicate completed'0 (self : borrowed (t_IntoIter'0)) =
    [%#shash_set5] Fset.is_empty (view'2 self)
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set7] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_IntoIter'0) (return'  (ret:t_HashSet'0))= {[@expl:collect 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_HashSet'0)-> {inv'0 result}
      {[%#siter2] exists done' : borrowed (t_IntoIter'0), prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_into_iter'0 (xs:t_HashSet'0) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {xs} (fun (_ret':t_IntoIter'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {_3} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : t_HashSet'0 = any_l () | & xs : t_HashSet'0 = xs | & _3 : t_IntoIter'0 = any_l () ] 
    [ return' (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_into_iter ensures] [%#scollections0] view'0 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_iter [#"collections.rs" 69 0 69 87]
  let%span scollections0 = "collections.rs" 68 10 68 24
  let%span shash_set1 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 19 0 38 1
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span smodel3 = "../../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span shash_set4 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 135 20 135 38
  let%span shash_set5 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 129 8 129 38
  let%span shash_set6 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 185 20 185 121
  let%span shash_set7 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 140 14 140 45
  let%span shash_set8 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 138 4 138 10
  let%span shash_set9 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 145 15 145 32
  let%span shash_set10 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 146 15 146 32
  let%span shash_set11 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 147 14 147 42
  let%span shash_set12 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 149 8 149 43
  let%span smodel13 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set14 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 58 16 65 23
  let%span sfset15 = "../../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel16 = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq17 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span shash_set18 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 71 11 71 33
  let%span shash_set19 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 72 11 72 33
  let%span shash_set20 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 73 10 73 43
  let%span shash_set21 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 81 4 81 31
  let%span sseq22 = "../../../../creusot-contracts/src/logic/seq.rs" 382 14 383 65
  let%span sseq23 = "../../../../creusot-contracts/src/logic/seq.rs" 381 4 381 12
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashSet'3  =
    { t_HashSet__map'1: t_HashMap'1 }
  
  type t_HashSet'1  =
    { t_HashSet__base'1: t_HashSet'3 }
  
  predicate inv'0 (_1 : t_HashSet'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_HashSet'1 [inv'0 x] . inv'0 x = true
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'3 (self : t_HashSet'1) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_HashSet'1) : Fset.fset t_DeepModelTy'0 =
    [%#smodel3] view'3 self
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  function view'2 (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  let rec iter'0 (self:t_HashSet'1) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'0 self}
    any [ return' (result:t_Iter'0)-> {[%#shash_set1] view'1 self = view'2 result} (! return' {result}) ] 
  
  predicate inv'1 (_1 : t_Iter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Iter'0 [inv'1 x] . inv'1 x = true
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'2  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'2 }
  
  predicate inv'2 (_1 : t_HashSet'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_HashSet'0 [inv'2 x] . inv'2 x = true
  
  type t_T'0
  
  use seq.Seq
  
  predicate resolve'0 (_1 : t_Iter'0) =
    true
  
  use set.Fset
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset15] Fset.mem e self
  
  function deep_model'1 (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel16] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0) =
    [%#shash_set14] Fset.cardinal (view'2 start) = Seq.length visited + Fset.cardinal (view'2 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'2 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'2 start) (deep_model'0 x) /\ not contains'0 (view'2 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 end') x
     -> contains'0 (view'2 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  use seq.Seq
  
  function concat_contains'0 (_1 : ()) : () =
    [%#sseq23] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq22] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
   =
    [%#shash_set21] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set18] set_produces'0 a ab b)
   -> ([%#shash_set19] set_produces'0 b bc c)  -> ([%#shash_set20] set_produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0) =
    [%#shash_set5] set_produces'0 self visited o
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#shash_set12] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set9] produces'0 a ab b)
   -> ([%#shash_set10] produces'0 b bc c)  -> ([%#shash_set11] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#shash_set8] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#shash_set7] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
  
  function view'4 (self : borrowed (t_Iter'0)) : Fset.fset t_DeepModelTy'0 =
    [%#smodel13] view'2 self.current
  
  use set.Fset
  
  predicate completed'0 (self : borrowed (t_Iter'0)) =
    [%#shash_set4] Fset.is_empty (view'4 self)
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set6] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_Iter'0) (return'  (ret:t_HashSet'0))= {[@expl:collect 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_HashSet'0)-> {inv'2 result}
      {[%#siter2] exists done' : borrowed (t_Iter'0), prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_iter'0 (xs:t_HashSet'1) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = iter'0 {xs} (fun (_ret':t_Iter'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = collect'0 {_3} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_HashSet'0 = any_l () | & xs : t_HashSet'1 = xs | & _3 : t_Iter'0 = any_l () ] 
    [ return' (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_iter ensures] [%#scollections0] view'0 result
      = view'1 xs}
      (! return' {result}) ]

end
module M_collections__hashset_intersection [#"collections.rs" 74 0 77 15]
  let%span scollections0 = "collections.rs" 73 10 73 42
  let%span shash_set1 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 32 30 32 67
  let%span siter2 = "../../../../creusot-contracts/src/std/iter.rs" 97 0 205 1
  let%span siter3 = "../../../../creusot-contracts/src/std/iter.rs" 166 26 167 120
  let%span smodel4 = "../../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span scopied5 = "../../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span scopied6 = "../../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 105
  let%span scopied7 = "../../../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span shash_set8 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 185 20 185 121
  let%span scopied9 = "../../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied10 = "../../../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied11 = "../../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied12 = "../../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied13 = "../../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span shash_set14 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 210 20 210 56
  let%span shash_set15 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 204 8 204 38
  let%span sfset16 = "../../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq17 = "../../../../creusot-contracts/src/logic/seq.rs" 355 20 355 77
  let%span shash_set18 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 215 14 215 45
  let%span shash_set19 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 213 4 213 10
  let%span shash_set20 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 220 15 220 32
  let%span shash_set21 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 221 15 221 32
  let%span shash_set22 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 222 14 222 42
  let%span shash_set23 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 43
  let%span sresolve24 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel25 = "../../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set26 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 58 16 65 23
  let%span shash_set27 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 71 11 71 33
  let%span shash_set28 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 72 11 72 33
  let%span shash_set29 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 73 10 73 43
  let%span shash_set30 = "../../../../creusot-contracts/src/std/collections/hash_set.rs" 81 4 81 31
  let%span smodel31 = "../../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq32 = "../../../../creusot-contracts/src/logic/seq.rs" 382 14 383 65
  let%span sseq33 = "../../../../creusot-contracts/src/logic/seq.rs" 381 4 381 12
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.UInt64
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: uint64; t_RandomState__k1'0: uint64 }
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: usize;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: usize;
      t_RawTableInner__items'0: usize }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  predicate inv'0 (_1 : t_HashSet'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_HashSet'0 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: uint16 }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: opaque_ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: opaque_ptr;
      t_RawIterRange__end'0: opaque_ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: usize }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  predicate inv'1 (_1 : t_Intersection'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Intersection'0 [inv'1 x] . inv'1 x = true
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'2 (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel4] view'0 self
  
  use set.Fset
  
  let rec intersection'0 (self:t_HashSet'0) (other:t_HashSet'0) (return'  (ret:t_Intersection'0))= {[@expl:intersection 'self' type invariant] inv'0 self}
    {[@expl:intersection 'other' type invariant] inv'0 other}
    any
    [ return' (result:t_Intersection'0)-> {inv'1 result}
      {[%#shash_set1] view'2 result = Fset.inter (view'1 self) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied'0  =
    { t_Copied__it'0: t_Intersection'0 }
  
  predicate inv'2 (_1 : t_Copied'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Copied'0 [inv'2 x] . inv'2 x = true
  
  function iter'0 (self : t_Copied'0) : t_Intersection'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied5] inv'2 self  -> inv'1 (iter'0 self)
  
  let rec copied'0 (self:t_Intersection'0) (return'  (ret:t_Copied'0))= {[@expl:copied 'self' type invariant] inv'1 self}
    any [ return' (result:t_Copied'0)-> {inv'2 result} {[%#siter2] iter'0 result = self} (! return' {result}) ] 
  
  predicate inv'3 (_1 : t_HashSet'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_HashSet'0 [inv'3 x] . inv'3 x = true
  
  type t_T'0
  
  use seq.Seq
  
  predicate resolve'2 (_1 : t_Intersection'0) =
    true
  
  predicate resolve'1 (self : t_Copied'0) =
    [%#scopied9] resolve'2 (iter'0 self)
  
  predicate resolve'0 (_1 : t_Copied'0) =
    resolve'1 _1
  
  use seq.Seq
  
  use seq.Seq
  
  use set.Fset
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset16] Fset.mem e self
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'1 (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel31] deep_model'0 self
  
  use seq.Seq
  
  predicate contains'2 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0) =
    [%#shash_set26] Fset.cardinal (view'2 start) = Seq.length visited + Fset.cardinal (view'2 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 start) x
     -> (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1) \/ contains'0 (view'2 end') x)
    /\ (forall x : t_T'0 . contains'2 visited x
     -> contains'0 (view'2 start) (deep_model'1 x) /\ not contains'0 (view'2 end') (deep_model'1 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 end') x
     -> contains'0 (view'2 start) x /\ not (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'1 (Seq.get visited i) = deep_model'1 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0 (_1 : ()) : () =
    [%#sseq33] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq32] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'2 (Seq.(++) a b) x
  = contains'2 a x
  \/ contains'2 b x
  
  function set_produces_trans'0 (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set30] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set27] set_produces'0 a ab b)
   -> ([%#shash_set28] set_produces'0 b bc c)  -> ([%#shash_set29] set_produces'0 a (Seq.(++) ab bc) c)
  
  use seq.Seq
  
  predicate produces'1 (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0) =
    [%#shash_set15] set_produces'0 self visited o
  
  function produces_trans'1 (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set23] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'1_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set20] produces'1 a ab b)
   -> ([%#shash_set21] produces'1 b bc c)  -> ([%#shash_set22] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Intersection'0) : () =
    [%#shash_set19] ()
  
  axiom produces_refl'1_spec : forall self : t_Intersection'0 . [%#shash_set18] produces'1 self (Seq.empty  : Seq.seq t_T'0) self
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0) =
    [%#scopied7] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Copied'0, ab : Seq.seq t_T'0, b : t_Copied'0, bc : Seq.seq t_T'0, c : t_Copied'0 . ([%#scopied11] produces'0 a ab b)
   -> ([%#scopied12] produces'0 b bc c)  -> ([%#scopied13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Copied'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Copied'0 . [%#scopied10] produces'0 self (Seq.empty  : Seq.seq t_T'0) self
  
  predicate resolve'3 (self : borrowed (t_Intersection'0)) =
    [%#sresolve24] self.final = self.current
  
  function view'3 (self : borrowed (t_Intersection'0)) : Fset.fset t_DeepModelTy'0 =
    [%#smodel25] view'2 self.current
  
  use set.Fset
  
  predicate completed'1 (self : borrowed (t_Intersection'0)) =
    [%#shash_set14] resolve'3 self /\ Fset.is_empty (view'3 self)
  
  predicate completed'0 (self : borrowed (t_Copied'0)) =
    [%#scopied6] exists inner : borrowed (t_Intersection'0) . inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'1 inner
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set8] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_Copied'0) (return'  (ret:t_HashSet'0))= {[@expl:collect 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_HashSet'0)-> {inv'3 result}
      {[%#siter3] exists done' : borrowed (t_Copied'0), prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_intersection'0 (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = intersection'0 {xs} {ys} (fun (_ret':t_Intersection'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied'0 {_5} (fun (_ret':t_Copied'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {_4} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : t_HashSet'0 = any_l ()
    | & xs : t_HashSet'0 = xs
    | & ys : t_HashSet'0 = ys
    | & _4 : t_Copied'0 = any_l ()
    | & _5 : t_Intersection'0 = any_l () ]
    
    [ return' (result:t_HashSet'0)-> {[@expl:hashset_intersection ensures] [%#scollections0] view'0 result
      = Fset.inter (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
