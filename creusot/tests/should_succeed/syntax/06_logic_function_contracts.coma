
module CreusotContracts_Logic_Seq2_Seq_Type
  use seq.Seq
  
  type t_seq 't =
    | C_Seq (Seq.seq 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_seq < 't > (input:t_seq 't) (ret  (field_0:Seq.seq 't))= any
    [ good (field_0:Seq.seq 't)-> {C_Seq field_0 = input} (! ret {field_0})
    | bad (field_0:Seq.seq 't)-> {C_Seq field_0 <> input} {false} any ]
    
  
  function seq_0 [@inline:trivial] (self : t_seq 't) : Seq.seq 't =
    match self with
      | C_Seq a -> a
      end
end
module C06LogicFunctionContracts_Sum_Impl
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 9 10 9 19
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq22 = "../../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span sseq23 = "../../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span sseq24 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span sseq25 = "../../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span sseq26 = "../../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span sseq27 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span8 = "../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span9 = "../../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span10 = "../../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span11 = "../../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'0 (self : Seq'0.t_seq int) =
    [%#span8] true
  
  predicate inv'0 (_x : Seq'0.t_seq int)
  
  axiom inv'0 : forall x : Seq'0.t_seq int . inv'0 x = true
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . ([%#sseq21] inv'0 self)  -> ([%#sseq22] len'0 self >= 0)
  
  constant empty'0 : Seq'0.t_seq int = [%#span9] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span11] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span10] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  use prelude.seq_ext.SeqExt
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq int) (x : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#sseq23] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq24] inv'0 self)
   -> ([%#sseq27] inv'0 (subsequence'0 self n m))
  && ([%#sseq26] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq25] len'0 (subsequence'0 self n m) = m - n)
  
  constant seq  : Seq'0.t_seq int
  
  function sum [#"../06_logic_function_contracts.rs" 10 0 10 32] (seq : Seq'0.t_seq int) : int
  
  goal vc_sum : ([%#sseq21] inv'0 seq)
  /\ (([%#sseq22] len'0 seq >= 0)
   -> match len'0 seq = 0 with
    | True -> true
    | False -> ([%#sseq21] inv'0 seq)
    /\ (([%#sseq22] len'0 seq >= 0)
     -> ([%#sseq21] inv'0 seq)
    /\ (([%#sseq22] len'0 seq >= 0)
     -> (([%#sseq24] inv'0 seq) && ([%#sseq23] 0 <= 0 /\ 0 <= len'0 seq - 1 /\ len'0 seq - 1 <= len'0 seq))
    /\ (([%#sseq27] inv'0 (subsequence'0 seq 0 (len'0 seq - 1)))
    && ([%#sseq26] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 seq 0 (len'0 seq - 1))
     -> index_logic'0 (subsequence'0 seq 0 (len'0 seq - 1)) i = index_logic'0 seq (0 + i))
    && ([%#sseq25] len'0 (subsequence'0 seq 0 (len'0 seq - 1)) = len'0 seq - 1 - 0)
     -> 0 <= ([%#s06_logic_function_contracts0] len'0 seq)
    /\ ([%#s06_logic_function_contracts0] len'0 (subsequence'0 seq 0 (len'0 seq - 1)))
    < ([%#s06_logic_function_contracts0] len'0 seq))))
    end)
end
module C06LogicFunctionContracts_AllZero_Impl
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 21 10 21 19
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 72 15 72 19
  
  let%span sseq22 = "../../../../../creusot-contracts/src/logic/seq2.rs" 71 14 71 25
  
  let%span sseq23 = "../../../../../creusot-contracts/src/logic/seq2.rs" 47 15 47 50
  
  let%span sseq24 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 23 50 27
  
  let%span sseq25 = "../../../../../creusot-contracts/src/logic/seq2.rs" 48 14 48 35
  
  let%span sseq26 = "../../../../../creusot-contracts/src/logic/seq2.rs" 49 4 49 87
  
  let%span sseq27 = "../../../../../creusot-contracts/src/logic/seq2.rs" 50 4 50 52
  
  let%span span8 = "../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span9 = "../../../../../creusot-contracts/src/logic/seq2.rs" 19 4 19 25
  
  let%span span10 = "../../../../../creusot-contracts/src/logic/seq2.rs" 23 14 23 36
  
  let%span span11 = "../../../../../creusot-contracts/src/logic/seq2.rs" 21 4 21 10
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  predicate invariant'0 (self : Seq'0.t_seq int) =
    [%#span8] true
  
  predicate inv'0 (_x : Seq'0.t_seq int)
  
  axiom inv'0 : forall x : Seq'0.t_seq int . inv'0 x = true
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  use CreusotContracts_Logic_Seq2_Seq_Type as CreusotContracts_Logic_Seq2_Seq_Type
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . ([%#sseq21] inv'0 self)  -> ([%#sseq22] len'0 self >= 0)
  
  constant empty'0 : Seq'0.t_seq int = [%#span9] ()
  
  function empty_len'0 (_1 : ()) : () =
    [%#span11] ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span10] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  use prelude.seq_ext.SeqExt
  
  use seq.Seq
  
  function index_logic'0 (self : Seq'0.t_seq int) (x : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#sseq23] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq24] inv'0 self)
   -> ([%#sseq27] inv'0 (subsequence'0 self n m))
  && ([%#sseq26] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq25] len'0 (subsequence'0 self n m) = m - n)
  
  constant seq  : Seq'0.t_seq int
  
  predicate all_zero [#"../06_logic_function_contracts.rs" 22 0 22 38] (seq : Seq'0.t_seq int)
  
  goal vc_all_zero : ([%#sseq21] inv'0 seq)
  /\ (([%#sseq22] len'0 seq >= 0)
   -> match len'0 seq = 0 with
    | True -> true
    | False -> ([%#sseq21] inv'0 seq)
    /\ (([%#sseq22] len'0 seq >= 0)
     -> (if index_logic'0 seq (len'0 seq - 1) = 0 then
      ([%#sseq21] inv'0 seq)
      /\ (([%#sseq22] len'0 seq >= 0)
       -> (([%#sseq24] inv'0 seq) && ([%#sseq23] 0 <= 0 /\ 0 <= len'0 seq - 1 /\ len'0 seq - 1 <= len'0 seq))
      /\ (([%#sseq27] inv'0 (subsequence'0 seq 0 (len'0 seq - 1)))
      && ([%#sseq26] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 seq 0 (len'0 seq - 1))
       -> index_logic'0 (subsequence'0 seq 0 (len'0 seq - 1)) i = index_logic'0 seq (0 + i))
      && ([%#sseq25] len'0 (subsequence'0 seq 0 (len'0 seq - 1)) = len'0 seq - 1 - 0)
       -> 0 <= ([%#s06_logic_function_contracts0] len'0 seq)
      /\ ([%#s06_logic_function_contracts0] len'0 (subsequence'0 seq 0 (len'0 seq - 1)))
      < ([%#s06_logic_function_contracts0] len'0 seq)))
    else
      true
    ))
    end)
end
module C06LogicFunctionContracts_Stupid_Impl
  type t
  
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 33 10 33 11
  
  use prelude.prelude.Int
  
  constant x  : t
  
  constant i  : int
  
  predicate stupid [#"../06_logic_function_contracts.rs" 34 0 34 38] (x : t) (i : int)
  
  goal vc_stupid : match i <= 0 with
    | True -> true
    | False -> match x = x with
      | True -> 0 <= ([%#s06_logic_function_contracts0] i)
      /\ ([%#s06_logic_function_contracts0] 0) < ([%#s06_logic_function_contracts0] i)
      | False -> true
      end
    end
end
