
module CreusotContracts_Logic_Seq2_Seq_Type
  type t_seq 't
end
module C06LogicFunctionContracts_Sum_Impl
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 9 10 9 19
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 68 14 68 25
  
  let%span sseq22 = "../../../../../creusot-contracts/src/logic/seq2.rs" 42 15 42 50
  
  let%span sseq23 = "../../../../../creusot-contracts/src/logic/seq2.rs" 43 14 43 35
  
  let%span sseq24 = "../../../../../creusot-contracts/src/logic/seq2.rs" 44 4 44 87
  
  let%span span5 = "../../../../../creusot-contracts/src/logic/seq2.rs" 16 14 16 36
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . [%#sseq21] len'0 self >= 0
  
  constant empty'0 : Seq'0.t_seq int
  
  function empty_len'0 (_1 : ()) : ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span5] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  function index_logic'0 (self : Seq'0.t_seq int) (_2 : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#sseq22] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq24] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq23] len'0 (subsequence'0 self n m) = m - n)
  
  constant seq  : Seq'0.t_seq int
  
  function sum [#"../06_logic_function_contracts.rs" 10 0 10 32] (seq : Seq'0.t_seq int) : int
  
  goal vc_sum : ([%#sseq21] len'0 seq >= 0)
   -> match len'0 seq = 0 with
    | True -> true
    | False -> ([%#sseq21] len'0 seq >= 0)
     -> ([%#sseq21] len'0 seq >= 0)
     -> ([%#sseq22] 0 <= 0 /\ 0 <= len'0 seq - 1 /\ len'0 seq - 1 <= len'0 seq)
    /\ (([%#sseq24] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 seq 0 (len'0 seq - 1))
     -> index_logic'0 (subsequence'0 seq 0 (len'0 seq - 1)) i = index_logic'0 seq (0 + i))
    && ([%#sseq23] len'0 (subsequence'0 seq 0 (len'0 seq - 1)) = len'0 seq - 1 - 0)
     -> 0 <= ([%#s06_logic_function_contracts0] len'0 seq)
    /\ ([%#s06_logic_function_contracts0] len'0 (subsequence'0 seq 0 (len'0 seq - 1)))
    < ([%#s06_logic_function_contracts0] len'0 seq))
    end
end
module C06LogicFunctionContracts_AllZero_Impl
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 21 10 21 19
  
  let%span sseq21 = "../../../../../creusot-contracts/src/logic/seq2.rs" 68 14 68 25
  
  let%span sseq22 = "../../../../../creusot-contracts/src/logic/seq2.rs" 42 15 42 50
  
  let%span sseq23 = "../../../../../creusot-contracts/src/logic/seq2.rs" 43 14 43 35
  
  let%span sseq24 = "../../../../../creusot-contracts/src/logic/seq2.rs" 44 4 44 87
  
  let%span span5 = "../../../../../creusot-contracts/src/logic/seq2.rs" 16 14 16 36
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int
  
  use CreusotContracts_Logic_Seq2_Seq_Type as Seq'0
  
  function len'0 (self : Seq'0.t_seq int) : int
  
  axiom len'0_spec : forall self : Seq'0.t_seq int . [%#sseq21] len'0 self >= 0
  
  constant empty'0 : Seq'0.t_seq int
  
  function empty_len'0 (_1 : ()) : ()
  
  axiom empty_len'0_spec : forall _1 : () . [%#span5] len'0 (empty'0 : Seq'0.t_seq int) = 0
  
  function index_logic'0 (self : Seq'0.t_seq int) (_2 : int) : int
  
  function subsequence'0 (self : Seq'0.t_seq int) (n : int) (m : int) : Seq'0.t_seq int
  
  axiom subsequence'0_spec : forall self : Seq'0.t_seq int, n : int, m : int . ([%#sseq22] 0 <= n
  /\ n <= m /\ m <= len'0 self)
   -> ([%#sseq24] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 self n m)
   -> index_logic'0 (subsequence'0 self n m) i = index_logic'0 self (n + i))
  && ([%#sseq23] len'0 (subsequence'0 self n m) = m - n)
  
  constant seq  : Seq'0.t_seq int
  
  predicate all_zero [#"../06_logic_function_contracts.rs" 22 0 22 38] (seq : Seq'0.t_seq int)
  
  goal vc_all_zero : ([%#sseq21] len'0 seq >= 0)
   -> match len'0 seq = 0 with
    | True -> true
    | False -> ([%#sseq21] len'0 seq >= 0)
     -> (if index_logic'0 seq (len'0 seq - 1) = 0 then
      ([%#sseq21] len'0 seq >= 0)
       -> ([%#sseq22] 0 <= 0 /\ 0 <= len'0 seq - 1 /\ len'0 seq - 1 <= len'0 seq)
      /\ (([%#sseq24] forall i : int . 0 <= i /\ i < len'0 (subsequence'0 seq 0 (len'0 seq - 1))
       -> index_logic'0 (subsequence'0 seq 0 (len'0 seq - 1)) i = index_logic'0 seq (0 + i))
      && ([%#sseq23] len'0 (subsequence'0 seq 0 (len'0 seq - 1)) = len'0 seq - 1 - 0)
       -> 0 <= ([%#s06_logic_function_contracts0] len'0 seq)
      /\ ([%#s06_logic_function_contracts0] len'0 (subsequence'0 seq 0 (len'0 seq - 1)))
      < ([%#s06_logic_function_contracts0] len'0 seq))
    else
      true
    )
    end
end
module C06LogicFunctionContracts_Stupid_Impl
  type t
  
  let%span s06_logic_function_contracts0 = "../06_logic_function_contracts.rs" 33 10 33 11
  
  use prelude.prelude.Int
  
  constant x  : t
  
  constant i  : int
  
  predicate stupid [#"../06_logic_function_contracts.rs" 34 0 34 38] (x : t) (i : int)
  
  goal vc_stupid : match i <= 0 with
    | True -> true
    | False -> match x = x with
      | True -> 0 <= ([%#s06_logic_function_contracts0] i)
      /\ ([%#s06_logic_function_contracts0] 0) < ([%#s06_logic_function_contracts0] i)
      | False -> true
      end
    end
end
