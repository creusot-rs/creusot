
module RedBlackTree_Color_Type
  type t_color  =
    | C_Red
    | C_Black
    
  function any_l (_ : 'b) : 'a
  let rec red (input:t_color) (ret  )= any [ good -> {C_Red  = input} (! ret) | bad -> {C_Red  <> input} {false} any ] 
  let rec black (input:t_color) (ret  )= any
    [ good -> {C_Black  = input} (! ret) | bad -> {C_Black  <> input} {false} any ]
    
end
module RedBlackTree_Impl16_Clone
  use prelude.Borrow
  use prelude.Intrinsic
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  let rec clone' (self:RedBlackTree_Color_Type.t_color) (return'  (ret:RedBlackTree_Color_Type.t_color))= (! bb0
    [ bb0 = s0
      [ s0 = any
        [ br0 -> {self = RedBlackTree_Color_Type.C_Red } (! bb2)
        | br1 -> {self = RedBlackTree_Color_Type.C_Black } (! bb3) ]
         ]
      
    | bb1 = s0 [ s0 = {[#"../red_black_tree.rs" 8 9 8 14] false} any ] 
    | bb3 = s0 [ s0 =  [ &_0 <- RedBlackTree_Color_Type.C_Black ] s1 | s1 = bb5 ] 
    | bb2 = s0 [ s0 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- RedBlackTree_Color_Type.C_Red ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & self : RedBlackTree_Color_Type.t_color = self ]
    
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {[@expl:postcondition] [#"../red_black_tree.rs" 8 9 8 14] result
      = self}
      (! return' {result}) ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  function any_l (_ : 'b) : 'a
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  type t_node 'k 'v =
    | C_Node (t_tree 'k 'v) (RedBlackTree_Color_Type.t_color) 'k 'v (t_tree 'k 'v)
    with t_tree 'k 'v =
    | C_Tree (Core_Option_Option_Type.t_option (t_node 'k 'v))
    
  function any_l (_ : 'b) : 'a
  let rec t_node < 'k > < 'v > (input:t_node 'k 'v) (ret  (left:t_tree 'k 'v) (color:RedBlackTree_Color_Type.t_color) (key:'k) (val':'v) (right:t_tree 'k 'v))= any
    [ good (left:t_tree 'k 'v) (color:RedBlackTree_Color_Type.t_color) (key:'k) (val':'v) (right:t_tree 'k 'v)-> {C_Node left color key val' right
      = input}
      (! ret {left} {color} {key} {val'} {right})
    | bad (left:t_tree 'k 'v) (color:RedBlackTree_Color_Type.t_color) (key:'k) (val':'v) (right:t_tree 'k 'v)-> {C_Node left color key val' right
      <> input}
      {false}
      any ]
    
  let rec t_tree < 'k > < 'v > (input:t_tree 'k 'v) (ret  (node:Core_Option_Option_Type.t_option (t_node 'k 'v)))= any
    [ good (node:Core_Option_Option_Type.t_option (t_node 'k 'v))-> {C_Tree node = input} (! ret {node})
    | bad (node:Core_Option_Option_Type.t_option (t_node 'k 'v))-> {C_Tree node <> input} {false} any ]
    
  function node_left (self : t_node 'k 'v) : t_tree 'k 'v =
    match self with
      | C_Node a _ _ _ _ -> a
      end
  function node_key (self : t_node 'k 'v) : 'k =
    match self with
      | C_Node _ _ a _ _ -> a
      end
  function node_right (self : t_node 'k 'v) : t_tree 'k 'v =
    match self with
      | C_Node _ _ _ _ a -> a
      end
  function node_val (self : t_node 'k 'v) : 'v =
    match self with
      | C_Node _ _ _ a _ -> a
      end
  function node_color (self : t_node 'k 'v) : RedBlackTree_Color_Type.t_color =
    match self with
      | C_Node _ a _ _ _ -> a
      end
  function tree_node (self : t_tree 'k 'v) : Core_Option_Option_Type.t_option (t_node 'k 'v) =
    match self with
      | C_Tree a -> a
      end
end
module RedBlackTree_Tree_Type
  use export RedBlackTree_Node_Type
end
module RedBlackTree_Impl0_ModelAccHasMapping_Impl
  type k
  type v
  predicate invariant'3 (self : v)
  let rec invariant'3 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : v)
  let rec inv'3 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ] 
  axiom inv'3 : forall x : v . inv'3 x = true
  type eq_model_ty'0
  predicate invariant'2 (self : eq_model_ty'0)
  let rec invariant'2 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : eq_model_ty'0)
  let rec inv'2 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : eq_model_ty'0 . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  predicate invariant'1 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'1 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'1 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'1 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use map.Map
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  constant self  : RedBlackTree_Tree_Type.t_tree k v
  constant accu  : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
  constant k  : eq_model_ty'0
  function model_acc_has_mapping [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
  goal vc_model_acc_has_mapping : ([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'1 accu)
   -> ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self)
   -> match self with
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> [#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k
    = Map.get accu k
    \/ (exists v : v . inv'3 v
    /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v)
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> (([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
    && ([#"../red_black_tree.rs" 65 35 65 39] inv'1 accu) && ([#"../red_black_tree.rs" 65 29 65 33] inv'0 left))
    /\ (([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 left accu) k = Map.get accu k
    \/ (exists v : v . inv'3 v
    /\ Map.get (model_acc'0 left accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 left k v))
     -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in (([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
    && ([#"../red_black_tree.rs" 65 35 65 39] inv'1 accu2) && ([#"../red_black_tree.rs" 65 29 65 33] inv'0 right))
    /\ (([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 right accu2) k = Map.get accu2 k
    \/ (exists v : v . inv'3 v
    /\ Map.get (model_acc'0 right accu2) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 right k v))
     -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : v . inv'3 v
    /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v)))))
    end
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
  function any_l (_ : 'b) : 'a
  let rec less (input:t_ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} {false} any ]
    
  let rec equal (input:t_ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} {false} any ]
    
  let rec greater (input:t_ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} {false} any ]
    
end
module RedBlackTree_Impl0_HasMappingModelAcc_Impl
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'2 (_x : eq_model_ty'0)
  let rec inv'2 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'3 (self : v)
  let rec invariant'3 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : v)
  let rec inv'3 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ] 
  axiom inv'3 : forall x : v . inv'3 x = true
  predicate invariant'2 (self : eq_model_ty'0)
  let rec invariant'2 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : eq_model_ty'0 . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  predicate invariant'1 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'1 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'1 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'1 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use map.Map
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'2 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'1 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'0 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'1 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'3 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'3 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'3 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  constant self  : RedBlackTree_Tree_Type.t_tree k v
  constant accu  : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
  constant k  : eq_model_ty'0
  function has_mapping_model_acc [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
  goal vc_has_mapping_model_acc : ([#"../red_black_tree.rs" 82 65 82 66] inv'2 k)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'1 accu)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> match self with
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> [#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'3 v
     -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> (([#"../red_black_tree.rs" 82 65 82 66] inv'2 k)
    && ([#"../red_black_tree.rs" 82 35 82 39] inv'1 accu)
    && ([#"../red_black_tree.rs" 82 29 82 33] inv'0 left)
    && ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 left))
    /\ (([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'3 v
     -> has_mapping'0 left k v  -> Map.get (model_acc'0 left accu) k = Core_Option_Option_Type.C_Some v)
     -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in (([#"../red_black_tree.rs" 82 65 82 66] inv'2 k)
    && ([#"../red_black_tree.rs" 82 35 82 39] inv'1 accu2)
    && ([#"../red_black_tree.rs" 82 29 82 33] inv'0 right)
    && ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 right))
    /\ (([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'3 v
     -> has_mapping'0 right k v  -> Map.get (model_acc'0 right accu2) k = Core_Option_Option_Type.C_Some v)
     -> (let _ = has_mapping_model_acc right accu2 k in (([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
    && ([#"../red_black_tree.rs" 65 35 65 39] inv'1 accu2) && ([#"../red_black_tree.rs" 65 29 65 33] inv'0 right))
    /\ (([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 right accu2) k = Map.get accu2 k
    \/ (exists v : v . inv'3 v
    /\ Map.get (model_acc'0 right accu2) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 right k v))
     -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'3 v
     -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v))))))
    end
end
module RedBlackTree_Impl0_HasMappingModel_Impl
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'1 (_x : eq_model_ty'0)
  let rec inv'1 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'1 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'1 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'1 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'1 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  predicate invariant'3 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'3 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'3 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'3 x = true
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : v)
  let rec inv'2 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : v . inv'2 x = true
  predicate invariant'1 (self : eq_model_ty'0)
  let rec invariant'1 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  axiom inv'1 : forall x : eq_model_ty'0 . inv'1 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use map.Map
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'1 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'3 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'0 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'3 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'1 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'2 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'2 v
     -> inv'1 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'2 v
     -> inv'1 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'1 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'3 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'0 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'3 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'1 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'2 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  use map.Const
  function view'0 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  constant self  : RedBlackTree_Tree_Type.t_tree k v
  constant k  : eq_model_ty'0
  function has_mapping_model [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
  goal vc_has_mapping_model : ([#"../red_black_tree.rs" 103 31 103 32] inv'1 k)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'0 self)
   -> ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> (([#"../red_black_tree.rs" 65 65 65 66] inv'1 k)
  && ([#"../red_black_tree.rs" 65 35 65 39] inv'3 (Const.const (Core_Option_Option_Type.C_None)))
  && ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self))
  /\ (([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))) k
  = Map.get (Const.const (Core_Option_Option_Type.C_None)) k
  \/ (exists v : v . inv'2 v
  /\ Map.get (model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))) k = Core_Option_Option_Type.C_Some v
  /\ has_mapping'0 self k v))
   -> (let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in (([#"../red_black_tree.rs" 82 65 82 66] inv'1 k)
  && ([#"../red_black_tree.rs" 82 35 82 39] inv'3 (Const.const (Core_Option_Option_Type.C_None)))
  && ([#"../red_black_tree.rs" 82 29 82 33] inv'0 self) && ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self))
  /\ (([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'2 v
   -> has_mapping'0 self k v
   -> Map.get (model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))) k = Core_Option_Option_Type.C_Some v)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'2 v
   -> has_mapping'0 self k v = (Map.get (view'0 self) k = Core_Option_Option_Type.C_Some v)))))
end
module RedBlackTree_Impl0_HasMappingInj_Impl
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'3 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'3 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'3 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'3 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'1 (_x : eq_model_ty'0)
  let rec inv'1 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'1 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'1 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'1 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'1 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'1 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'1 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'1 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'1 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'1 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : v)
  let rec inv'2 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : v . inv'2 x = true
  predicate invariant'1 (self : eq_model_ty'0)
  let rec invariant'1 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  axiom inv'1 : forall x : eq_model_ty'0 . inv'1 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'0 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'1 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'3 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'0 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'3 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'1 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'2 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'2 v
     -> inv'1 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'2 v
     -> inv'1 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'1 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'3 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'0 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'3 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'1 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'2 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'1 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'0 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'0 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'1 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'2 v
   -> has_mapping'0 self k v = (Map.get (view'0 self) k = Core_Option_Option_Type.C_Some v))
  constant self  : RedBlackTree_Tree_Type.t_tree k v
  constant k  : eq_model_ty'0
  constant v1  : v
  constant v2  : v
  function has_mapping_inj [#"../red_black_tree.rs" 118 4 120 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v1 : v) (v2 : v) : ()
    
  goal vc_has_mapping_inj : ([#"../red_black_tree.rs" 118 53 118 55] inv'2 v2)
   -> ([#"../red_black_tree.rs" 118 46 118 48] inv'2 v1)
   -> ([#"../red_black_tree.rs" 118 29 118 30] inv'1 k)
   -> ([#"../red_black_tree.rs" 118 23 118 27] inv'0 self)
   -> ([#"../red_black_tree.rs" 116 15 116 38] has_mapping'0 self k v2)
   -> ([#"../red_black_tree.rs" 115 15 115 38] has_mapping'0 self k v1)
   -> ([#"../red_black_tree.rs" 114 15 114 35] bst_invariant'0 self)
   -> (([#"../red_black_tree.rs" 103 31 103 32] inv'1 k)
  && ([#"../red_black_tree.rs" 103 25 103 29] inv'0 self)
  && ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self))
  /\ (([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'2 v
   -> has_mapping'0 self k v = (Map.get (view'0 self) k = Core_Option_Option_Type.C_Some v))
   -> (let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
    | Core_Option_Option_Type.C_None -> [#"../red_black_tree.rs" 117 14 117 22] v1 = v2
    | Core_Option_Option_Type.C_Some _v -> [#"../red_black_tree.rs" 117 14 117 22] v1 = v2
    end))
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
  function any_l (_ : 'b) : 'a
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
  function any_l (_ : 'b) : 'a
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
  function any_l (_ : 'b) : 'a
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't))= any
    [ good (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
  function any_l (_ : 'b) : 'a
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
  function any_l (_ : 'b) : 'a
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module RedBlackTree_Impl1_HasMapping_Impl
  type k
  type v
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'3 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'3 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : v)
  let rec inv'2 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : v . inv'2 x = true
  type eq_model_ty'0
  predicate invariant'1 (self : eq_model_ty'0)
  let rec invariant'1 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : eq_model_ty'0)
  let rec inv'1 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : eq_model_ty'0 . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'0 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Node_Type.t_node k v . inv'0 x = true
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  constant self  : RedBlackTree_Node_Type.t_node k v
  constant k  : eq_model_ty'0
  constant v  : v
  predicate has_mapping [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
  goal vc_has_mapping : ([#"../red_black_tree.rs" 133 42 133 43] inv'2 v)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'1 k)
   -> ([#"../red_black_tree.rs" 133 19 133 23] inv'0 self)
   -> (if k = eq_model'0 (RedBlackTree_Node_Type.node_key self) then
    [#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
     -> self = node
     -> ((has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v)
    \/ v = RedBlackTree_Node_Type.node_val self)
    = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v
  else
    [#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
     -> self = node
     -> ((has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v)
    \/ false)
    = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v
  )
end
module RedBlackTree_Cp_Type
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  type t_cp  =
    | C_CPL (RedBlackTree_Color_Type.t_color)
    | C_CPN (RedBlackTree_Color_Type.t_color) (t_cp) (t_cp)
    
  function any_l (_ : 'b) : 'a
  let rec cpl (input:t_cp) (ret  (field_0:RedBlackTree_Color_Type.t_color))= any
    [ good (field_0:RedBlackTree_Color_Type.t_color)-> {C_CPL field_0 = input} (! ret {field_0})
    | bad (field_0:RedBlackTree_Color_Type.t_color)-> {C_CPL field_0 <> input} {false} any ]
    
  let rec cpn (input:t_cp) (ret  (field_0:RedBlackTree_Color_Type.t_color) (field_1:t_cp) (field_2:t_cp))= any
    [ good (field_0:RedBlackTree_Color_Type.t_color) (field_1:t_cp) (field_2:t_cp)-> {C_CPN field_0 field_1 field_2
      = input}
      (! ret {field_0} {field_1} {field_2})
    | bad (field_0:RedBlackTree_Color_Type.t_color) (field_1:t_cp) (field_2:t_cp)-> {C_CPN field_0 field_1 field_2
      <> input}
      {false}
      any ]
    
end
module RedBlackTree_Impl9_Height_Impl
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use prelude.Int
  constant self  : RedBlackTree_Tree_Type.t_tree k v
  function height [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int
  goal vc_height : ([#"../red_black_tree.rs" 289 14 289 18] inv'0 self)
   -> match self with
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> [#"../red_black_tree.rs" 288 14 288 25] 0 >= 0
    | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
      | RedBlackTree_Color_Type.C_Red -> ([#"../red_black_tree.rs" 289 14 289 18] inv'0 left)
      /\ (([#"../red_black_tree.rs" 288 14 288 25] height left >= 0)
       -> ([#"../red_black_tree.rs" 288 14 288 25] height left >= 0))
      | RedBlackTree_Color_Type.C_Black -> ([#"../red_black_tree.rs" 289 14 289 18] inv'0 left)
      /\ (([#"../red_black_tree.rs" 288 14 288 25] height left >= 0)
       -> ([#"../red_black_tree.rs" 288 14 288 25] height left + 1 >= 0))
      end
    end
end
module RedBlackTree_Impl10_Height_Impl
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'2 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'2 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'2 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'2 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'1 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'1 : forall x : RedBlackTree_Node_Type.t_node k v . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'0 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Node_Type.t_node k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'2 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'2 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  constant self  : RedBlackTree_Node_Type.t_node k v
  function height [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int
  goal vc_height : ([#"../red_black_tree.rs" 321 14 321 18] inv'0 self)
   -> match RedBlackTree_Node_Type.node_color self with
    | RedBlackTree_Color_Type.C_Red -> ([#"../red_black_tree.rs" 289 14 289 18] inv'2 (RedBlackTree_Node_Type.node_left self))
    /\ (([#"../red_black_tree.rs" 288 14 288 25] height'0 (RedBlackTree_Node_Type.node_left self) >= 0)
     -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
     -> self = node
     -> height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node))))
    | RedBlackTree_Color_Type.C_Black -> ([#"../red_black_tree.rs" 289 14 289 18] inv'2 (RedBlackTree_Node_Type.node_left self))
    /\ (([#"../red_black_tree.rs" 288 14 288 25] height'0 (RedBlackTree_Node_Type.node_left self) >= 0)
     -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
     -> self = node
     -> height'0 (RedBlackTree_Node_Type.node_left self) + 1
    = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node))))
    end
end
module RedBlackTree_Impl13_IsRed
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  use prelude.Borrow
  use prelude.Intrinsic
  predicate resolve'0 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec resolve'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec is_red (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[#"../red_black_tree.rs" 381 15 381 19] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> {self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            any
            [ br0 -> {rnode'0 = Core_Option_Option_Type.C_None } (! bb6)
            | br1 (a:RedBlackTree_Node_Type.t_node k v)-> {rnode'0 = Core_Option_Option_Type.C_Some a} (! bb2) ]
            ) ]
      
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb1 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = RedBlackTree_Tree_Type.t_tree <k> <v> {self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> {rnode'0}
              (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
                RedBlackTree_Node_Type.t_node <k> <v> {r0'0}
                  (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    any
                    [ br0 -> {rcolor'0 = RedBlackTree_Color_Type.C_Red } (! bb3)
                    | br1 -> {rcolor'0 = RedBlackTree_Color_Type.C_Black } (! bb1) ]
                    ))) ]
      
    | bb1 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 384 17 384 22] false ] s1 | s1 = bb5 ] 
    | bb3 = s0 [ s0 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 383 49 383 53] true ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = return' {_0} ]  ]
    ) [ & _0 : bool = any_l () : bool | & self : RedBlackTree_Tree_Type.t_tree k v = self ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_RotateRight
  type k
  type v
  type eq_model_ty'0
  predicate invariant'11 (self : eq_model_ty'0)
  let rec invariant'11 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : eq_model_ty'0)
  let rec inv'11 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : eq_model_ty'0 . inv'11 x = true
  predicate invariant'10 (self : v)
  let rec invariant'10 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : v)
  let rec inv'10 (_x:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : v . inv'10 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use prelude.Borrow
  predicate invariant'9 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'9 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : borrowed (RedBlackTree_Color_Type.t_color))
  let rec inv'9 (_x:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : borrowed (RedBlackTree_Color_Type.t_color) . inv'9 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'11 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'11 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'11 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'11 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'8 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'8 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'8 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'8 x = true
  predicate invariant'7 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'7 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'7 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'7 x = true
  predicate invariant'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'6 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'6 : forall x : RedBlackTree_Node_Type.t_node k v . inv'6 x = true
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'5 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : RedBlackTree_Node_Type.t_node k v . inv'5 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'4 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'4 x = true
  predicate invariant'3 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'3 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'3 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'3 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'2 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'2 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'2 x
  = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  use prelude.Snapshot
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'0 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'0 x = true
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'3 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'3 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'5 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'5 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'10 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'11 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'5 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'5 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'11 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'10 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'6 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'6 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec resolve'5 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  use prelude.Snapshot
  predicate resolve'4 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  let rec swap'2 (x:borrowed (RedBlackTree_Color_Type.t_color)) (y:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:()))= {[@expl:precondition] inv'9 y}
    {[@expl:precondition] inv'9 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  let rec swap'1 (x:borrowed (RedBlackTree_Node_Type.t_node k v)) (y:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] inv'8 y}
    {[@expl:precondition] inv'8 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  let rec swap'0 (x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (y:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:()))= {[@expl:precondition] inv'4 y}
    {[@expl:precondition] inv'4 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'6 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate is_default'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/std/option.rs" 146 20 146 32] self = Core_Option_Option_Type.C_None
  let rec is_default'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec take'0 (dest:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'2 dest}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42] is_default'0 ( ^ dest)}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37] result =  * dest}
      (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec resolve'0 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  let rec rotate_right (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[#"../red_black_tree.rs" 405 25 405 29] inv'8 self}
    {[#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[#"../red_black_tree.rs" 393 15 393 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [#"../red_black_tree.rs" 406 23 406 41] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_16 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_left'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node (RedBlackTree_Tree_Type.C_Tree ( ^ _16) : RedBlackTree_Tree_Type.t_tree k v) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s3)))))
      | s3 = -{inv'1 ( ^ _16)}- s4
      | s4 = Borrow.borrow_final
          <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
          { * _16}
          {Borrow.get_id _16}
          (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_15 <- _ret' ] 
             [ &_16 <- { _16 with current = ( ^ _15) ; } ] 
            s5)
      | s5 = -{inv'1 ( ^ _15)}- s6
      | s6 = take'0 {_15}
          (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->  [ &_14 <- _ret' ] s7)
      | s7 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'2 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_19 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * self}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node ( ^ _19) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'3 ( ^ _19)}- s2
      | s2 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _19} {Borrow.get_id _19}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_18 <- _ret' ] 
             [ &_19 <- { _19 with current = ( ^ _18) ; } ] 
            s3)
      | s3 = -{inv'3 ( ^ _18)}- s4
      | s4 = RedBlackTree_Node_Type.t_node <k> <v> {x}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'1}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_21 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> {x}
                  (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &x <- RedBlackTree_Node_Type.C_Node l_left'1 l_color'1 l_key'1 l_val'1 ( ^ _21) : RedBlackTree_Node_Type.t_node k v ]
                    
                    s5)))
      | s5 = -{inv'3 ( ^ _21)}- s6
      | s6 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _21} {Borrow.get_id _21}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_20 <- _ret' ] 
             [ &_21 <- { _21 with current = ( ^ _20) ; } ] 
            s7)
      | s7 = -{inv'3 ( ^ _20)}- s8
      | s8 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s9)
      | s9 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 _21} s1
      | s1 = -{resolve'2 _21}- s2
      | s2 = {[@expl:type invariant] inv'4 _19} s3
      | s3 = -{resolve'2 _19}- s4
      | s4 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_23 <- _ret' ] 
             [ &self <- { self with current = ( ^ _23) ; } ] 
            s5)
      | s5 = -{inv'5 ( ^ _23)}- s6
      | s6 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> {x}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_25 <- _ret' ]  [ &x <-  ^ _25 ] s7)
      | s7 = -{inv'6 ( ^ _25)}- s8
      | s8 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * _25}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_24 <- _ret' ] 
             [ &_25 <- { _25 with current = ( ^ _24) ; } ] 
            s9)
      | s9 = -{inv'5 ( ^ _24)}- s10
      | s10 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s11)
      | s11 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'7 _25} s1
      | s1 = -{resolve'3 _25}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_final <RedBlackTree_Color_Type.t_color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_28 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * self}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 ( ^ _28) l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s3)))
      | s3 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _28} {Borrow.get_id _28}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = ( ^ _27) ; } ] 
            s4)
      | s4 = RedBlackTree_Node_Type.t_node <k> <v> {x}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Color_Type.t_color> {rcolor'1}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_30 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> {x}
                  (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &x <- RedBlackTree_Node_Type.C_Node l_left'1 ( ^ _30) l_key'1 l_val'1 l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                    
                    s5)))
      | s5 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _30} {Borrow.get_id _30}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = ( ^ _29) ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'4 _30}- s1
      | s1 = -{resolve'4 _28}- s2
      | s2 = {[@expl:assertion] [#"../red_black_tree.rs" 434 8 434 88] has_mapping'0 (RedBlackTree_Node_Type.node_left ( * Snapshot.inner old_self)) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) (RedBlackTree_Node_Type.node_val ( * self))}
        s3
      | s3 = 
        [ &_34 <- Core_Option_Option_Type.C_Some x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        (any [ any_ (_any:RedBlackTree_Node_Type.t_node k v)-> (!  [ &x <- _any ] s4) ] )
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_33 <- RedBlackTree_Tree_Type.C_Tree _34 : RedBlackTree_Tree_Type.t_tree k v ] 
        (any
        [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_34 <- _any ] s1) ]
        )
      | s1 = bb8 ]
      
    | bb8 = s0 [ s0 = bb9 ] 
    | bb9 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 _33 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Tree_Type.t_tree k v)-> (!  [ &_33 <- _any ] s1) ] ))
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            {[@expl:type invariant] inv'3 rright'0}
            s2)
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            -{resolve'5 rright'1}-
            s3)
      | s3 = {[@expl:type invariant] inv'8 self} s4
      | s4 = -{resolve'6 self}- s5
      | s5 = bb11 ]
      
    | bb11 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 405 31 441 5] () ] s1 | s1 = bb12 ] 
    | bb12 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & x : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _14 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _15 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _16 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _17 : () = any_l () : ()
    | & _18 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _19 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _20 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _21 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _22 : () = any_l () : ()
    | & _23 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _24 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _25 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _26 : () = any_l () : ()
    | & _27 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _28 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _29 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _30 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _33 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _34 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'6 r
      /\ inv'6 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[@expl:postcondition] [#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[@expl:postcondition] [#"../red_black_tree.rs" 397 14 397 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 396 14 396 42] internal_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_RotateLeft
  type k
  type v
  type eq_model_ty'0
  predicate invariant'11 (self : eq_model_ty'0)
  let rec invariant'11 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : eq_model_ty'0)
  let rec inv'11 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : eq_model_ty'0 . inv'11 x = true
  predicate invariant'10 (self : v)
  let rec invariant'10 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : v)
  let rec inv'10 (_x:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : v . inv'10 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use prelude.Borrow
  predicate invariant'9 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'9 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : borrowed (RedBlackTree_Color_Type.t_color))
  let rec inv'9 (_x:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : borrowed (RedBlackTree_Color_Type.t_color) . inv'9 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'11 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'11 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'11 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'11 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'11 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'11 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'11 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'11 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'11 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'8 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'8 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'8 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'8 x = true
  predicate invariant'7 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'7 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'7 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'7 x = true
  predicate invariant'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'6 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'6 : forall x : RedBlackTree_Node_Type.t_node k v . inv'6 x = true
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'5 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : RedBlackTree_Node_Type.t_node k v . inv'5 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'4 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'4 x = true
  predicate invariant'3 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'3 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'3 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'3 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'2 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'2 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'2 x
  = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  use prelude.Snapshot
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'0 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'0 x = true
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'3 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'3 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'5 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'5 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'10 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'11 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'5 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'5 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'11 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'10 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'11 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'6 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'6 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec resolve'5 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  use prelude.Snapshot
  predicate resolve'4 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  let rec swap'2 (x:borrowed (RedBlackTree_Color_Type.t_color)) (y:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:()))= {[@expl:precondition] inv'9 y}
    {[@expl:precondition] inv'9 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  let rec swap'1 (x:borrowed (RedBlackTree_Node_Type.t_node k v)) (y:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] inv'8 y}
    {[@expl:precondition] inv'8 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  let rec swap'0 (x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (y:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:()))= {[@expl:precondition] inv'4 y}
    {[@expl:precondition] inv'4 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'6 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate is_default'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/std/option.rs" 146 20 146 32] self = Core_Option_Option_Type.C_None
  let rec is_default'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec take'0 (dest:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'2 dest}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42] is_default'0 ( ^ dest)}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37] result =  * dest}
      (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec resolve'0 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  let rec rotate_left (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[#"../red_black_tree.rs" 455 24 455 28] inv'8 self}
    {[#"../red_black_tree.rs" 444 15 444 43] color'0 (RedBlackTree_Node_Type.node_right ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[#"../red_black_tree.rs" 443 15 443 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [#"../red_black_tree.rs" 456 23 456 41] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_16 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_right'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 (RedBlackTree_Tree_Type.C_Tree ( ^ _16) : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s3)))))
      | s3 = -{inv'1 ( ^ _16)}- s4
      | s4 = Borrow.borrow_final
          <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
          { * _16}
          {Borrow.get_id _16}
          (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_15 <- _ret' ] 
             [ &_16 <- { _16 with current = ( ^ _15) ; } ] 
            s5)
      | s5 = -{inv'1 ( ^ _15)}- s6
      | s6 = take'0 {_15}
          (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->  [ &_14 <- _ret' ] s7)
      | s7 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'2 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_19 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * self}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _19) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'3 ( ^ _19)}- s2
      | s2 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _19} {Borrow.get_id _19}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_18 <- _ret' ] 
             [ &_19 <- { _19 with current = ( ^ _18) ; } ] 
            s3)
      | s3 = -{inv'3 ( ^ _18)}- s4
      | s4 = RedBlackTree_Node_Type.t_node <k> <v> {x}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'1}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_21 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> {x}
                  (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &x <- RedBlackTree_Node_Type.C_Node ( ^ _21) l_color'1 l_key'1 l_val'1 l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                    
                    s5)))
      | s5 = -{inv'3 ( ^ _21)}- s6
      | s6 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _21} {Borrow.get_id _21}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_20 <- _ret' ] 
             [ &_21 <- { _21 with current = ( ^ _20) ; } ] 
            s7)
      | s7 = -{inv'3 ( ^ _20)}- s8
      | s8 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s9)
      | s9 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 _21} s1
      | s1 = -{resolve'2 _21}- s2
      | s2 = {[@expl:type invariant] inv'4 _19} s3
      | s3 = -{resolve'2 _19}- s4
      | s4 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_23 <- _ret' ] 
             [ &self <- { self with current = ( ^ _23) ; } ] 
            s5)
      | s5 = -{inv'5 ( ^ _23)}- s6
      | s6 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> {x}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_25 <- _ret' ]  [ &x <-  ^ _25 ] s7)
      | s7 = -{inv'6 ( ^ _25)}- s8
      | s8 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * _25}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_24 <- _ret' ] 
             [ &_25 <- { _25 with current = ( ^ _24) ; } ] 
            s9)
      | s9 = -{inv'5 ( ^ _24)}- s10
      | s10 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s11)
      | s11 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'7 _25} s1
      | s1 = -{resolve'3 _25}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_final <RedBlackTree_Color_Type.t_color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_28 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * self}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 ( ^ _28) l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s3)))
      | s3 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _28} {Borrow.get_id _28}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = ( ^ _27) ; } ] 
            s4)
      | s4 = RedBlackTree_Node_Type.t_node <k> <v> {x}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Color_Type.t_color> {rcolor'1}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_30 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> {x}
                  (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &x <- RedBlackTree_Node_Type.C_Node l_left'1 ( ^ _30) l_key'1 l_val'1 l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                    
                    s5)))
      | s5 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _30} {Borrow.get_id _30}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = ( ^ _29) ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'4 _30}- s1
      | s1 = -{resolve'4 _28}- s2
      | s2 = {[@expl:assertion] [#"../red_black_tree.rs" 461 8 461 89] has_mapping'0 (RedBlackTree_Node_Type.node_right ( * Snapshot.inner old_self)) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) (RedBlackTree_Node_Type.node_val ( * self))}
        s3
      | s3 = 
        [ &_34 <- Core_Option_Option_Type.C_Some x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        (any [ any_ (_any:RedBlackTree_Node_Type.t_node k v)-> (!  [ &x <- _any ] s4) ] )
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 =  [ &_33 <- RedBlackTree_Tree_Type.C_Tree _34 : RedBlackTree_Tree_Type.t_tree k v ] 
        (any
        [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_34 <- _any ] s1) ]
        )
      | s1 = bb8 ]
      
    | bb8 = s0 [ s0 = bb9 ] 
    | bb9 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node _33 l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Tree_Type.t_tree k v)-> (!  [ &_33 <- _any ] s1) ] ))
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            {[@expl:type invariant] inv'3 rleft'0}
            s2)
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            -{resolve'5 rleft'1}-
            s3)
      | s3 = {[@expl:type invariant] inv'8 self} s4
      | s4 = -{resolve'6 self}- s5
      | s5 = bb11 ]
      
    | bb11 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 455 30 463 5] () ] s1 | s1 = bb12 ] 
    | bb12 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Snapshot.snap_ty (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & x : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _14 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _15 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _16 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _17 : () = any_l () : ()
    | & _18 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _19 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _20 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _21 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _22 : () = any_l () : ()
    | & _23 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _24 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _25 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _26 : () = any_l () : ()
    | & _27 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _28 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _29 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _30 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _33 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _34 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 451 4 454 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'6 r
      /\ inv'6 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l
      /\ (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( ^ self))
      = (RedBlackTree_Node_Type.node_left ( * self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      /\ RedBlackTree_Node_Type.node_key l = RedBlackTree_Node_Type.node_key ( * self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 450 14 450 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 449 14 449 41] color'0 (RedBlackTree_Node_Type.node_left ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[@expl:postcondition] [#"../red_black_tree.rs" 448 14 448 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self)))}
      {[@expl:postcondition] [#"../red_black_tree.rs" 447 14 447 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 446 14 446 42] internal_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 445 14 445 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_FlipColors
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'9 (_x : eq_model_ty'0)
  let rec inv'9 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'9 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'9 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'9 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'9 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'9 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'9 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'9 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'9 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'9 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'9 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'9 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'9 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'9 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'9 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'10 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'10 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'10 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'10 x = true
  predicate invariant'9 (self : eq_model_ty'0)
  let rec invariant'9 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  axiom inv'9 : forall x : eq_model_ty'0 . inv'9 x = true
  predicate invariant'8 (self : v)
  let rec invariant'8 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : v)
  let rec inv'8 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ] 
  axiom inv'8 : forall x : v . inv'8 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'7 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'7 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'7 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : RedBlackTree_Node_Type.t_node k v . inv'7 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use prelude.Borrow
  predicate invariant'6 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'6 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : borrowed (RedBlackTree_Color_Type.t_color))
  let rec inv'6 (_x:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : borrowed (RedBlackTree_Color_Type.t_color) . inv'6 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'5 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'5 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'5 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'5 x
  = true
  predicate invariant'4 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'4 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'4 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'4 x
  = true
  predicate invariant'3 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'3 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'1 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'0 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'8 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'9 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'7 self}
    any [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ] 
  axiom has_mapping'0_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'7 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'9 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'8 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
   -> self = node
   -> has_mapping'0 self k v = has_mapping'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'8 v
     -> inv'9 k  -> has_mapping'0 self k v = has_mapping'0 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'10 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'10 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'7 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'7 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'8 v
     -> inv'9 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'8 v
     -> inv'9 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (RedBlackTree_Color_Type.t_color)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  let rec swap'0 (x:borrowed (RedBlackTree_Color_Type.t_color)) (y:borrowed (RedBlackTree_Color_Type.t_color)) (return'  (ret:()))= {[@expl:precondition] inv'6 y}
    {[@expl:precondition] inv'6 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'5 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'5 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'1 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec flip_colors (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[#"../red_black_tree.rs" 479 24 479 28] inv'2 self}
    {[#"../red_black_tree.rs" 468 15 468 60] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = color'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[#"../red_black_tree.rs" 467 15 467 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    {[#"../red_black_tree.rs" 466 15 466 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    {[#"../red_black_tree.rs" 465 15 465 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_final
                  <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_15 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_left'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node (RedBlackTree_Tree_Type.C_Tree ( ^ _15) : RedBlackTree_Tree_Type.t_tree k v) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s1)))))
      | s1 = -{inv'0 ( ^ _15)}- s2
      | s2 = as_mut'0 {_15}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_14 <- _ret' ] 
            s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Node_Type.t_node <k> <v> { * _13}
              (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                
                [ &_13 <- { _13 with current = (RedBlackTree_Node_Type.C_Node l_left'0 rcolor'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                
                s1))
      | s1 = {[@expl:type invariant] inv'1 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_final <RedBlackTree_Color_Type.t_color> {rcolor'1} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_18 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * self}
                  (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'1 ( ^ _18) l_key'1 l_val'1 l_right'1 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s4)))
      | s4 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _18} {Borrow.get_id _18}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_17 <- _ret' ] 
             [ &_18 <- { _18 with current = ( ^ _17) ; } ] 
            s5)
      | s5 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'2:RedBlackTree_Tree_Type.t_tree k v) (rcolor'2:RedBlackTree_Color_Type.t_color) (rkey'2:k) (rval'2:v) (rright'2:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'2}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_final
                  <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_23 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'2:RedBlackTree_Tree_Type.t_tree k v) (l_color'2:RedBlackTree_Color_Type.t_color) (l_key'2:k) (l_val'2:v) (l_right'2:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_right'2}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'2 l_color'2 l_key'2 l_val'2 (RedBlackTree_Tree_Type.C_Tree ( ^ _23) : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s6)))))
      | s6 = -{inv'0 ( ^ _23)}- s7
      | s7 = as_mut'0 {_23}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_22 <- _ret' ] 
            s8)
      | s8 = bb3 ]
      
    | bb3 = s0
      [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _21}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Color_Type.t_color> {rcolor'0}
              (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
                 [ &_20 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * _21}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &_21 <- { _21 with current = (RedBlackTree_Node_Type.C_Node l_left'0 ( ^ _20) l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = Borrow.borrow_final <RedBlackTree_Color_Type.t_color> { * _20} {Borrow.get_id _20}
          (fun (_ret':borrowed (RedBlackTree_Color_Type.t_color)) ->
             [ &_19 <- _ret' ] 
             [ &_20 <- { _20 with current = ( ^ _19) ; } ] 
            s2)
      | s2 = swap'0 {_17} {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'1 _20}- s3
      | s3 = -{resolve'1 _18}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 =  [ &_0 <- [#"../red_black_tree.rs" 479 30 482 5] () ] s7
      | s7 = return' {_0} ]
       ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & _13 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _14 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _15 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _16 : () = any_l () : ()
    | & _17 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _18 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _19 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _20 : borrowed (RedBlackTree_Color_Type.t_color) = any_l () : borrowed (RedBlackTree_Color_Type.t_color)
    | & _21 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _22 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _23 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 476 4 478 90] exists r2 : RedBlackTree_Node_Type.t_node k v . exists r1 : RedBlackTree_Node_Type.t_node k v . inv'3 r2
      /\ inv'3 r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r2
      /\ RedBlackTree_Node_Type.node_left r1 = RedBlackTree_Node_Type.node_left r2
      /\ RedBlackTree_Node_Type.node_right r1 = RedBlackTree_Node_Type.node_right r2
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color r2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color r1
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2}
      {[@expl:postcondition] [#"../red_black_tree.rs" 473 4 475 70] exists l2 : RedBlackTree_Node_Type.t_node k v . exists l1 : RedBlackTree_Node_Type.t_node k v . inv'3 l2
      /\ inv'3 l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l2
      /\ RedBlackTree_Node_Type.node_left l1 = RedBlackTree_Node_Type.node_left l2
      /\ RedBlackTree_Node_Type.node_right l1 = RedBlackTree_Node_Type.node_right l2
      /\ RedBlackTree_Node_Type.node_key l1 = RedBlackTree_Node_Type.node_key l2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color l2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color l1}
      {[@expl:postcondition] [#"../red_black_tree.rs" 472 14 472 40] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 471 14 471 42] same_mappings'0 ( * self) ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 470 14 470 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 469 14 469 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_Balance
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'9 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'9 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'9 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'9 x = true
  type eq_model_ty'0
  predicate invariant'8 (self : eq_model_ty'0)
  let rec invariant'8 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : eq_model_ty'0)
  let rec inv'8 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : eq_model_ty'0 . inv'8 x = true
  predicate invariant'7 (self : v)
  let rec invariant'7 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : v)
  let rec inv'7 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ] 
  axiom inv'7 : forall x : v . inv'7 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'6 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'6 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'6 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'6 x = true
  predicate invariant'5 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'5 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'3 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'3 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'3 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'3 x = true
  use prelude.Borrow
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'1 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : RedBlackTree_Node_Type.t_node k v . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'0 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Node_Type.t_node k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'4 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate color_invariant'1 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'1 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'9 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'9 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'0 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'0 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'4 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'1 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'0 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'7 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'0 self}
    any [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ] 
  axiom has_mapping'0_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'0 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'8 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'7 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'4 node
   -> self = node
   -> has_mapping'0 self k v = has_mapping'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'7 v
     -> inv'8 k  -> has_mapping'0 self k v = has_mapping'0 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'7 v
     -> inv'8 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'7 v
     -> inv'8 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  let rec flip_colors'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 479 24 479 28] inv'2 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 468 15 468 60] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = color'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 467 15 467 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 466 15 466 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 465 15 465 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 476 4 478 90] exists r2 : RedBlackTree_Node_Type.t_node k v . exists r1 : RedBlackTree_Node_Type.t_node k v . inv'4 r2
      /\ inv'4 r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r2
      /\ RedBlackTree_Node_Type.node_left r1 = RedBlackTree_Node_Type.node_left r2
      /\ RedBlackTree_Node_Type.node_right r1 = RedBlackTree_Node_Type.node_right r2
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color r2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color r1
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2}
      {[#"../red_black_tree.rs" 473 4 475 70] exists l2 : RedBlackTree_Node_Type.t_node k v . exists l1 : RedBlackTree_Node_Type.t_node k v . inv'4 l2
      /\ inv'4 l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l2
      /\ RedBlackTree_Node_Type.node_left l1 = RedBlackTree_Node_Type.node_left l2
      /\ RedBlackTree_Node_Type.node_right l1 = RedBlackTree_Node_Type.node_right l2
      /\ RedBlackTree_Node_Type.node_key l1 = RedBlackTree_Node_Type.node_key l2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color l2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color l1}
      {[#"../red_black_tree.rs" 472 14 472 40] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( ^ self)}
      {[#"../red_black_tree.rs" 471 14 471 42] same_mappings'0 ( * self) ( ^ self)}
      {[#"../red_black_tree.rs" 470 14 470 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 469 14 469 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  let rec rotate_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 405 25 405 29] inv'2 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 393 15 393 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'4 r
      /\ inv'4 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[#"../red_black_tree.rs" 397 14 397 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 396 14 396 42] internal_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'6 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_ref'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'5 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'6 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 66 16 68 18] self = Core_Option_Option_Type.C_None
      \/ (exists r : RedBlackTree_Node_Type.t_node k v . inv'1 r
      /\ result = Core_Option_Option_Type.C_Some r /\ self = Core_Option_Option_Type.C_Some r)}
      {[#"../../../../creusot-contracts/src/std/option.rs" 65 16 65 60] self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec rotate_left'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 455 24 455 28] inv'2 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 444 15 444 43] color'0 (RedBlackTree_Node_Type.node_right ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 443 15 443 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 451 4 454 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'4 r
      /\ inv'4 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l
      /\ (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( ^ self))
      = (RedBlackTree_Node_Type.node_left ( * self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      /\ RedBlackTree_Node_Type.node_key l = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 450 14 450 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 449 14 449 41] color'0 (RedBlackTree_Node_Type.node_left ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 448 14 448 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self)))}
      {[#"../red_black_tree.rs" 447 14 447 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 446 14 446 42] internal_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 445 14 445 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'3 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  let rec balance (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[#"../red_black_tree.rs" 503 20 503 24] inv'2 self}
    {[#"../red_black_tree.rs" 489 4 489 110] RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red  -> false}
    {[#"../red_black_tree.rs" 487 4 488 48] RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[#"../red_black_tree.rs" 485 4 486 47] RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))}
    {[#"../red_black_tree.rs" 484 15 484 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = any [ br0 -> {_15 = false} (! bb7) | br1 -> {_15} (! bb2) ]  ] 
    | bb2 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1))
      | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ]  ] 
    | bb4 = s0 [ s0 = bb8 ] 
    | bb5 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_20 <- _ret' ] 
             [ &self <- { self with current = ( ^ _20) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _20)}- s2
      | s2 = rotate_left'0 {_20} (fun (_ret':()) ->  [ &_19 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = s0 [ s0 =  [ &_14 <- [#"../red_black_tree.rs" 504 54 506 9] () ] s1 | s1 = bb9 ] 
    | bb7 = s0 [ s0 = bb8 ] 
    | bb8 = s0 [ s0 =  [ &_14 <- [#"../red_black_tree.rs" 506 9 506 9] () ] s1 | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = s0 [ s0 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &_27 <- _ret' ] 
                    s1)))
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_27} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &_26 <- _ret' ] s1) | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'1 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {_26}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s3))
      | s3 = bb14 ]
      
    | bb14 = s0 [ s0 = any [ br0 -> {_24 = false} (! bb17) | br1 -> {_24} (! bb15) ]  ] 
    | bb15 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = ( ^ _30) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _30)}- s2
      | s2 = rotate_right'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s3)
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 =  [ &_21 <- [#"../red_black_tree.rs" 508 80 510 9] () ] s1 | s1 = bb20 ] 
    | bb17 = s0 [ s0 = bb19 ] 
    | bb18 = s0 [ s0 = bb19 ] 
    | bb19 = s0 [ s0 =  [ &_21 <- [#"../red_black_tree.rs" 510 9 510 9] () ] s1 | s1 = bb20 ] 
    | bb20 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s1))
      | s1 = bb21 ]
      
    | bb21 = s0 [ s0 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ]  ] 
    | bb22 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1))
      | s1 = bb23 ]
      
    | bb23 = s0 [ s0 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ]  ] 
    | bb24 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * self} {Borrow.get_id self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_36 <- _ret' ] 
             [ &self <- { self with current = ( ^ _36) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _36)}- s2
      | s2 = flip_colors'0 {_36} (fun (_ret':()) ->  [ &_35 <- _ret' ] s3)
      | s3 = bb25 ]
      
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 =  [ &_0 <- [#"../red_black_tree.rs" 512 53 514 9] () ] s3
      | s3 = bb29 ]
      
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb28 ] 
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb28 ] 
    | bb28 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 514 9 514 9] () ] s1 | s1 = bb29 ] 
    | bb29 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & _14 : () = any_l () : ()
    | & _15 : bool = any_l () : bool
    | & _17 : bool = any_l () : bool
    | & _19 : () = any_l () : ()
    | & _20 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _21 : () = any_l () : ()
    | & _22 : bool = any_l () : bool
    | & _24 : bool = any_l () : bool
    | & _26 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _27 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _29 : () = any_l () : ()
    | & _30 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _31 : bool = any_l () : bool
    | & _33 : bool = any_l () : bool
    | & _35 : () = any_l () : ()
    | & _36 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 501 4 502 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 499 4 500 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 497 4 498 63] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 495 4 496 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 493 4 494 34] color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))
      /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Black  ->  * self =  ^ self}
      {[@expl:postcondition] [#"../red_black_tree.rs" 492 14 492 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 491 14 491 42] internal_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 490 14 490 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_MoveRedLeft
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'10 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'10 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'10 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'10 x = true
  predicate invariant'9 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'9 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'9 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'9 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'8 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'8 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'8 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'8 x
  = true
  predicate invariant'7 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'7 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'7 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'7 x
  = true
  predicate invariant'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'6 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'6 : forall x : RedBlackTree_Node_Type.t_node k v . inv'6 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'5 (_x : eq_model_ty'0)
  let rec inv'5 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'5 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'5 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'5 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'5 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'5 (self : eq_model_ty'0)
  let rec invariant'5 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  axiom inv'5 : forall x : eq_model_ty'0 . inv'5 x = true
  predicate invariant'4 (self : v)
  let rec invariant'4 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : v)
  let rec inv'4 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ] 
  axiom inv'4 : forall x : v . inv'4 x = true
  predicate invariant'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'3 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'0 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Node_Type.t_node k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'1 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  let rec color_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'1 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'0 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'4 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'5 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'0 self}
    any [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ] 
  axiom has_mapping'0_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'0 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'5 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'4 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node
   -> has_mapping'0 self k v = has_mapping'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'10 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'10 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'0 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'0 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'6 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'0 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k  -> has_mapping'0 self k v = has_mapping'0 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  let rec rotate_left'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 455 24 455 28] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 444 15 444 43] color'0 (RedBlackTree_Node_Type.node_right ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 443 15 443 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 451 4 454 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'6 r
      /\ inv'6 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l
      /\ (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( ^ self))
      = (RedBlackTree_Node_Type.node_left ( * self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      /\ RedBlackTree_Node_Type.node_key l = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 450 14 450 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 449 14 449 41] color'0 (RedBlackTree_Node_Type.node_left ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 448 14 448 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self)))}
      {[#"../red_black_tree.rs" 447 14 447 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 446 14 446 42] internal_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 445 14 445 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  let rec rotate_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 405 25 405 29] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 393 15 393 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'6 r
      /\ inv'6 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[#"../red_black_tree.rs" 397 14 397 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 396 14 396 42] internal_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'9 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'8 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'8 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec flip_colors'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 479 24 479 28] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 468 15 468 60] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = color'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 467 15 467 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 466 15 466 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 465 15 465 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 476 4 478 90] exists r2 : RedBlackTree_Node_Type.t_node k v . exists r1 : RedBlackTree_Node_Type.t_node k v . inv'6 r2
      /\ inv'6 r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r2
      /\ RedBlackTree_Node_Type.node_left r1 = RedBlackTree_Node_Type.node_left r2
      /\ RedBlackTree_Node_Type.node_right r1 = RedBlackTree_Node_Type.node_right r2
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color r2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color r1
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2}
      {[#"../red_black_tree.rs" 473 4 475 70] exists l2 : RedBlackTree_Node_Type.t_node k v . exists l1 : RedBlackTree_Node_Type.t_node k v . inv'6 l2
      /\ inv'6 l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l2
      /\ RedBlackTree_Node_Type.node_left l1 = RedBlackTree_Node_Type.node_left l2
      /\ RedBlackTree_Node_Type.node_right l1 = RedBlackTree_Node_Type.node_right l2
      /\ RedBlackTree_Node_Type.node_key l1 = RedBlackTree_Node_Type.node_key l2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color l2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color l1}
      {[#"../red_black_tree.rs" 472 14 472 40] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( ^ self)}
      {[#"../red_black_tree.rs" 471 14 471 42] same_mappings'0 ( * self) ( ^ self)}
      {[#"../red_black_tree.rs" 470 14 470 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 469 14 469 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  let rec move_red_left (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[#"../red_black_tree.rs" 535 26 535 30] inv'3 self}
    {[#"../red_black_tree.rs" 519 15 519 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[#"../red_black_tree.rs" 518 15 518 43] internal_invariant'0 ( * self)}
    {[#"../red_black_tree.rs" 517 15 517 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_16 <- _ret' ] 
             [ &self <- { self with current = ( ^ _16) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _16)}- s2
      | s2 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_22 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_right'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 (RedBlackTree_Tree_Type.C_Tree ( ^ _22) : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s1)))))
      | s1 = -{inv'1 ( ^ _22)}- s2
      | s2 = as_mut'0 {_22}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_21 <- _ret' ] 
            s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_20 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _20}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_28 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_right'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 (RedBlackTree_Tree_Type.C_Tree ( ^ _28) : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s3)))))
      | s3 = -{inv'1 ( ^ _28)}- s4
      | s4 = as_mut'0 {_28}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_27 <- _ret' ] 
            s5)
      | s5 = bb6 ]
      
    | bb6 = s0
      [ s0 = unwrap'0 {_27} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * _26}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_25 <- _ret' ] 
             [ &_26 <- { _26 with current = ( ^ _25) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _25)}- s2
      | s2 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s3)
      | s3 = bb8 ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'2 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_30 <- _ret' ] 
             [ &self <- { self with current = ( ^ _30) ; } ] 
            s3)
      | s3 = -{inv'0 ( ^ _30)}- s4
      | s4 = rotate_left'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s5)
      | s5 = bb9 ]
      
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_32 <- _ret' ] 
             [ &self <- { self with current = ( ^ _32) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _32)}- s2
      | s2 = flip_colors'0 {_32} (fun (_ret':()) ->  [ &_31 <- _ret' ] s3)
      | s3 = bb10 ]
      
    | bb10 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_final
                  <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_35 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_left'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node (RedBlackTree_Tree_Type.C_Tree ( ^ _35) : RedBlackTree_Tree_Type.t_tree k v) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s1)))))
      | s1 = -{inv'1 ( ^ _35)}- s2
      | s2 = as_mut'0 {_35}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_34 <- _ret' ] 
            s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = unwrap'0 {_34} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_33 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * _33}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_0 <- _ret' ] 
             [ &_33 <- { _33 with current = ( ^ _0) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _0)}- s2
      | s2 = {[@expl:type invariant] inv'2 _33} s3
      | s3 = -{resolve'0 _33}- s4
      | s4 = bb16 ]
      
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb14 ] 
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 =  [ &_0 <- self ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &self <- _any ] s3) ] )
      | s3 = bb14 ]
      
    | bb14 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & _15 : () = any_l () : ()
    | & _16 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _18 : bool = any_l () : bool
    | & _20 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _21 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _22 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _24 : () = any_l () : ()
    | & _25 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _26 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _27 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _28 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _29 : () = any_l () : ()
    | & _30 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _31 : () = any_l () : ()
    | & _32 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _33 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _34 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _35 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ]
    
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 535 35 535 44] inv'3 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 533 4 534 45] color_invariant'0 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_right ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 531 14 532 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 529 4 530 108] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k
       -> has_mapping'0 ( ^ self) k v
      = (has_mapping'0 ( ^ result) k v \/ has_mapping'0 ( * self) k v /\ not has_mapping'0 ( * result) k v)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 527 4 528 47] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k
       -> has_mapping'0 ( * self) k v /\ le_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))
       -> has_mapping'0 ( * result) k v}
      {[@expl:postcondition] [#"../red_black_tree.rs" 526 4 526 103] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k  -> has_mapping'0 ( * result) k v  -> has_mapping'0 ( * self) k v}
      {[@expl:postcondition] [#"../red_black_tree.rs" 525 14 525 42] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( * result)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 524 4 524 97] height'0 ( * result) = height'0 ( ^ result)
       -> height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 521 4 523 48] internal_invariant'0 ( ^ result)
      /\ height'0 ( * result) = height'0 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k  -> has_mapping'0 ( ^ result) k v  -> has_mapping'0 ( * result) k v)
       -> internal_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 520 14 520 44] internal_invariant'0 ( * result)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl14_MoveRedRight
  type k
  type v
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'10 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'10 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'10 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'10 x = true
  predicate invariant'9 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'9 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'9 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'9 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'8 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'8 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'8 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'8 x
  = true
  predicate invariant'7 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'7 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'7 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'7 x
  = true
  predicate invariant'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'6 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'6 : forall x : RedBlackTree_Node_Type.t_node k v . inv'6 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'5 (_x : eq_model_ty'0)
  let rec inv'5 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'5 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'5 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'5 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'5 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'5 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'5 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'5 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'5 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'5 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'5 (self : eq_model_ty'0)
  let rec invariant'5 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  axiom inv'5 : forall x : eq_model_ty'0 . inv'5 x = true
  predicate invariant'4 (self : v)
  let rec invariant'4 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : v)
  let rec inv'4 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ] 
  axiom inv'4 : forall x : v . inv'4 x = true
  predicate invariant'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'3 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'0 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Node_Type.t_node k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'1 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  let rec color_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'1 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'1 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'0 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'4 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'5 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'0 self}
    any [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ] 
  axiom has_mapping'0_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'0 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'5 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'4 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node
   -> has_mapping'0 self k v = has_mapping'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  use prelude.Int
  function height'1 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'1 left
        | RedBlackTree_Color_Type.C_Black -> height'1 left + 1
        end
      end
  let rec height'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'10 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'10 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'1 self >= 0)
  function height'0 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'1 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'1 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'0 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'0 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'6 node
   -> self = node  -> height'0 self = height'1 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'6 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'0 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'1 (RedBlackTree_Node_Type.node_left self)
    = height'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  let rec height_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k
     -> has_mapping'1 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  let rec bst_invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'1 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'1 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'4 v
     -> inv'5 k  -> has_mapping'0 self k v = has_mapping'0 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  let rec rotate_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 405 25 405 29] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 393 15 393 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'6 r
      /\ inv'6 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[#"../red_black_tree.rs" 397 14 397 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 396 14 396 42] internal_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'9 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'8 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'8 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec flip_colors'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 479 24 479 28] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 468 15 468 60] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = color'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 467 15 467 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 466 15 466 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    {[@expl:precondition] [#"../red_black_tree.rs" 465 15 465 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 476 4 478 90] exists r2 : RedBlackTree_Node_Type.t_node k v . exists r1 : RedBlackTree_Node_Type.t_node k v . inv'6 r2
      /\ inv'6 r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
      = Core_Option_Option_Type.C_Some r1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r2
      /\ RedBlackTree_Node_Type.node_left r1 = RedBlackTree_Node_Type.node_left r2
      /\ RedBlackTree_Node_Type.node_right r1 = RedBlackTree_Node_Type.node_right r2
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color r2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color r1
      /\ RedBlackTree_Node_Type.node_key r1 = RedBlackTree_Node_Type.node_key r2}
      {[#"../red_black_tree.rs" 473 4 475 70] exists l2 : RedBlackTree_Node_Type.t_node k v . exists l1 : RedBlackTree_Node_Type.t_node k v . inv'6 l2
      /\ inv'6 l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l1
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( ^ self))
      = Core_Option_Option_Type.C_Some l2
      /\ RedBlackTree_Node_Type.node_left l1 = RedBlackTree_Node_Type.node_left l2
      /\ RedBlackTree_Node_Type.node_right l1 = RedBlackTree_Node_Type.node_right l2
      /\ RedBlackTree_Node_Type.node_key l1 = RedBlackTree_Node_Type.node_key l2
      /\ RedBlackTree_Node_Type.node_color ( * self) = RedBlackTree_Node_Type.node_color l2
      /\ RedBlackTree_Node_Type.node_color ( ^ self) = RedBlackTree_Node_Type.node_color l1}
      {[#"../red_black_tree.rs" 472 14 472 40] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( ^ self)}
      {[#"../red_black_tree.rs" 471 14 471 42] same_mappings'0 ( * self) ( ^ self)}
      {[#"../red_black_tree.rs" 470 14 470 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 469 14 469 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  let rec move_red_right (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[#"../red_black_tree.rs" 564 27 564 31] inv'3 self}
    {[#"../red_black_tree.rs" 548 15 548 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)))) ( * self)}
    {[#"../red_black_tree.rs" 547 15 547 43] internal_invariant'0 ( * self)}
    {[#"../red_black_tree.rs" 546 15 546 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_16 <- _ret' ] 
             [ &self <- { self with current = ( ^ _16) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _16)}- s2
      | s2 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_22 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_left'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node (RedBlackTree_Tree_Type.C_Tree ( ^ _22) : RedBlackTree_Tree_Type.t_tree k v) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s1)))))
      | s1 = -{inv'1 ( ^ _22)}- s2
      | s2 = as_mut'0 {_22}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_21 <- _ret' ] 
            s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_20 <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _20}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_25 <- _ret' ] 
             [ &self <- { self with current = ( ^ _25) ; } ] 
            s3)
      | s3 = -{inv'0 ( ^ _25)}- s4
      | s4 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s5)
      | s5 = bb6 ]
      
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_27 <- _ret' ] 
             [ &self <- { self with current = ( ^ _27) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _27)}- s2
      | s2 = flip_colors'0 {_27} (fun (_ret':()) ->  [ &_26 <- _ret' ] s3)
      | s3 = bb7 ]
      
    | bb7 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * self}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_final
                  <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_30 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * self}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        RedBlackTree_Tree_Type.t_tree <k> <v> {l_right'0}
                          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                            
                            [ &self <- { self with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 (RedBlackTree_Tree_Type.C_Tree ( ^ _30) : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Node_Type.t_node k v) ; } ]
                            
                            s1)))))
      | s1 = -{inv'1 ( ^ _30)}- s2
      | s2 = as_mut'0 {_30}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_29 <- _ret' ] 
            s3)
      | s3 = bb8 ]
      
    | bb8 = s0
      [ s0 = unwrap'0 {_29} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_28 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * _28}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_0 <- _ret' ] 
             [ &_28 <- { _28 with current = ( ^ _0) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _0)}- s2
      | s2 = {[@expl:type invariant] inv'2 _28} s3
      | s3 = -{resolve'0 _28}- s4
      | s4 = bb13 ]
      
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb11 ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 =  [ &_0 <- self ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &self <- _any ] s3) ] )
      | s3 = bb11 ]
      
    | bb11 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & self : borrowed (RedBlackTree_Node_Type.t_node k v) = self
    | & _15 : () = any_l () : ()
    | & _16 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _18 : bool = any_l () : bool
    | & _20 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _21 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _22 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _24 : () = any_l () : ()
    | & _25 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _26 : () = any_l () : ()
    | & _27 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _28 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _29 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _30 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ]
    
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 564 36 564 45] inv'3 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 562 4 563 45] color_invariant'0 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_left ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 560 14 561 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 558 4 559 108] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k
       -> has_mapping'0 ( ^ self) k v
      = (has_mapping'0 ( ^ result) k v \/ has_mapping'0 ( * self) k v /\ not has_mapping'0 ( * result) k v)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 556 4 557 47] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k
       -> has_mapping'0 ( * self) k v /\ le_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) k
       -> has_mapping'0 ( * result) k v}
      {[@expl:postcondition] [#"../red_black_tree.rs" 555 4 555 103] forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k  -> has_mapping'0 ( * result) k v  -> has_mapping'0 ( * self) k v}
      {[@expl:postcondition] [#"../red_black_tree.rs" 554 14 554 42] RedBlackTree_Node_Type.node_key ( * result)
      = RedBlackTree_Node_Type.node_key ( * self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 553 4 553 97] height'0 ( * result) = height'0 ( ^ result)
       -> height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 550 4 552 48] internal_invariant'0 ( ^ result)
      /\ height'0 ( * result) = height'0 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'4 v
       -> inv'5 k  -> has_mapping'0 ( ^ result) k v  -> has_mapping'0 ( * result) k v)
       -> internal_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 549 14 549 44] internal_invariant'0 ( * result)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_New
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'2 (_x : eq_model_ty'0)
  let rec inv'2 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'3 (self : eq_model_ty'0)
  let rec invariant'3 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : eq_model_ty'0 . inv'2 x = true
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : v)
  let rec inv'1 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ] 
  axiom inv'1 : forall x : v . inv'1 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'1 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'0 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'0 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use map.Const
  use map.Map
  use map.Map
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  function view'0 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  use prelude.Intrinsic
  let rec new (_1:()) (return'  (ret:RedBlackTree_Tree_Type.t_tree k v))= (! bb0
    [ bb0 = s0
      [ s0 = 
        [ &_3 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        s1
      | s1 =  [ &_0 <- RedBlackTree_Tree_Type.C_Tree _3 : RedBlackTree_Tree_Type.t_tree k v ] 
        (any
        [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_3 <- _any ] s2) ]
        )
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _3 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:RedBlackTree_Tree_Type.t_tree k v)-> {[@expl:postcondition] [#"../red_black_tree.rs" 581 20 581 30] inv'0 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 580 14 580 32] invariant'0 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 579 14 579 43] view'0 result
      = Const.const (Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_InsertRec
  type k
  type v
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  predicate invariant'11 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'11 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'11 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'11 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'10 (_x : eq_model_ty'0)
  let rec inv'10 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'10 (self : eq_model_ty'0)
  let rec invariant'10 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  axiom inv'10 : forall x : eq_model_ty'0 . inv'10 x = true
  predicate invariant'9 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'9 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'9 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Node_Type.t_node k v . inv'9 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'8 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'8 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'8 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'8 x = true
  predicate invariant'7 (self : k)
  let rec invariant'7 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : k)
  let rec inv'7 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ] 
  axiom inv'7 : forall x : k . inv'7 x = true
  predicate invariant'6 (self : v)
  let rec invariant'6 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : v)
  let rec inv'6 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ] 
  axiom inv'6 : forall x : v . inv'6 x = true
  predicate invariant'5 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'5 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'4 (self : k)
  let rec invariant'4 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : k)
  let rec inv'4 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ] 
  axiom inv'4 : forall x : k . inv'4 x = true
  predicate invariant'3 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'3 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'1 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'1 x
  = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'3 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'8 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'8 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'6 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'6 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate color_invariant'1 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'1 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function height'1 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'0 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'0 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'9 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'9 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
   -> self = node  -> height'1 self = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'6 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'10 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'9 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'9 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'10 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'6 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'3 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'6 v
     -> inv'10 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate internal_invariant'1 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'1 self /\ height_invariant'1 self
  let rec internal_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'1 self} (! return' {result}) ]
    
  let rec balance'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 503 20 503 24] inv'11 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 489 4 489 110] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red  -> false}
    {[@expl:precondition] [#"../red_black_tree.rs" 487 4 488 48] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 485 4 486 47] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 484 15 484 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 501 4 502 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 499 4 500 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 497 4 498 63] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 495 4 496 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 493 4 494 34] color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))
      /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Black  ->  * self =  ^ self}
      {[#"../red_black_tree.rs" 492 14 492 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 491 14 491 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 490 14 490 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'6 (self : k)
  let rec resolve'6 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : v)
  let rec resolve'5 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= {[@expl:precondition] inv'4 other}
    {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 81] result
      = cmp_log'0 (eq_model'0 self) (eq_model'0 other)}
      (! return' {result}) ]
    
  predicate resolve'3 (self : k)
  let rec resolve'3 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec resolve'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec insert_rec (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (val':v) (return'  (ret:()))= {[#"../red_black_tree.rs" 593 37 593 40] inv'6 val'}
    {[#"../red_black_tree.rs" 593 29 593 32] inv'7 key}
    {[#"../red_black_tree.rs" 593 23 593 27] inv'2 self}
    {[#"../red_black_tree.rs" 586 15 586 40] color_invariant'0 ( * self)}
    {[#"../red_black_tree.rs" 585 15 585 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 = bb1 ] 
    | bb1 = s0 [ s0 = bb2 ] 
    | bb2 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_11 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _11) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'0 ( ^ _11)}- s2
      | s2 = any
        [ br0 -> { * _11 = Core_Option_Option_Type.C_None } (! bb19)
        | br1 (a:RedBlackTree_Node_Type.t_node k v)-> { * _11 = Core_Option_Option_Type.C_Some a} (! bb3) ]
         ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'1 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 = 
        [ &_35 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        s3
      | s3 =  [ &_34 <- RedBlackTree_Tree_Type.C_Tree _35 : RedBlackTree_Tree_Type.t_tree k v ] 
        (any
        [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_35 <- _any ] s4) ]
        )
      | s4 = bb20 ]
      
    | bb20 = s0
      [ s0 =  [ &_36 <- RedBlackTree_Color_Type.C_Red ] s1
      | s1 = 
        [ &_40 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        s2
      | s2 =  [ &_39 <- RedBlackTree_Tree_Type.C_Tree _40 : RedBlackTree_Tree_Type.t_tree k v ] 
        (any
        [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_40 <- _any ] s3) ]
        )
      | s3 = bb21 ]
      
    | bb21 = s0
      [ s0 =  [ &_33 <- RedBlackTree_Node_Type.C_Node _34 _36 key val' _39 : RedBlackTree_Node_Type.t_node k v ] 
        (any
        [ any_ (_any:RedBlackTree_Tree_Type.t_tree k v)-> (!  [ &_34 <- _any ] 
          (any
          [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_36 <- _any ] 
            (any
            [ any_ (_any:k)-> (!  [ &key <- _any ] 
              (any
              [ any_ (_any:v)-> (!  [ &val' <- _any ] 
                (any [ any_ (_any:RedBlackTree_Tree_Type.t_tree k v)-> (!  [ &_39 <- _any ] s1) ] )) ]
              )) ]
            )) ]
          )) ]
        )
      | s1 = bb22 ]
      
    | bb22 = s0 [ s0 = bb23 ] 
    | bb23 = s0 [ s0 = bb24 ] 
    | bb24 = s0 [ s0 = bb25 ] 
    | bb25 = s0 [ s0 = bb26 ] 
    | bb26 = s0
      [ s0 = 
        [ &_31 <- Core_Option_Option_Type.C_Some _33 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
        
        (any [ any_ (_any:RedBlackTree_Node_Type.t_node k v)-> (!  [ &_33 <- _any ] s1) ] )
      | s1 = bb27 ]
      
    | bb27 = s0 [ s0 = bb28 ] 
    | bb28 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            
            [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree _31 : RedBlackTree_Tree_Type.t_tree k v) ; } ]
            
            (any
            [ any_ (_any:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_31 <- _any ] 
              s1) ]
            ))
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            {[@expl:type invariant] inv'0 rnode'0}
            s2)
      | s2 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'1:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            -{resolve'1 rnode'1}-
            s3)
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb30 ]
      
    | bb30 = s0 [ s0 =  [ &_0 <- [#"../red_black_tree.rs" 612 12 612 18] () ] s1 | s1 = bb32 ] 
    | bb3 = s0 [ s0 = bb4 ] 
    | bb4 = s0
      [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _11}
          (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
            Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _11) 1}
              (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
                 [ &node <- _ret' ] 
                Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _11}
                  (fun (l_0'0:RedBlackTree_Node_Type.t_node k v) ->
                    
                    [ &_11 <- { _11 with current = (Core_Option_Option_Type.C_Some ( ^ node) : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ; } ]
                    
                    s1)))
      | s1 = -{inv'3 ( ^ node)}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
             [ &_18 <- rkey'0 ] 
            s3)
      | s3 = {[@expl:type invariant] inv'4 _18} s4
      | s4 = -{resolve'3 _18}- s5
      | s5 = cmp'0 {key} {_18} (fun (_ret':Core_Cmp_Ordering_Type.t_ordering) ->  [ &_15 <- _ret' ] s6)
      | s6 = bb5 ]
      
    | bb5 = s0
      [ s0 = any
        [ br0 -> {_15 = Core_Cmp_Ordering_Type.C_Less } (! bb7)
        | br1 -> {_15 = Core_Cmp_Ordering_Type.C_Equal } (! bb8)
        | br2 -> {_15 = Core_Cmp_Ordering_Type.C_Greater } (! bb9) ]
         ]
      
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'6 val'} s3
      | s3 = -{resolve'5 val'}- s4
      | s4 = {[@expl:type invariant] inv'7 key} s5
      | s5 = -{resolve'6 key}- s6
      | s6 = {[@expl:type invariant] inv'1 _11} s7
      | s7 = -{resolve'0 _11}- s8
      | s8 = {[@expl:type invariant] inv'2 self} s9
      | s9 = -{resolve'2 self}- s10
      | s10 = {[#"../red_black_tree.rs" 595 18 595 36] false} any ]
      
    | bb9 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_25 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _25) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'8 ( ^ _25)}- s2
      | s2 = insert_rec {_25} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 = bb17 ] 
    | bb8 = s0 [ s0 = bb12 ] 
    | bb12 = s0 [ s0 = {[@expl:type invariant] inv'7 key} s1 | s1 = -{resolve'6 key}- s2 | s2 = bb13 ] 
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 val' l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:v)-> (!  [ &val' <- _any ] s1) ] ))
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            {[@expl:type invariant] inv'6 rval'0}
            s2)
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
            -{resolve'5 rval'1}-
            s3)
      | s3 = {[@expl:type invariant] inv'5 node} s4
      | s4 = -{resolve'4 node}- s5
      | s5 = bb15 ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'1 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- [#"../red_black_tree.rs" 599 20 599 26] () ] s5
      | s5 = bb32 ]
      
    | bb32 = s0 [ s0 = bb33 ] 
    | bb33 = s0 [ s0 = bb34 ] 
    | bb7 = s0 [ s0 = bb10 ] 
    | bb10 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_20 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node ( ^ _20) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'8 ( ^ _20)}- s2
      | s2 = insert_rec {_20} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0 [ s0 = bb17 ] 
    | bb17 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_29 <- _ret' ] 
             [ &node <- { node with current = ( ^ _29) ; } ] 
            s1)
      | s1 = -{inv'9 ( ^ _29)}- s2
      | s2 = balance'0 {_29} (fun (_ret':()) ->  [ &_28 <- _ret' ] s3)
      | s3 = bb18 ]
      
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 =  [ &_0 <- [#"../red_black_tree.rs" 594 43 604 9] () ] s7
      | s7 = bb31 ]
      
    | bb31 = s0 [ s0 = bb34 ] 
    | bb34 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & key : k = key
    | & val' : v = val'
    | & _11 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _14 : () = any_l () : ()
    | & _15 : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _18 : k = any_l () : k
    | & _20 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _25 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _28 : () = any_l () : ()
    | & _29 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _31 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _33 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _34 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _35 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _36 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & _39 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _40 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 592 4 592 123] forall v : v . forall k : eq_model_ty'0 . inv'6 v
       -> inv'10 k  -> k = eq_model'0 key \/ has_mapping'0 ( * self) k v = has_mapping'0 ( ^ self) k v}
      {[@expl:postcondition] [#"../red_black_tree.rs" 591 14 591 54] has_mapping'0 ( ^ self) (eq_model'0 key) val'}
      {[@expl:postcondition] [#"../red_black_tree.rs" 589 14 590 39] match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)
      /\ color'0 ( * self) = RedBlackTree_Color_Type.C_Red
      \/ color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 588 14 588 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 587 14 587 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_Insert
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'6 (_x : eq_model_ty'0)
  let rec inv'6 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'6 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'6 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'6 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'6 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  predicate invariant'11 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'11 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'10 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'10 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'10 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'10 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'10 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'9 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'9 : forall x : RedBlackTree_Node_Type.t_node k v . inv'9 x = true
  use prelude.Borrow
  predicate invariant'9 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'9 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'8 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'8 x
  = true
  predicate invariant'8 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'8 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'7 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'7 x
  = true
  predicate invariant'7 (self : eq_model_ty'0)
  let rec invariant'7 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  axiom inv'6 : forall x : eq_model_ty'0 . inv'6 x = true
  predicate invariant'6 (self : v)
  let rec invariant'6 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : v)
  let rec inv'5 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ] 
  axiom inv'5 : forall x : v . inv'5 x = true
  predicate invariant'5 (self : k)
  let rec invariant'5 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : k)
  let rec inv'4 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ] 
  axiom inv'4 : forall x : k . inv'4 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'3 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'3 x = true
  predicate invariant'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'2 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  predicate invariant'1 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'0 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  function view'1 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'0 ( * self)
  let rec view'1 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'0 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'0 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'5 v
     -> inv'6 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'5 v
     -> inv'6 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  predicate resolve'2 (self : Snapshot.snap_ty ())
  let rec resolve'2 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use map.Map
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'10 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'0 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'10 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'6 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'5 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'10 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'0 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'0 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'10 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'6 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'5 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'0 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'0 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'6 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'5 v
   -> has_mapping'0 self k v = (Map.get (view'0 self) k = Core_Option_Option_Type.C_Some v))
  predicate resolve'1 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'8 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'8 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'9 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  let rec insert_rec'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (val':v) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 593 37 593 40] inv'5 val'}
    {[@expl:precondition] [#"../red_black_tree.rs" 593 29 593 32] inv'4 key}
    {[@expl:precondition] [#"../red_black_tree.rs" 593 23 593 27] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 586 15 586 40] color_invariant'0 ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 585 15 585 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 592 4 592 123] forall v : v . forall k : eq_model_ty'0 . inv'5 v
       -> inv'6 k  -> k = eq_model'0 key \/ has_mapping'0 ( * self) k v = has_mapping'0 ( ^ self) k v}
      {[#"../red_black_tree.rs" 591 14 591 54] has_mapping'0 ( ^ self) (eq_model'0 key) val'}
      {[#"../red_black_tree.rs" 589 14 590 39] match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)
      /\ color'0 ( * self) = RedBlackTree_Color_Type.C_Red
      \/ color_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 588 14 588 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 587 14 587 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  let rec insert (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (val':v) (return'  (ret:()))= {[#"../red_black_tree.rs" 619 37 619 40] inv'5 val'}
    {[#"../red_black_tree.rs" 619 29 619 32] inv'4 key}
    {[#"../red_black_tree.rs" 619 23 619 27] inv'3 self}
    {[#"../red_black_tree.rs" 616 15 616 34] invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 = bb1 ] 
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_8 <- _ret' ] 
             [ &self <- { self with current = ( ^ _8) ; } ] 
            s1)
      | s1 = -{inv'0 ( ^ _8)}- s2
      | s2 = insert_rec'0 {_8} {key} {val'} (fun (_ret':()) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &_11 <- RedBlackTree_Color_Type.C_Black ] s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_14 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _14) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'1 ( ^ _14)}- s3
      | s3 = as_mut'0 {_14}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_13 <- _ret' ] 
            s4)
      | s4 = bb3 ]
      
    | bb3 = s0
      [ s0 = unwrap'0 {_13} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_12 <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _12}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &_12 <- { _12 with current = (RedBlackTree_Node_Type.C_Node l_left'0 _11 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_11 <- _any ] s1) ] ))
      | s1 = {[@expl:type invariant] inv'2 _12} s2
      | s2 = -{resolve'0 _12}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 =  [ &_15 <- [#"../red_black_tree.rs" 622 8 622 45] Snapshot.new () ] s6
      | s6 = bb5 ]
      
    | bb5 = s0 [ s0 = -{resolve'2 _15}- s1 | s1 =  [ &_0 <- [#"../red_black_tree.rs" 619 45 623 5] () ] s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = bb7 ] 
    | bb7 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & key : k = key
    | & val' : v = val'
    | & _7 : () = any_l () : ()
    | & _8 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _11 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & _12 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _13 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _14 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _15 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty () ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../red_black_tree.rs" 618 14 618 62] view'0 ( ^ self)
      = Map.set (view'1 self) (eq_model'0 key) (Core_Option_Option_Type.C_Some val')}
      {[@expl:postcondition] [#"../red_black_tree.rs" 617 14 617 33] invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_DeleteMaxRec
  type k
  type v
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'15 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'15 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'15 self} (! return' {result}) ]
    
  predicate inv'15 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'15 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'15 _x} (! return' {result}) ]
    
  axiom inv'15 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'15 x = true
  predicate invariant'14 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'14 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'14 self} (! return' {result}) ]
    
  predicate inv'14 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'14 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'14 _x} (! return' {result}) ]
    
  axiom inv'14 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'14 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'13 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'13 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'13 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'13 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'13 x = true
  use prelude.Borrow
  predicate invariant'12 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'12 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'12 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'12 x
  = true
  predicate invariant'11 (self : (k, v))
  let rec invariant'11 (self:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : (k, v))
  let rec inv'11 (_x:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : (k, v) . inv'11 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'10 (_x : eq_model_ty'0)
  let rec inv'10 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'10 (self : eq_model_ty'0)
  let rec invariant'10 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  axiom inv'10 : forall x : eq_model_ty'0 . inv'10 x = true
  predicate invariant'9 (self : v)
  let rec invariant'9 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : v)
  let rec inv'9 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ] 
  axiom inv'9 : forall x : v . inv'9 x = true
  predicate invariant'8 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'8 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'8 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'8 x
  = true
  predicate invariant'7 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'7 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'7 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'7 x = true
  predicate invariant'6 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'6 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'6 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'6 x = true
  predicate invariant'5 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'5 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'3 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'3 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'1 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'1 : forall x : RedBlackTree_Node_Type.t_node k v . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'6 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'6 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'1 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 35 8 35 31] resolve'6 self
  let rec resolve'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  let rec unwrap'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate is_default'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/std/option.rs" 146 20 146 32] self = Core_Option_Option_Type.C_None
  let rec is_default'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec take'0 (dest:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'8 dest}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'0 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42] is_default'0 ( ^ dest)}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37] result =  * dest}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate color_invariant'1 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'1 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function height'1 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'0 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'0 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'3 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'3 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node  -> height'1 self = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'9 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'10 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'3 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'3 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'10 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'9 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate internal_invariant'1 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'1 self /\ height_invariant'1 self
  let rec internal_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'1 self} (! return' {result}) ]
    
  let rec balance'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 503 20 503 24] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 489 4 489 110] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red  -> false}
    {[@expl:precondition] [#"../red_black_tree.rs" 487 4 488 48] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 485 4 486 47] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 484 15 484 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 501 4 502 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 499 4 500 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 497 4 498 63] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 495 4 496 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 493 4 494 34] color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))
      /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Black  ->  * self =  ^ self}
      {[#"../red_black_tree.rs" 492 14 492 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 491 14 491 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 490 14 490 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  let rec move_red_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] [#"../red_black_tree.rs" 564 27 564 31] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 548 15 548 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 547 15 547 43] internal_invariant'1 ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 546 15 546 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[#"../red_black_tree.rs" 564 36 564 45] inv'5 result}
      {[#"../red_black_tree.rs" 562 4 563 45] color_invariant'1 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_left ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 560 14 561 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[#"../red_black_tree.rs" 558 4 559 108] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'1 ( ^ self) k v
      = (has_mapping'1 ( ^ result) k v \/ has_mapping'1 ( * self) k v /\ not has_mapping'1 ( * result) k v)}
      {[#"../red_black_tree.rs" 556 4 557 47] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'1 ( * self) k v /\ le_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self))) k
       -> has_mapping'1 ( * result) k v}
      {[#"../red_black_tree.rs" 555 4 555 103] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'1 ( * result) k v  -> has_mapping'1 ( * self) k v}
      {[#"../red_black_tree.rs" 554 14 554 42] RedBlackTree_Node_Type.node_key ( * result)
      = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 553 4 553 97] height'1 ( * result) = height'1 ( ^ result)
       -> height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 550 4 552 48] internal_invariant'1 ( ^ result)
      /\ height'1 ( * result) = height'1 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'1 ( ^ result) k v  -> has_mapping'1 ( * result) k v)
       -> internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 549 14 549 44] internal_invariant'1 ( * result)}
      (! return' {result}) ]
    
  predicate resolve'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  let rec unwrap'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'15 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'4 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_ref'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'14 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'15 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 66 16 68 18] self = Core_Option_Option_Type.C_None
      \/ (exists r : RedBlackTree_Node_Type.t_node k v . inv'4 r
      /\ result = Core_Option_Option_Type.C_Some r /\ self = Core_Option_Option_Type.C_Some r)}
      {[#"../../../../creusot-contracts/src/std/option.rs" 65 16 65 60] self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec rotate_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 405 25 405 29] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 393 15 393 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'1 r
      /\ inv'1 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[#"../red_black_tree.rs" 397 14 397 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 396 14 396 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'13 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec as_mut'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'5 result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 36 26 36 43]  ^ self =  ^ result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 35 26 35 43]  * self =  * result}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'8 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'12 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec delete_max_rec (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:(k, v)))= {[#"../red_black_tree.rs" 636 27 636 31] inv'7 self}
    {[#"../red_black_tree.rs" 626 15 627 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[#"../red_black_tree.rs" 625 15 625 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_15 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _15) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'0 ( ^ _15)}- s2
      | s2 = as_mut'0 {_15}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_14 <- _ret' ] 
            s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _13} {Borrow.get_id _13}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_12 <- _ret' ] 
             [ &_13 <- { _13 with current = ( ^ _12) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _12)}- s2
      | s2 = as_mut'1 {_12} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &node <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_17 = false} (! bb7) | br1 -> {_17} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_19 <- _ret' ] 
             [ &node <- { node with current = ( ^ _19) ; } ] 
            s1)
      | s1 = -{inv'3 ( ^ _19)}- s2
      | s2 = rotate_right'0 {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = s0 [ s0 = bb8 ] 
    | bb7 = s0 [ s0 =  [ &_16 <- [#"../red_black_tree.rs" 640 9 640 9] () ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                any
                [ br0 -> {rnode'0 = Core_Option_Option_Type.C_None } (! bb9)
                | br1 (a:RedBlackTree_Node_Type.t_node k v)-> {rnode'0 = Core_Option_Option_Type.C_Some a} (! bb15) ]
                )) ]
      
    | bb15 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = s0 [ s0 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ]  ] 
    | bb17 = s0 [ s0 = bb25 ] 
    | bb18 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &_35 <- _ret' ] 
                    s1)))
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = unwrap'1 {_35} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &_34 <- _ret' ] s1) | s1 = bb20 ]
      
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv'4 _34} s1
      | s1 = -{resolve'1 _34}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {_34}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s3))
      | s3 = bb21 ]
      
    | bb21 = s0 [ s0 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb22) ]  ] 
    | bb22 = s0 [ s0 = bb25 ] 
    | bb25 = s0 [ s0 =  [ &_29 <- [#"../red_black_tree.rs" 647 9 647 9] () ] s1 | s1 = bb26 ] 
    | bb23 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_39 <- _ret' ] 
             [ &node <- { node with current = ( ^ _39) ; } ] 
            s1)
      | s1 = -{inv'3 ( ^ _39)}- s2
      | s2 = move_red_right'0 {_39} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_38 <- _ret' ] s3)
      | s3 = bb24 ]
      
    | bb24 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _38} {Borrow.get_id _38}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_37 <- _ret' ] 
             [ &_38 <- { _38 with current = ( ^ _37) ; } ] 
            s1)
      | s1 = -{inv'3 ( ^ _37)}- s2
      | s2 = {[@expl:type invariant] inv'5 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 =  [ &node <- _37 ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_37 <- _any ] s5) ] )
      | s5 = {[@expl:type invariant] inv'5 _38} s6
      | s6 = -{resolve'2 _38}- s7
      | s7 =  [ &_29 <- [#"../red_black_tree.rs" 645 84 647 9] () ] s8
      | s8 = bb26 ]
      
    | bb26 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_41 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _41) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'6 ( ^ _41)}- s2
      | s2 = delete_max_rec {_41} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s3)
      | s3 = bb27 ]
      
    | bb27 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_43 <- _ret' ] 
             [ &node <- { node with current = ( ^ _43) ; } ] 
            s1)
      | s1 = -{inv'3 ( ^ _43)}- s2
      | s2 = balance'0 {_43} (fun (_ret':()) ->  [ &_42 <- _ret' ] s3)
      | s3 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- r ] (any [ any_ (_any:(k, v))-> (!  [ &r <- _any ] s5) ] )
      | s5 = bb29 ]
      
    | bb29 = s0 [ s0 = bb31 ] 
    | bb9 = s0 [ s0 = bb10 ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_26 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _26) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s3)))
      | s3 = -{inv'0 ( ^ _26)}- s4
      | s4 = Borrow.borrow_final
          <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
          { * _26}
          {Borrow.get_id _26}
          (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_25 <- _ret' ] 
             [ &_26 <- { _26 with current = ( ^ _25) ; } ] 
            s5)
      | s5 = -{inv'0 ( ^ _25)}- s6
      | s6 = take'0 {_25}
          (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->  [ &_24 <- _ret' ] s7)
      | s7 = bb11 ]
      
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'8 _26} s1
      | s1 = -{resolve'4 _26}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 = unwrap'2 {_24} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb12 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'1 node1} s1
      | s1 = -{resolve'5 node1}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {node1}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Node_Type.t_node <k> <v> {node1}
              (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                (any
                [ any_ (_any:k)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                    (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                      
                      [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 _any l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v ]
                      
                      (any
                      [ any_ (_any:v)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                          (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                            
                            [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'1 l_color'1 l_key'1 _any l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                            
                            s3)) ]
                      ))) ]
                )))
      | s3 = bb13 ]
      
    | bb13 = s0 [ s0 = bb14 ] 
    | bb14 = s0 [ s0 = bb30 ] 
    | bb30 = s0 [ s0 = bb31 ] 
    | bb31 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : (k, v) = any_l () : (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _12 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _13 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _14 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _15 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _16 : () = any_l () : ()
    | & _17 : bool = any_l () : bool
    | & _19 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & node1 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _24 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _25 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _26 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _29 : () = any_l () : ()
    | & _30 : bool = any_l () : bool
    | & _32 : bool = any_l () : bool
    | & _34 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _35 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _37 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _38 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _39 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & r : (k, v) = any_l () : (k, v)
    | & _41 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _42 : () = any_l () : ()
    | & _43 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:(k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 636 36 636 42] inv'11 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 635 4 635 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[@expl:postcondition] [#"../red_black_tree.rs" 634 14 634 39] color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 632 4 633 71] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'0 ( ^ self) k v = (eq_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 ( * self) k v)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 631 4 631 100] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'0 ( * self) k v  -> le_log'0 k (eq_model'0 (let (a, _) = result in a))}
      {[@expl:postcondition] [#"../red_black_tree.rs" 630 14 630 64] has_mapping'0 ( * self) (eq_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 629 14 629 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 628 14 628 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_DeleteMax
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'14 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'14 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'14 self} (! return' {result}) ]
    
  predicate inv'13 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'13 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'13 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  predicate invariant'13 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'13 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'12 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'12 x
  = true
  predicate invariant'12 (self : (k, v))
  let rec invariant'12 (self:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'11 (_x : (k, v))
  let rec inv'11 (_x:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : (k, v) . inv'11 x = true
  predicate invariant'11 (self : v)
  let rec invariant'11 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'10 (_x : v)
  let rec inv'10 (_x:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : v . inv'10 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'10 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'10 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'9 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'9 x = true
  predicate invariant'9 (self : Core_Option_Option_Type.t_option (k, v))
  let rec invariant'9 (self:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Core_Option_Option_Type.t_option (k, v))
  let rec inv'8 (_x:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Core_Option_Option_Type.t_option (k, v) . inv'8 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'7 (_x : eq_model_ty'0)
  let rec inv'7 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'7 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'7 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'7 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'7 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'7 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'7 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'7 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'7 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'7 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'7 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'7 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'7 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'7 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'7 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'8 (self : eq_model_ty'0)
  let rec invariant'8 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  axiom inv'7 : forall x : eq_model_ty'0 . inv'7 x = true
  predicate invariant'7 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'7 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'6 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'6 x = true
  predicate invariant'6 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'6 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'3 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'3 x = true
  predicate invariant'3 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'3 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'2 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'2 x
  = true
  predicate invariant'2 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'1 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'1 x = true
  use prelude.Snapshot
  predicate invariant'1 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec invariant'1 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)) . inv'0 x = true
  use map.Const
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  function view'1 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use map.Map
  function view'0 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'1 ( * self)
  let rec view'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'6 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'6 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'7 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'7 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'4 (self : Snapshot.snap_ty ())
  let rec resolve'4 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  use prelude.Snapshot
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'7 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'13 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'6 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'13 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'7 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'10 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'7 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'13 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'13 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'7 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'10 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'7 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'6 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'7 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'10 v
   -> has_mapping'0 self k v = (Map.get (view'1 self) k = Core_Option_Option_Type.C_Some v))
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'5 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'12 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'4 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  let rec delete_max_rec'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [#"../red_black_tree.rs" 636 27 636 31] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 626 15 627 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 625 15 625 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:(k, v))-> {[#"../red_black_tree.rs" 636 36 636 42] inv'11 result}
      {[#"../red_black_tree.rs" 635 4 635 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[#"../red_black_tree.rs" 634 14 634 39] color_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 632 4 633 71] forall v : v . forall k : eq_model_ty'0 . inv'10 v
       -> inv'7 k
       -> has_mapping'0 ( ^ self) k v = (eq_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 ( * self) k v)}
      {[#"../red_black_tree.rs" 631 4 631 100] forall v : v . forall k : eq_model_ty'0 . inv'10 v
       -> inv'7 k  -> has_mapping'0 ( * self) k v  -> le_log'0 k (eq_model'0 (let (a, _) = result in a))}
      {[#"../red_black_tree.rs" 630 14 630 64] has_mapping'0 ( * self) (eq_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[#"../red_black_tree.rs" 629 14 629 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 628 14 628 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  predicate same_mappings'0 [#"../red_black_tree.rs" 42 4 42 43] (self : RedBlackTree_Tree_Type.t_tree k v) (o : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 43 8 45 9] forall v : v . forall k : eq_model_ty'0 . inv'10 v
     -> inv'7 k  -> has_mapping'0 self k v = has_mapping'0 o k v
  let rec same_mappings'0 (self:RedBlackTree_Tree_Type.t_tree k v) (o:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  use prelude.Snapshot
  predicate resolve'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'9 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec resolve'0 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  let rec delete_max (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Core_Option_Option_Type.t_option (k, v)))= {[#"../red_black_tree.rs" 660 27 660 31] inv'3 self}
    {[#"../red_black_tree.rs" 653 15 653 34] invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [#"../red_black_tree.rs" 661 23 661 41] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_8 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _8) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s3)))
      | s3 = -{inv'1 ( ^ _8)}- s4
      | s4 = any
        [ br0 -> { * _8 = Core_Option_Option_Type.C_None } (! bb8)
        | br1 (a:RedBlackTree_Node_Type.t_node k v)-> { * _8 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'2 _8} s1
      | s1 = -{resolve'1 _8}- s2
      | s2 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (k, v) ] s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb19 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _8}
          (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
            Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _8) 1}
              (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
                 [ &node <- _ret' ] 
                Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _8}
                  (fun (l_0'0:RedBlackTree_Node_Type.t_node k v) ->
                    
                    [ &_8 <- { _8 with current = (Core_Option_Option_Type.C_Some ( ^ node) : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ; } ]
                    
                    s1)))
      | s1 = -{inv'4 ( ^ node)}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'3 node}- s2
      | s2 = {[@expl:type invariant] inv'2 _8} s3
      | s3 = -{resolve'1 _8}- s4
      | s4 =  [ &_7 <- [#"../red_black_tree.rs" 665 13 665 13] () ] s5
      | s5 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_13 <- RedBlackTree_Color_Type.C_Red ] s1
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 _13 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_13 <- _any ] s2) ] ))
      | s2 = {[@expl:type invariant] inv'5 node} s3
      | s3 = -{resolve'3 node}- s4
      | s4 = {[@expl:type invariant] inv'2 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 =  [ &_7 <- [#"../red_black_tree.rs" 663 35 665 13] () ] s7
      | s7 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:assertion] [#"../red_black_tree.rs" 669 24 669 53] same_mappings'0 ( * Snapshot.inner old_self) ( * self)}
        s1
      | s1 = Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_18 <- _ret' ] 
             [ &self <- { self with current = ( ^ _18) ; } ] 
            s2)
      | s2 = -{inv'6 ( ^ _18)}- s3
      | s3 = delete_max_rec'0 {_18} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s4)
      | s4 = bb9 ]
      
    | bb9 = s0 [ s0 = is_red'0 { * self} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_20 = false} (! bb14) | br1 -> {_20} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 =  [ &_22 <- RedBlackTree_Color_Type.C_Black ] s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_25 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _25) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'1 ( ^ _25)}- s3
      | s3 = as_mut'0 {_25}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_24 <- _ret' ] 
            s4)
      | s4 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_24} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _23}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &_23 <- { _23 with current = (RedBlackTree_Node_Type.C_Node l_left'0 _22 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_22 <- _any ] s1) ] ))
      | s1 = {[@expl:type invariant] inv'5 _23} s2
      | s2 = -{resolve'3 _23}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 =  [ &_19 <- [#"../red_black_tree.rs" 671 25 673 9] () ] s6
      | s6 = bb15 ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'3 self} s1
      | s1 = -{resolve'2 self}- s2
      | s2 =  [ &_19 <- [#"../red_black_tree.rs" 673 9 673 9] () ] s3
      | s3 = bb15 ]
      
    | bb15 = s0 [ s0 =  [ &_26 <- [#"../red_black_tree.rs" 674 8 674 45] Snapshot.new () ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = -{resolve'4 _26}- s1
      | s1 =  [ &_0 <- Core_Option_Option_Type.C_Some r : Core_Option_Option_Type.t_option (k, v) ] 
        (any [ any_ (_any:(k, v))-> (!  [ &r <- _any ] s2) ] )
      | s2 = bb17 ]
      
    | bb17 = s0 [ s0 = bb18 ] 
    | bb18 = s0 [ s0 = bb19 ] 
    | bb19 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)) = any_l () : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))
    | & _7 : () = any_l () : ()
    | & _8 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _11 : bool = any_l () : bool
    | & _13 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & r : (k, v) = any_l () : (k, v)
    | & _18 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _19 : () = any_l () : ()
    | & _20 : bool = any_l () : bool
    | & _22 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & _23 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _24 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _25 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _26 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty () ]
    
    [ return' (result:Core_Option_Option_Type.t_option (k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 660 36 660 50] inv'8 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 655 14 659 65] match result with
        | Core_Option_Option_Type.C_Some (k, v) -> Map.get (view'0 self) (eq_model'0 k)
        = Core_Option_Option_Type.C_Some v
        /\ (forall k2 : eq_model_ty'0 . inv'7 k2
         -> Map.get (view'0 self) k2 = Core_Option_Option_Type.C_None \/ le_log'0 k2 (eq_model'0 k))
        /\ view'1 ( ^ self) = Map.set (view'0 self) (eq_model'0 k) (Core_Option_Option_Type.C_None)
        | Core_Option_Option_Type.C_None -> view'1 ( ^ self) = view'0 self
        /\ view'0 self = Const.const (Core_Option_Option_Type.C_None)
        end}
      {[@expl:postcondition] [#"../red_black_tree.rs" 654 14 654 33] invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_DeleteMinRec
  type k
  type v
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'15 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'15 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'15 self} (! return' {result}) ]
    
  predicate inv'15 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'15 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'15 _x} (! return' {result}) ]
    
  axiom inv'15 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'15 x = true
  predicate invariant'14 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'14 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'14 self} (! return' {result}) ]
    
  predicate inv'14 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'14 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'14 _x} (! return' {result}) ]
    
  axiom inv'14 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'14 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'13 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'13 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'13 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'13 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'13 x = true
  use prelude.Borrow
  predicate invariant'12 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'12 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'12 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'12 x
  = true
  predicate invariant'11 (self : (k, v))
  let rec invariant'11 (self:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : (k, v))
  let rec inv'11 (_x:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : (k, v) . inv'11 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'10 (_x : eq_model_ty'0)
  let rec inv'10 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'10 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'10 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'10 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'10 (self : eq_model_ty'0)
  let rec invariant'10 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  axiom inv'10 : forall x : eq_model_ty'0 . inv'10 x = true
  predicate invariant'9 (self : v)
  let rec invariant'9 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : v)
  let rec inv'9 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ] 
  axiom inv'9 : forall x : v . inv'9 x = true
  predicate invariant'8 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'8 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'8 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'8 x
  = true
  predicate invariant'7 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'7 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'7 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'7 x = true
  predicate invariant'6 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'6 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'6 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'6 x = true
  predicate invariant'5 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'5 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'3 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'3 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'1 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'1 : forall x : RedBlackTree_Node_Type.t_node k v . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'6 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'6 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'1 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 35 8 35 31] resolve'6 self
  let rec resolve'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  let rec unwrap'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate is_default'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/std/option.rs" 146 20 146 32] self = Core_Option_Option_Type.C_None
  let rec is_default'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec take'0 (dest:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'8 dest}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'0 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42] is_default'0 ( ^ dest)}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37] result =  * dest}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate color_invariant'1 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'1 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function height'1 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'0 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'0 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'4 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'4 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node  -> height'1 self = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'0 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'9 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'10 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'4 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'4 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'10 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'9 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'10 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate internal_invariant'1 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'1 self /\ height_invariant'1 self
  let rec internal_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'1 self} (! return' {result}) ]
    
  let rec balance'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 503 20 503 24] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 489 4 489 110] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red  -> false}
    {[@expl:precondition] [#"../red_black_tree.rs" 487 4 488 48] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 485 4 486 47] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 484 15 484 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 501 4 502 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 499 4 500 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 497 4 498 63] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 495 4 496 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 493 4 494 34] color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))
      /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Black  ->  * self =  ^ self}
      {[#"../red_black_tree.rs" 492 14 492 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 491 14 491 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 490 14 490 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  let rec move_red_left'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] [#"../red_black_tree.rs" 535 26 535 30] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 519 15 519 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 518 15 518 43] internal_invariant'1 ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 517 15 517 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[#"../red_black_tree.rs" 535 35 535 44] inv'5 result}
      {[#"../red_black_tree.rs" 533 4 534 45] color_invariant'1 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_right ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 531 14 532 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[#"../red_black_tree.rs" 529 4 530 108] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'1 ( ^ self) k v
      = (has_mapping'1 ( ^ result) k v \/ has_mapping'1 ( * self) k v /\ not has_mapping'1 ( * result) k v)}
      {[#"../red_black_tree.rs" 527 4 528 47] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'1 ( * self) k v /\ le_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key ( * self)))
       -> has_mapping'1 ( * result) k v}
      {[#"../red_black_tree.rs" 526 4 526 103] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'1 ( * result) k v  -> has_mapping'1 ( * self) k v}
      {[#"../red_black_tree.rs" 525 14 525 42] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( * result)}
      {[#"../red_black_tree.rs" 524 4 524 97] height'1 ( * result) = height'1 ( ^ result)
       -> height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 521 4 523 48] internal_invariant'1 ( ^ result)
      /\ height'1 ( * result) = height'1 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'1 ( ^ result) k v  -> has_mapping'1 ( * result) k v)
       -> internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 520 14 520 44] internal_invariant'1 ( * result)}
      (! return' {result}) ]
    
  predicate resolve'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  let rec unwrap'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'15 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'3 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_ref'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'14 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'15 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 66 16 68 18] self = Core_Option_Option_Type.C_None
      \/ (exists r : RedBlackTree_Node_Type.t_node k v . inv'3 r
      /\ result = Core_Option_Option_Type.C_Some r /\ self = Core_Option_Option_Type.C_Some r)}
      {[#"../../../../creusot-contracts/src/std/option.rs" 65 16 65 60] self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'13 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec as_mut'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'5 result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 36 26 36 43]  ^ self =  ^ result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 35 26 35 43]  * self =  * result}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'8 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'12 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec delete_min_rec (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:(k, v)))= {[#"../red_black_tree.rs" 689 27 689 31] inv'7 self}
    {[#"../red_black_tree.rs" 679 15 680 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[#"../red_black_tree.rs" 678 15 678 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_15 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _15) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'0 ( ^ _15)}- s2
      | s2 = as_mut'0 {_15}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_14 <- _ret' ] 
            s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _13} {Borrow.get_id _13}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_12 <- _ret' ] 
             [ &_13 <- { _13 with current = ( ^ _12) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _12)}- s2
      | s2 = as_mut'1 {_12} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &node <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                any
                [ br0 -> {rnode'0 = Core_Option_Option_Type.C_None } (! bb4)
                | br1 (a:RedBlackTree_Node_Type.t_node k v)-> {rnode'0 = Core_Option_Option_Type.C_Some a} (! bb10) ]
                )) ]
      
    | bb10 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = s0 [ s0 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ]  ] 
    | bb12 = s0 [ s0 = bb20 ] 
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &_31 <- _ret' ] 
                    s1)))
      | s1 = bb14 ]
      
    | bb14 = s0
      [ s0 = unwrap'1 {_31} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &_30 <- _ret' ] s1) | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'3 _30} s1
      | s1 = -{resolve'1 _30}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {_30}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s3))
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb17) ]  ] 
    | bb17 = s0 [ s0 = bb20 ] 
    | bb20 = s0 [ s0 =  [ &_25 <- [#"../red_black_tree.rs" 697 9 697 9] () ] s1 | s1 = bb21 ] 
    | bb18 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_35 <- _ret' ] 
             [ &node <- { node with current = ( ^ _35) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _35)}- s2
      | s2 = move_red_left'0 {_35} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_34 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _34} {Borrow.get_id _34}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_33 <- _ret' ] 
             [ &_34 <- { _34 with current = ( ^ _33) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _33)}- s2
      | s2 = {[@expl:type invariant] inv'5 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 =  [ &node <- _33 ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_33 <- _any ] s5) ] )
      | s5 = {[@expl:type invariant] inv'5 _34} s6
      | s6 = -{resolve'2 _34}- s7
      | s7 =  [ &_25 <- [#"../red_black_tree.rs" 695 82 697 9] () ] s8
      | s8 = bb21 ]
      
    | bb21 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_37 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node ( ^ _37) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'6 ( ^ _37)}- s2
      | s2 = delete_min_rec {_37} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_39 <- _ret' ] 
             [ &node <- { node with current = ( ^ _39) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _39)}- s2
      | s2 = balance'0 {_39} (fun (_ret':()) ->  [ &_38 <- _ret' ] s3)
      | s3 = bb23 ]
      
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- r ] (any [ any_ (_any:(k, v))-> (!  [ &r <- _any ] s5) ] )
      | s5 = bb24 ]
      
    | bb24 = s0 [ s0 = bb26 ] 
    | bb4 = s0 [ s0 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_22 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _22) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s3)))
      | s3 = -{inv'0 ( ^ _22)}- s4
      | s4 = Borrow.borrow_final
          <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
          { * _22}
          {Borrow.get_id _22}
          (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_21 <- _ret' ] 
             [ &_22 <- { _22 with current = ( ^ _21) ; } ] 
            s5)
      | s5 = -{inv'0 ( ^ _21)}- s6
      | s6 = take'0 {_21}
          (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->  [ &_20 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'8 _22} s1
      | s1 = -{resolve'4 _22}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 = unwrap'2 {_20} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 node1} s1
      | s1 = -{resolve'5 node1}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {node1}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Node_Type.t_node <k> <v> {node1}
              (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                (any
                [ any_ (_any:k)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                    (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                      
                      [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 _any l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v ]
                      
                      (any
                      [ any_ (_any:v)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                          (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                            
                            [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'1 l_color'1 l_key'1 _any l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                            
                            s3)) ]
                      ))) ]
                )))
      | s3 = bb8 ]
      
    | bb8 = s0 [ s0 = bb9 ] 
    | bb9 = s0 [ s0 = bb25 ] 
    | bb25 = s0 [ s0 = bb26 ] 
    | bb26 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : (k, v) = any_l () : (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _12 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _13 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _14 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _15 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node1 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _20 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _21 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _22 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _25 : () = any_l () : ()
    | & _26 : bool = any_l () : bool
    | & _28 : bool = any_l () : bool
    | & _30 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _31 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _33 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _34 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _35 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & r : (k, v) = any_l () : (k, v)
    | & _37 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _38 : () = any_l () : ()
    | & _39 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:(k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 689 36 689 42] inv'11 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 688 4 688 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[@expl:postcondition] [#"../red_black_tree.rs" 687 14 687 39] color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 685 4 686 71] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k
       -> has_mapping'0 ( ^ self) k v = (eq_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 ( * self) k v)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 684 4 684 100] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'10 k  -> has_mapping'0 ( * self) k v  -> le_log'0 (eq_model'0 (let (a, _) = result in a)) k}
      {[@expl:postcondition] [#"../red_black_tree.rs" 683 14 683 64] has_mapping'0 ( * self) (eq_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 682 14 682 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 681 14 681 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_DeleteMin
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'13 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'13 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'12 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'12 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  predicate invariant'12 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'12 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'11 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'11 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'11 x
  = true
  predicate invariant'11 (self : (k, v))
  let rec invariant'11 (self:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'10 (_x : (k, v))
  let rec inv'10 (_x:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : (k, v) . inv'10 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'10 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'10 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'9 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'9 x = true
  predicate invariant'9 (self : v)
  let rec invariant'9 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'8 (_x : v)
  let rec inv'8 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ] 
  axiom inv'8 : forall x : v . inv'8 x = true
  predicate invariant'8 (self : Core_Option_Option_Type.t_option (k, v))
  let rec invariant'8 (self:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'7 (_x : Core_Option_Option_Type.t_option (k, v))
  let rec inv'7 (_x:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : Core_Option_Option_Type.t_option (k, v) . inv'7 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'6 (_x : eq_model_ty'0)
  let rec inv'6 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'6 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'6 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'6 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'6 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'6 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'6 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'6 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'6 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'6 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'7 (self : eq_model_ty'0)
  let rec invariant'7 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  axiom inv'6 : forall x : eq_model_ty'0 . inv'6 x = true
  predicate invariant'6 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'6 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'5 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'5 x = true
  predicate invariant'5 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'5 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'4 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'4 x = true
  predicate invariant'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'3 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'3 : forall x : RedBlackTree_Node_Type.t_node k v . inv'3 x = true
  predicate invariant'3 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'3 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'2 x = true
  predicate invariant'2 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'2 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'1 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'1 x
  = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  use map.Const
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  function view'1 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use map.Map
  function view'0 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'1 ( * self)
  let rec view'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'5 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'5 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'8 v
     -> inv'6 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'8 v
     -> inv'6 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'11 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'4 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'11 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'4 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'3 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  let rec delete_min_rec'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [#"../red_black_tree.rs" 689 27 689 31] inv'2 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 679 15 680 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 678 15 678 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:(k, v))-> {[#"../red_black_tree.rs" 689 36 689 42] inv'10 result}
      {[#"../red_black_tree.rs" 688 4 688 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[#"../red_black_tree.rs" 687 14 687 39] color_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 685 4 686 71] forall v : v . forall k : eq_model_ty'0 . inv'8 v
       -> inv'6 k
       -> has_mapping'0 ( ^ self) k v = (eq_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 ( * self) k v)}
      {[#"../red_black_tree.rs" 684 4 684 100] forall v : v . forall k : eq_model_ty'0 . inv'8 v
       -> inv'6 k  -> has_mapping'0 ( * self) k v  -> le_log'0 (eq_model'0 (let (a, _) = result in a)) k}
      {[#"../red_black_tree.rs" 683 14 683 64] has_mapping'0 ( * self) (eq_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[#"../red_black_tree.rs" 682 14 682 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 681 14 681 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'9 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty ())
  let rec resolve'0 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'5 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'5 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'6 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'8 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'5 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'6 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'8 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'6 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'5 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'6 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'8 v
   -> has_mapping'0 self k v = (Map.get (view'1 self) k = Core_Option_Option_Type.C_Some v))
  let rec delete_min (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Core_Option_Option_Type.t_option (k, v)))= {[#"../red_black_tree.rs" 712 27 712 31] inv'2 self}
    {[#"../red_black_tree.rs" 703 15 703 34] invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [#"../red_black_tree.rs" 713 8 713 45] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _5}- s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_8 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _8) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'0 ( ^ _8)}- s3
      | s3 = any
        [ br0 -> { * _8 = Core_Option_Option_Type.C_None } (! bb8)
        | br1 (a:RedBlackTree_Node_Type.t_node k v)-> { * _8 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _8} s1
      | s1 = -{resolve'1 _8}- s2
      | s2 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (k, v) ] s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb18 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _8}
          (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
            Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _8) 1}
              (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
                 [ &node <- _ret' ] 
                Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _8}
                  (fun (l_0'0:RedBlackTree_Node_Type.t_node k v) ->
                    
                    [ &_8 <- { _8 with current = (Core_Option_Option_Type.C_Some ( ^ node) : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ; } ]
                    
                    s1)))
      | s1 = -{inv'3 ( ^ node)}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'3 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _8} s3
      | s3 = -{resolve'1 _8}- s4
      | s4 =  [ &_7 <- [#"../red_black_tree.rs" 718 13 718 13] () ] s5
      | s5 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_13 <- RedBlackTree_Color_Type.C_Red ] s1
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 _13 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_13 <- _any ] s2) ] ))
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'3 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 =  [ &_7 <- [#"../red_black_tree.rs" 716 35 718 13] () ] s7
      | s7 = bb7 ]
      
    | bb7 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_16 <- _ret' ] 
             [ &self <- { self with current = ( ^ _16) ; } ] 
            s1)
      | s1 = -{inv'5 ( ^ _16)}- s2
      | s2 = delete_min_rec'0 {_16} (fun (_ret':(k, v)) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = s0 [ s0 = is_red'0 { * self} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 =  [ &_20 <- RedBlackTree_Color_Type.C_Black ] s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_23 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _23) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'0 ( ^ _23)}- s3
      | s3 = as_mut'0 {_23}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_22 <- _ret' ] 
            s4)
      | s4 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _21}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &_21 <- { _21 with current = (RedBlackTree_Node_Type.C_Node l_left'0 _20 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_20 <- _any ] s1) ] ))
      | s1 = {[@expl:type invariant] inv'4 _21} s2
      | s2 = -{resolve'3 _21}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 =  [ &_17 <- [#"../red_black_tree.rs" 723 25 725 9] () ] s6
      | s6 = bb15 ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'2 self}- s2
      | s2 =  [ &_17 <- [#"../red_black_tree.rs" 725 9 725 9] () ] s3
      | s3 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_0 <- Core_Option_Option_Type.C_Some r : Core_Option_Option_Type.t_option (k, v) ] 
        (any [ any_ (_any:(k, v))-> (!  [ &r <- _any ] s1) ] )
      | s1 = bb16 ]
      
    | bb16 = s0 [ s0 = bb17 ] 
    | bb17 = s0 [ s0 = bb18 ] 
    | bb18 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & _5 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty ()
    | & _7 : () = any_l () : ()
    | & _8 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _11 : bool = any_l () : bool
    | & _13 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & r : (k, v) = any_l () : (k, v)
    | & _16 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _17 : () = any_l () : ()
    | & _18 : bool = any_l () : bool
    | & _20 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & _21 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _22 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _23 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ]
    
    [ return' (result:Core_Option_Option_Type.t_option (k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 712 36 712 50] inv'7 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 705 14 711 5] match result with
        | Core_Option_Option_Type.C_Some (k, v) -> Map.get (view'0 self) (eq_model'0 k)
        = Core_Option_Option_Type.C_Some v
        /\ (forall k2 : eq_model_ty'0 . inv'6 k2
         -> Map.get (view'0 self) k2 = Core_Option_Option_Type.C_None \/ le_log'0 (eq_model'0 k) k2)
        /\ view'1 ( ^ self) = Map.set (view'0 self) (eq_model'0 k) (Core_Option_Option_Type.C_None)
        | Core_Option_Option_Type.C_None -> view'1 ( ^ self) = view'0 self
        /\ view'0 self = Const.const (Core_Option_Option_Type.C_None)
        end}
      {[@expl:postcondition] [#"../red_black_tree.rs" 704 14 704 33] invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_DeleteRec
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'21 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'21 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'21 self} (! return' {result}) ]
    
  predicate inv'21 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'21 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'21 _x} (! return' {result}) ]
    
  axiom inv'21 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'21 x = true
  predicate invariant'20 (self : (k, v))
  let rec invariant'20 (self:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'20 self} (! return' {result}) ]
    
  predicate inv'20 (_x : (k, v))
  let rec inv'20 (_x:(k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'20 _x} (! return' {result}) ]
    
  axiom inv'20 : forall x : (k, v) . inv'20 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'19 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'19 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'19 self} (! return' {result}) ]
    
  predicate inv'19 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'19 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'19 _x} (! return' {result}) ]
    
  axiom inv'19 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'19 x = true
  predicate invariant'18 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'18 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'18 self} (! return' {result}) ]
    
  predicate inv'18 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'18 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'18 _x} (! return' {result}) ]
    
  axiom inv'18 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'18 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'17 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'17 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'17 self} (! return' {result}) ]
    
  predicate inv'17 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'17 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'17 _x} (! return' {result}) ]
    
  axiom inv'17 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'17 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'14 (_x : eq_model_ty'0)
  let rec inv'14 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'14 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'14 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'14 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'14 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'14 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'14 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'14 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'14 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'14 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'14 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'14 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'14 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'14 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'14 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'14 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use prelude.Borrow
  predicate invariant'16 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'16 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'16 self} (! return' {result}) ]
    
  predicate inv'16 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'16 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'16 _x} (! return' {result}) ]
    
  axiom inv'16 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'16 x
  = true
  predicate invariant'15 (self : Core_Option_Option_Type.t_option (k, v))
  let rec invariant'15 (self:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'15 self} (! return' {result}) ]
    
  predicate inv'15 (_x : Core_Option_Option_Type.t_option (k, v))
  let rec inv'15 (_x:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'15 _x} (! return' {result}) ]
    
  axiom inv'15 : forall x : Core_Option_Option_Type.t_option (k, v) . inv'15 x = true
  predicate invariant'14 (self : eq_model_ty'0)
  let rec invariant'14 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'14 self} (! return' {result}) ]
    
  axiom inv'14 : forall x : eq_model_ty'0 . inv'14 x = true
  predicate invariant'13 (self : borrowed v)
  let rec invariant'13 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'13 (_x : borrowed v)
  let rec inv'13 (_x:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : borrowed v . inv'13 x = true
  predicate invariant'12 (self : v)
  let rec invariant'12 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : v)
  let rec inv'12 (_x:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : v . inv'12 x = true
  predicate invariant'11 (self : borrowed k)
  let rec invariant'11 (self:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : borrowed k)
  let rec inv'11 (_x:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : borrowed k . inv'11 x = true
  predicate invariant'10 (self : k)
  let rec invariant'10 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : k)
  let rec inv'10 (_x:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : k . inv'10 x = true
  predicate invariant'9 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'9 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'9 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : RedBlackTree_Node_Type.t_node k v . inv'9 x = true
  predicate invariant'8 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'8 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'8 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'8 x = true
  predicate invariant'7 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'7 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'7 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'7 x
  = true
  predicate invariant'6 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'6 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'6 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'6 x = true
  predicate invariant'5 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'5 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'5 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'5 x = true
  predicate invariant'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'3 (self : k)
  let rec invariant'3 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : k)
  let rec inv'3 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ] 
  axiom inv'3 : forall x : k . inv'3 x = true
  predicate invariant'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'1 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'1 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'1 : forall x : RedBlackTree_Node_Type.t_node k v . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  function eq_model'1 (self : k) : eq_model_ty'0
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'1 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'1 self
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'5 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'5 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'1 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'12 v
     -> inv'14 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'1 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'12 v
     -> inv'14 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'1 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  predicate color_invariant'1 [#"../red_black_tree.rs" 279 4 279 36] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 280 8 280 112] color_invariant_here'0 self
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ color_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec color_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'1 self} (! return' {result}) ]
    
  predicate match_n'0 [#"../red_black_tree.rs" 237 4 237 52] (self : RedBlackTree_Cp_Type.t_cp) (node : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 239 12 242 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> RedBlackTree_Node_Type.node_color node = color /\ color_invariant'1 node
      | RedBlackTree_Cp_Type.C_CPN color l r -> RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_n'0 (self:RedBlackTree_Cp_Type.t_cp) (node:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_n'0 self node} (! return' {result}) ]
    
  function height'1 [#"../red_black_tree.rs" 321 4 321 26] (self : RedBlackTree_Node_Type.t_node k v) : int =
    [#"../red_black_tree.rs" 323 12 326 13] match RedBlackTree_Node_Type.node_color self with
      | RedBlackTree_Color_Type.C_Red -> height'0 (RedBlackTree_Node_Type.node_left self)
      | RedBlackTree_Color_Type.C_Black -> height'0 (RedBlackTree_Node_Type.node_left self) + 1
      end
  let rec height'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 321 14 321 18] inv'4 self}
    any [ return' (result:int)-> {result = height'1 self} (! return' {result}) ] 
  axiom height'1_spec : forall self : RedBlackTree_Node_Type.t_node k v . ([#"../red_black_tree.rs" 321 14 321 18] inv'4 self)
   -> ([#"../red_black_tree.rs" 319 4 320 77] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node  -> height'1 self = height'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)))
  predicate has_mapping'1 [#"../red_black_tree.rs" 133 4 133 55] (self : RedBlackTree_Node_Type.t_node k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 134 8 137 9] has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
    \/ has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
    \/ k = eq_model'1 (RedBlackTree_Node_Type.node_key self) /\ v = RedBlackTree_Node_Type.node_val self
  let rec has_mapping'1 (self:RedBlackTree_Node_Type.t_node k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 133 42 133 43] inv'12 v}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 25 133 26] inv'14 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 133 19 133 23] inv'4 self}
    any [ return' (result:bool)-> {result = has_mapping'1 self k v} (! return' {result}) ] 
  axiom has_mapping'1_spec : forall self : RedBlackTree_Node_Type.t_node k v, k : eq_model_ty'0, v : v . ([#"../red_black_tree.rs" 133 19 133 23] inv'4 self)
   -> ([#"../red_black_tree.rs" 133 25 133 26] inv'14 k)
   -> ([#"../red_black_tree.rs" 133 42 133 43] inv'12 v)
   -> ([#"../red_black_tree.rs" 131 4 132 86] forall node : RedBlackTree_Node_Type.t_node k v . inv'1 node
   -> self = node
   -> has_mapping'1 self k v = has_mapping'0 (RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node)) k v)
  predicate same_mappings'0 [#"../red_black_tree.rs" 141 4 141 43] (self : RedBlackTree_Node_Type.t_node k v) (o : RedBlackTree_Node_Type.t_node k v)
    
   =
    [#"../red_black_tree.rs" 142 8 144 9] forall v : v . forall k : eq_model_ty'0 . inv'12 v
     -> inv'14 k  -> has_mapping'1 self k v = has_mapping'1 o k v
  let rec same_mappings'0 (self:RedBlackTree_Node_Type.t_node k v) (o:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = same_mappings'0 self o} (! return' {result}) ]
    
  predicate height_invariant'1 [#"../red_black_tree.rs" 336 4 336 37] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 337 8 337 115] height_invariant_here'0 self
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ height_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'1 self} (! return' {result}) ]
    
  predicate bst_invariant'1 [#"../red_black_tree.rs" 185 4 185 34] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 186 8 188 9] bst_invariant_here'0 self
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_left self)
    /\ bst_invariant'0 (RedBlackTree_Node_Type.node_right self)
  let rec bst_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'1 self} (! return' {result}) ]
    
  predicate internal_invariant'1 [#"../red_black_tree.rs" 370 4 370 43] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 372 12 372 59] bst_invariant'1 self /\ height_invariant'1 self
  let rec internal_invariant'1 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'1 self} (! return' {result}) ]
    
  let rec balance'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 503 20 503 24] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 489 4 489 110] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red  -> false}
    {[@expl:precondition] [#"../red_black_tree.rs" 487 4 488 48] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_right ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 485 4 486 47] RedBlackTree_Node_Type.node_color ( * self)
    = RedBlackTree_Color_Type.C_Red
    /\ color'0 (RedBlackTree_Node_Type.node_left ( * self)) = RedBlackTree_Color_Type.C_Red
     -> color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))}
    {[@expl:precondition] [#"../red_black_tree.rs" 484 15 484 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 501 4 502 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 499 4 500 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 497 4 498 63] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * self)
       -> match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( ^ self)}
      {[#"../red_black_tree.rs" 495 4 496 39] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)
       -> match_n'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( ^ self)}
      {[#"../red_black_tree.rs" 493 4 494 34] color_invariant'0 (RedBlackTree_Node_Type.node_left ( * self))
      /\ color'0 (RedBlackTree_Node_Type.node_right ( * self)) = RedBlackTree_Color_Type.C_Black  ->  * self =  ^ self}
      {[#"../red_black_tree.rs" 492 14 492 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 491 14 491 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 490 14 490 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  let rec move_red_left'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] [#"../red_black_tree.rs" 535 26 535 30] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 519 15 519 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 518 15 518 43] internal_invariant'1 ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 517 15 517 41] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( * self))
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[#"../red_black_tree.rs" 535 35 535 44] inv'6 result}
      {[#"../red_black_tree.rs" 533 4 534 45] color_invariant'1 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_right ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 531 14 532 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[#"../red_black_tree.rs" 529 4 530 108] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k
       -> has_mapping'1 ( ^ self) k v
      = (has_mapping'1 ( ^ result) k v \/ has_mapping'1 ( * self) k v /\ not has_mapping'1 ( * result) k v)}
      {[#"../red_black_tree.rs" 527 4 528 47] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k
       -> has_mapping'1 ( * self) k v /\ le_log'0 k (eq_model'1 (RedBlackTree_Node_Type.node_key ( * self)))
       -> has_mapping'1 ( * result) k v}
      {[#"../red_black_tree.rs" 526 4 526 103] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'1 ( * result) k v  -> has_mapping'1 ( * self) k v}
      {[#"../red_black_tree.rs" 525 14 525 42] RedBlackTree_Node_Type.node_key ( * self)
      = RedBlackTree_Node_Type.node_key ( * result)}
      {[#"../red_black_tree.rs" 524 4 524 97] height'1 ( * result) = height'1 ( ^ result)
       -> height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 521 4 523 48] internal_invariant'1 ( ^ result)
      /\ height'1 ( * result) = height'1 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'1 ( ^ result) k v  -> has_mapping'1 ( * result) k v)
       -> internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 520 14 520 44] internal_invariant'1 ( * result)}
      (! return' {result}) ]
    
  predicate resolve'9 (self : borrowed v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'9 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'9 self} (! return' {result}) ]
    
  let rec swap'1 (x:borrowed v) (y:borrowed v) (return'  (ret:()))= {[@expl:precondition] inv'13 y}
    {[@expl:precondition] inv'13 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'8 (self : borrowed k) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'8 (self:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'8 self} (! return' {result}) ]
    
  let rec swap'0 (x:borrowed k) (y:borrowed k) (return'  (ret:()))= {[@expl:precondition] inv'11 y}
    {[@expl:precondition] inv'11 x}
    any
    [ return' (result:())-> {[#"../../../../creusot-contracts/src/std/mem.rs" 14 22 14 30]  ^ y =  * x}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 13 22 13 30]  ^ x =  * y}
      (! return' {result}) ]
    
  predicate resolve'7 (self : Snapshot.snap_ty ())
  let rec resolve'7 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'7 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use map.Map
  use map.Map
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'0 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'14 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'21 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'5 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'5 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'21 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'14 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'12 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'14 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'21 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'5 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'21 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'14 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'12 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'14 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'5 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'14 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'12 v
   -> has_mapping'0 self k v = (Map.get (view'0 self) k = Core_Option_Option_Type.C_Some v))
  function has_mapping_inj'0 [#"../red_black_tree.rs" 118 4 120 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v1 : v) (v2 : v) : ()
    
   =
    [#"../red_black_tree.rs" 123 12 123 37] let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
      | Core_Option_Option_Type.C_None -> ()
      | Core_Option_Option_Type.C_Some _v -> ()
      end
  let rec has_mapping_inj'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v1:v) (v2:v) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 118 53 118 55] inv'12 v2}
    {[@expl:precondition] [#"../red_black_tree.rs" 118 46 118 48] inv'12 v1}
    {[@expl:precondition] [#"../red_black_tree.rs" 118 29 118 30] inv'14 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 118 23 118 27] inv'5 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 116 15 116 38] has_mapping'0 self k v2}
    {[@expl:precondition] [#"../red_black_tree.rs" 115 15 115 38] has_mapping'0 self k v1}
    {[@expl:precondition] [#"../red_black_tree.rs" 114 15 114 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_inj'0 self k v1 v2} (! return' {result}) ] 
  axiom has_mapping_inj'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0, v1 : v, v2 : v . ([#"../red_black_tree.rs" 114 15 114 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 115 15 115 38] has_mapping'0 self k v1)
   -> ([#"../red_black_tree.rs" 116 15 116 38] has_mapping'0 self k v2)
   -> ([#"../red_black_tree.rs" 118 23 118 27] inv'5 self)
   -> ([#"../red_black_tree.rs" 118 29 118 30] inv'14 k)
   -> ([#"../red_black_tree.rs" 118 46 118 48] inv'12 v1)
   -> ([#"../red_black_tree.rs" 118 53 118 55] inv'12 v2)  -> ([#"../red_black_tree.rs" 117 14 117 22] v1 = v2)
  let rec delete_min_rec'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:(k, v)))= {[@expl:precondition] [#"../red_black_tree.rs" 689 27 689 31] inv'8 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 679 15 680 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 678 15 678 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:(k, v))-> {[#"../red_black_tree.rs" 689 36 689 42] inv'20 result}
      {[#"../red_black_tree.rs" 688 4 688 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[#"../red_black_tree.rs" 687 14 687 39] color_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 685 4 686 71] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k
       -> has_mapping'0 ( ^ self) k v = (eq_model'1 (let (a, _) = result in a) <> k /\ has_mapping'0 ( * self) k v)}
      {[#"../red_black_tree.rs" 684 4 684 100] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'0 ( * self) k v  -> le_log'0 (eq_model'1 (let (a, _) = result in a)) k}
      {[#"../red_black_tree.rs" 683 14 683 64] has_mapping'0 ( * self) (eq_model'1 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[#"../red_black_tree.rs" 682 14 682 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 681 14 681 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  let rec move_red_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] [#"../red_black_tree.rs" 564 27 564 31] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 548 15 548 86] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Red) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 547 15 547 43] internal_invariant'1 ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 546 15 546 40] RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {[#"../red_black_tree.rs" 564 36 564 45] inv'6 result}
      {[#"../red_black_tree.rs" 562 4 563 45] color_invariant'1 ( ^ result)
      /\ (color'0 (RedBlackTree_Node_Type.node_left ( * result)) = RedBlackTree_Color_Type.C_Black
       -> RedBlackTree_Node_Type.node_color ( ^ result) = RedBlackTree_Color_Type.C_Black)
       -> color_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 560 14 561 61] match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)
      \/ match_n'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red))) ( * result)}
      {[#"../red_black_tree.rs" 558 4 559 108] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k
       -> has_mapping'1 ( ^ self) k v
      = (has_mapping'1 ( ^ result) k v \/ has_mapping'1 ( * self) k v /\ not has_mapping'1 ( * result) k v)}
      {[#"../red_black_tree.rs" 556 4 557 47] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k
       -> has_mapping'1 ( * self) k v /\ le_log'0 (eq_model'1 (RedBlackTree_Node_Type.node_key ( * self))) k
       -> has_mapping'1 ( * result) k v}
      {[#"../red_black_tree.rs" 555 4 555 103] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'1 ( * result) k v  -> has_mapping'1 ( * self) k v}
      {[#"../red_black_tree.rs" 554 14 554 42] RedBlackTree_Node_Type.node_key ( * result)
      = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 553 4 553 97] height'1 ( * result) = height'1 ( ^ result)
       -> height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 550 4 552 48] internal_invariant'1 ( ^ result)
      /\ height'1 ( * result) = height'1 ( ^ result)
      /\ (forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'1 ( ^ result) k v  -> has_mapping'1 ( * result) k v)
       -> internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 549 14 549 44] internal_invariant'1 ( * result)}
      (! return' {result}) ]
    
  predicate resolve'6 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'6 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  let rec unwrap'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'19 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'9 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_ref'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'18 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'19 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 66 16 68 18] self = Core_Option_Option_Type.C_None
      \/ (exists r : RedBlackTree_Node_Type.t_node k v . inv'9 r
      /\ result = Core_Option_Option_Type.C_Some r /\ self = Core_Option_Option_Type.C_Some r)}
      {[#"../../../../creusot-contracts/src/std/option.rs" 65 16 65 60] self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  predicate resolve'10 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'10 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'10 self} (! return' {result}) ]
    
  predicate resolve'5 (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 35 8 35 31] resolve'10 self
  let rec resolve'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  let rec unwrap'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:RedBlackTree_Node_Type.t_node k v))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:RedBlackTree_Node_Type.t_node k v)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate is_default'0 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/std/option.rs" 146 20 146 32] self = Core_Option_Option_Type.C_None
  let rec is_default'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = is_default'0 self} (! return' {result}) ]
    
  let rec take'0 (dest:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'7 dest}
    any
    [ return' (result:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))-> {inv'0 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 18 22 18 42] is_default'0 ( ^ dest)}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 17 22 17 37] result =  * dest}
      (! return' {result}) ]
    
  predicate resolve'2 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'2 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  let rec is_none'0 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= {[@expl:precondition] inv'18 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec rotate_right'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 405 25 405 29] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 394 15 394 42] color'0 (RedBlackTree_Node_Type.node_left ( * self))
    = RedBlackTree_Color_Type.C_Red}
    {[@expl:precondition] [#"../red_black_tree.rs" 393 15 393 43] internal_invariant'1 ( * self)}
    any
    [ return' (result:())-> {[#"../red_black_tree.rs" 401 4 404 36] exists r : RedBlackTree_Node_Type.t_node k v . exists l : RedBlackTree_Node_Type.t_node k v . inv'1 r
      /\ inv'1 l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_left ( * self))
      = Core_Option_Option_Type.C_Some l
      /\ RedBlackTree_Tree_Type.tree_node (RedBlackTree_Node_Type.node_right ( ^ self))
      = Core_Option_Option_Type.C_Some r
      /\ (RedBlackTree_Node_Type.node_left ( ^ self), RedBlackTree_Node_Type.node_left r, RedBlackTree_Node_Type.node_right r)
      = (RedBlackTree_Node_Type.node_left l, RedBlackTree_Node_Type.node_right l, RedBlackTree_Node_Type.node_right ( * self))
      /\ RedBlackTree_Node_Type.node_key r = RedBlackTree_Node_Type.node_key ( * self)}
      {[#"../red_black_tree.rs" 400 14 400 44] RedBlackTree_Node_Type.node_color ( ^ self)
      = RedBlackTree_Node_Type.node_color ( * self)}
      {[#"../red_black_tree.rs" 399 14 399 42] color'0 (RedBlackTree_Node_Type.node_right ( ^ self))
      = RedBlackTree_Color_Type.C_Red}
      {[#"../red_black_tree.rs" 398 14 398 61] lt_log'0 (eq_model'1 (RedBlackTree_Node_Type.node_key ( ^ self))) (eq_model'1 (RedBlackTree_Node_Type.node_key ( * self)))}
      {[#"../red_black_tree.rs" 397 14 397 50] height'1 ( * self) = height'1 ( ^ self)}
      {[#"../red_black_tree.rs" 396 14 396 42] internal_invariant'1 ( ^ self)}
      {[#"../red_black_tree.rs" 395 14 395 42] same_mappings'0 ( * self) ( ^ self)}
      (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'17 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 81] result
      = cmp_log'0 (eq_model'1 self) (eq_model'1 other)}
      (! return' {result}) ]
    
  predicate resolve'1 (self : k)
  let rec resolve'1 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'0 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec as_mut'1 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'6 result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 36 26 36 43]  ^ self =  ^ result}
      {[#"../../../../creusot-contracts/src/std/boxed.rs" 35 26 35 43]  * self =  * result}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'16 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'16 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'2 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  let rec delete_rec (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (return'  (ret:Core_Option_Option_Type.t_option (k, v)))= {[#"../red_black_tree.rs" 741 29 741 32] inv'3 key}
    {[#"../red_black_tree.rs" 741 23 741 27] inv'8 self}
    {[#"../red_black_tree.rs" 730 15 731 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[#"../red_black_tree.rs" 729 15 729 43] internal_invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_16 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _16) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'0 ( ^ _16)}- s2
      | s2 = as_mut'0 {_16}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_15 <- _ret' ] 
            s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_15} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _14} {Borrow.get_id _14}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_13 <- _ret' ] 
             [ &_14 <- { _14 with current = ( ^ _13) ; } ] 
            s1)
      | s1 = -{inv'1 ( ^ _13)}- s2
      | s2 = as_mut'1 {_13} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &node <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
             [ &_21 <- rkey'0 ] 
            s3)
      | s3 = {[@expl:type invariant] inv'3 _21} s4
      | s4 = -{resolve'1 _21}- s5
      | s5 = cmp'0 {key} {_21} (fun (_ret':Core_Cmp_Ordering_Type.t_ordering) ->  [ &_18 <- _ret' ] s6)
      | s6 = bb4 ]
      
    | bb4 = s0
      [ s0 = any
        [ br0 -> {_18 = Core_Cmp_Ordering_Type.C_Less } (! bb6)
        | br1 -> {_18 = Core_Cmp_Ordering_Type.C_Equal } (! bb5)
        | br2 -> {_18 = Core_Cmp_Ordering_Type.C_Greater } (! bb5) ]
         ]
      
    | bb5 = s0
      [ s0 =  [ &ord <- _18 ] s1
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s2))
      | s2 = bb26 ]
      
    | bb26 = s0 [ s0 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ]  ] 
    | bb27 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Node_Type.t_node k v> { * node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_45 <- _ret' ] 
             [ &node <- { node with current = ( ^ _45) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _45)}- s2
      | s2 = rotate_right'0 {_45} (fun (_ret':()) ->  [ &_44 <- _ret' ] s3)
      | s3 = bb28 ]
      
    | bb28 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_47 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _47) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'5 ( ^ _47)}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'1 key}- s4
      | s4 = delete_rec {_47} {key} (fun (_ret':Core_Option_Option_Type.t_option (k, v)) ->  [ &_46 <- _ret' ] s5)
      | s5 = bb29 ]
      
    | bb29 = s0 [ s0 = bb30 ] 
    | bb30 = s0
      [ s0 =  [ &r <- _46 ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &_46 <- _any ] s1) ] )
      | s1 =  [ &_17 <- [#"../red_black_tree.rs" 757 20 757 50] () ] s2
      | s2 = bb32 ]
      
    | bb32 = s0 [ s0 = bb68 ] 
    | bb33 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s1)))
      | s1 = bb34 ]
      
    | bb34 = s0 [ s0 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ]  ] 
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'6 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'1 key}- s4
      | s4 = any
        [ br0 -> {ord = Core_Cmp_Ordering_Type.C_Less } (! bb38)
        | br1 -> {ord = Core_Cmp_Ordering_Type.C_Equal } (! bb38)
        | br2 -> {ord = Core_Cmp_Ordering_Type.C_Greater } (! bb36) ]
         ]
      
    | bb38 = s0
      [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_59 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _59) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'0 ( ^ _59)}- s2
      | s2 = Borrow.borrow_final
          <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
          { * _59}
          {Borrow.get_id _59}
          (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_58 <- _ret' ] 
             [ &_59 <- { _59 with current = ( ^ _58) ; } ] 
            s3)
      | s3 = -{inv'0 ( ^ _58)}- s4
      | s4 = take'0 {_58}
          (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->  [ &_57 <- _ret' ] s5)
      | s5 = bb39 ]
      
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'7 _59} s1
      | s1 = -{resolve'3 _59}- s2
      | s2 = {[@expl:type invariant] inv'8 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = unwrap'1 {_57} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb40 ]
      
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'1 node1} s1
      | s1 = -{resolve'5 node1}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {node1}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Node_Type.t_node <k> <v> {node1}
              (fun (rleft'1:RedBlackTree_Tree_Type.t_tree k v) (rcolor'1:RedBlackTree_Color_Type.t_color) (rkey'1:k) (rval'1:v) (rright'1:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_60 <- (rkey'0, rval'1) ] 
                (any
                [ any_ (_any:k)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                    (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                      
                      [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 _any l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v ]
                      
                      (any
                      [ any_ (_any:v)-> (! RedBlackTree_Node_Type.t_node <k> <v> {node1}
                          (fun (l_left'1:RedBlackTree_Tree_Type.t_tree k v) (l_color'1:RedBlackTree_Color_Type.t_color) (l_key'1:k) (l_val'1:v) (l_right'1:RedBlackTree_Tree_Type.t_tree k v) ->
                            
                            [ &node1 <- RedBlackTree_Node_Type.C_Node l_left'1 l_color'1 l_key'1 _any l_right'1 : RedBlackTree_Node_Type.t_node k v ]
                            
                            s3)) ]
                      ))) ]
                )))
      | s3 = bb41 ]
      
    | bb41 = s0 [ s0 = bb42 ] 
    | bb42 = s0
      [ s0 =  [ &_0 <- Core_Option_Option_Type.C_Some _60 : Core_Option_Option_Type.t_option (k, v) ] 
        (any [ any_ (_any:(k, v))-> (!  [ &_60 <- _any ] s1) ] )
      | s1 = bb43 ]
      
    | bb43 = s0 [ s0 = bb72 ] 
    | bb72 = s0 [ s0 = bb73 ] 
    | bb36 = s0 [ s0 = bb37 ] 
    | bb37 = s0
      [ s0 = {[@expl:type invariant] inv'8 self} s1
      | s1 = -{resolve'4 self}- s2
      | s2 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (k, v) ] s3
      | s3 = bb73 ]
      
    | bb73 = s0 [ s0 = bb74 ] 
    | bb44 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rright'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &_67 <- _ret' ] 
                    s1)))
      | s1 = bb45 ]
      
    | bb45 = s0
      [ s0 = unwrap'2 {_67} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &_66 <- _ret' ] s1) | s1 = bb46 ]
      
    | bb46 = s0
      [ s0 = {[@expl:type invariant] inv'9 _66} s1
      | s1 = -{resolve'6 _66}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {_66}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_64 <- _ret' ] s3))
      | s3 = bb47 ]
      
    | bb47 = s0 [ s0 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb48) ]  ] 
    | bb48 = s0 [ s0 =  [ &_63 <- [#"../red_black_tree.rs" 768 21 768 21] () ] s1 | s1 = bb51 ] 
    | bb49 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_71 <- _ret' ] 
             [ &node <- { node with current = ( ^ _71) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _71)}- s2
      | s2 = move_red_right'0 {_71} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_70 <- _ret' ] s3)
      | s3 = bb50 ]
      
    | bb50 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _70} {Borrow.get_id _70}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_69 <- _ret' ] 
             [ &_70 <- { _70 with current = ( ^ _69) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _69)}- s2
      | s2 = {[@expl:type invariant] inv'6 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 =  [ &node <- _69 ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_69 <- _any ] s5) ] )
      | s5 = {[@expl:type invariant] inv'6 _70} s6
      | s6 = -{resolve'2 _70}- s7
      | s7 =  [ &_63 <- [#"../red_black_tree.rs" 766 72 768 21] () ] s8
      | s8 = bb51 ]
      
    | bb51 = s0
      [ s0 = any
        [ br0 -> {ord = Core_Cmp_Ordering_Type.C_Less } (! bb63)
        | br1 -> {ord = Core_Cmp_Ordering_Type.C_Equal } (! bb52)
        | br2 -> {ord = Core_Cmp_Ordering_Type.C_Greater } (! bb63) ]
         ]
      
    | bb63 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_90 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _90) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'5 ( ^ _90)}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'1 key}- s4
      | s4 = delete_rec {_90} {key} (fun (_ret':Core_Option_Option_Type.t_option (k, v)) ->  [ &_89 <- _ret' ] s5)
      | s5 = bb64 ]
      
    | bb64 = s0 [ s0 = bb65 ] 
    | bb65 = s0
      [ s0 =  [ &r <- _89 ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &_89 <- _any ] s1) ] )
      | s1 =  [ &_17 <- [#"../red_black_tree.rs" 776 24 776 54] () ] s2
      | s2 = bb67 ]
      
    | bb67 = s0 [ s0 = bb68 ] 
    | bb52 = s0 [ s0 = bb53 ] 
    | bb53 = s0
      [ s0 = {[@expl:type invariant] inv'3 key} s1
      | s1 = -{resolve'1 key}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_74 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _74) : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s3)))
      | s3 = -{inv'5 ( ^ _74)}- s4
      | s4 = delete_min_rec'0 {_74} (fun (_ret':(k, v)) ->  [ &kv <- _ret' ] s5)
      | s5 = bb54 ]
      
    | bb54 = s0 [ s0 =  [ &_75 <- [#"../red_black_tree.rs" 771 24 771 59] Snapshot.new () ] s1 | s1 = bb55 ] 
    | bb55 = s0
      [ s0 = -{resolve'7 _75}- s1
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <k> {rkey'0}
              (fun (_ret':borrowed k) ->
                 [ &_79 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 ( ^ _79) l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'10 ( ^ _79)}- s3
      | s3 = Borrow.borrow_final <k> { * _79} {Borrow.get_id _79}
          (fun (_ret':borrowed k) ->  [ &_78 <- _ret' ]  [ &_79 <- { _79 with current = ( ^ _78) ; } ] s4)
      | s4 = -{inv'10 ( ^ _78)}- s5
      | s5 = Borrow.borrow_mut <k> {let (r'0, _) = kv in r'0}
          (fun (_ret':borrowed k) ->  [ &_81 <- _ret' ]  [ &kv <- let (_, l'2) = kv in ( ^ _81, l'2) ] s6)
      | s6 = -{inv'10 ( ^ _81)}- s7
      | s7 = Borrow.borrow_final <k> { * _81} {Borrow.get_id _81}
          (fun (_ret':borrowed k) ->  [ &_80 <- _ret' ]  [ &_81 <- { _81 with current = ( ^ _80) ; } ] s8)
      | s8 = -{inv'10 ( ^ _80)}- s9
      | s9 = swap'0 {_78} {_80} (fun (_ret':()) ->  [ &_77 <- _ret' ] s10)
      | s10 = bb56 ]
      
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'11 _81} s1
      | s1 = -{resolve'8 _81}- s2
      | s2 = {[@expl:type invariant] inv'11 _79} s3
      | s3 = -{resolve'8 _79}- s4
      | s4 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <v> {rval'0}
              (fun (_ret':borrowed v) ->
                 [ &_84 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 ( ^ _84) l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s5)))
      | s5 = -{inv'12 ( ^ _84)}- s6
      | s6 = Borrow.borrow_final <v> { * _84} {Borrow.get_id _84}
          (fun (_ret':borrowed v) ->  [ &_83 <- _ret' ]  [ &_84 <- { _84 with current = ( ^ _83) ; } ] s7)
      | s7 = -{inv'12 ( ^ _83)}- s8
      | s8 = Borrow.borrow_mut <v> {let (_, r'0) = kv in r'0}
          (fun (_ret':borrowed v) ->  [ &_86 <- _ret' ]  [ &kv <- let (l'1, _) = kv in (l'1,  ^ _86) ] s9)
      | s9 = -{inv'12 ( ^ _86)}- s10
      | s10 = Borrow.borrow_final <v> { * _86} {Borrow.get_id _86}
          (fun (_ret':borrowed v) ->  [ &_85 <- _ret' ]  [ &_86 <- { _86 with current = ( ^ _85) ; } ] s11)
      | s11 = -{inv'12 ( ^ _85)}- s12
      | s12 = swap'1 {_83} {_85} (fun (_ret':()) ->  [ &_82 <- _ret' ] s13)
      | s13 = bb57 ]
      
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'13 _86} s1
      | s1 = -{resolve'9 _86}- s2
      | s2 = {[@expl:type invariant] inv'13 _84} s3
      | s3 = -{resolve'9 _84}- s4
      | s4 =  [ &_87 <- Core_Option_Option_Type.C_Some kv : Core_Option_Option_Type.t_option (k, v) ] 
        (any [ any_ (_any:(k, v))-> (!  [ &kv <- _any ] s5) ] )
      | s5 = bb58 ]
      
    | bb58 = s0 [ s0 = bb59 ] 
    | bb59 = s0
      [ s0 =  [ &r <- _87 ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &_87 <- _any ] s1) ] )
      | s1 =  [ &_17 <- [#"../red_black_tree.rs" 774 24 774 36] () ] s2
      | s2 = bb61 ]
      
    | bb61 = s0 [ s0 = bb62 ] 
    | bb62 = s0 [ s0 = bb68 ] 
    | bb68 = s0 [ s0 = bb69 ] 
    | bb6 = s0 [ s0 = bb7 ] 
    | bb7 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)))
      | s1 = bb8 ]
      
    | bb8 = s0 [ s0 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ]  ] 
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'6 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'1 key}- s4
      | s4 = {[@expl:type invariant] inv'8 self} s5
      | s5 = -{resolve'4 self}- s6
      | s6 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (k, v) ] s7
      | s7 = bb74 ]
      
    | bb74 = s0 [ s0 = bb75 ] 
    | bb75 = s0 [ s0 = bb76 ] 
    | bb10 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = s0 [ s0 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb12) ]  ] 
    | bb12 = s0 [ s0 = bb20 ] 
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            RedBlackTree_Tree_Type.t_tree <k> <v> {rleft'0}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &_33 <- _ret' ] 
                    s1)))
      | s1 = bb14 ]
      
    | bb14 = s0
      [ s0 = unwrap'2 {_33} (fun (_ret':RedBlackTree_Node_Type.t_node k v) ->  [ &_32 <- _ret' ] s1) | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'9 _32} s1
      | s1 = -{resolve'6 _32}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {_32}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s3))
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ]  ] 
    | bb17 = s0 [ s0 = bb20 ] 
    | bb20 = s0 [ s0 =  [ &_27 <- [#"../red_black_tree.rs" 751 17 751 17] () ] s1 | s1 = bb21 ] 
    | bb18 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_37 <- _ret' ] 
             [ &node <- { node with current = ( ^ _37) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _37)}- s2
      | s2 = move_red_left'0 {_37} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_36 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * _36} {Borrow.get_id _36}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_35 <- _ret' ] 
             [ &_36 <- { _36 with current = ( ^ _35) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _35)}- s2
      | s2 = {[@expl:type invariant] inv'6 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 =  [ &node <- _35 ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Node_Type.t_node k v))-> (!  [ &_35 <- _any ] s5) ] )
      | s5 = {[@expl:type invariant] inv'6 _36} s6
      | s6 = -{resolve'2 _36}- s7
      | s7 =  [ &_27 <- [#"../red_black_tree.rs" 749 90 751 17] () ] s8
      | s8 = bb21 ]
      
    | bb21 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'0}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_39 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node ( ^ _39) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s1)))
      | s1 = -{inv'5 ( ^ _39)}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'1 key}- s4
      | s4 = delete_rec {_39} {key} (fun (_ret':Core_Option_Option_Type.t_option (k, v)) ->  [ &_38 <- _ret' ] s5)
      | s5 = bb22 ]
      
    | bb22 = s0 [ s0 = bb23 ] 
    | bb23 = s0
      [ s0 =  [ &r <- _38 ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &_38 <- _any ] s1) ] )
      | s1 =  [ &_17 <- [#"../red_black_tree.rs" 752 16 752 45] () ] s2
      | s2 = bb25 ]
      
    | bb25 = s0 [ s0 = bb69 ] 
    | bb69 = s0
      [ s0 = Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> { * node} {Borrow.get_id node}
          (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
             [ &_93 <- _ret' ] 
             [ &node <- { node with current = ( ^ _93) ; } ] 
            s1)
      | s1 = -{inv'4 ( ^ _93)}- s2
      | s2 = balance'0 {_93} (fun (_ret':()) ->  [ &_92 <- _ret' ] s3)
      | s3 = bb70 ]
      
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'6 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'8 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 =  [ &_0 <- r ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &r <- _any ] s5) ] )
      | s5 = bb71 ]
      
    | bb71 = s0 [ s0 = bb76 ] 
    | bb76 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & key : k = key
    | & r : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _13 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _14 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _15 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _16 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _17 : () = any_l () : ()
    | & _18 : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _21 : k = any_l () : k
    | & _24 : bool = any_l () : bool
    | & _27 : () = any_l () : ()
    | & _28 : bool = any_l () : bool
    | & _30 : bool = any_l () : bool
    | & _32 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _33 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _35 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _36 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _37 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _38 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & _39 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & ord : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _42 : bool = any_l () : bool
    | & _44 : () = any_l () : ()
    | & _45 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _46 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & _47 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _50 : bool = any_l () : bool
    | & node1 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _57 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _58 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _59 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & _60 : (k, v) = any_l () : (k, v)
    | & _63 : () = any_l () : ()
    | & _64 : bool = any_l () : bool
    | & _66 : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _67 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & _69 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _70 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _71 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & kv : (k, v) = any_l () : (k, v)
    | & _74 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _75 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty ()
    | & _77 : () = any_l () : ()
    | & _78 : borrowed k = any_l () : borrowed k
    | & _79 : borrowed k = any_l () : borrowed k
    | & _80 : borrowed k = any_l () : borrowed k
    | & _81 : borrowed k = any_l () : borrowed k
    | & _82 : () = any_l () : ()
    | & _83 : borrowed v = any_l () : borrowed v
    | & _84 : borrowed v = any_l () : borrowed v
    | & _85 : borrowed v = any_l () : borrowed v
    | & _86 : borrowed v = any_l () : borrowed v
    | & _87 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & _89 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & _90 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _92 : () = any_l () : ()
    | & _93 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v) ]
    
    [ return' (result:Core_Option_Option_Type.t_option (k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 741 41 741 55] inv'15 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 740 4 740 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[@expl:postcondition] [#"../red_black_tree.rs" 739 14 739 39] color_invariant'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 738 4 738 125] forall v : v . forall k : eq_model_ty'0 . inv'12 v
       -> inv'14 k  -> has_mapping'0 ( ^ self) k v = (eq_model'0 key <> k /\ has_mapping'0 ( * self) k v)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 734 14 737 5] match result with
        | Core_Option_Option_Type.C_None -> forall v : v . inv'12 v  -> not has_mapping'0 ( * self) (eq_model'0 key) v
        | Core_Option_Option_Type.C_Some (k, v) -> eq_model'0 key = eq_model'1 k
        /\ has_mapping'0 ( * self) (eq_model'1 k) v
        end}
      {[@expl:postcondition] [#"../red_black_tree.rs" 733 14 733 50] height'0 ( * self) = height'0 ( ^ self)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 732 14 732 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_Delete
  type k
  type v
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  type eq_model_ty'0
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'8 (_x : eq_model_ty'0)
  let rec inv'8 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  predicate invariant'13 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'13 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'12 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'12 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  use prelude.Borrow
  predicate invariant'12 (self : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'12 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'11 (_x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'11 (_x:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) . inv'11 x
  = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'11 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'11 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'10 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'10 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'10 x = true
  predicate invariant'10 (self : v)
  let rec invariant'10 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : v)
  let rec inv'9 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ] 
  axiom inv'9 : forall x : v . inv'9 x = true
  predicate invariant'9 (self : eq_model_ty'0)
  let rec invariant'9 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  axiom inv'8 : forall x : eq_model_ty'0 . inv'8 x = true
  predicate invariant'8 (self : Core_Option_Option_Type.t_option (k, v))
  let rec invariant'8 (self:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'7 (_x : Core_Option_Option_Type.t_option (k, v))
  let rec inv'7 (_x:Core_Option_Option_Type.t_option (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : Core_Option_Option_Type.t_option (k, v) . inv'7 x = true
  predicate invariant'7 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'7 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'6 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'6 x = true
  predicate invariant'6 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'6 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'5 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 x = true
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'4 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'4 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'3 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'3 x = true
  predicate invariant'3 (self : k)
  let rec invariant'3 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'2 (_x : k)
  let rec inv'2 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : k . inv'2 x = true
  predicate invariant'2 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'2 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'1 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'1 x
  = true
  predicate invariant'1 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'1 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'0 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'0 x = true
  use map.Map
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'1 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use map.Map
  function view'0 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'1 ( * self)
  let rec view'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  function eq_model'1 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'0 self
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'6 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'6 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'0 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'8 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'0 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'9 v
     -> inv'8 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'0 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:borrowed (RedBlackTree_Node_Type.t_node k v)))= {[@expl:precondition] inv'11 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:borrowed (RedBlackTree_Node_Type.t_node k v))-> {inv'5 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec as_mut'0 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)))-> {inv'11 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 58 16 61 18]  * self = Core_Option_Option_Type.C_None
      \/ (exists r : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'5 r
      /\ result = Core_Option_Option_Type.C_Some r
      /\  * self = Core_Option_Option_Type.C_Some ( * r) /\  ^ self = Core_Option_Option_Type.C_Some ( ^ r))}
      {[#"../../../../creusot-contracts/src/std/option.rs" 57 16 57 77]  * self = Core_Option_Option_Type.C_None
       -> result = Core_Option_Option_Type.C_None /\  ^ self = Core_Option_Option_Type.C_None}
      (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  function cpn'0 [#"../red_black_tree.rs" 219 0 219 36] (c : RedBlackTree_Color_Type.t_color) (l : RedBlackTree_Cp_Type.t_cp) (r : RedBlackTree_Cp_Type.t_cp) : RedBlackTree_Cp_Type.t_cp
    
   =
    [#"../red_black_tree.rs" 220 16 220 48] RedBlackTree_Cp_Type.C_CPN c l r
  let rec cpn'0 (c:RedBlackTree_Color_Type.t_color) (l:RedBlackTree_Cp_Type.t_cp) (r:RedBlackTree_Cp_Type.t_cp) (return'  (ret:RedBlackTree_Cp_Type.t_cp))= any
    [ return' (result:RedBlackTree_Cp_Type.t_cp)-> {result = cpn'0 c l r} (! return' {result}) ]
    
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'4 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  let rec delete_rec'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (return'  (ret:Core_Option_Option_Type.t_option (k, v)))= {[@expl:precondition] [#"../red_black_tree.rs" 741 29 741 32] inv'2 key}
    {[@expl:precondition] [#"../red_black_tree.rs" 741 23 741 27] inv'3 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 730 15 731 62] match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) ( * self)
    \/ match_t'0 (cpn'0 (RedBlackTree_Color_Type.C_Black) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Red)) (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black))) ( * self)}
    {[@expl:precondition] [#"../red_black_tree.rs" 729 15 729 43] internal_invariant'0 ( * self)}
    any
    [ return' (result:Core_Option_Option_Type.t_option (k, v))-> {[#"../red_black_tree.rs" 741 41 741 55] inv'7 result}
      {[#"../red_black_tree.rs" 740 4 740 69] color'0 ( * self) = RedBlackTree_Color_Type.C_Black
       -> color'0 ( ^ self) = RedBlackTree_Color_Type.C_Black}
      {[#"../red_black_tree.rs" 739 14 739 39] color_invariant'0 ( ^ self)}
      {[#"../red_black_tree.rs" 738 4 738 125] forall v : v . forall k : eq_model_ty'0 . inv'9 v
       -> inv'8 k  -> has_mapping'0 ( ^ self) k v = (eq_model'1 key <> k /\ has_mapping'0 ( * self) k v)}
      {[#"../red_black_tree.rs" 734 14 737 5] match result with
        | Core_Option_Option_Type.C_None -> forall v : v . inv'9 v  -> not has_mapping'0 ( * self) (eq_model'1 key) v
        | Core_Option_Option_Type.C_Some (k, v) -> eq_model'1 key = eq_model'0 k
        /\ has_mapping'0 ( * self) (eq_model'0 k) v
        end}
      {[#"../red_black_tree.rs" 733 14 733 50] height'0 ( * self) = height'0 ( ^ self)}
      {[#"../red_black_tree.rs" 732 14 732 42] internal_invariant'0 ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  let rec is_red'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= {[@expl:precondition] [#"../red_black_tree.rs" 381 15 381 19] inv'10 self}
    any
    [ return' (result:bool)-> {[#"../red_black_tree.rs" 380 14 380 45] result
      = (color'0 self = RedBlackTree_Color_Type.C_Red)}
      (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate resolve'2 (self : k)
  let rec resolve'2 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty ())
  let rec resolve'0 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'6 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'8 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'9 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'0 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'8 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'9 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'6 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'8 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'9 v
   -> has_mapping'0 self k v = (Map.get (view'1 self) k = Core_Option_Option_Type.C_Some v))
  let rec delete (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (return'  (ret:Core_Option_Option_Type.t_option (k, v)))= {[#"../red_black_tree.rs" 793 29 793 32] inv'2 key}
    {[#"../red_black_tree.rs" 793 23 793 27] inv'3 self}
    {[#"../red_black_tree.rs" 785 15 785 34] invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_7 <- [#"../red_black_tree.rs" 794 8 794 45] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _7}- s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_mut <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)> {rnode'0}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_10 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _10) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'0 ( ^ _10)}- s3
      | s3 = any
        [ br0 -> { * _10 = Core_Option_Option_Type.C_None } (! bb8)
        | br1 (a:RedBlackTree_Node_Type.t_node k v)-> { * _10 = Core_Option_Option_Type.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _10} s1
      | s1 = -{resolve'1 _10}- s2
      | s2 = {[@expl:type invariant] inv'2 key} s3
      | s3 = -{resolve'2 key}- s4
      | s4 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (k, v) ] s5
      | s5 = {[@expl:type invariant] inv'3 self} s6
      | s6 = -{resolve'3 self}- s7
      | s7 = bb17 ]
      
    | bb2 = s0 [ s0 = bb3 ] 
    | bb3 = s0
      [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _10}
          (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
            Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _10) 1}
              (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
                 [ &node <- _ret' ] 
                Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _10}
                  (fun (l_0'0:RedBlackTree_Node_Type.t_node k v) ->
                    
                    [ &_10 <- { _10 with current = (Core_Option_Option_Type.C_Some ( ^ node) : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ; } ]
                    
                    s1)))
      | s1 = -{inv'4 ( ^ node)}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = s0 [ s0 = any [ br0 -> {_13 = false} (! bb6) | br1 -> {_13} (! bb5) ]  ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _10} s3
      | s3 = -{resolve'1 _10}- s4
      | s4 =  [ &_9 <- [#"../red_black_tree.rs" 799 13 799 13] () ] s5
      | s5 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_15 <- RedBlackTree_Color_Type.C_Red ] s1
      | s1 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 _15 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_15 <- _any ] s2) ] ))
      | s2 = {[@expl:type invariant] inv'5 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _10} s5
      | s5 = -{resolve'1 _10}- s6
      | s6 =  [ &_9 <- [#"../red_black_tree.rs" 797 35 799 13] () ] s7
      | s7 = bb7 ]
      
    | bb7 = s0
      [ s0 = Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> { * self}
          (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
             [ &_18 <- _ret' ] 
             [ &self <- { self with current = ( ^ _18) ; } ] 
            s1)
      | s1 = -{inv'6 ( ^ _18)}- s2
      | s2 = {[@expl:type invariant] inv'2 key} s3
      | s3 = -{resolve'2 key}- s4
      | s4 = delete_rec'0 {_18} {key} (fun (_ret':Core_Option_Option_Type.t_option (k, v)) ->  [ &r <- _ret' ] s5)
      | s5 = bb9 ]
      
    | bb9 = s0 [ s0 = is_red'0 { * self} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 =  [ &_23 <- RedBlackTree_Color_Type.C_Black ] s1
      | s1 = RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
          (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
            Borrow.borrow_final
              <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                 [ &_26 <- _ret' ] 
                RedBlackTree_Tree_Type.t_tree <k> <v> { * self}
                  (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                    
                    [ &self <- { self with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _26) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'0 ( ^ _26)}- s3
      | s3 = as_mut'0 {_26}
          (fun (_ret':Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))) ->
             [ &_25 <- _ret' ] 
            s4)
      | s4 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_25} (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->  [ &_24 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * _24}
          (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
            
            [ &_24 <- { _24 with current = (RedBlackTree_Node_Type.C_Node l_left'0 _23 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
            
            (any [ any_ (_any:RedBlackTree_Color_Type.t_color)-> (!  [ &_23 <- _any ] s1) ] ))
      | s1 = {[@expl:type invariant] inv'5 _24} s2
      | s2 = -{resolve'4 _24}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'3 self}- s5
      | s5 =  [ &_20 <- [#"../red_black_tree.rs" 804 25 806 9] () ] s6
      | s6 = bb15 ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'3 self} s1
      | s1 = -{resolve'3 self}- s2
      | s2 =  [ &_20 <- [#"../red_black_tree.rs" 806 9 806 9] () ] s3
      | s3 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_0 <- r ] (any [ any_ (_any:Core_Option_Option_Type.t_option (k, v))-> (!  [ &r <- _any ] s1) ] )
      | s1 = bb16 ]
      
    | bb16 = s0 [ s0 = bb17 ] 
    | bb17 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & key : k = key
    | & _7 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty ()
    | & _9 : () = any_l () : ()
    | & _10 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _13 : bool = any_l () : bool
    | & _15 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & r : Core_Option_Option_Type.t_option (k, v) = any_l () : Core_Option_Option_Type.t_option (k, v)
    | & _18 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _20 : () = any_l () : ()
    | & _21 : bool = any_l () : bool
    | & _23 : RedBlackTree_Color_Type.t_color = any_l () : RedBlackTree_Color_Type.t_color
    | & _24 : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _25 : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v)) = any_l () : Core_Option_Option_Type.t_option (borrowed (RedBlackTree_Node_Type.t_node k v))
    | & _26 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ]
    
    [ return' (result:Core_Option_Option_Type.t_option (k, v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 793 41 793 55] inv'7 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 792 14 792 57] view'1 ( ^ self)
      = Map.set (view'0 self) (eq_model'1 key) (Core_Option_Option_Type.C_None)}
      {[@expl:postcondition] [#"../red_black_tree.rs" 787 14 791 5] match result with
        | Core_Option_Option_Type.C_Some (k, v) -> eq_model'0 k = eq_model'1 key
        /\ Map.get (view'0 self) (eq_model'1 key) = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (view'0 self) (eq_model'1 key) = Core_Option_Option_Type.C_None
        end}
      {[@expl:postcondition] [#"../red_black_tree.rs" 786 14 786 33] invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_Get
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'10 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'10 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'9 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'9 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'8 (_x : eq_model_ty'0)
  let rec inv'8 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'8 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'8 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'8 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  predicate invariant'9 (self : eq_model_ty'0)
  let rec invariant'9 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  axiom inv'8 : forall x : eq_model_ty'0 . inv'8 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'8 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'8 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'7 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'7 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'7 x = true
  predicate invariant'7 (self : Core_Option_Option_Type.t_option v)
  let rec invariant'7 (self:Core_Option_Option_Type.t_option v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'6 (_x : Core_Option_Option_Type.t_option v)
  let rec inv'6 (_x:Core_Option_Option_Type.t_option v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : Core_Option_Option_Type.t_option v . inv'6 x = true
  predicate invariant'6 (self : v)
  let rec invariant'6 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : v)
  let rec inv'5 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ] 
  axiom inv'5 : forall x : v . inv'5 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'4 (self : k)
  let rec invariant'4 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : k)
  let rec inv'3 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ] 
  axiom inv'3 : forall x : k . inv'3 x = true
  predicate invariant'3 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'3 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'2 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'2 x = true
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : v)
  let rec inv'1 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ] 
  axiom inv'1 : forall x : v . inv'1 x = true
  predicate invariant'1 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'0 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'0 x = true
  use map.Map
  use map.Map
  function eq_model'1 (self : k) : eq_model_ty'0
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'1 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use prelude.Borrow
  function view'0 (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'1 self
  let rec view'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'7 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'7 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'1 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'8 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'1 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'8 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'1 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Intrinsic
  predicate resolve'5 (self : v)
  let rec resolve'5 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  predicate resolve'4 (self : RedBlackTree_Node_Type.t_node k v)
  let rec resolve'4 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= {[@expl:precondition] inv'3 other}
    {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 81] result
      = cmp_log'0 (eq_model'1 self) (eq_model'1 other)}
      (! return' {result}) ]
    
  predicate resolve'3 (self : k)
  let rec resolve'3 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate resolve'2 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec resolve'2 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  function eq_model'0 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'1 self
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate resolve'1 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec resolve'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty ())
  let rec resolve'0 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'9 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'7 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'7 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'9 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'8 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'1 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'9 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'7 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'7 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'9 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'8 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'1 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'8 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'7 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'7 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'8 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'1 v
   -> has_mapping'0 self k v = (Map.get (view'1 self) k = Core_Option_Option_Type.C_Some v))
  let rec get (self:RedBlackTree_Tree_Type.t_tree k v) (key:k) (return'  (ret:Core_Option_Option_Type.t_option v))= {[#"../red_black_tree.rs" 815 22 815 25] inv'3 key}
    {[#"../red_black_tree.rs" 815 16 815 20] inv'0 self}
    {[#"../red_black_tree.rs" 810 15 810 34] invariant'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_6 <- [#"../red_black_tree.rs" 816 8 816 45] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1
      | s1 =  [ &tree <- self ] s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb2 ]
      
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant] [#"../red_black_tree.rs" 819 8 819 45] forall v : v . inv'1 v
         -> has_mapping'0 self (eq_model'0 key) v = has_mapping'0 tree (eq_model'0 key) v}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 819 20 819 43] bst_invariant'0 tree}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> {tree}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                 [ &_13 <- rnode'0 ] 
                s1)
          | s1 = {[@expl:type invariant] inv'0 tree} s2
          | s2 = -{resolve'1 tree}- s3
          | s3 = any
            [ br0 -> {_13 = Core_Option_Option_Type.C_None } (! bb14)
            | br1 (a:RedBlackTree_Node_Type.t_node k v)-> {_13 = Core_Option_Option_Type.C_Some a} (! bb4) ]
             ]
          
        | bb4 = s0 [ s0 = bb5 ] 
        | bb5 = s0
          [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> {_13}
              (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->  [ &node <- r0'0 ] s1)
          | s1 = {[@expl:type invariant] inv'2 _13} s2
          | s2 = -{resolve'2 _13}- s3
          | s3 = RedBlackTree_Node_Type.t_node <k> <v> {node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_19 <- rkey'0 ] 
                s4)
          | s4 = {[@expl:type invariant] inv'3 _19} s5
          | s5 = -{resolve'3 _19}- s6
          | s6 = cmp'0 {key} {_19} (fun (_ret':Core_Cmp_Ordering_Type.t_ordering) ->  [ &_16 <- _ret' ] s7)
          | s7 = bb6 ]
          
        | bb6 = s0
          [ s0 = any
            [ br0 -> {_16 = Core_Cmp_Ordering_Type.C_Less } (! bb8)
            | br1 -> {_16 = Core_Cmp_Ordering_Type.C_Equal } (! bb9)
            | br2 -> {_16 = Core_Cmp_Ordering_Type.C_Greater } (! bb10) ]
             ]
          
        | bb10 = s0
          [ s0 = RedBlackTree_Node_Type.t_node <k> <v> {node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_27 <- rright'0 ] 
                s1)
          | s1 = {[@expl:type invariant] inv'4 node} s2
          | s2 = -{resolve'4 node}- s3
          | s3 = {[@expl:type invariant] inv'0 _27} s4
          | s4 = -{resolve'1 _27}- s5
          | s5 =  [ &tree <- _27 ] s6
          | s6 =  [ &_12 <- [#"../red_black_tree.rs" 825 27 825 45] () ] s7
          | s7 = bb13 ]
          
        | bb8 = s0 [ s0 = bb11 ] 
        | bb11 = s0
          [ s0 = RedBlackTree_Node_Type.t_node <k> <v> {node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_22 <- rleft'0 ] 
                s1)
          | s1 = {[@expl:type invariant] inv'4 node} s2
          | s2 = -{resolve'4 node}- s3
          | s3 = {[@expl:type invariant] inv'0 _22} s4
          | s4 = -{resolve'1 _22}- s5
          | s5 =  [ &tree <- _22 ] s6
          | s6 =  [ &_12 <- [#"../red_black_tree.rs" 823 24 823 41] () ] s7
          | s7 = bb13 ]
          
        | bb13 = s0 [ s0 = bb2 ]  ]
         ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'2 _13}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'3 key}- s4
      | s4 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option v ] s5
      | s5 = bb15 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'3 key} s3
      | s3 = -{resolve'3 key}- s4
      | s4 = {[#"../red_black_tree.rs" 822 18 822 36] false} any ]
      
    | bb9 = s0 [ s0 = bb12 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'3 key} s1
      | s1 = -{resolve'3 key}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> {node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
             [ &_25 <- rval'0 ] 
            s3)
      | s3 = {[@expl:type invariant] inv'4 node} s4
      | s4 = -{resolve'4 node}- s5
      | s5 = {[@expl:type invariant] inv'5 _25} s6
      | s6 = -{resolve'5 _25}- s7
      | s7 =  [ &_0 <- Core_Option_Option_Type.C_Some _25 : Core_Option_Option_Type.t_option v ] s8
      | s8 = bb15 ]
      
    | bb15 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option v = any_l () : Core_Option_Option_Type.t_option v
    | & self : RedBlackTree_Tree_Type.t_tree k v = self
    | & key : k = key
    | & _6 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty ()
    | & tree : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _12 : () = any_l () : ()
    | & _13 : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) = any_l () : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)
    | & node : RedBlackTree_Node_Type.t_node k v = any_l () : RedBlackTree_Node_Type.t_node k v
    | & _16 : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _19 : k = any_l () : k
    | & _22 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v
    | & _25 : v = any_l () : v
    | & _27 : RedBlackTree_Tree_Type.t_tree k v = any_l () : RedBlackTree_Tree_Type.t_tree k v ]
    
    [ return' (result:Core_Option_Option_Type.t_option v)-> {[@expl:postcondition] [#"../red_black_tree.rs" 815 34 815 44] inv'6 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 811 14 814 5] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (view'0 self) (eq_model'0 key) = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (view'0 self) (eq_model'0 key) = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl15_GetMut
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  type eq_model_ty'0
  use map.Map
  predicate invariant'13 (self : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec invariant'13 (self:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'12 (_x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))
  let rec inv'12 (_x:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v) . inv'12 x = true
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log'0 (self : eq_model_ty'0) (_2 : eq_model_ty'0) : Core_Cmp_Ordering_Type.t_ordering
  let rec cmp_log'0 (self:eq_model_ty'0) (_2:eq_model_ty'0) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {result = cmp_log'0 self _2} (! return' {result}) ]
    
  predicate inv'2 (_x : eq_model_ty'0)
  let rec inv'2 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function eq_cmp'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec eq_cmp'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x}
    any [ return' (result:())-> {result = eq_cmp'0 x y} (! return' {result}) ] 
  axiom eq_cmp'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 14 70 15] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 70 23 70 24] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59] (x = y)
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Equal))
  function antisym2'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym2'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Greater}
    any [ return' (result:())-> {result = antisym2'0 x y} (! return' {result}) ] 
  axiom antisym2'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Greater)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 16 66 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 66 25 66 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Less)
  function antisym1'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec antisym1'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
    = Core_Cmp_Ordering_Type.C_Less}
    any [ return' (result:())-> {result = antisym1'0 x y} (! return' {result}) ] 
  axiom antisym1'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45] cmp_log'0 x y
  = Core_Cmp_Ordering_Type.C_Less)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 16 61 17] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 61 25 61 26] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47] cmp_log'0 y x = Core_Cmp_Ordering_Type.C_Greater)
  function trans'0 (x : eq_model_ty'0) (y : eq_model_ty'0) (z : eq_model_ty'0) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    
  let rec trans'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (z:eq_model_ty'0) (o:Core_Cmp_Ordering_Type.t_ordering) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y = o}
    any [ return' (result:())-> {result = trans'0 x y z o} (! return' {result}) ] 
  axiom trans'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0, z : eq_model_ty'0, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32] cmp_log'0 x y
  = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32] cmp_log'0 y z = o)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 13 56 14] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 22 56 23] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 56 31 56 32] inv'2 z)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31] cmp_log'0 x z = o)
  function refl'0 (x : eq_model_ty'0) : ()
  let rec refl'0 (x:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x}
    any [ return' (result:())-> {result = refl'0 x} (! return' {result}) ] 
  axiom refl'0_spec : forall x : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 50 12 50 13] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45] cmp_log'0 x x = Core_Cmp_Ordering_Type.C_Equal)
  function gt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec gt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = gt_log'0 self o} (! return' {result}) ]
    
  function cmp_gt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_gt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_gt_log'0 x y} (! return' {result}) ] 
  axiom cmp_gt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 18 46 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 46 27 46 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64] gt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Greater))
  function ge_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec ge_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = ge_log'0 self o} (! return' {result}) ]
    
  function cmp_ge_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_ge_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_ge_log'0 x y} (! return' {result}) ] 
  axiom cmp_ge_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 18 36 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 36 27 36 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61] ge_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Less))
  function lt_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec lt_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = lt_log'0 self o} (! return' {result}) ]
    
  function cmp_lt_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_lt_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_lt_log'0 x y} (! return' {result}) ] 
  axiom cmp_lt_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 18 26 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 26 27 26 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61] lt_log'0 x y
  = (cmp_log'0 x y = Core_Cmp_Ordering_Type.C_Less))
  function le_log'0 (self : eq_model_ty'0) (o : eq_model_ty'0) : bool
  let rec le_log'0 (self:eq_model_ty'0) (o:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = le_log'0 self o} (! return' {result}) ]
    
  function cmp_le_log'0 (x : eq_model_ty'0) (y : eq_model_ty'0) : ()
  let rec cmp_le_log'0 (x:eq_model_ty'0) (y:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x}
    any [ return' (result:())-> {result = cmp_le_log'0 x y} (! return' {result}) ] 
  axiom cmp_le_log'0_spec : forall x : eq_model_ty'0, y : eq_model_ty'0 . ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 18 16 19] inv'2 x)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 16 27 16 28] inv'2 y)
   -> ([#"../../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64] le_log'0 x y
  = (cmp_log'0 x y <> Core_Cmp_Ordering_Type.C_Greater))
  use prelude.Borrow
  predicate invariant'12 (self : Core_Option_Option_Type.t_option (borrowed v))
  let rec invariant'12 (self:Core_Option_Option_Type.t_option (borrowed v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'11 (_x : Core_Option_Option_Type.t_option (borrowed v))
  let rec inv'11 (_x:Core_Option_Option_Type.t_option (borrowed v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : Core_Option_Option_Type.t_option (borrowed v) . inv'11 x = true
  predicate invariant'11 (self : borrowed v)
  let rec invariant'11 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'10 (_x : borrowed v)
  let rec inv'10 (_x:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : borrowed v . inv'10 x = true
  use RedBlackTree_Node_Type as RedBlackTree_Node_Type
  predicate invariant'10 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec invariant'10 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'9 (_x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)))
  let rec inv'9 (_x:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) . inv'9 x
  = true
  predicate invariant'9 (self : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'9 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'8 (_x : borrowed (RedBlackTree_Node_Type.t_node k v))
  let rec inv'8 (_x:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : borrowed (RedBlackTree_Node_Type.t_node k v) . inv'8 x = true
  use RedBlackTree_Tree_Type as RedBlackTree_Tree_Type
  predicate invariant'8 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec invariant'8 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'7 (_x : borrowed (RedBlackTree_Tree_Type.t_tree k v))
  let rec inv'7 (_x:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : borrowed (RedBlackTree_Tree_Type.t_tree k v) . inv'7 x = true
  predicate invariant'7 (self : RedBlackTree_Tree_Type.t_tree k v)
  let rec invariant'7 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'6 (_x : RedBlackTree_Tree_Type.t_tree k v)
  let rec inv'6 (_x:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : RedBlackTree_Tree_Type.t_tree k v . inv'6 x = true
  predicate invariant'6 (self : k)
  let rec invariant'6 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'5 (_x : k)
  let rec inv'5 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ] 
  axiom inv'5 : forall x : k . inv'5 x = true
  predicate invariant'5 (self : RedBlackTree_Node_Type.t_node k v)
  let rec invariant'5 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'4 (_x : RedBlackTree_Node_Type.t_node k v)
  let rec inv'4 (_x:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  axiom inv'4 : forall x : RedBlackTree_Node_Type.t_node k v . inv'4 x = true
  predicate invariant'4 (self : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec invariant'4 (self:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
  let rec inv'3 (_x:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v) . inv'3 x = true
  predicate invariant'3 (self : eq_model_ty'0)
  let rec invariant'3 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : eq_model_ty'0 . inv'2 x = true
  predicate invariant'2 (self : v)
  let rec invariant'2 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'1 (_x : v)
  let rec inv'1 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ] 
  axiom inv'1 : forall x : v . inv'1 x = true
  use prelude.Snapshot
  predicate invariant'1 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec invariant'1 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)) . inv'0 x = true
  use map.Map
  function eq_model'1 (self : k) : eq_model_ty'0
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  function model_acc'0 [#"../red_black_tree.rs" 49 4 49 78] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 51 12 58 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> accu
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc'0 right accu2
      end
  let rec model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = model_acc'0 self accu}
      (! return' {result}) ]
    
  use map.Const
  function view'1 [#"../red_black_tree.rs" 165 4 165 33] (self : RedBlackTree_Tree_Type.t_tree k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../red_black_tree.rs" 166 20 166 54] model_acc'0 self (Const.const (Core_Option_Option_Type.C_None))
  let rec view'1 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use map.Map
  function view'0 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'1 ( * self)
  let rec view'0 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  function color'0 [#"../red_black_tree.rs" 249 4 249 27] (self : RedBlackTree_Tree_Type.t_tree k v) : RedBlackTree_Color_Type.t_color
    
   =
    [#"../red_black_tree.rs" 251 12 254 13] match RedBlackTree_Tree_Type.tree_node self with
      | Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node _ color _ _ _) -> color
      | _ -> RedBlackTree_Color_Type.C_Black
      end
  let rec color'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:RedBlackTree_Color_Type.t_color))= any
    [ return' (result:RedBlackTree_Color_Type.t_color)-> {result = color'0 self} (! return' {result}) ]
    
  predicate color_invariant_here'0 [#"../red_black_tree.rs" 274 4 274 41] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 275 20 275 102] color'0 (RedBlackTree_Node_Type.node_right self)
    = RedBlackTree_Color_Type.C_Black
    /\ (RedBlackTree_Node_Type.node_color self = RedBlackTree_Color_Type.C_Black
    \/ color'0 (RedBlackTree_Node_Type.node_left self) = RedBlackTree_Color_Type.C_Black)
  let rec color_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant_here'0 self} (! return' {result}) ]
    
  predicate color_invariant'0 [#"../red_black_tree.rs" 259 4 259 36] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 261 12 267 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  let rec color_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = color_invariant'0 self} (! return' {result}) ]
    
  use prelude.Int
  function height'0 [#"../red_black_tree.rs" 289 4 289 26] (self : RedBlackTree_Tree_Type.t_tree k v) : int =
    [#"../red_black_tree.rs" 291 12 299 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> 0
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left color _ _ _)) -> match color with
        | RedBlackTree_Color_Type.C_Red -> height'0 left
        | RedBlackTree_Color_Type.C_Black -> height'0 left + 1
        end
      end
  let rec height'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:int))= {[@expl:precondition] [#"../red_black_tree.rs" 289 14 289 18] inv'6 self}
    any [ return' (result:int)-> {result = height'0 self} (! return' {result}) ] 
  axiom height'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v . ([#"../red_black_tree.rs" 289 14 289 18] inv'6 self)
   -> ([#"../red_black_tree.rs" 288 14 288 25] height'0 self >= 0)
  predicate height_invariant_here'0 [#"../red_black_tree.rs" 331 4 331 42] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 332 20 332 61] height'0 (RedBlackTree_Node_Type.node_left self)
    = height'0 (RedBlackTree_Node_Type.node_right self)
  let rec height_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant_here'0 self} (! return' {result}) ]
    
  predicate height_invariant'0 [#"../red_black_tree.rs" 304 4 304 37] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 306 12 312 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  let rec height_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = height_invariant'0 self} (! return' {result}) ]
    
  predicate has_mapping'0 [#"../red_black_tree.rs" 31 4 31 55] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) (v : v)
    
   =
    [#"../red_black_tree.rs" 33 12 37 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> false
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = eq_model'1 key /\ v = val'
      end
  let rec has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (v:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_mapping'0 self k v} (! return' {result}) ]
    
  predicate bst_invariant_here'0 [#"../red_black_tree.rs" 177 4 177 39] (self : RedBlackTree_Node_Type.t_node k v) =
    [#"../red_black_tree.rs" 179 12 180 100] (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_left self) k v
     -> lt_log'0 k (eq_model'1 (RedBlackTree_Node_Type.node_key self)))
    /\ (forall v : v . forall k : eq_model_ty'0 . inv'1 v
     -> inv'2 k
     -> has_mapping'0 (RedBlackTree_Node_Type.node_right self) k v
     -> lt_log'0 (eq_model'1 (RedBlackTree_Node_Type.node_key self)) k)
  let rec bst_invariant_here'0 (self:RedBlackTree_Node_Type.t_node k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant_here'0 self} (! return' {result}) ]
    
  predicate bst_invariant'0 [#"../red_black_tree.rs" 197 4 197 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 199 12 205 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> true
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some node) -> let RedBlackTree_Node_Type.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  let rec bst_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = bst_invariant'0 self} (! return' {result}) ]
    
  predicate internal_invariant'0 [#"../red_black_tree.rs" 349 4 349 43] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 351 12 351 59] bst_invariant'0 self /\ height_invariant'0 self
  let rec internal_invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = internal_invariant'0 self} (! return' {result}) ]
    
  predicate invariant'0 [#"../red_black_tree.rs" 357 4 357 34] (self : RedBlackTree_Tree_Type.t_tree k v) =
    [#"../red_black_tree.rs" 359 12 359 88] internal_invariant'0 self
    /\ color_invariant'0 self /\ color'0 self = RedBlackTree_Color_Type.C_Black
  let rec invariant'0 (self:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'6 (self : borrowed v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'6 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'5 (self:borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed (RedBlackTree_Node_Type.t_node k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed (RedBlackTree_Node_Type.t_node k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed (RedBlackTree_Tree_Type.t_tree k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  let rec cmp'0 (self:k) (other:k) (return'  (ret:Core_Cmp_Ordering_Type.t_ordering))= {[@expl:precondition] inv'5 other}
    {[@expl:precondition] inv'5 self}
    any
    [ return' (result:Core_Cmp_Ordering_Type.t_ordering)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 50 26 50 81] result
      = cmp_log'0 (eq_model'1 self) (eq_model'1 other)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : k)
  let rec resolve'2 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  use RedBlackTree_Cp_Type as RedBlackTree_Cp_Type
  predicate match_t'0 [#"../red_black_tree.rs" 225 4 225 52] (self : RedBlackTree_Cp_Type.t_cp) (tree : RedBlackTree_Tree_Type.t_tree k v)
    
   =
    [#"../red_black_tree.rs" 227 12 232 13] match self with
      | RedBlackTree_Cp_Type.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | RedBlackTree_Cp_Type.C_CPN color l r -> exists node : RedBlackTree_Node_Type.t_node k v . inv'4 node
      /\ RedBlackTree_Tree_Type.tree_node tree = Core_Option_Option_Type.C_Some node
      /\ RedBlackTree_Node_Type.node_color node = color
      /\ match_t'0 l (RedBlackTree_Node_Type.node_left node) /\ match_t'0 r (RedBlackTree_Node_Type.node_right node)
      end
  let rec match_t'0 (self:RedBlackTree_Cp_Type.t_cp) (tree:RedBlackTree_Tree_Type.t_tree k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = match_t'0 self tree} (! return' {result}) ]
    
  use prelude.Snapshot
  function eq_model'0 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'1 self
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  predicate resolve'1 (self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)))
  let rec resolve'1 (self:Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Snapshot
  predicate resolve'0 (self : Snapshot.snap_ty ())
  let rec resolve'0 (self:Snapshot.snap_ty ()) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  function model_acc_has_mapping'0 [#"../red_black_tree.rs" 65 4 65 81] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 67 12 75 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  let rec model_acc_has_mapping'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 65 65 65 66] inv'2 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 35 65 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 65 29 65 33] inv'6 self}
    any [ return' (result:())-> {result = model_acc_has_mapping'0 self accu k} (! return' {result}) ] 
  axiom model_acc_has_mapping'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 65 29 65 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 65 35 65 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 65 65 65 66] inv'2 k)
   -> ([#"../red_black_tree.rs" 63 4 64 93] Map.get (model_acc'0 self accu) k = Map.get accu k
  \/ (exists v : v . inv'1 v
  /\ Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v /\ has_mapping'0 self k v))
  function has_mapping_model_acc'0 [#"../red_black_tree.rs" 82 4 84 31] (self : RedBlackTree_Tree_Type.t_tree k v) (accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 87 12 96 13] match self with
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_None) -> ()
      | RedBlackTree_Tree_Type.C_Tree (Core_Option_Option_Type.C_Some (RedBlackTree_Node_Type.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (eq_model'1 key) (Core_Option_Option_Type.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  let rec has_mapping_model_acc'0 (self:RedBlackTree_Tree_Type.t_tree k v) (accu:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 82 65 82 66] inv'2 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 35 82 39] inv'12 accu}
    {[@expl:precondition] [#"../red_black_tree.rs" 82 29 82 33] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model_acc'0 self accu k} (! return' {result}) ] 
  axiom has_mapping_model_acc'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, accu : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v), k : eq_model_ty'0 . ([#"../red_black_tree.rs" 80 15 80 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 82 29 82 33] inv'6 self)
   -> ([#"../red_black_tree.rs" 82 35 82 39] inv'12 accu)
   -> ([#"../red_black_tree.rs" 82 65 82 66] inv'2 k)
   -> ([#"../red_black_tree.rs" 81 4 81 94] forall v : v . inv'1 v
   -> has_mapping'0 self k v  -> Map.get (model_acc'0 self accu) k = Core_Option_Option_Type.C_Some v)
  function has_mapping_model'0 [#"../red_black_tree.rs" 103 4 105 31] (self : RedBlackTree_Tree_Type.t_tree k v) (k : eq_model_ty'0) : ()
    
   =
    [#"../red_black_tree.rs" 108 12 108 61] let _ = model_acc_has_mapping'0 self (Const.const (Core_Option_Option_Type.C_None)) k in has_mapping_model_acc'0 self (Const.const (Core_Option_Option_Type.C_None)) k
  let rec has_mapping_model'0 (self:RedBlackTree_Tree_Type.t_tree k v) (k:eq_model_ty'0) (return'  (ret:()))= {[@expl:precondition] [#"../red_black_tree.rs" 103 31 103 32] inv'2 k}
    {[@expl:precondition] [#"../red_black_tree.rs" 103 25 103 29] inv'6 self}
    {[@expl:precondition] [#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self}
    any [ return' (result:())-> {result = has_mapping_model'0 self k} (! return' {result}) ] 
  axiom has_mapping_model'0_spec : forall self : RedBlackTree_Tree_Type.t_tree k v, k : eq_model_ty'0 . ([#"../red_black_tree.rs" 101 15 101 35] bst_invariant'0 self)
   -> ([#"../red_black_tree.rs" 103 25 103 29] inv'6 self)
   -> ([#"../red_black_tree.rs" 103 31 103 32] inv'2 k)
   -> ([#"../red_black_tree.rs" 102 4 102 80] forall v : v . inv'1 v
   -> has_mapping'0 self k v = (Map.get (view'1 self) k = Core_Option_Option_Type.C_Some v))
  let rec get_mut (self:borrowed (RedBlackTree_Tree_Type.t_tree k v)) (key:k) (return'  (ret:Core_Option_Option_Type.t_option (borrowed v)))= {[#"../red_black_tree.rs" 837 30 837 33] inv'5 key}
    {[#"../red_black_tree.rs" 837 24 837 28] inv'7 self}
    {[#"../red_black_tree.rs" 831 15 831 34] invariant'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_7 <- [#"../red_black_tree.rs" 838 8 838 45] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _7}- s1
      | s1 =  [ &old_self <- [#"../red_black_tree.rs" 840 23 840 41] Snapshot.new self ] s2
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'1 old_self}- s2
      | s2 =  [ &tree <- self ] 
        (any [ any_ (_any:borrowed (RedBlackTree_Tree_Type.t_tree k v))-> (!  [ &self <- _any ] s3) ] )
      | s3 = bb3 ]
      
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] forall v : v . forall k : eq_model_ty'0 . inv'1 v
         -> inv'2 k
         -> has_mapping'0 ( * tree) k v = has_mapping'0 ( ^ tree) k v
         -> has_mapping'0 ( * Snapshot.inner old_self) k v = has_mapping'0 ( ^ Snapshot.inner old_self) k v}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] match_t'0 (RedBlackTree_Cp_Type.C_CPL (color'0 ( * tree))) ( ^ tree)
         -> match_t'0 (RedBlackTree_Cp_Type.C_CPL (RedBlackTree_Color_Type.C_Black)) ( ^ Snapshot.inner old_self)}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] height'0 ( * tree) = height'0 ( ^ tree)
        /\ height_invariant'0 ( ^ tree)  -> height_invariant'0 ( ^ Snapshot.inner old_self)}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] (forall v : v . forall k : eq_model_ty'0 . inv'1 v
         -> inv'2 k  -> k = eq_model'0 key \/ has_mapping'0 ( * tree) k v = has_mapping'0 ( ^ tree) k v)
         -> bst_invariant'0 ( ^ tree)  -> bst_invariant'0 ( ^ Snapshot.inner old_self)}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] forall v : v . inv'1 v
         -> has_mapping'0 ( * tree) (eq_model'0 key) v = has_mapping'0 ( * Snapshot.inner old_self) (eq_model'0 key) v}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 8 843 45] forall v : v . inv'1 v
         -> has_mapping'0 ( ^ tree) (eq_model'0 key) v = has_mapping'0 ( ^ Snapshot.inner old_self) (eq_model'0 key) v}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 845 20 845 45] color_invariant'0 ( * tree)}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 844 20 844 46] height_invariant'0 ( * tree)}
        {[@expl:loop invariant] [#"../red_black_tree.rs" 843 20 843 43] bst_invariant'0 ( * tree)}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = RedBlackTree_Tree_Type.t_tree <k> <v> { * tree}
              (fun (rnode'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                Borrow.borrow_final
                  <Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.get_id tree) 1}
                  (fun (_ret':borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))) ->
                     [ &_23 <- _ret' ] 
                    RedBlackTree_Tree_Type.t_tree <k> <v> { * tree}
                      (fun (l_node'0:Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ->
                        
                        [ &tree <- { tree with current = (RedBlackTree_Tree_Type.C_Tree ( ^ _23) : RedBlackTree_Tree_Type.t_tree k v) ; } ]
                        
                        s1)))
          | s1 = -{inv'3 ( ^ _23)}- s2
          | s2 = any
            [ br0 -> { * _23 = Core_Option_Option_Type.C_None } (! bb15)
            | br1 (a:RedBlackTree_Node_Type.t_node k v)-> { * _23 = Core_Option_Option_Type.C_Some a} (! bb5) ]
             ]
          
        | bb5 = s0 [ s0 = bb6 ] 
        | bb6 = s0
          [ s0 = Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _23}
              (fun (r0'0:RedBlackTree_Node_Type.t_node k v) ->
                Borrow.borrow_final <RedBlackTree_Node_Type.t_node k v> {r0'0} {Borrow.inherit_id (Borrow.get_id _23) 1}
                  (fun (_ret':borrowed (RedBlackTree_Node_Type.t_node k v)) ->
                     [ &node <- _ret' ] 
                    Core_Option_Option_Type.some <RedBlackTree_Node_Type.t_node k v> { * _23}
                      (fun (l_0'0:RedBlackTree_Node_Type.t_node k v) ->
                        
                        [ &_23 <- { _23 with current = (Core_Option_Option_Type.C_Some ( ^ node) : Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) ; } ]
                        
                        s1)))
          | s1 = -{inv'4 ( ^ node)}- s2
          | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                 [ &_29 <- rkey'0 ] 
                s3)
          | s3 = {[@expl:type invariant] inv'5 _29} s4
          | s4 = -{resolve'2 _29}- s5
          | s5 = cmp'0 {key} {_29} (fun (_ret':Core_Cmp_Ordering_Type.t_ordering) ->  [ &_26 <- _ret' ] s6)
          | s6 = bb7 ]
          
        | bb7 = s0
          [ s0 = any
            [ br0 -> {_26 = Core_Cmp_Ordering_Type.C_Less } (! bb9)
            | br1 -> {_26 = Core_Cmp_Ordering_Type.C_Equal } (! bb10)
            | br2 -> {_26 = Core_Cmp_Ordering_Type.C_Greater } (! bb11) ]
             ]
          
        | bb11 = s0
          [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rright'0}
                  (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                     [ &_37 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * node}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        
                        [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 l_val'0 ( ^ _37) : RedBlackTree_Node_Type.t_node k v) ; } ]
                        
                        s1)))
          | s1 = -{inv'6 ( ^ _37)}- s2
          | s2 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _37} {Borrow.get_id _37}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_36 <- _ret' ] 
                 [ &_37 <- { _37 with current = ( ^ _36) ; } ] 
                s3)
          | s3 = -{inv'6 ( ^ _36)}- s4
          | s4 = {[@expl:type invariant] inv'7 tree} s5
          | s5 = -{resolve'3 tree}- s6
          | s6 =  [ &tree <- _36 ] 
            (any [ any_ (_any:borrowed (RedBlackTree_Tree_Type.t_tree k v))-> (!  [ &_36 <- _any ] s7) ] )
          | s7 =  [ &_22 <- [#"../red_black_tree.rs" 859 27 859 49] () ] s8
          | s8 = {[@expl:type invariant] inv'7 _37} s9
          | s9 = -{resolve'3 _37}- s10
          | s10 = bb14 ]
          
        | bb9 = s0 [ s0 = bb12 ] 
        | bb12 = s0
          [ s0 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
              (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
                Borrow.borrow_mut <RedBlackTree_Tree_Type.t_tree k v> {rleft'0}
                  (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                     [ &_32 <- _ret' ] 
                    RedBlackTree_Node_Type.t_node <k> <v> { * node}
                      (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                        
                        [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node ( ^ _32) l_color'0 l_key'0 l_val'0 l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                        
                        s1)))
          | s1 = -{inv'6 ( ^ _32)}- s2
          | s2 = Borrow.borrow_final <RedBlackTree_Tree_Type.t_tree k v> { * _32} {Borrow.get_id _32}
              (fun (_ret':borrowed (RedBlackTree_Tree_Type.t_tree k v)) ->
                 [ &_31 <- _ret' ] 
                 [ &_32 <- { _32 with current = ( ^ _31) ; } ] 
                s3)
          | s3 = -{inv'6 ( ^ _31)}- s4
          | s4 = {[@expl:type invariant] inv'7 tree} s5
          | s5 = -{resolve'3 tree}- s6
          | s6 =  [ &tree <- _31 ] 
            (any [ any_ (_any:borrowed (RedBlackTree_Tree_Type.t_tree k v))-> (!  [ &_31 <- _any ] s7) ] )
          | s7 =  [ &_22 <- [#"../red_black_tree.rs" 857 24 857 45] () ] s8
          | s8 = {[@expl:type invariant] inv'7 _32} s9
          | s9 = -{resolve'3 _32}- s10
          | s10 = bb14 ]
          
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'8 node} s1
          | s1 = -{resolve'4 node}- s2
          | s2 = {[@expl:type invariant] inv'9 _23} s3
          | s3 = -{resolve'5 _23}- s4
          | s4 = bb3 ]
           ]
         ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'9 _23} s1
      | s1 = -{resolve'5 _23}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'2 key}- s4
      | s4 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option (borrowed v) ] s5
      | s5 = bb16 ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'2 key}- s4
      | s4 = {[@expl:type invariant] inv'9 _23} s5
      | s5 = -{resolve'5 _23}- s6
      | s6 = {[@expl:type invariant] inv'7 tree} s7
      | s7 = -{resolve'3 tree}- s8
      | s8 = {[#"../red_black_tree.rs" 856 18 856 36] false} any ]
      
    | bb10 = s0 [ s0 = bb13 ] 
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv'5 key} s1
      | s1 = -{resolve'2 key}- s2
      | s2 = RedBlackTree_Node_Type.t_node <k> <v> { * node}
          (fun (rleft'0:RedBlackTree_Tree_Type.t_tree k v) (rcolor'0:RedBlackTree_Color_Type.t_color) (rkey'0:k) (rval'0:v) (rright'0:RedBlackTree_Tree_Type.t_tree k v) ->
            Borrow.borrow_mut <v> {rval'0}
              (fun (_ret':borrowed v) ->
                 [ &_35 <- _ret' ] 
                RedBlackTree_Node_Type.t_node <k> <v> { * node}
                  (fun (l_left'0:RedBlackTree_Tree_Type.t_tree k v) (l_color'0:RedBlackTree_Color_Type.t_color) (l_key'0:k) (l_val'0:v) (l_right'0:RedBlackTree_Tree_Type.t_tree k v) ->
                    
                    [ &node <- { node with current = (RedBlackTree_Node_Type.C_Node l_left'0 l_color'0 l_key'0 ( ^ _35) l_right'0 : RedBlackTree_Node_Type.t_node k v) ; } ]
                    
                    s3)))
      | s3 = -{inv'1 ( ^ _35)}- s4
      | s4 = Borrow.borrow_final <v> { * _35} {Borrow.get_id _35}
          (fun (_ret':borrowed v) ->  [ &_34 <- _ret' ]  [ &_35 <- { _35 with current = ( ^ _34) ; } ] s5)
      | s5 = -{inv'1 ( ^ _34)}- s6
      | s6 =  [ &_0 <- Core_Option_Option_Type.C_Some _34 : Core_Option_Option_Type.t_option (borrowed v) ] 
        (any [ any_ (_any:borrowed v)-> (!  [ &_34 <- _any ] s7) ] )
      | s7 = {[@expl:type invariant] inv'10 _35} s8
      | s8 = -{resolve'6 _35}- s9
      | s9 = {[@expl:type invariant] inv'8 node} s10
      | s10 = -{resolve'4 node}- s11
      | s11 = {[@expl:type invariant] inv'9 _23} s12
      | s12 = -{resolve'5 _23}- s13
      | s13 = bb16 ]
      
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'7 tree} s1 | s1 = -{resolve'3 tree}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option (borrowed v) = any_l () : Core_Option_Option_Type.t_option (borrowed v)
    | & self : borrowed (RedBlackTree_Tree_Type.t_tree k v) = self
    | & key : k = key
    | & _7 : Snapshot.snap_ty () = any_l () : Snapshot.snap_ty ()
    | & old_self : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v)) = any_l () : Snapshot.snap_ty (borrowed (RedBlackTree_Tree_Type.t_tree k v))
    | & tree : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _22 : () = any_l () : ()
    | & _23 : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v)) = any_l () : borrowed (Core_Option_Option_Type.t_option (RedBlackTree_Node_Type.t_node k v))
    | & node : borrowed (RedBlackTree_Node_Type.t_node k v) = any_l () : borrowed (RedBlackTree_Node_Type.t_node k v)
    | & _26 : Core_Cmp_Ordering_Type.t_ordering = any_l () : Core_Cmp_Ordering_Type.t_ordering
    | & _29 : k = any_l () : k
    | & _31 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _32 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _34 : borrowed v = any_l () : borrowed v
    | & _35 : borrowed v = any_l () : borrowed v
    | & _36 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v)
    | & _37 : borrowed (RedBlackTree_Tree_Type.t_tree k v) = any_l () : borrowed (RedBlackTree_Tree_Type.t_tree k v) ]
    
    [ return' (result:Core_Option_Option_Type.t_option (borrowed v))-> {[@expl:postcondition] [#"../red_black_tree.rs" 837 42 837 56] inv'11 result}
      {[@expl:postcondition] [#"../red_black_tree.rs" 833 14 836 5] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (view'0 self) (eq_model'0 key)
        = Core_Option_Option_Type.C_Some ( * v)
        /\ view'1 ( ^ self) = Map.set (view'0 self) (eq_model'0 key) (Core_Option_Option_Type.C_Some ( ^ v))
        | Core_Option_Option_Type.C_None -> Map.get (view'0 self) (eq_model'0 key) = Core_Option_Option_Type.C_None
        /\ view'1 ( ^ self) = view'0 self
        end}
      {[@expl:postcondition] [#"../red_black_tree.rs" 832 14 832 33] invariant'0 ( ^ self)}
      (! return' {result}) ]
    
end
module RedBlackTree_Impl16
  use RedBlackTree_Color_Type as RedBlackTree_Color_Type
  predicate invariant'1 (self : RedBlackTree_Color_Type.t_color) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:RedBlackTree_Color_Type.t_color) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : RedBlackTree_Color_Type.t_color)
  let rec inv'1 (_x:RedBlackTree_Color_Type.t_color) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : RedBlackTree_Color_Type.t_color . inv'1 x = true
  predicate invariant'0 (self : RedBlackTree_Color_Type.t_color) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:RedBlackTree_Color_Type.t_color) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : RedBlackTree_Color_Type.t_color)
  let rec inv'0 (_x:RedBlackTree_Color_Type.t_color) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : RedBlackTree_Color_Type.t_color . inv'0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../red_black_tree.rs" 8 9 8 14] forall self : RedBlackTree_Color_Type.t_color . inv'0 self
   -> (forall result : RedBlackTree_Color_Type.t_color . result = self  -> inv'1 result /\ result = self)
end
module RedBlackTree_Impl17
  
end
module RedBlackTree_Impl2
  type k
  type v
end
module RedBlackTree_Impl3
  type k
  type v
end
