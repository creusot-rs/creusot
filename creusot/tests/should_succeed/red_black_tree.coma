
module T_red_black_tree__Color [#"red_black_tree.rs" 13 0 13 10]
  type t_Color  =
    | C_Red
    | C_Black
  
  let rec v_Red (input:t_Color) (ret  )= any
    [ good -> {C_Red  = input} (! ret) | bad -> {C_Red  <> input} (! {false} any) ]
    
  
  let rec v_Black (input:t_Color) (ret  )= any
    [ good -> {C_Black  = input} (! ret) | bad -> {C_Black  <> input} (! {false} any) ]
    
end
module M_red_black_tree__qyi11959472507597060150__clone [#"red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 12 9 12 14
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Intrinsic
  
  use T_red_black_tree__Color as Color'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone' (self:Color'0.t_Color) (return'  (ret:Color'0.t_Color))= (! bb0
    [ bb0 = any [ br0 -> {self = Color'0.C_Red } (! bb2) | br1 -> {self = Color'0.C_Black } (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- Color'0.C_Black ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- Color'0.C_Red ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : Color'0.t_Color = any_l () | & self : Color'0.t_Color = self ] 
    [ return' (result:Color'0.t_Color)-> {[@expl:postcondition] [%#sred_black_tree0] result = self}
      (! return' {result}) ]
    
end
module T_core__option__Option
  type t_T'0
  
  type t_Option 't_T'0 =
    | C_None
    | C_Some 't_T'0
  
  let rec v_None < 't_T'0 > (input:t_Option 't_T'0) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't_T'0 > (input:t_Option 't_T'0) (ret  (field_0:'t_T'0))= any
    [ good (field_0:'t_T'0)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't_T'0 [C_Some field_0 : t_Option 't_T'0] . C_Some field_0 <> input} (! {false} any) ]
    
end
module T_red_black_tree__Node [#"red_black_tree.rs" 19 0 19 17]
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Color as Color'0
  
  type t_V'0
  
  type t_K'0
  
  type t_Node 't_K'0 't_V'0 =
    | C_Node (t_Tree 't_K'0 't_V'0) (Color'0.t_Color) 't_K'0 't_V'0 (t_Tree 't_K'0 't_V'0)
  with t_Tree 't_K'0 't_V'0 =
    | C_Tree (Option'0.t_Option (t_Node 't_K'0 't_V'0))
  
  let rec t_Node < 't_K'0 > < 't_V'0 > (input:t_Node 't_K'0 't_V'0) (ret  (left:t_Tree 't_K'0 't_V'0) (color:Color'0.t_Color) (key:'t_K'0) (val':'t_V'0) (right:t_Tree 't_K'0 't_V'0))= any
    [ good (left:t_Tree 't_K'0 't_V'0) (color:Color'0.t_Color) (key:'t_K'0) (val':'t_V'0) (right:t_Tree 't_K'0 't_V'0)-> {C_Node left color key val' right
      = input}
      (! ret {left} {color} {key} {val'} {right}) ]
    
  
  let rec t_Tree < 't_K'0 > < 't_V'0 > (input:t_Tree 't_K'0 't_V'0) (ret  (node:Option'0.t_Option (t_Node 't_K'0 't_V'0)))= any
    [ good (node:Option'0.t_Option (t_Node 't_K'0 't_V'0))-> {C_Tree node = input} (! ret {node}) ]
    
  
  function t_Node__left (self : t_Node 't_K'0 't_V'0) : t_Tree 't_K'0 't_V'0 =
    match self with
      | C_Node a _ _ _ _ -> a
      end
  
  function t_Node__key (self : t_Node 't_K'0 't_V'0) : 't_K'0 =
    match self with
      | C_Node _ _ a _ _ -> a
      end
  
  function t_Node__right (self : t_Node 't_K'0 't_V'0) : t_Tree 't_K'0 't_V'0 =
    match self with
      | C_Node _ _ _ _ a -> a
      end
  
  function t_Node__val (self : t_Node 't_K'0 't_V'0) : 't_V'0 =
    match self with
      | C_Node _ _ _ a _ -> a
      end
  
  function t_Node__color (self : t_Node 't_K'0 't_V'0) : Color'0.t_Color =
    match self with
      | C_Node _ a _ _ _ -> a
      end
  
  function t_Tree__node (self : t_Tree 't_K'0 't_V'0) : Option'0.t_Option (t_Node 't_K'0 't_V'0) =
    match self with
      | C_Tree a -> a
      end
end
module T_red_black_tree__Tree [#"red_black_tree.rs" 27 0 27 17]
  use export T_red_black_tree__Node
end
module M_red_black_tree__qyi2476155906044564626__model_acc_has_mapping [#"red_black_tree.rs" 69 4 69 83] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree1 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree2 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree3 = "red_black_tree.rs" 71 12 79 13
  
  use map.Map
  
  type t_DeepModelTy'0
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  type t_V'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree1] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  constant accu  : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
  
  constant k  : t_DeepModelTy'0
  
  function model_acc_has_mapping [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_model_acc_has_mapping : match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> ([%#sred_black_tree0] Map.get (model_acc'0 left accu) k
    = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 left accu) k = Option'0.C_Some v /\ has_mapping'0 left k v))
     -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in ([%#sred_black_tree0] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 right accu2) k = Option'0.C_Some v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)))
    end
end
module T_core__cmp__Ordering
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  let rec v_Less (input:t_Ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} (! {false} any) ]
    
  
  let rec v_Equal (input:t_Ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} (! {false} any) ]
    
  
  let rec v_Greater (input:t_Ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} (! {false} any) ]
    
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_model_acc [#"red_black_tree.rs" 86 4 88 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree1 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree2 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree3 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree4 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree5 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree6 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree7 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree8 = "red_black_tree.rs" 215 12 216 104
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord19] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord20] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord18] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord14] cmp_log'0 x y
  = o)  -> ([%#sord15] cmp_log'0 y z = o)  -> ([%#sord16] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord13] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  type t_V'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree4] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree5] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree7] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree8] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree3] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  constant accu  : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model_acc [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_has_mapping_model_acc : ([%#sred_black_tree0] bst_invariant'0 self)
   -> match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> ([%#sred_black_tree0] bst_invariant'0 left)
    /\ (([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 left k v
     -> Map.get (model_acc'0 left accu) k = Option'0.C_Some v)
     -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in ([%#sred_black_tree0] bst_invariant'0 right)
    /\ (([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 right k v
     -> Map.get (model_acc'0 right accu2) k = Option'0.C_Some v)
     -> (let _ = has_mapping_model_acc right accu2 k in ([%#sred_black_tree2] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 right accu2) k = Option'0.C_Some v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)))))
    end
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_model [#"red_black_tree.rs" 107 4 109 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree1 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree2 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree3 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree4 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree5 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree6 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree7 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree8 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree9 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree10 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree11 = "red_black_tree.rs" 215 12 216 104
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord24] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord22] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord23] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord20] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord21] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord17] cmp_log'0 x y
  = o)  -> ([%#sord18] cmp_log'0 y z = o)  -> ([%#sord19] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord16] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  type t_V'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree9] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree11] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree5] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree10] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree3] bst_invariant'0 self)
   -> ([%#sred_black_tree4] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  use map.Const
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree7] model_acc'0 self (Const.const (Option'0.C_None))
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
  
  goal vc_has_mapping_model : ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree2] Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k
  = Map.get (Const.const (Option'0.C_None)) k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k = Option'0.C_Some v
  /\ has_mapping'0 self k v))
   -> (let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in ([%#sred_black_tree3] bst_invariant'0 self)
  /\ (([%#sred_black_tree4] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self (Const.const (Option'0.C_None))) k = Option'0.C_Some v)
   -> ([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = Option'0.C_Some v))))
end
module M_red_black_tree__qyi2476155906044564626__has_mapping_inj [#"red_black_tree.rs" 122 4 124 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 118 15 118 35
  let%span sred_black_tree1 = "red_black_tree.rs" 119 15 119 38
  let%span sred_black_tree2 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree3 = "red_black_tree.rs" 121 14 121 22
  let%span sred_black_tree4 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree5 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree6 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree7 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree8 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree9 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree10 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree11 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree12 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree13 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree14 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree15 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree16 = "red_black_tree.rs" 55 12 62 13
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord29] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord27] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord28] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord25] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord26] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord22] cmp_log'0 x y
  = o)  -> ([%#sord23] cmp_log'0 y z = o)  -> ([%#sord24] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord21] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord18] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord17] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  type t_V'0
  
  use T_red_black_tree__Tree as Tree'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree9] model_acc'0 self (Const.const (Option'0.C_None))
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree7] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree12] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree11] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree10] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree13] bst_invariant'0 self)
   -> ([%#sred_black_tree14] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree8] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = Option'0.C_Some v))
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  constant k  : t_DeepModelTy'0
  
  constant v1  : t_V'0
  
  constant v2  : t_V'0
  
  function has_mapping_inj [#"red_black_tree.rs" 122 4 124 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v1 : t_V'0) (v2 : t_V'0) : ()
    
  
  goal vc_has_mapping_inj : ([%#sred_black_tree2] has_mapping'0 self k v2)
   -> ([%#sred_black_tree1] has_mapping'0 self k v1)
   -> ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree4] bst_invariant'0 self)
  /\ (([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = Option'0.C_Some v))
   -> (let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
    | Option'0.C_None -> [%#sred_black_tree3] v1 = v2
    | Option'0.C_Some _v -> [%#sred_black_tree3] v1 = v2
    end))
end
module M_red_black_tree__qyi17561227306860881838__has_mapping [#"red_black_tree.rs" 137 4 137 57] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree1 = "red_black_tree.rs" 37 12 41 13
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  type t_V'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree1] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  constant self  : Node'0.t_Node t_K'0 t_V'0
  
  constant k  : t_DeepModelTy'0
  
  constant v  : t_V'0
  
  predicate has_mapping [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
  
  goal vc_has_mapping : if k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) then
    [%#sred_black_tree0] forall node : Node'0.t_Node t_K'0 t_V'0 . self = node
     -> ((has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v)
    \/ v = T_red_black_tree__Node.t_Node__val self)
    = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  else
    [%#sred_black_tree0] forall node : Node'0.t_Node t_K'0 t_V'0 . self = node
     -> ((has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v)
    \/ false)
    = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
end
module M_red_black_tree__qyi14787627995992352676__resolve_coherence [#"red_black_tree.rs" 187 4 187 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 185 15 185 39
  let%span sred_black_tree1 = "red_black_tree.rs" 186 14 186 31
  let%span sred_black_tree2 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree3 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve4 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sresolve5 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span sred_black_tree6 = "red_black_tree.rs" 194 8 196 9
  let%span sred_black_tree7 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree8 = "red_black_tree.rs" 138 8 141 9
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Tree as Tree'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'2 (_1 : t_V'0)
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree3] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'0 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree2] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree8] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree7] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'7 [#"red_black_tree.rs" 193 4 193 28] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'6 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'7 _1
  
  predicate resolve'5 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sresolve5] resolve'6 self
  
  predicate resolve'4 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'5 _1
  
  predicate resolve'3 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve4] match self with
      | Option'0.C_Some x -> resolve'4 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Tree'0.t_Tree t_K'0 t_V'0) =
    match x with
      | Tree'0.C_Tree a -> resolve'1 a
      end
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  function resolve_coherence [#"red_black_tree.rs" 187 4 187 31] (self : Tree'0.t_Tree t_K'0 t_V'0) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)  -> ([%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi16896830124134315792__resolve_coherence [#"red_black_tree.rs" 203 4 203 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 201 15 201 39
  let%span sred_black_tree1 = "red_black_tree.rs" 202 14 202 31
  let%span sred_black_tree2 = "red_black_tree.rs" 194 8 196 9
  let%span sred_black_tree3 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree4 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree5 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree6 = "red_black_tree.rs" 37 12 41 13
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'2 (_1 : t_V'0)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_core__option__Option as Option'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree4] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree3] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'0 [#"red_black_tree.rs" 193 4 193 28] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree2] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Color as Color'0
  
  predicate resolve'4 (_1 : Color'0.t_Color) =
    true
  
  predicate resolve'3 (_1 : t_K'0)
  
  predicate resolve'5 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree5] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'5 _1
  
  predicate structural_resolve'0 (x : Node'0.t_Node t_K'0 t_V'0) =
    match x with
      | Node'0.C_Node a b c d e -> resolve'1 e /\ resolve'2 d /\ resolve'3 c /\ resolve'4 b /\ resolve'1 a
      end
  
  constant self  : Node'0.t_Node t_K'0 t_V'0
  
  function resolve_coherence [#"red_black_tree.rs" 203 4 203 31] (self : Node'0.t_Node t_K'0 t_V'0) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)  -> ([%#sred_black_tree1] resolve'0 self)
end
module T_red_black_tree__CP [#"red_black_tree.rs" 248 0 248 7]
  use T_red_black_tree__Color as Color'0
  
  type t_CP  =
    | C_CPL (Color'0.t_Color)
    | C_CPN (Color'0.t_Color) (t_CP) (t_CP)
  
  let rec v_CPL (input:t_CP) (ret  (field_0:Color'0.t_Color))= any
    [ good (field_0:Color'0.t_Color)-> {C_CPL field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : Color'0.t_Color [C_CPL field_0 : t_CP] . C_CPL field_0 <> input} (! {false} any) ]
    
  
  let rec v_CPN (input:t_CP) (ret  (field_0:Color'0.t_Color) (field_1:t_CP) (field_2:t_CP))= any
    [ good (field_0:Color'0.t_Color) (field_1:t_CP) (field_2:t_CP)-> {C_CPN field_0 field_1 field_2 = input}
      (! ret {field_0} {field_1} {field_2})
    | bad -> {forall field_0 : Color'0.t_Color, field_1 : t_CP, field_2 : t_CP [C_CPN field_0 field_1 field_2 : t_CP] . C_CPN field_0 field_1 field_2
      <> input}
      (! {false}
      any) ]
    
end
module M_red_black_tree__qyi2476155906044564626__height [#"red_black_tree.rs" 325 4 325 26] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree1 = "red_black_tree.rs" 327 12 335 13
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Tree as Tree'0
  
  use prelude.prelude.Int
  
  constant self  : Tree'0.t_Tree t_K'0 t_V'0
  
  function height [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int
  
  goal vc_height : match self with
    | Tree'0.C_Tree (Option'0.C_None) -> [%#sred_black_tree0] 0 >= 0
    | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
      | Color'0.C_Red -> ([%#sred_black_tree0] height left >= 0)  -> ([%#sred_black_tree0] height left >= 0)
      | Color'0.C_Black -> ([%#sred_black_tree0] height left >= 0)  -> ([%#sred_black_tree0] height left + 1 >= 0)
      end
    end
end
module M_red_black_tree__qyi17561227306860881838__height [#"red_black_tree.rs" 357 4 357 26] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree1 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree2 = "red_black_tree.rs" 327 12 335 13
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use prelude.prelude.Int
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Tree as Tree'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree1] height'0 self >= 0
  
  constant self  : Node'0.t_Node t_K'0 t_V'0
  
  function height [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int
  
  goal vc_height : match T_red_black_tree__Node.t_Node__color self with
    | Color'0.C_Red -> ([%#sred_black_tree1] height'0 (T_red_black_tree__Node.t_Node__left self) >= 0)
     -> ([%#sred_black_tree0] forall node : Node'0.t_Node t_K'0 t_V'0 . self = node
     -> height'0 (T_red_black_tree__Node.t_Node__left self) = height'0 (Tree'0.C_Tree (Option'0.C_Some node)))
    | Color'0.C_Black -> ([%#sred_black_tree1] height'0 (T_red_black_tree__Node.t_Node__left self) >= 0)
     -> ([%#sred_black_tree0] forall node : Node'0.t_Node t_K'0 t_V'0 . self = node
     -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1 = height'0 (Tree'0.C_Tree (Option'0.C_Some node)))
    end
end
module M_red_black_tree__qyi2476155906044564626__is_red [#"red_black_tree.rs" 412 4 412 28] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 415 17 415 22
  let%span sred_black_tree1 = "red_black_tree.rs" 414 49 414 53
  let%span sred_black_tree2 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree3 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree4 = "red_black_tree.rs" 287 12 290 13
  let%span sinvariant5 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed6 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  predicate inv'6 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'5 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed6] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree4] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec is_red (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[%#sred_black_tree2] inv'0 self}
    (! bb0
    [ bb0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self}
        (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
          any
          [ br0 -> {rnode'0 = Option'0.C_None } (! bb6)
          | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {rnode'0 = Option'0.C_Some a} (! bb2) ]
          )
    | bb6 = bb1
    | bb2 = Tree'0.t_Tree <t_K'0> <t_V'0> {self}
        (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
          Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {rnode'0}
            (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
              Node'0.t_Node <t_K'0> <t_V'0> {r0'0}
                (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                  any [ br0 -> {rcolor'0 = Color'0.C_Red } (! bb3) | br1 -> {rcolor'0 = Color'0.C_Black } (! bb1) ] )))
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree0] false ] s1 | s1 = bb5 ] 
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree1] true ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : bool = any_l () | & self : Tree'0.t_Tree t_K'0 t_V'0 = self ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sred_black_tree3] result = (color'0 self = Color'0.C_Red)}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__rotate_right [#"red_black_tree.rs" 436 4 436 30] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 437 23 437 41
  let%span sred_black_tree1 = "red_black_tree.rs" 465 8 465 90
  let%span sred_black_tree2 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree3 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree4 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree5 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree6 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree7 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree8 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree9 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree10 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree11 = "red_black_tree.rs" 432 4 435 36
  let%span smem12 = "../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem13 = "../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span smem15 = "../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem16 = "../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree17 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree18 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree19 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree20 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree21 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree22 = "red_black_tree.rs" 359 12 362 13
  let%span soption23 = "../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree25 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree26 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree27 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree28 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree29 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree30 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree31 = "red_black_tree.rs" 327 12 335 13
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sinvariant45 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed46 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree47 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree48 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree49 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree50 = "red_black_tree.rs" 342 12 348 13
  
  use T_red_black_tree__Color as Color'0
  
  use prelude.prelude.Borrow
  
  predicate inv'8 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'8 x] . inv'8 x = true
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord42] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord43] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord40] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord41] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord37] cmp_log'0 x y
  = o)  -> ([%#sord38] cmp_log'0 y z = o)  -> ([%#sord39] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord36] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord35] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord34] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord33] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord32] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'4 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant45] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'5 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant45] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed46] inv'4 self
  
  axiom inv_axiom'5 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'9 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant45] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant45] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree30] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree22] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree21] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree17] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree29] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree28] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree20] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree19] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree49] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree50] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree27] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree47] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree26] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree18] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'11 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'11 _1
  
  predicate resolve'12 (_1 : t_V'0)
  
  predicate resolve'10 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree25] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'10 _1
  
  use prelude.prelude.Snapshot
  
  predicate resolve'9 (self : borrowed (Color'0.t_Color)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Color'0.t_Color)) =
    resolve'9 _1
  
  let rec swap'2 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] inv'8 y}
    {[@expl:precondition] inv'8 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'8 _1
  
  let rec swap'1 (x:borrowed (Node'0.t_Node t_K'0 t_V'0)) (y:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] inv'7 y}
    {[@expl:precondition] inv'7 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'7 _1
  
  let rec swap'0 (x:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (y:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] inv'3 y}
    {[@expl:precondition] inv'3 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'5 result}
      {[%#soption14] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'6 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#soption23] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'1 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'0 result}
      {[%#smem13] is_default'0 dest.final}
      {[%#smem12] result = dest.current}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_right (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[%#sred_black_tree4] inv'7 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red}
    {[%#sred_black_tree2] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_16 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = {inv'0 _16.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {_16.current} {Borrow.get_id _16}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'2 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_19 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = {inv'2 _19.current}
        Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_19.current} {Borrow.get_id _19}
          (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final ; } ] 
            s2)
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {x}
          (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'2 rright'1}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'1}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_21 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &x <- Node'0.C_Node rleft'1 rcolor'1 rkey'1 rval'1 _ret'.final ] 
                s3))
      | s3 = {inv'2 _21.current}
        Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_21.current} {Borrow.get_id _21}
          (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s5)
      | s5 = {inv'5 x}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {x}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_25 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &x <- _ret'.final ] 
            s6)
      | s6 = {inv'4 _25.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_25.current} {Borrow.get_id _25}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final ; } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_28 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s3))
      | s3 = Borrow.borrow_final <Color'0.t_Color> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s4)
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {x}
          (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_mut <Color'0.t_Color> {rcolor'1}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_30 <- _ret' ] 
                 [ &x <- Node'0.C_Node rleft'1 _ret'.final rkey'1 rval'1 rright'1 ] 
                s5))
      | s5 = Borrow.borrow_final <Color'0.t_Color> {_30.current} {Borrow.get_id _30}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = _ret'.final ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (T_red_black_tree__Node.t_Node__left (Snapshot.inner old_self).current) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (T_red_black_tree__Node.t_Node__val self.current)}
        s3
      | s3 =  [ &_34 <- Option'0.C_Some x ] s4
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 =  [ &_33 <- Tree'0.C_Tree _34 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Node'0.C_Node _ _ _ _ x'0} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Node'0.C_Node _ _ _ _ x'1} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _33 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
      
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & old_self : Snapshot.snap_ty (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & x : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _14 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _17 : () = any_l ()
    | & _18 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _19 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _21 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _22 : () = any_l ()
    | & _23 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _24 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _25 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Color'0.t_Color) = any_l ()
    | & _28 : borrowed (Color'0.t_Color) = any_l ()
    | & _29 : borrowed (Color'0.t_Color) = any_l ()
    | & _30 : borrowed (Color'0.t_Color) = any_l ()
    | & _33 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _34 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree11] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree10] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 (T_red_black_tree__Node.t_Node__right self.final)
      = Color'0.C_Red}
      {[@expl:postcondition] [%#sred_black_tree8] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__rotate_left [#"red_black_tree.rs" 486 4 486 29] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 487 23 487 41
  let%span sred_black_tree1 = "red_black_tree.rs" 492 8 492 91
  let%span sred_black_tree2 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree3 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree4 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree5 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree6 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree7 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree8 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree9 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree10 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree11 = "red_black_tree.rs" 482 4 485 36
  let%span smem12 = "../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem13 = "../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span smem15 = "../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem16 = "../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree17 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree18 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree19 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree20 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree21 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree22 = "red_black_tree.rs" 359 12 362 13
  let%span soption23 = "../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree25 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree26 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree27 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree28 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree29 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree30 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree31 = "red_black_tree.rs" 327 12 335 13
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sinvariant45 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed46 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree47 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree48 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree49 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree50 = "red_black_tree.rs" 342 12 348 13
  
  use T_red_black_tree__Color as Color'0
  
  use prelude.prelude.Borrow
  
  predicate inv'8 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'8 x] . inv'8 x = true
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord42] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord43] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord40] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord41] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord37] cmp_log'0 x y
  = o)  -> ([%#sord38] cmp_log'0 y z = o)  -> ([%#sord39] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord36] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord35] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord34] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord33] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord32] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'4 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant45] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'5 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant45] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed46] inv'4 self
  
  axiom inv_axiom'5 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'9 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant45] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant45] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree30] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree22] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree21] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree17] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree29] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree28] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree20] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree19] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree49] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree50] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree27] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree47] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree26] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree18] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'11 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'11 _1
  
  predicate resolve'12 (_1 : t_V'0)
  
  predicate resolve'10 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree25] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'10 _1
  
  use prelude.prelude.Snapshot
  
  predicate resolve'9 (self : borrowed (Color'0.t_Color)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Color'0.t_Color)) =
    resolve'9 _1
  
  let rec swap'2 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] inv'8 y}
    {[@expl:precondition] inv'8 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'8 _1
  
  let rec swap'1 (x:borrowed (Node'0.t_Node t_K'0 t_V'0)) (y:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] inv'7 y}
    {[@expl:precondition] inv'7 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'7 _1
  
  let rec swap'0 (x:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (y:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] inv'3 y}
    {[@expl:precondition] inv'3 x}
    any
    [ return' (result:())-> {[%#smem16] y.final = x.current} {[%#smem15] x.final = y.current} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'5 result}
      {[%#soption14] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'6 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#soption23] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'1 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'0 result}
      {[%#smem13] is_default'0 dest.final}
      {[%#smem12] result = dest.current}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_left (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[%#sred_black_tree4] inv'7 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red}
    {[%#sred_black_tree2] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_16 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = {inv'0 _16.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {_16.current} {Borrow.get_id _16}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'2 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_19 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = {inv'2 _19.current}
        Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_19.current} {Borrow.get_id _19}
          (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final ; } ] 
            s2)
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {x}
          (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'2 rleft'1}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rleft'1}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_21 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &x <- Node'0.C_Node _ret'.final rcolor'1 rkey'1 rval'1 rright'1 ] 
                s3))
      | s3 = {inv'2 _21.current}
        Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_21.current} {Borrow.get_id _21}
          (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s5)
      | s5 = {inv'5 x}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {x}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_25 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &x <- _ret'.final ] 
            s6)
      | s6 = {inv'4 _25.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_25.current} {Borrow.get_id _25}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final ; } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_28 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s3))
      | s3 = Borrow.borrow_final <Color'0.t_Color> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_27 <- _ret' ] 
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s4)
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {x}
          (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_mut <Color'0.t_Color> {rcolor'1}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_30 <- _ret' ] 
                 [ &x <- Node'0.C_Node rleft'1 _ret'.final rkey'1 rval'1 rright'1 ] 
                s5))
      | s5 = Borrow.borrow_final <Color'0.t_Color> {_30.current} {Borrow.get_id _30}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_29 <- _ret' ] 
             [ &_30 <- { _30 with current = _ret'.final ; } ] 
            s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
      
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (T_red_black_tree__Node.t_Node__right (Snapshot.inner old_self).current) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (T_red_black_tree__Node.t_Node__val self.current)}
        s3
      | s3 =  [ &_34 <- Option'0.C_Some x ] s4
      | s4 = bb7 ]
      
    | bb7 = s0 [ s0 =  [ &_33 <- Tree'0.C_Tree _34 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Node'0.C_Node x'0 _ _ _ _} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Node'0.C_Node x'1 _ _ _ _} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &self <- { self with current = Node'0.C_Node _33 rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
      
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & old_self : Snapshot.snap_ty (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & x : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _14 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _17 : () = any_l ()
    | & _18 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _19 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _21 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _22 : () = any_l ()
    | & _23 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _24 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _25 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Color'0.t_Color) = any_l ()
    | & _28 : borrowed (Color'0.t_Color) = any_l ()
    | & _29 : borrowed (Color'0.t_Color) = any_l ()
    | & _30 : borrowed (Color'0.t_Color) = any_l ()
    | & _33 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _34 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree11] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree10] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 (T_red_black_tree__Node.t_Node__left self.final)
      = Color'0.C_Red}
      {[@expl:postcondition] [%#sred_black_tree8] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__flip_colors [#"red_black_tree.rs" 510 4 510 29] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree1 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree2 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree3 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree4 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree5 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree6 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree7 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree8 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree9 = "red_black_tree.rs" 504 4 506 70
  let%span sred_black_tree10 = "red_black_tree.rs" 507 4 509 90
  let%span soption11 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span smem14 = "../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem15 = "../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree16 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree17 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree18 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree19 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree20 = "red_black_tree.rs" 146 8 148 9
  let%span sresolve21 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree22 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree23 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree24 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree25 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree26 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree27 = "red_black_tree.rs" 138 8 141 9
  let%span sinvariant28 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree29 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree30 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree31 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree32 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree33 = "red_black_tree.rs" 37 12 41 13
  let%span sboxed34 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'8 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'8 x] . inv'8 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord45] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord46] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord43] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord44] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord40] cmp_log'0 x y
  = o)  -> ([%#sord41] cmp_log'0 y z = o)  -> ([%#sord42] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord39] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord38] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord37] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord36] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord35] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'9 (_1 : t_K'0)
  
  predicate inv'7 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'7 x] . inv'7 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'8 left /\ inv'9 key /\ inv'10 val' /\ inv'8 right
    end
  
  predicate invariant'3 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'6 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  use T_red_black_tree__Color as Color'0
  
  use prelude.prelude.Borrow
  
  predicate inv'5 (_1 : borrowed (Color'0.t_Color))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Color'0.t_Color) [inv'5 x] . inv'5 x = true
  
  predicate inv'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant28] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'3 x] . inv'3 x
  = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant28] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant28] inv'6 self.current /\ inv'6 self.final
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree33] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree27] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree26] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree20] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree24] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree19] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree18] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree17] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree31] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree23] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree29] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree22] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree16] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  predicate resolve'4 (self : borrowed (Color'0.t_Color)) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Color'0.t_Color)) =
    resolve'4 _1
  
  let rec swap'0 (x:borrowed (Color'0.t_Color)) (y:borrowed (Color'0.t_Color)) (return'  (ret:()))= {[@expl:precondition] inv'5 y}
    {[@expl:precondition] inv'5 x}
    any
    [ return' (result:())-> {[%#smem15] y.final = x.current} {[%#smem14] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve21] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'3 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'4 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'1 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'4 result}
      {[%#soption12] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption11] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec flip_colors (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[%#sred_black_tree4] inv'2 self}
    {[%#sred_black_tree3] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[%#sred_black_tree2] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[%#sred_black_tree1] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_15 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_15}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Node'0.t_Node <t_K'0> <t_V'0> {_13.current}
              (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_13 <- { _13 with current = Node'0.C_Node rleft'1 rcolor'0 rkey'1 rval'1 rright'1 ; } ] 
                s1))
      | s1 = {[@expl:type invariant] inv'1 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'2:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'2:Color'0.t_Color) (rkey'2:t_K'0) (rval'2:t_V'0) (rright'2:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'2} {Borrow.inherit_id (Borrow.get_id self) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_18 <- _ret' ] 
                 [ &self <- { self with current = Node'0.C_Node rleft'2 _ret'.final rkey'2 rval'2 rright'2 ; } ] 
                s4))
      | s4 = Borrow.borrow_final <Color'0.t_Color> {_18.current} {Borrow.get_id _18}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_17 <- _ret' ] 
             [ &_18 <- { _18 with current = _ret'.final ; } ] 
            s5)
      | s5 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'3:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'3:Color'0.t_Color) (rkey'3:t_K'0) (rval'3:t_V'0) (rright'3:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'3}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_23 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'3 rcolor'3 rkey'3 rval'3 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s6)))
      | s6 = as_mut'0 {_23}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_22 <- _ret' ] s7)
      | s7 = bb3 ]
      
    | bb3 = s0
      [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_21 <- _ret' ] s1) | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_21.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Borrow.borrow_final <Color'0.t_Color> {rcolor'0} {Borrow.inherit_id (Borrow.get_id _21) 2}
              (fun (_ret':borrowed (Color'0.t_Color)) ->
                 [ &_20 <- _ret' ] 
                 [ &_21 <- { _21 with current = Node'0.C_Node rleft'0 _ret'.final rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = Borrow.borrow_final <Color'0.t_Color> {_20.current} {Borrow.get_id _20}
          (fun (_ret':borrowed (Color'0.t_Color)) ->
             [ &_19 <- _ret' ] 
             [ &_20 <- { _20 with current = _ret'.final ; } ] 
            s2)
      | s2 = swap'0 {_17} {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'1 _20}- s3
      | s3 = -{resolve'1 _18}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = return' {_0} ]
       ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & _13 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _16 : () = any_l ()
    | & _17 : borrowed (Color'0.t_Color) = any_l ()
    | & _18 : borrowed (Color'0.t_Color) = any_l ()
    | & _19 : borrowed (Color'0.t_Color) = any_l ()
    | & _20 : borrowed (Color'0.t_Color) = any_l ()
    | & _21 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _22 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _23 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree10] exists r1 : Node'0.t_Node t_K'0 t_V'0, r2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[@expl:postcondition] [%#sred_black_tree9] exists l1 : Node'0.t_Node t_K'0 t_V'0, l2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[@expl:postcondition] [%#sred_black_tree8] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key self.final}
      {[@expl:postcondition] [%#sred_black_tree7] same_mappings'0 self.current self.final}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__balance [#"red_black_tree.rs" 534 4 534 25] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree1 = "red_black_tree.rs" 516 4 517 47
  let%span sred_black_tree2 = "red_black_tree.rs" 518 4 519 48
  let%span sred_black_tree3 = "red_black_tree.rs" 520 4 520 110
  let%span sred_black_tree4 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree5 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree6 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree7 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree8 = "red_black_tree.rs" 524 4 525 34
  let%span sred_black_tree9 = "red_black_tree.rs" 526 4 527 39
  let%span sred_black_tree10 = "red_black_tree.rs" 528 4 529 63
  let%span sred_black_tree11 = "red_black_tree.rs" 530 4 531 61
  let%span sred_black_tree12 = "red_black_tree.rs" 532 4 533 39
  let%span sred_black_tree13 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree14 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree15 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree16 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree17 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree18 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree19 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree20 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree21 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree22 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree23 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree24 = "red_black_tree.rs" 482 4 485 36
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span soption27 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sred_black_tree28 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree29 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree30 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree31 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree32 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree33 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree34 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree35 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree36 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree37 = "red_black_tree.rs" 432 4 435 36
  let%span sred_black_tree38 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree39 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree40 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree41 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree42 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree43 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree44 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree45 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree46 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree47 = "red_black_tree.rs" 504 4 506 70
  let%span sred_black_tree48 = "red_black_tree.rs" 507 4 509 90
  let%span sred_black_tree49 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree50 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree51 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree52 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree53 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree54 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree55 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree56 = "red_black_tree.rs" 275 12 278 13
  let%span sresolve57 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree58 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree59 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree60 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree61 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree62 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree63 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree64 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree65 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree66 = "red_black_tree.rs" 263 12 268 13
  let%span sord67 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord68 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord69 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord70 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord71 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord72 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord73 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord74 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord75 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord76 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord77 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord78 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord79 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sinvariant80 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree81 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree82 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree83 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree84 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree85 = "red_black_tree.rs" 37 12 41 13
  let%span sinvariant86 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed87 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'4 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed87] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'9 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'6 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'6 x] . inv'6 x
  = match x with
    | Tree'0.C_Tree node -> inv'9 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sinvariant86] inv'10 self
  
  predicate inv'5 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'4 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'5 a_0
    end
  
  predicate invariant'2 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant86] inv'9 self
  
  predicate inv'3 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'3 x] . inv'3 x
  = invariant'2 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord79] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord77] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord78] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord75] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord76] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord72] cmp_log'0 x y
  = o)  -> ([%#sord73] cmp_log'0 y z = o)  -> ([%#sord74] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord71] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord69] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord68] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord67] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant86] inv'6 self
  
  predicate inv'2 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant80] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'8 (_1 : t_V'0)
  
  predicate inv'7 (_1 : t_K'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'6 left /\ inv'7 key /\ inv'8 val' /\ inv'6 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree50] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree60] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree51] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree66] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree65] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree56] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree55] CP'0.C_CPN c l r
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree64] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree63] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree54] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree53] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree85] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree62] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree61] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree52] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree83] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree84] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree59] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree81] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree82] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree58] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree49] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve57] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'1 _1
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree42] inv'1 self}
    {[@expl:precondition] [%#sred_black_tree41] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree40] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree39] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree38] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree48] exists r1 : Node'0.t_Node t_K'0 t_V'0, r2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#sred_black_tree47] exists l1 : Node'0.t_Node t_K'0 t_V'0, l2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#sred_black_tree46] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key self.final}
      {[%#sred_black_tree45] same_mappings'0 self.current self.final}
      {[%#sred_black_tree44] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree43] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree30] inv'1 self}
    {[@expl:precondition] [%#sred_black_tree29] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree28] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree37] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree36] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree35] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#sred_black_tree34] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#sred_black_tree33] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree32] internal_invariant'0 self.final}
      {[%#sred_black_tree31] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'4 self}
    {[@expl:precondition] [%#soption27] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'5 result}
      {[%#soption27] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'3 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#soption26] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node t_K'0 t_V'0 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption25] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec rotate_left'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree17] inv'1 self}
    {[@expl:precondition] [%#sred_black_tree16] color'0 (T_red_black_tree__Node.t_Node__right self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree15] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree24] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree23] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree22] color'0 (T_red_black_tree__Node.t_Node__left self.final) = Color'0.C_Red}
      {[%#sred_black_tree21] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree19] internal_invariant'0 self.final}
      {[%#sred_black_tree18] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree13] inv'2 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree14] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec balance (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[%#sred_black_tree4] inv'1 self}
    {[%#sred_black_tree3] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[%#sred_black_tree2] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[%#sred_black_tree1] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = bb1 ]
      
    | bb1 = any [ br0 -> {_15 = false} (! bb7) | br1 -> {_15} (! bb2) ] 
    | bb2 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1))
      | s1 = bb3 ]
      
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ] 
    | bb4 = bb8
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_20 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_left'0 {_20} (fun (_ret':()) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = bb9
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_27 <- _ret' ] s1)))
      | s1 = bb12 ]
      
    | bb12 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &_26 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_26}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1))
      | s1 = bb14 ]
      
    | bb14 = any [ br0 -> {_24 = false} (! bb17) | br1 -> {_24} (! bb15) ] 
    | bb15 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = bb20
    | bb17 = bb19
    | bb18 = bb19
    | bb19 = bb20
    | bb20 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s1))
      | s1 = bb21 ]
      
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ] 
    | bb22 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1))
      | s1 = bb23 ]
      
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ] 
    | bb24 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {self.current} {Borrow.get_id self}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_36 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_36} (fun (_ret':()) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb25 ]
      
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ] 
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb28 = bb29
    | bb29 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & _15 : bool = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : () = any_l ()
    | & _20 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _27 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _29 : () = any_l ()
    | & _30 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _31 : bool = any_l ()
    | & _33 : bool = any_l ()
    | & _35 : () = any_l ()
    | & _36 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree12] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[@expl:postcondition] [%#sred_black_tree10] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[@expl:postcondition] [%#sred_black_tree9] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[@expl:postcondition] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__move_red_left [#"red_black_tree.rs" 566 4 566 44] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree1 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree2 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree3 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree4 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree5 = "red_black_tree.rs" 552 4 554 48
  let%span sred_black_tree6 = "red_black_tree.rs" 555 4 555 97
  let%span sred_black_tree7 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree8 = "red_black_tree.rs" 557 4 557 105
  let%span sred_black_tree9 = "red_black_tree.rs" 558 4 559 47
  let%span sred_black_tree10 = "red_black_tree.rs" 560 4 561 108
  let%span sred_black_tree11 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree12 = "red_black_tree.rs" 564 4 565 45
  let%span sred_black_tree13 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree14 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree15 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree16 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree17 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree18 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree19 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree20 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree21 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree22 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree23 = "red_black_tree.rs" 504 4 506 70
  let%span sred_black_tree24 = "red_black_tree.rs" 507 4 509 90
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption27 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sred_black_tree28 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree29 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree30 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree31 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree32 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree33 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree34 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree35 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree36 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree37 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree38 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree39 = "red_black_tree.rs" 432 4 435 36
  let%span sred_black_tree40 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree41 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree42 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree43 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree44 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree45 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree46 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree47 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree48 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree49 = "red_black_tree.rs" 482 4 485 36
  let%span sred_black_tree50 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree51 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree52 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree53 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree54 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree55 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree56 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree57 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree58 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree59 = "red_black_tree.rs" 146 8 148 9
  let%span sresolve60 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree61 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree62 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree63 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree64 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree65 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree66 = "red_black_tree.rs" 37 12 41 13
  let%span sord67 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord68 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord69 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord70 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord71 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord72 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord73 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord74 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord75 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord76 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord77 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord78 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord79 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree80 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree81 = "red_black_tree.rs" 297 12 303 13
  let%span sinvariant82 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree83 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree84 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree85 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree86 = "red_black_tree.rs" 342 12 348 13
  let%span sinvariant87 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed88 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'4 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed88] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'7 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'7 x] . inv'7 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant87] inv'7 self
  
  predicate inv'6 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant82] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'4 x] . inv'4 x
  = invariant'2 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord79] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord77] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord78] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord75] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord76] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord72] cmp_log'0 x y
  = o)  -> ([%#sord73] cmp_log'0 y z = o)  -> ([%#sord74] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord71] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord69] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord68] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord67] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant82] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant82] inv'10 self.current /\ inv'10 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  predicate inv'9 (_1 : t_V'0)
  
  predicate inv'8 (_1 : t_K'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'7 left /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree58] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree80] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'1 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree81] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree57] color_invariant_here'0 self
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree66] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree56] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree55] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree65] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree64] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree54] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree53] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree63] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree52] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'0 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree51] CP'0.C_CPN c l r
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree85] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree86] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree62] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree83] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree84] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree61] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree50] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve60] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'3 _1
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree59] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec rotate_left'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree42] inv'3 self}
    {[@expl:precondition] [%#sred_black_tree41] color'0 (T_red_black_tree__Node.t_Node__right self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree40] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree49] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l
      /\ (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.final)
      = (T_red_black_tree__Node.t_Node__left self.current, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      /\ T_red_black_tree__Node.t_Node__key l = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree48] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree47] color'0 (T_red_black_tree__Node.t_Node__left self.final) = Color'0.C_Red}
      {[%#sred_black_tree46] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final))}
      {[%#sred_black_tree45] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree44] internal_invariant'0 self.final}
      {[%#sred_black_tree43] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree32] inv'3 self}
    {[@expl:precondition] [%#sred_black_tree31] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree30] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree39] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree38] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree37] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#sred_black_tree36] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#sred_black_tree35] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree34] internal_invariant'0 self.final}
      {[%#sred_black_tree33] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve60] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'2 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree28] inv'6 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree29] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'5 self}
    {[@expl:precondition] [%#soption27] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption27] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'5 result}
      {[%#soption26] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption25] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree18] inv'3 self}
    {[@expl:precondition] [%#sred_black_tree17] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree16] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree15] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree14] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree24] exists r1 : Node'0.t_Node t_K'0 t_V'0, r2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#sred_black_tree23] exists l1 : Node'0.t_Node t_K'0 t_V'0, l2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#sred_black_tree22] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key self.final}
      {[%#sred_black_tree21] same_mappings'0 self.current self.final}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree19] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_left (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[%#sred_black_tree3] inv'3 self}
    {[%#sred_black_tree2] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    {[%#sred_black_tree0] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_22}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_20.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_28 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_28}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0
      [ s0 = unwrap'0 {_27} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_26 <- _ret' ] s1) | s1 = bb7 ]
      
    | bb7 = s0
      [ s0 = {inv'0 _26.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_26.current} {Borrow.get_id _26}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'2 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s3)
      | s3 = rotate_left'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s4)
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_32 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_32} (fun (_ret':()) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_35 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_35}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 = unwrap'0 {_34} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = {inv'0 _33.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_33.current} {Borrow.get_id _33}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_33 <- { _33 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
      
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb14 ] 
    | bb13 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb14 ] 
    | bb14 = return' {_0} ]
    )
    [ & _0 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & _15 : () = any_l ()
    | & _16 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _21 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _24 : () = any_l ()
    | & _25 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _26 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _27 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _28 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _29 : () = any_l ()
    | & _30 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _31 : () = any_l ()
    | & _32 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _33 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _34 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _35 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l () ]
    
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[@expl:postcondition] [%#sred_black_tree13] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree12] color_invariant'0 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[@expl:postcondition] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
      /\ le_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'0 result.current k v}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:postcondition] [%#sred_black_tree7] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key result.current}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree4] internal_invariant'0 result.current}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi17561227306860881838__move_red_right [#"red_black_tree.rs" 595 4 595 45] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree1 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree2 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree3 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree4 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree5 = "red_black_tree.rs" 581 4 583 48
  let%span sred_black_tree6 = "red_black_tree.rs" 584 4 584 97
  let%span sred_black_tree7 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree8 = "red_black_tree.rs" 586 4 586 105
  let%span sred_black_tree9 = "red_black_tree.rs" 587 4 588 47
  let%span sred_black_tree10 = "red_black_tree.rs" 589 4 590 108
  let%span sred_black_tree11 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree12 = "red_black_tree.rs" 593 4 594 45
  let%span sred_black_tree13 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree14 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree15 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree16 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree17 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree18 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree19 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree20 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree21 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree22 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree23 = "red_black_tree.rs" 504 4 506 70
  let%span sred_black_tree24 = "red_black_tree.rs" 507 4 509 90
  let%span soption25 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption26 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption27 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sred_black_tree28 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree29 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree30 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree31 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree32 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree33 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree34 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree35 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree36 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree37 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree38 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree39 = "red_black_tree.rs" 432 4 435 36
  let%span sred_black_tree40 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree41 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree42 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree43 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree44 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree45 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree46 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree47 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree48 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree49 = "red_black_tree.rs" 146 8 148 9
  let%span sresolve50 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree51 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree52 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree53 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree54 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree55 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree56 = "red_black_tree.rs" 37 12 41 13
  let%span sord57 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord58 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord59 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord60 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord61 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord62 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord63 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord64 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord65 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord66 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord67 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord68 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord69 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree70 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree71 = "red_black_tree.rs" 297 12 303 13
  let%span sinvariant72 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree73 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree74 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree75 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree76 = "red_black_tree.rs" 342 12 348 13
  let%span sinvariant77 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sboxed78 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'0 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'4 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed78] inv'0 self
  
  predicate inv'10 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'7 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'7 x] . inv'7 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant77] inv'7 self
  
  predicate inv'6 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate invariant'2 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant72] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'4 x] . inv'4 x
  = invariant'2 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord69] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord67] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord68] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord65] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord66] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord62] cmp_log'0 x y
  = o)  -> ([%#sord63] cmp_log'0 y z = o)  -> ([%#sord64] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord61] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord60] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord59] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord58] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord57] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant72] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant72] inv'10 self.current /\ inv'10 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  predicate inv'9 (_1 : t_V'0)
  
  predicate inv'8 (_1 : t_K'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'7 left /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree48] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree70] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'1 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree71] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree47] color_invariant_here'0 self
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree56] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree46] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree45] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  use prelude.prelude.Int
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree55] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'1 left
        | Color'0.C_Black -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree54] height'1 self >= 0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree44] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'1 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'1 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree43] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'0 self = height'1 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree53] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'1 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree42] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'0 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree41] CP'0.C_CPN c l r
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree75] height'1 (T_red_black_tree__Node.t_Node__left self)
    = height'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree76] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree52] height_invariant_here'0 self
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree73] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree74] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree51] bst_invariant_here'0 self
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'1 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree40] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve50] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'3 _1
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree49] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree32] inv'3 self}
    {[@expl:precondition] [%#sred_black_tree31] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree30] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree39] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree38] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree37] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#sred_black_tree36] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#sred_black_tree35] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree34] internal_invariant'0 self.final}
      {[%#sred_black_tree33] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve50] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'2 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree28] inv'6 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree29] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'5 self}
    {[@expl:precondition] [%#soption27] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption27] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'4 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'5 result}
      {[%#soption26] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption25] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec flip_colors'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree18] inv'3 self}
    {[@expl:precondition] [%#sred_black_tree17] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = color'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree16] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree15] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    {[@expl:precondition] [%#sred_black_tree14] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree24] exists r1 : Node'0.t_Node t_K'0 t_V'0, r2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
      = Option'0.C_Some r1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r2
      /\ T_red_black_tree__Node.t_Node__left r1 = T_red_black_tree__Node.t_Node__left r2
      /\ T_red_black_tree__Node.t_Node__right r1 = T_red_black_tree__Node.t_Node__right r2
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color r2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color r1
      /\ T_red_black_tree__Node.t_Node__key r1 = T_red_black_tree__Node.t_Node__key r2}
      {[%#sred_black_tree23] exists l1 : Node'0.t_Node t_K'0 t_V'0, l2 : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l1
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.final) = Option'0.C_Some l2
      /\ T_red_black_tree__Node.t_Node__left l1 = T_red_black_tree__Node.t_Node__left l2
      /\ T_red_black_tree__Node.t_Node__right l1 = T_red_black_tree__Node.t_Node__right l2
      /\ T_red_black_tree__Node.t_Node__key l1 = T_red_black_tree__Node.t_Node__key l2
      /\ T_red_black_tree__Node.t_Node__color self.current = T_red_black_tree__Node.t_Node__color l2
      /\ T_red_black_tree__Node.t_Node__color self.final = T_red_black_tree__Node.t_Node__color l1}
      {[%#sred_black_tree22] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key self.final}
      {[%#sred_black_tree21] same_mappings'0 self.current self.final}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree19] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_right (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[%#sred_black_tree3] inv'3 self}
    {[%#sred_black_tree2] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    {[%#sred_black_tree0] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node (Tree'0.C_Tree _ret'.final) rcolor'0 rkey'0 rval'0 rright'0 ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_22}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = unwrap'0 {_21} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_20.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ]
      
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0
      [ s0 = {inv'0 self.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {self.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_27 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final ; } ] 
            s1)
      | s1 = flip_colors'0 {_27} (fun (_ret':()) ->  [ &_26 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {self.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 5) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_30 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                    
                    [ &self <- { self with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 (Tree'0.C_Tree _ret'.final) ; } ]
                    
                    s1)))
      | s1 = as_mut'0 {_30}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb8 ]
      
    | bb8 = s0
      [ s0 = unwrap'0 {_29} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_28 <- _ret' ] s1) | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = {inv'0 _28.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_28.current} {Borrow.get_id _28}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_28 <- { _28 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
      
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb11 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & self : borrowed (Node'0.t_Node t_K'0 t_V'0) = self
    | & _15 : () = any_l ()
    | & _16 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _21 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _24 : () = any_l ()
    | & _25 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _26 : () = any_l ()
    | & _27 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _28 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _29 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _30 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l () ]
    
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[@expl:postcondition] [%#sred_black_tree13] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree12] color_invariant'0 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree11] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[@expl:postcondition] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
      /\ le_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'0 result.current k v}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:postcondition] [%#sred_black_tree7] T_red_black_tree__Node.t_Node__key result.current
      = T_red_black_tree__Node.t_Node__key self.current}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree4] internal_invariant'0 result.current}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__insert_rec [#"red_black_tree.rs" 618 4 618 44] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 610 15 610 43
  let%span sred_black_tree1 = "red_black_tree.rs" 611 15 611 40
  let%span sred_black_tree2 = "red_black_tree.rs" 618 23 618 27
  let%span sred_black_tree3 = "red_black_tree.rs" 618 29 618 32
  let%span sred_black_tree4 = "red_black_tree.rs" 618 37 618 40
  let%span sred_black_tree5 = "red_black_tree.rs" 612 14 612 42
  let%span sred_black_tree6 = "red_black_tree.rs" 613 14 613 50
  let%span sred_black_tree7 = "red_black_tree.rs" 614 14 615 39
  let%span sred_black_tree8 = "red_black_tree.rs" 616 14 616 56
  let%span sred_black_tree9 = "red_black_tree.rs" 617 4 617 127
  let%span scmp10 = "../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span sred_black_tree11 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree12 = "red_black_tree.rs" 516 4 517 47
  let%span sred_black_tree13 = "red_black_tree.rs" 518 4 519 48
  let%span sred_black_tree14 = "red_black_tree.rs" 520 4 520 110
  let%span sred_black_tree15 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree16 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree17 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree18 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree19 = "red_black_tree.rs" 524 4 525 34
  let%span sred_black_tree20 = "red_black_tree.rs" 526 4 527 39
  let%span sred_black_tree21 = "red_black_tree.rs" 528 4 529 63
  let%span sred_black_tree22 = "red_black_tree.rs" 530 4 531 61
  let%span sred_black_tree23 = "red_black_tree.rs" 532 4 533 39
  let%span sred_black_tree24 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree25 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree26 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree27 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree28 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree29 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree30 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree31 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve32 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sresolve33 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sred_black_tree34 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree35 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree36 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree37 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree38 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree39 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree40 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree41 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant42 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed43 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord56 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree57 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree58 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree59 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree60 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree61 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree62 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree63 = "red_black_tree.rs" 368 20 368 61
  let%span sresolve64 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span sinvariant65 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree66 = "red_black_tree.rs" 194 8 196 9
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'8 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  use prelude.prelude.Borrow
  
  predicate invariant'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant42] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'10 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'10 x] . inv'10 x = invariant'5 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord56] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord54] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord55] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord52] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord53] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord49] cmp_log'0 x y
  = o)  -> ([%#sord50] cmp_log'0 y z = o)  -> ([%#sord51] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord48] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'5 (_1 : t_K'0)
  
  predicate invariant'4 (self : t_K'0) =
    [%#sinvariant65] inv'5 self
  
  predicate inv'9 (_1 : t_K'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_K'0 [inv'9 x] . inv'9 x = invariant'4 x
  
  predicate inv'6 (_1 : t_V'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'8 x] . inv'8 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'4 left /\ inv'5 key /\ inv'6 val' /\ inv'4 right
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant42] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'7 x] . inv'7 x = invariant'3 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed43] inv'8 self
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant42] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'2 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant42] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree30] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree41] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree29] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree28] CP'0.C_CPN c l r
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree27] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree26] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree63] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree62] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree24] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree61] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree38] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree37] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree36] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree60] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree59] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree35] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree58] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree57] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree34] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree15] inv'10 self}
    {[@expl:precondition] [%#sred_black_tree14] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#sred_black_tree13] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree12] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#sred_black_tree11] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree23] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree22] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree21] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree20] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree19] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#sred_black_tree18] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree17] internal_invariant'1 self.final}
      {[%#sred_black_tree16] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'9 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'9 _1
  
  predicate resolve'4 (_1 : t_V'0)
  
  predicate resolve'3 (_1 : t_K'0)
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] inv'9 other}
    {[@expl:precondition] inv'9 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#scmp10] result = cmp_log'0 (deep_model'0 self) (deep_model'0 other)}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'8 _1
  
  predicate resolve'13 [#"red_black_tree.rs" 193 4 193 28] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree66] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'4 v
  
  predicate resolve'12 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'13 _1
  
  predicate resolve'11 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sresolve64] resolve'12 self
  
  predicate resolve'10 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'11 _1
  
  predicate resolve'7 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve33] match self with
      | Option'0.C_Some x -> resolve'10 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'7 _1
  
  predicate resolve'6 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'6 _1
  
  meta "compute_max_steps" 1000000
  
  let rec insert_rec (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[%#sred_black_tree4] inv'6 val'}
    {[%#sred_black_tree3] inv'5 key}
    {[%#sred_black_tree2] inv'2 self}
    {[%#sred_black_tree1] color_invariant'0 self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_11 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = any
        [ br0 -> {_11.current = Option'0.C_None } (! bb19)
        | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_11.current = Option'0.C_Some a} (! bb3) ]
         ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'1 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 =  [ &_35 <- Option'0.C_None ] s3
      | s3 =  [ &_34 <- Tree'0.C_Tree _35 ] s4
      | s4 = bb20 ]
      
    | bb20 = s0
      [ s0 =  [ &_36 <- Color'0.C_Red ] s1
      | s1 =  [ &_40 <- Option'0.C_None ] s2
      | s2 =  [ &_39 <- Tree'0.C_Tree _40 ] s3
      | s3 = bb21 ]
      
    | bb21 = s0 [ s0 =  [ &_33 <- Node'0.C_Node _34 _36 key val' _39 ] s1 | s1 = bb22 ] 
    | bb22 = bb23
    | bb23 = bb24
    | bb24 = bb25
    | bb25 = bb26
    | bb26 = s0 [ s0 =  [ &_31 <- Option'0.C_Some _33 ] s1 | s1 = bb27 ] 
    | bb27 = bb28
    | bb28 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = Tree'0.C_Tree x'0} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = Tree'0.C_Tree x'1} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &self <- { self with current = Tree'0.C_Tree _31 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb30 ]
      
    | bb30 = bb32
    | bb3 = bb4
    | bb4 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_11.current}
          (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id _11) 1}
              (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_11 <- { _11 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_18 <- rkey'0 ] 
            s2)
      | s2 = cmp'0 {key} {_18} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb5 ]
      
    | bb5 = any
      [ br0 -> {_15 = Ordering'0.C_Less } (! bb7)
      | br1 -> {_15 = Ordering'0.C_Equal } (! bb8)
      | br2 -> {_15 = Ordering'0.C_Greater } (! bb9) ]
      
    | bb9 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_25 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = insert_rec {_25} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = bb17
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'5 key} s1 | s1 = -{resolve'3 key}- s2 | s2 = bb12 ] 
    | bb12 = bb13
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match node with
          | {current = Node'0.C_Node _ _ _ x'0 _} -> inv'6 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node with
          | {current = Node'0.C_Node _ _ _ x'1 _} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 val' rright'0 ; } ] 
            s3)
      | s3 = {[@expl:type invariant] inv'7 node} s4
      | s4 = -{resolve'5 node}- s5
      | s5 = {[@expl:type invariant] inv'1 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'2 self} s8
      | s8 = -{resolve'2 self}- s9
      | s9 = bb15 ]
      
    | bb15 = bb32
    | bb32 = bb33
    | bb33 = bb34
    | bb7 = bb10
    | bb10 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_20 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = insert_rec {_20} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = bb17
    | bb17 = s0
      [ s0 = {inv'8 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_29 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_29} (fun (_ret':()) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb18 ]
      
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'7 node} s1
      | s1 = -{resolve'5 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = bb31 ]
      
    | bb31 = bb34
    | bb34 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = self
    | & key : t_K'0 = key
    | & val' : t_V'0 = val'
    | & _11 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _14 : () = any_l ()
    | & _15 : Ordering'0.t_Ordering = any_l ()
    | & _18 : t_K'0 = any_l ()
    | & _20 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _25 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _28 : () = any_l ()
    | & _29 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _31 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _33 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _34 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _35 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _36 : Color'0.t_Color = any_l ()
    | & _39 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _40 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . k
      = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      {[@expl:postcondition] [%#sred_black_tree8] has_mapping'0 self.final (deep_model'0 key) val'}
      {[@expl:postcondition] [%#sred_black_tree7] match_t'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final
      /\ color'0 self.current = Color'0.C_Red
      \/ color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_max_rec [#"red_black_tree.rs" 652 4 652 42] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 641 15 641 43
  let%span sred_black_tree1 = "red_black_tree.rs" 642 15 643 62
  let%span sred_black_tree2 = "red_black_tree.rs" 652 27 652 31
  let%span sred_black_tree3 = "red_black_tree.rs" 644 14 644 42
  let%span sred_black_tree4 = "red_black_tree.rs" 645 14 645 50
  let%span sred_black_tree5 = "red_black_tree.rs" 646 14 646 66
  let%span sred_black_tree6 = "red_black_tree.rs" 647 4 647 104
  let%span sred_black_tree7 = "red_black_tree.rs" 648 4 649 73
  let%span sred_black_tree8 = "red_black_tree.rs" 650 14 650 39
  let%span sred_black_tree9 = "red_black_tree.rs" 651 4 651 69
  let%span sred_black_tree10 = "red_black_tree.rs" 652 36 652 42
  let%span soption11 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span sred_black_tree16 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree17 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree18 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree19 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree20 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree21 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree22 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree23 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree24 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree25 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree26 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree27 = "red_black_tree.rs" 432 4 435 36
  let%span soption28 = "../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span soption29 = "../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span sred_black_tree30 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree31 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree32 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree33 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree34 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree35 = "red_black_tree.rs" 581 4 583 48
  let%span sred_black_tree36 = "red_black_tree.rs" 584 4 584 97
  let%span sred_black_tree37 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree38 = "red_black_tree.rs" 586 4 586 105
  let%span sred_black_tree39 = "red_black_tree.rs" 587 4 588 47
  let%span sred_black_tree40 = "red_black_tree.rs" 589 4 590 108
  let%span sred_black_tree41 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree42 = "red_black_tree.rs" 593 4 594 45
  let%span sred_black_tree43 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree44 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree45 = "red_black_tree.rs" 516 4 517 47
  let%span sred_black_tree46 = "red_black_tree.rs" 518 4 519 48
  let%span sred_black_tree47 = "red_black_tree.rs" 520 4 520 110
  let%span sred_black_tree48 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree49 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree50 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree51 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree52 = "red_black_tree.rs" 524 4 525 34
  let%span sred_black_tree53 = "red_black_tree.rs" 526 4 527 39
  let%span sred_black_tree54 = "red_black_tree.rs" 528 4 529 63
  let%span sred_black_tree55 = "red_black_tree.rs" 530 4 531 61
  let%span sred_black_tree56 = "red_black_tree.rs" 532 4 533 39
  let%span smem57 = "../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem58 = "../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span sred_black_tree59 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree60 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree61 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree62 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree63 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree64 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree65 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree66 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve67 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree68 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree69 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree70 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree71 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree72 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree73 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree74 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree75 = "red_black_tree.rs" 316 8 316 112
  let%span soption76 = "../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span sred_black_tree77 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree78 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree79 = "red_black_tree.rs" 342 12 348 13
  let%span sord80 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord81 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord82 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord83 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord84 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord85 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord86 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord87 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord88 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord89 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord90 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord91 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord92 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree93 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed94 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant95 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree96 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree97 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree98 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree99 = "red_black_tree.rs" 368 20 368 61
  let%span sinvariant100 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sinvariant100] inv'1 self
  
  predicate inv'13 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'13 x] . inv'13 x = invariant'7 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'12 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'12 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'12 x] . inv'12 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'13 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  predicate invariant'6 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant100] inv'0 self
  
  predicate inv'11 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'11 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'11 x] . inv'11 x
  = invariant'6 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  predicate invariant'5 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant100] inv'5 self
  
  predicate inv'10 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'9 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'9 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'15 (_1 : t_V'0)
  
  predicate inv'14 (_1 : t_K'0)
  
  predicate inv'8 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'8 x] . inv'8 x
  = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord92] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord90] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord91] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord88] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord89] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord85] cmp_log'0 x y
  = o)  -> ([%#sord86] cmp_log'0 y z = o)  -> ([%#sord87] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord84] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord83] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord82] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord81] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord80] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'4 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant95] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'7 x] . inv'7 x
  = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant95] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant95] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'2 x
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant95] inv'1 self.current /\ inv'1 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed94] inv'3 self
  
  axiom inv_axiom'1 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree66] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree93] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree65] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree64] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree63] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree62] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree61] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree60] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree99] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree79] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree98] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree78] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree59] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'10 (_1 : t_V'0)
  
  predicate resolve'9 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree77] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'9 _1
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'1 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'8 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#soption76] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'7 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'0 result}
      {[%#smem58] is_default'0 dest.final}
      {[%#smem57] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'7 _1
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree75] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree72] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree71] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree70] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree74] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree73] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree69] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree97] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree96] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree68] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree48] inv'4 self}
    {[@expl:precondition] [%#sred_black_tree47] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#sred_black_tree46] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree45] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#sred_black_tree44] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree56] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree55] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree54] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree53] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree52] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#sred_black_tree51] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree50] internal_invariant'1 self.final}
      {[%#sred_black_tree49] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'6 _1
  
  let rec move_red_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] [%#sred_black_tree33] inv'4 self}
    {[@expl:precondition] [%#sred_black_tree32] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[@expl:precondition] [%#sred_black_tree31] internal_invariant'1 self.current}
    {[@expl:precondition] [%#sred_black_tree30] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[%#sred_black_tree43] inv'4 result}
      {[%#sred_black_tree42] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#sred_black_tree41] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#sred_black_tree40] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree39] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'1 result.current k v}
      {[%#sred_black_tree38] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree37] T_red_black_tree__Node.t_Node__key result.current
      = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree36] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree35] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree34] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'13 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'11 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'12 result}
      {[%#soption29] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node t_K'0 t_V'0 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption28] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree20] inv'4 self}
    {[@expl:precondition] [%#sred_black_tree19] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree18] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree27] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree26] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree25] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#sred_black_tree24] lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#sred_black_tree23] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree22] internal_invariant'1 self.final}
      {[%#sred_black_tree21] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree16] inv'10 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree17] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#sboxed15] self.final = result.final}
      {[%#sboxed14] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'9 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'9 result}
      {[%#soption12] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption11] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max_rec (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:(t_K'0, t_V'0)))= {[%#sred_black_tree2] inv'6 self}
    {[%#sred_black_tree1] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_15}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s3))
      | s3 = bb4 ]
      
    | bb4 = any [ br0 -> {_17 = false} (! bb7) | br1 -> {_17} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {node.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_19 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = bb8
    | bb7 = bb8
    | bb8 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
        (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
          Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
            (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
              any
              [ br0 -> {rnode'0 = Option'0.C_None } (! bb9)
              | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {rnode'0 = Option'0.C_Some a} (! bb15) ]
              ))
    | bb15 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rright'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb25
    | bb18 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_35 <- _ret' ] s1)))
      | s1 = bb19 ]
      
    | bb19 = s0 [ s0 = unwrap'1 {_35} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &_34 <- _ret' ] s1) | s1 = bb20 ] 
    | bb20 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_34}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1))
      | s1 = bb21 ]
      
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb22) ] 
    | bb22 = bb25
    | bb25 = bb26
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_right'0 {_39} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_38.current} {Borrow.get_id _38}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_38 <- { _38 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'4 _38} s5
      | s5 = -{resolve'1 _38}- s6
      | s6 = bb26 ]
      
    | bb26 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'5 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_41 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_max_rec {_41} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb27 ]
      
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_43 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_43} (fun (_ret':()) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb29 ]
      
    | bb29 = bb31
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb10 ] 
    | bb10 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_26 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _26.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {_26.current} {Borrow.get_id _26}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_25} (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_24 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'3 _26}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_24} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb12 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {node1}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Node'0.t_Node <t_K'0> <t_V'0> {node1}
              (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb13 ]
      
    | bb13 = bb14
    | bb14 = bb30
    | bb30 = bb31
    | bb31 = return' {_0} ]
    )
    [ & _0 : (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = self
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _12 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _13 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _16 : () = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & node1 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _24 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _25 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _26 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : bool = any_l ()
    | & _34 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _35 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _37 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _38 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _39 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & r : (t_K'0, t_V'0) = any_l ()
    | & _41 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _42 : () = any_l ()
    | & _43 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:(t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree10] inv'8 result}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[@expl:postcondition] [%#sred_black_tree5] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [%#sred_black_tree4] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree3] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_min_rec [#"red_black_tree.rs" 680 4 680 42] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree1 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree2 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree3 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree4 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree5 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree6 = "red_black_tree.rs" 675 4 675 104
  let%span sred_black_tree7 = "red_black_tree.rs" 676 4 677 73
  let%span sred_black_tree8 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree9 = "red_black_tree.rs" 679 4 679 69
  let%span sred_black_tree10 = "red_black_tree.rs" 680 36 680 42
  let%span soption11 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sboxed14 = "../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span sred_black_tree16 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree17 = "red_black_tree.rs" 411 14 411 45
  let%span soption18 = "../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span soption19 = "../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span sred_black_tree20 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree21 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree22 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree23 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree24 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree25 = "red_black_tree.rs" 552 4 554 48
  let%span sred_black_tree26 = "red_black_tree.rs" 555 4 555 97
  let%span sred_black_tree27 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree28 = "red_black_tree.rs" 557 4 557 105
  let%span sred_black_tree29 = "red_black_tree.rs" 558 4 559 47
  let%span sred_black_tree30 = "red_black_tree.rs" 560 4 561 108
  let%span sred_black_tree31 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree32 = "red_black_tree.rs" 564 4 565 45
  let%span sred_black_tree33 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree34 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree35 = "red_black_tree.rs" 516 4 517 47
  let%span sred_black_tree36 = "red_black_tree.rs" 518 4 519 48
  let%span sred_black_tree37 = "red_black_tree.rs" 520 4 520 110
  let%span sred_black_tree38 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree39 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree40 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree41 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree42 = "red_black_tree.rs" 524 4 525 34
  let%span sred_black_tree43 = "red_black_tree.rs" 526 4 527 39
  let%span sred_black_tree44 = "red_black_tree.rs" 528 4 529 63
  let%span sred_black_tree45 = "red_black_tree.rs" 530 4 531 61
  let%span sred_black_tree46 = "red_black_tree.rs" 532 4 533 39
  let%span smem47 = "../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem48 = "../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span sred_black_tree49 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree50 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree51 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree52 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree53 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree54 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree55 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree56 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve57 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree58 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree59 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree60 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree61 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree62 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree63 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree64 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree65 = "red_black_tree.rs" 146 8 148 9
  let%span soption66 = "../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span sred_black_tree67 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree68 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree69 = "red_black_tree.rs" 342 12 348 13
  let%span sord70 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord71 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord72 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord73 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord74 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord75 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord76 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord77 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord78 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord79 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord80 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord81 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord82 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree83 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed84 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant85 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree86 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree87 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree88 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree89 = "red_black_tree.rs" 368 20 368 61
  let%span sinvariant90 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  use prelude.prelude.Borrow
  
  predicate invariant'7 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sinvariant90] inv'1 self
  
  predicate inv'13 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'13 x] . inv'13 x = invariant'7 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'12 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'12 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'12 x] . inv'12 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'13 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  predicate invariant'6 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant90] inv'0 self
  
  predicate inv'11 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'11 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'11 x] . inv'11 x
  = invariant'6 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  predicate invariant'5 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant90] inv'5 self
  
  predicate inv'10 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'9 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'9 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'9 x] . inv'9 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'15 (_1 : t_V'0)
  
  predicate inv'14 (_1 : t_K'0)
  
  predicate inv'8 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'8 x] . inv'8 x
  = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord82] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord80] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord81] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord78] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord79] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord75] cmp_log'0 x y
  = o)  -> ([%#sord76] cmp_log'0 y z = o)  -> ([%#sord77] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord74] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord73] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord72] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord71] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate invariant'4 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant85] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'7 x] . inv'7 x
  = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant85] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant85] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'2 x
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant85] inv'1 self.current /\ inv'1 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed84] inv'3 self
  
  axiom inv_axiom'1 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree56] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree83] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree55] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree54] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree53] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree52] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree51] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree50] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree89] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree69] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree88] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree68] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree49] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'10 (_1 : t_V'0)
  
  predicate resolve'9 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree67] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'9 _1
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'1 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve57] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'8 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#soption66] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'7 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'0 result}
      {[%#smem48] is_default'0 dest.final}
      {[%#smem47] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve57] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'7 _1
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree64] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree59] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree61] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree60] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree63] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree62] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree65] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree87] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree86] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree58] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree38] inv'4 self}
    {[@expl:precondition] [%#sred_black_tree37] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#sred_black_tree36] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree35] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#sred_black_tree34] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree46] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree45] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree44] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree43] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree42] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#sred_black_tree41] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree40] internal_invariant'1 self.final}
      {[%#sred_black_tree39] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve57] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'6 _1
  
  let rec move_red_left'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] [%#sred_black_tree23] inv'4 self}
    {[@expl:precondition] [%#sred_black_tree22] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree21] internal_invariant'1 self.current}
    {[@expl:precondition] [%#sred_black_tree20] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[%#sred_black_tree33] inv'4 result}
      {[%#sred_black_tree32] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#sred_black_tree31] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#sred_black_tree30] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree29] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'1 result.current k v}
      {[%#sred_black_tree28] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree27] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key result.current}
      {[%#sred_black_tree26] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree25] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree24] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'13 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'11 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'12 result}
      {[%#soption19] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node t_K'0 t_V'0 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption18] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree16] inv'10 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree17] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve57] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#sboxed15] self.final = result.final}
      {[%#sboxed14] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'9 self}
    {[@expl:precondition] [%#soption13] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption13] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'9 result}
      {[%#soption12] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption11] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min_rec (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:(t_K'0, t_V'0)))= {[%#sred_black_tree2] inv'6 self}
    {[%#sred_black_tree1] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree0] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_15}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_14} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_13.current} {Borrow.get_id _13}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                any
                [ br0 -> {rnode'0 = Option'0.C_None } (! bb4)
                | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {rnode'0 = Option'0.C_Some a} (! bb10) ]
                )) ]
      
    | bb10 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_31 <- _ret' ] s1)))
      | s1 = bb14 ]
      
    | bb14 = s0 [ s0 = unwrap'1 {_31} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &_30 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_30}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_left'0 {_35} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_33 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'4 _34} s5
      | s5 = -{resolve'1 _34}- s6
      | s6 = bb21 ]
      
    | bb21 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'5 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_37 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = delete_min_rec {_37} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_39} (fun (_ret':()) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb23 ]
      
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb24 ]
      
    | bb24 = bb26
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb5 ] 
    | bb5 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_22 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _22.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {_22.current} {Borrow.get_id _22}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
             [ &_21 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_22 <- { _22 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_21} (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'7 _22} s1
      | s1 = -{resolve'3 _22}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_20} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {node1}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Node'0.t_Node <t_K'0> <t_V'0> {node1}
              (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_0 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb8 ]
      
    | bb8 = bb9
    | bb9 = bb25
    | bb25 = bb26
    | bb26 = return' {_0} ]
    )
    [ & _0 : (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = self
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _12 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _13 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _14 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _15 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node1 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _20 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _21 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _26 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _30 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _31 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _33 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _34 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _35 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & r : (t_K'0, t_V'0) = any_l ()
    | & _37 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _38 : () = any_l ()
    | & _39 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:(t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree10] inv'8 result}
      {[@expl:postcondition] [%#sred_black_tree9] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree8] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[@expl:postcondition] [%#sred_black_tree5] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:postcondition] [%#sred_black_tree4] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree3] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi2476155906044564626__delete_rec [#"red_black_tree.rs" 706 4 706 55] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 736 24 736 59
  let%span sred_black_tree1 = "red_black_tree.rs" 694 15 694 43
  let%span sred_black_tree2 = "red_black_tree.rs" 695 15 696 62
  let%span sred_black_tree3 = "red_black_tree.rs" 706 23 706 27
  let%span sred_black_tree4 = "red_black_tree.rs" 706 29 706 32
  let%span sred_black_tree5 = "red_black_tree.rs" 697 14 697 42
  let%span sred_black_tree6 = "red_black_tree.rs" 698 14 698 50
  let%span sred_black_tree7 = "red_black_tree.rs" 699 14 702 5
  let%span sred_black_tree8 = "red_black_tree.rs" 703 4 703 129
  let%span sred_black_tree9 = "red_black_tree.rs" 704 14 704 39
  let%span sred_black_tree10 = "red_black_tree.rs" 705 4 705 69
  let%span sred_black_tree11 = "red_black_tree.rs" 706 41 706 55
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption14 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sboxed15 = "../../../creusot-contracts/src/std/boxed.rs" 43 26 43 43
  let%span sboxed16 = "../../../creusot-contracts/src/std/boxed.rs" 44 26 44 43
  let%span scmp17 = "../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span sred_black_tree18 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree19 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree20 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree21 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree22 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree23 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree24 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree25 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree26 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree27 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree28 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree29 = "red_black_tree.rs" 432 4 435 36
  let%span soption30 = "../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span smem31 = "../../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem32 = "../../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption33 = "../../../creusot-contracts/src/std/option.rs" 66 16 66 60
  let%span soption34 = "../../../creusot-contracts/src/std/option.rs" 67 16 69 18
  let%span sred_black_tree35 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree36 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree37 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree38 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree39 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree40 = "red_black_tree.rs" 581 4 583 48
  let%span sred_black_tree41 = "red_black_tree.rs" 584 4 584 97
  let%span sred_black_tree42 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree43 = "red_black_tree.rs" 586 4 586 105
  let%span sred_black_tree44 = "red_black_tree.rs" 587 4 588 47
  let%span sred_black_tree45 = "red_black_tree.rs" 589 4 590 108
  let%span sred_black_tree46 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree47 = "red_black_tree.rs" 593 4 594 45
  let%span sred_black_tree48 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree49 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree50 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree51 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree52 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree53 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree54 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree55 = "red_black_tree.rs" 675 4 675 104
  let%span sred_black_tree56 = "red_black_tree.rs" 676 4 677 73
  let%span sred_black_tree57 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree58 = "red_black_tree.rs" 679 4 679 69
  let%span sred_black_tree59 = "red_black_tree.rs" 680 36 680 42
  let%span sred_black_tree60 = "red_black_tree.rs" 118 15 118 35
  let%span sred_black_tree61 = "red_black_tree.rs" 119 15 119 38
  let%span sred_black_tree62 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree63 = "red_black_tree.rs" 121 14 121 22
  let%span sred_black_tree64 = "red_black_tree.rs" 127 12 127 37
  let%span smem65 = "../../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem66 = "../../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree67 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree68 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree69 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree70 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree71 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree72 = "red_black_tree.rs" 552 4 554 48
  let%span sred_black_tree73 = "red_black_tree.rs" 555 4 555 97
  let%span sred_black_tree74 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree75 = "red_black_tree.rs" 557 4 557 105
  let%span sred_black_tree76 = "red_black_tree.rs" 558 4 559 47
  let%span sred_black_tree77 = "red_black_tree.rs" 560 4 561 108
  let%span sred_black_tree78 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree79 = "red_black_tree.rs" 564 4 565 45
  let%span sred_black_tree80 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree81 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree82 = "red_black_tree.rs" 516 4 517 47
  let%span sred_black_tree83 = "red_black_tree.rs" 518 4 519 48
  let%span sred_black_tree84 = "red_black_tree.rs" 520 4 520 110
  let%span sred_black_tree85 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree86 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree87 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree88 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree89 = "red_black_tree.rs" 524 4 525 34
  let%span sred_black_tree90 = "red_black_tree.rs" 526 4 527 39
  let%span sred_black_tree91 = "red_black_tree.rs" 528 4 529 63
  let%span sred_black_tree92 = "red_black_tree.rs" 530 4 531 61
  let%span sred_black_tree93 = "red_black_tree.rs" 532 4 533 39
  let%span sred_black_tree94 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree95 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree96 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree97 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree98 = "red_black_tree.rs" 327 12 335 13
  let%span smodel99 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span sred_black_tree100 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree101 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree102 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve103 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree104 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree105 = "red_black_tree.rs" 146 8 148 9
  let%span sred_black_tree106 = "red_black_tree.rs" 355 4 356 77
  let%span sred_black_tree107 = "red_black_tree.rs" 359 12 362 13
  let%span soption108 = "../../../creusot-contracts/src/std/option.rs" 147 20 147 32
  let%span sred_black_tree109 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree110 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree111 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree112 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree113 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree114 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree115 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree116 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree117 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree118 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree119 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree120 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed121 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sinvariant122 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sord123 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord124 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord125 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord126 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord127 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord128 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord129 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord130 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord131 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord132 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord133 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord134 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord135 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree136 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree137 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree138 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree139 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree140 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree141 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree142 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree143 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree144 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree145 = "red_black_tree.rs" 368 20 368 61
  let%span sinvariant146 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  
  type t_V'0
  
  predicate inv'10 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'8 (_1 : t_K'0)
  
  predicate inv'19 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'17 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'19 x] . inv'19 x
  = (let (a, b) = x in inv'8 a /\ inv'10 b)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  use prelude.prelude.Borrow
  
  predicate invariant'10 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sinvariant146] inv'1 self
  
  predicate inv'18 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'18 x] . inv'18 x = invariant'10 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'17 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'15 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'17 x] . inv'17 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'18 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  predicate invariant'9 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant146] inv'0 self
  
  predicate inv'16 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'14 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'16 x] . inv'16 x
  = invariant'9 x
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  predicate invariant'8 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant146] inv'4 self
  
  predicate inv'15 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'15 x] . inv'15 x = invariant'8 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord135] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord133] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord134] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord131] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord132] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord128] cmp_log'0 x y
  = o)  -> ([%#sord129] cmp_log'0 y z = o)  -> ([%#sord130] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord127] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord126] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord125] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord124] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord123] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'14 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'12 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'14 x] . inv'14 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  use T_core__option__Option as Option'0
  
  predicate inv'13 (_1 : Option'0.t_Option (t_K'0, t_V'0))
  
  axiom inv_axiom'11 [@rewrite] : forall x : Option'0.t_Option (t_K'0, t_V'0) [inv'13 x] . inv'13 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'19 a_0
    end
  
  predicate invariant'7 (self : t_K'0) =
    [%#sinvariant146] inv'8 self
  
  predicate inv'12 (_1 : t_K'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_K'0 [inv'12 x] . inv'12 x = invariant'7 x
  
  predicate invariant'6 (self : borrowed t_V'0) =
    [%#sinvariant122] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'11 (_1 : borrowed t_V'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed t_V'0 [inv'11 x] . inv'11 x = invariant'6 x
  
  predicate invariant'5 (self : borrowed t_K'0) =
    [%#sinvariant122] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_1 : borrowed t_K'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed t_K'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  predicate invariant'4 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant122] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant122] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'6 x] . inv'6 x
  = invariant'3 x
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant122] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'5 x] . inv'5 x = invariant'2 x
  
  axiom inv_axiom'4 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'4 left /\ inv'8 key /\ inv'10 val' /\ inv'4 right
    end
  
  predicate invariant'1 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant122] inv'1 self.current /\ inv'1 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed121] inv'3 self
  
  axiom inv_axiom'1 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'1 a_0
    end
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Color as Color'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree102] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree120] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree101] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree100] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel99] deep_model'1 self
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree98] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree97] height'0 self >= 0
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree96] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree95] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree145] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree119] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree138] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree114] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree94] bst_invariant'0 self /\ height_invariant'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree113] color_invariant_here'0 self
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ color_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : CP'0.t_CP) (node : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree110] match self with
      | CP'0.C_CPL color -> T_red_black_tree__Node.t_Node__color node = color /\ color_invariant'1 node
      | CP'0.C_CPN color l r -> T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : Node'0.t_Node t_K'0 t_V'0) : int =
    [%#sred_black_tree107] match T_red_black_tree__Node.t_Node__color self with
      | Color'0.C_Red -> height'0 (T_red_black_tree__Node.t_Node__left self)
      | Color'0.C_Black -> height'0 (T_red_black_tree__Node.t_Node__left self) + 1
      end
  
  axiom height'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0 . [%#sred_black_tree106] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> height'1 self = height'0 (Tree'0.C_Tree (Option'0.C_Some node))
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree112] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'1 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree111] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : Node'0.t_Node t_K'0 t_V'0) (o : Node'0.t_Node t_K'0 t_V'0)
    
   =
    [%#sred_black_tree105] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree137] height_invariant_here'0 self
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ height_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree136] bst_invariant_here'0 self
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__left self)
    /\ bst_invariant'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree104] bst_invariant'1 self /\ height_invariant'1 self
  
  let rec balance'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree85] inv'5 self}
    {[@expl:precondition] [%#sred_black_tree84] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red  -> false}
    {[@expl:precondition] [%#sred_black_tree83] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__right self.current)}
    {[@expl:precondition] [%#sred_black_tree82] T_red_black_tree__Node.t_Node__color self.current = Color'0.C_Red
    /\ color'0 (T_red_black_tree__Node.t_Node__left self.current) = Color'0.C_Red
     -> color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)}
    {[@expl:precondition] [%#sred_black_tree81] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree93] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree92] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree91] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) self.current
       -> match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final}
      {[%#sred_black_tree90] match_n'0 (cpn'0 (Color'0.C_Black) (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current
       -> match_n'0 (CP'0.C_CPL (Color'0.C_Red)) self.final}
      {[%#sred_black_tree89] color_invariant'0 (T_red_black_tree__Node.t_Node__left self.current)
      /\ color'0 (T_red_black_tree__Node.t_Node__right self.current) = Color'0.C_Black  -> self.current = self.final}
      {[%#sred_black_tree88] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree87] internal_invariant'1 self.final}
      {[%#sred_black_tree86] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec move_red_left'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] [%#sred_black_tree70] inv'5 self}
    {[@expl:precondition] [%#sred_black_tree69] match_n'0 (cpn'0 (Color'0.C_Red) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black))) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree68] internal_invariant'1 self.current}
    {[@expl:precondition] [%#sred_black_tree67] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[%#sred_black_tree80] inv'5 result}
      {[%#sred_black_tree79] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__right result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#sred_black_tree78] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#sred_black_tree77] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree76] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current))
       -> has_mapping'1 result.current k v}
      {[%#sred_black_tree75] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree74] T_red_black_tree__Node.t_Node__key self.current
      = T_red_black_tree__Node.t_Node__key result.current}
      {[%#sred_black_tree73] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree72] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree71] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  predicate resolve'13 (self : borrowed t_V'0) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed t_V'0) =
    resolve'13 _1
  
  let rec swap'1 (x:borrowed t_V'0) (y:borrowed t_V'0) (return'  (ret:()))= {[@expl:precondition] inv'11 y}
    {[@expl:precondition] inv'11 x}
    any
    [ return' (result:())-> {[%#smem66] y.final = x.current} {[%#smem65] x.final = y.current} (! return' {result}) ]
    
  
  predicate resolve'12 (self : borrowed t_K'0) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed t_K'0) =
    resolve'12 _1
  
  let rec swap'0 (x:borrowed t_K'0) (y:borrowed t_K'0) (return'  (ret:()))= {[@expl:precondition] inv'9 y}
    {[@expl:precondition] inv'9 x}
    any
    [ return' (result:())-> {[%#smem66] y.final = x.current} {[%#smem65] x.final = y.current} (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree144] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree118] model_acc'0 self (Const.const (Option'0.C_None))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree140] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree139] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree143] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree141] bst_invariant'0 self)
   -> ([%#sred_black_tree142] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree117] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree115] bst_invariant'0 self)
   -> ([%#sred_black_tree116] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = Option'0.C_Some v))
  
  function has_mapping_inj'0 [#"red_black_tree.rs" 122 4 124 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v1 : t_V'0) (v2 : t_V'0) : ()
    
   =
    [%#sred_black_tree64] let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
      | Option'0.C_None -> ()
      | Option'0.C_Some _v -> ()
      end
  
  axiom has_mapping_inj'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0, v1 : t_V'0, v2 : t_V'0 . ([%#sred_black_tree60] bst_invariant'0 self)
   -> ([%#sred_black_tree61] has_mapping'0 self k v1)
   -> ([%#sred_black_tree62] has_mapping'0 self k v2)  -> ([%#sred_black_tree63] v1 = v2)
  
  let rec delete_min_rec'0 (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:precondition] [%#sred_black_tree51] inv'7 self}
    {[@expl:precondition] [%#sred_black_tree50] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree49] internal_invariant'0 self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree59] inv'19 result}
      {[%#sred_black_tree58] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#sred_black_tree57] color_invariant'0 self.final}
      {[%#sred_black_tree56] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'1 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree55] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'1 (let (a, _) = result in a)) k}
      {[%#sred_black_tree54] has_mapping'0 self.current (deep_model'1 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree53] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree52] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  let rec move_red_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] [%#sred_black_tree38] inv'5 self}
    {[@expl:precondition] [%#sred_black_tree37] match_n'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Black)) (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Black)))) self.current}
    {[@expl:precondition] [%#sred_black_tree36] internal_invariant'1 self.current}
    {[@expl:precondition] [%#sred_black_tree35] T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
    <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {[%#sred_black_tree48] inv'5 result}
      {[%#sred_black_tree47] color_invariant'1 result.final
      /\ (color'0 (T_red_black_tree__Node.t_Node__left result.current) = Color'0.C_Black
       -> T_red_black_tree__Node.t_Node__color result.final = Color'0.C_Black)  -> color_invariant'1 self.final}
      {[%#sred_black_tree46] match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Black)) (CP'0.C_CPL (Color'0.C_Red))) result.current
      \/ match_n'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Red))) result.current}
      {[%#sred_black_tree45] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree44] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current)) k
       -> has_mapping'1 result.current k v}
      {[%#sred_black_tree43] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree42] T_red_black_tree__Node.t_Node__key result.current
      = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree41] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree40] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree39] internal_invariant'1 result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'2 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'17 self}
    {[@expl:precondition] [%#soption14] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'18 result}
      {[%#soption14] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_ref'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'16 self}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'17 result}
      {[%#soption34] self = Option'0.C_None
      \/ (exists r : Node'0.t_Node t_K'0 t_V'0 . result = Option'0.C_Some r /\ self = Option'0.C_Some r)}
      {[%#soption33] self = Option'0.C_None  -> result = Option'0.C_None}
      (! return' {result}) ]
    
  
  predicate resolve'14 (_1 : t_V'0)
  
  predicate resolve'11 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree109] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'14 v
  
  predicate resolve'4 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'11 _1
  
  let rec unwrap'1 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:Node'0.t_Node t_K'0 t_V'0))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [%#soption14] self <> Option'0.C_None}
    any
    [ return' (result:Node'0.t_Node t_K'0 t_V'0)-> {inv'1 result}
      {[%#soption14] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  predicate resolve'10 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'10 _1
  
  predicate resolve'9 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'9 _1
  
  predicate is_default'0 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#soption108] self = Option'0.C_None
  
  let rec take'0 (dest:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'6 dest}
    any
    [ return' (result:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))-> {inv'0 result}
      {[%#smem32] is_default'0 dest.final}
      {[%#smem31] result = dest.current}
      (! return' {result}) ]
    
  
  predicate resolve'8 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'8 _1
  
  let rec is_none'0 (self:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:bool))= {[@expl:precondition] inv'16 self}
    any [ return' (result:bool)-> {[%#soption30] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec rotate_right'0 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree22] inv'5 self}
    {[@expl:precondition] [%#sred_black_tree21] color'0 (T_red_black_tree__Node.t_Node__left self.current)
    = Color'0.C_Red}
    {[@expl:precondition] [%#sred_black_tree20] internal_invariant'1 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree29] exists l : Node'0.t_Node t_K'0 t_V'0, r : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__left self.current)
      = Option'0.C_Some l
      /\ T_red_black_tree__Tree.t_Tree__node (T_red_black_tree__Node.t_Node__right self.final) = Option'0.C_Some r
      /\ (T_red_black_tree__Node.t_Node__left self.final, T_red_black_tree__Node.t_Node__left r, T_red_black_tree__Node.t_Node__right r)
      = (T_red_black_tree__Node.t_Node__left l, T_red_black_tree__Node.t_Node__right l, T_red_black_tree__Node.t_Node__right self.current)
      /\ T_red_black_tree__Node.t_Node__key r = T_red_black_tree__Node.t_Node__key self.current}
      {[%#sred_black_tree28] T_red_black_tree__Node.t_Node__color self.final
      = T_red_black_tree__Node.t_Node__color self.current}
      {[%#sred_black_tree27] color'0 (T_red_black_tree__Node.t_Node__right self.final) = Color'0.C_Red}
      {[%#sred_black_tree26] lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self.final)) (deep_model'1 (T_red_black_tree__Node.t_Node__key self.current))}
      {[%#sred_black_tree25] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree24] internal_invariant'1 self.final}
      {[%#sred_black_tree23] same_mappings'0 self.current self.final}
      (! return' {result}) ]
    
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree18] inv'15 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree19] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] inv'12 other}
    {[@expl:precondition] inv'12 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#scmp17] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve103] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'7 _1
  
  let rec as_mut'1 (self:borrowed (Node'0.t_Node t_K'0 t_V'0)) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'5 result}
      {[%#sboxed16] self.final = result.final}
      {[%#sboxed15] self.current = result.current}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'14 self}
    {[@expl:precondition] [%#soption14] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption14] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'6 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'14 result}
      {[%#soption13] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption12] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec delete_rec (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (key:t_K'0) (return'  (ret:Option'0.t_Option (t_K'0, t_V'0)))= {[%#sred_black_tree4] inv'12 key}
    {[%#sred_black_tree3] inv'7 self}
    {[%#sred_black_tree2] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[%#sred_black_tree1] internal_invariant'0 self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_16 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = as_mut'0 {_16}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 = unwrap'0 {_15} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = {inv'1 _14.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_14.current} {Borrow.get_id _14}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_13 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_14 <- { _14 with current = _ret'.final ; } ] 
            s1)
      | s1 = as_mut'1 {_13} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_21 <- rkey'0 ] 
            s3)
      | s3 = cmp'0 {key} {_21} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_18 <- _ret' ] s4)
      | s4 = bb4 ]
      
    | bb4 = any
      [ br0 -> {_18 = Ordering'0.C_Less } (! bb6)
      | br1 -> {_18 = Ordering'0.C_Equal } (! bb5)
      | br2 -> {_18 = Ordering'0.C_Greater } (! bb5) ]
      
    | bb5 = s0
      [ s0 =  [ &ord <- _18 ] s1
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s2))
      | s2 = bb26 ]
      
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ] 
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_mut <Node'0.t_Node t_K'0 t_V'0> {node.current}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_45 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = rotate_right'0 {_45} (fun (_ret':()) ->  [ &_44 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_47 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_rec {_47} {key} (fun (_ret':Option'0.t_Option (t_K'0, t_V'0)) ->  [ &_46 <- _ret' ] s2)
      | s2 = bb29 ]
      
    | bb29 = bb30
    | bb30 = s0 [ s0 =  [ &r <- _46 ] s1 | s1 = bb32 ] 
    | bb32 = bb68
    | bb33 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s1)))
      | s1 = bb34 ]
      
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ] 
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = any
        [ br0 -> {ord = Ordering'0.C_Less } (! bb38)
        | br1 -> {ord = Ordering'0.C_Equal } (! bb38)
        | br2 -> {ord = Ordering'0.C_Greater } (! bb36) ]
         ]
      
    | bb38 = s0
      [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {self.current}
          (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
            {inv'0 rnode'0}
            Borrow.borrow_final
              <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
              {rnode'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                 [ &_59 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Tree'0.C_Tree _ret'.final ; } ] 
                s1))
      | s1 = {inv'0 _59.current}
        Borrow.borrow_final <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {_59.current} {Borrow.get_id _59}
          (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
             [ &_58 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_59 <- { _59 with current = _ret'.final ; } ] 
            s2)
      | s2 = take'0 {_58} (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_57 <- _ret' ] s3)
      | s3 = bb39 ]
      
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'6 _59} s1
      | s1 = -{resolve'2 _59}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 = unwrap'1 {_57} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb40 ]
      
    | bb40 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node _ _ _ _ x'0 -> inv'4 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | Node'0.C_Node _ _ _ _ x'1 -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | Node'0.C_Node x'2 _ _ _ _ -> inv'4 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | Node'0.C_Node x'3 _ _ _ _ -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {node1}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Node'0.t_Node <t_K'0> <t_V'0> {node1}
              (fun (rleft'1:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'1:Color'0.t_Color) (rkey'1:t_K'0) (rval'1:t_V'0) (rright'1:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_60 <- (rkey'0, rval'1) ] 
                s5))
      | s5 = bb41 ]
      
    | bb41 = bb42
    | bb42 = s0 [ s0 =  [ &_0 <- Option'0.C_Some _60 ] s1 | s1 = bb43 ] 
    | bb43 = bb72
    | bb72 = bb73
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'3 self}- s2 | s2 = bb37 ] 
    | bb37 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb73 ] 
    | bb73 = bb74
    | bb44 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rright'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_67 <- _ret' ] s1)))
      | s1 = bb45 ]
      
    | bb45 = s0 [ s0 = unwrap'2 {_67} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &_66 <- _ret' ] s1) | s1 = bb46 ] 
    | bb46 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_66}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_64 <- _ret' ] s1))
      | s1 = bb47 ]
      
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb48) ] 
    | bb48 = bb51
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_71 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_right'0 {_71} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_70 <- _ret' ] s2)
      | s2 = bb50 ]
      
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_70.current} {Borrow.get_id _70}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_69 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_70 <- { _70 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'5 _70} s5
      | s5 = -{resolve'1 _70}- s6
      | s6 = bb51 ]
      
    | bb51 = any
      [ br0 -> {ord = Ordering'0.C_Less } (! bb63)
      | br1 -> {ord = Ordering'0.C_Equal } (! bb52)
      | br2 -> {ord = Ordering'0.C_Greater } (! bb63) ]
      
    | bb63 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_90 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_rec {_90} {key} (fun (_ret':Option'0.t_Option (t_K'0, t_V'0)) ->  [ &_89 <- _ret' ] s2)
      | s2 = bb64 ]
      
    | bb64 = bb65
    | bb65 = s0 [ s0 =  [ &r <- _89 ] s1 | s1 = bb67 ] 
    | bb67 = bb68
    | bb52 = bb53
    | bb53 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rright'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rright'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_74 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                s1))
      | s1 = delete_min_rec'0 {_74} (fun (_ret':(t_K'0, t_V'0)) ->  [ &kv <- _ret' ] s2)
      | s2 = bb54 ]
      
    | bb54 = s0 [ s0 =  [ &_75 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb55 ] 
    | bb55 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'8 rkey'0}
            Borrow.borrow_mut <t_K'0> {rkey'0}
              (fun (_ret':borrowed t_K'0) ->
                 [ &_79 <- _ret' ] 
                -{inv'8 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 _ret'.final rval'0 rright'0 ; } ] 
                s1))
      | s1 = {inv'8 _79.current}
        Borrow.borrow_final <t_K'0> {_79.current} {Borrow.get_id _79}
          (fun (_ret':borrowed t_K'0) ->
             [ &_78 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_79 <- { _79 with current = _ret'.final ; } ] 
            s2)
      | s2 = {inv'8 (let (r'0, _) = kv in r'0)}
        Borrow.borrow_mut <t_K'0> {let (r'0, _) = kv in r'0}
          (fun (_ret':borrowed t_K'0) ->
             [ &_81 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &kv <- let (_, r'2) = kv in (_ret'.final, r'2) ] 
            s3)
      | s3 = {inv'8 _81.current}
        Borrow.borrow_final <t_K'0> {_81.current} {Borrow.get_id _81}
          (fun (_ret':borrowed t_K'0) ->
             [ &_80 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_81 <- { _81 with current = _ret'.final ; } ] 
            s4)
      | s4 = swap'0 {_78} {_80} (fun (_ret':()) ->  [ &_77 <- _ret' ] s5)
      | s5 = bb56 ]
      
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'9 _81} s1
      | s1 = -{resolve'5 _81}- s2
      | s2 = {[@expl:type invariant] inv'9 _79} s3
      | s3 = -{resolve'5 _79}- s4
      | s4 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'10 rval'0}
            Borrow.borrow_mut <t_V'0> {rval'0}
              (fun (_ret':borrowed t_V'0) ->
                 [ &_84 <- _ret' ] 
                -{inv'10 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 _ret'.final rright'0 ; } ] 
                s5))
      | s5 = {inv'10 _84.current}
        Borrow.borrow_final <t_V'0> {_84.current} {Borrow.get_id _84}
          (fun (_ret':borrowed t_V'0) ->
             [ &_83 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_84 <- { _84 with current = _ret'.final ; } ] 
            s6)
      | s6 = {inv'10 (let (_, r'0) = kv in r'0)}
        Borrow.borrow_mut <t_V'0> {let (_, r'0) = kv in r'0}
          (fun (_ret':borrowed t_V'0) ->
             [ &_86 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &kv <- let (r'1, _) = kv in (r'1, _ret'.final) ] 
            s7)
      | s7 = {inv'10 _86.current}
        Borrow.borrow_final <t_V'0> {_86.current} {Borrow.get_id _86}
          (fun (_ret':borrowed t_V'0) ->
             [ &_85 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_86 <- { _86 with current = _ret'.final ; } ] 
            s8)
      | s8 = swap'1 {_83} {_85} (fun (_ret':()) ->  [ &_82 <- _ret' ] s9)
      | s9 = bb57 ]
      
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'11 _86} s1
      | s1 = -{resolve'6 _86}- s2
      | s2 = {[@expl:type invariant] inv'11 _84} s3
      | s3 = -{resolve'6 _84}- s4
      | s4 =  [ &_87 <- Option'0.C_Some kv ] s5
      | s5 = bb58 ]
      
    | bb58 = bb59
    | bb59 = s0 [ s0 =  [ &r <- _87 ] s1 | s1 = bb61 ] 
    | bb61 = bb62
    | bb62 = bb68
    | bb68 = bb69
    | bb6 = bb7
    | bb7 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                is_none'0 {rnode'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)))
      | s1 = bb8 ]
      
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ] 
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb74 ]
      
    | bb74 = bb75
    | bb75 = bb76
    | bb10 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1))
      | s1 = bb11 ]
      
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {rleft'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                as_ref'0 {rnode'0}
                  (fun (_ret':Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_33 <- _ret' ] s1)))
      | s1 = bb14 ]
      
    | bb14 = s0 [ s0 = unwrap'2 {_33} (fun (_ret':Node'0.t_Node t_K'0 t_V'0) ->  [ &_32 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_32}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = bb16 ]
      
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = move_red_left'0 {_37} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_36 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {_36.current} {Borrow.get_id _36}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_36 <- { _36 with current = _ret'.final ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'5 _36} s5
      | s5 = -{resolve'1 _36}- s6
      | s6 = bb21 ]
      
    | bb21 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'4 rleft'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {rleft'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_39 <- _ret' ] 
                -{inv'4 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                s1))
      | s1 = delete_rec {_39} {key} (fun (_ret':Option'0.t_Option (t_K'0, t_V'0)) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb22 ]
      
    | bb22 = bb23
    | bb23 = s0 [ s0 =  [ &r <- _38 ] s1 | s1 = bb25 ] 
    | bb25 = bb69
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {node.current} {Borrow.get_id node}
          (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
             [ &_93 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final ; } ] 
            s1)
      | s1 = balance'0 {_93} (fun (_ret':()) ->  [ &_92 <- _ret' ] s2)
      | s2 = bb70 ]
      
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb71 ]
      
    | bb71 = bb76
    | bb76 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = self
    | & key : t_K'0 = key
    | & r : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _13 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _14 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _15 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _16 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _18 : Ordering'0.t_Ordering = any_l ()
    | & _21 : t_K'0 = any_l ()
    | & _24 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _33 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _35 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _36 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _37 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _38 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & _39 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & ord : Ordering'0.t_Ordering = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : () = any_l ()
    | & _45 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _46 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & _47 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _50 : bool = any_l ()
    | & node1 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _57 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _58 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _59 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _60 : (t_K'0, t_V'0) = any_l ()
    | & _64 : bool = any_l ()
    | & _66 : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _67 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _69 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _70 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _71 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & kv : (t_K'0, t_V'0) = any_l ()
    | & _74 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _75 : Snapshot.snap_ty () = any_l ()
    | & _77 : () = any_l ()
    | & _78 : borrowed t_K'0 = any_l ()
    | & _79 : borrowed t_K'0 = any_l ()
    | & _80 : borrowed t_K'0 = any_l ()
    | & _81 : borrowed t_K'0 = any_l ()
    | & _82 : () = any_l ()
    | & _83 : borrowed t_V'0 = any_l ()
    | & _84 : borrowed t_V'0 = any_l ()
    | & _85 : borrowed t_V'0 = any_l ()
    | & _86 : borrowed t_V'0 = any_l ()
    | & _87 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & _89 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & _90 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _92 : () = any_l ()
    | & _93 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:Option'0.t_Option (t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree11] inv'13 result}
      {[@expl:postcondition] [%#sred_black_tree10] color'0 self.current = Color'0.C_Black
       -> color'0 self.final = Color'0.C_Black}
      {[@expl:postcondition] [%#sred_black_tree9] color_invariant'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 key <> k /\ has_mapping'0 self.current k v)}
      {[@expl:postcondition] [%#sred_black_tree7] match result with
        | Option'0.C_None -> forall v : t_V'0 . not has_mapping'0 self.current (deep_model'0 key) v
        | Option'0.C_Some (k, v) -> deep_model'0 key = deep_model'1 k /\ has_mapping'0 self.current (deep_model'1 k) v
        end}
      {[@expl:postcondition] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:postcondition] [%#sred_black_tree5] internal_invariant'0 self.final}
      (! return' {result}) ]
    
end
module T_red_black_tree__Map [#"red_black_tree.rs" 753 0 753 20]
  use T_red_black_tree__Tree as Tree'0
  
  type t_V'0
  
  type t_K'0
  
  type t_Map 't_K'0 't_V'0 =
    | C_Map (Tree'0.t_Tree 't_K'0 't_V'0)
  
  let rec t_Map < 't_K'0 > < 't_V'0 > (input:t_Map 't_K'0 't_V'0) (ret  (field_0:Tree'0.t_Tree 't_K'0 't_V'0))= any
    [ good (field_0:Tree'0.t_Tree 't_K'0 't_V'0)-> {C_Map field_0 = input} (! ret {field_0}) ]
    
  
  function t_Map__0 (self : t_Map 't_K'0 't_V'0) : Tree'0.t_Tree 't_K'0 't_V'0 =
    match self with
      | C_Map a -> a
      end
end
module M_red_black_tree__qyi10312951825188598006__resolve_coherence [#"red_black_tree.rs" 793 4 793 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 790 15 790 39
  let%span sred_black_tree1 = "red_black_tree.rs" 791 14 791 31
  let%span sred_black_tree2 = "red_black_tree.rs" 785 8 785 70
  let%span sred_black_tree3 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree4 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree5 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree6 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree7 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree8 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree9 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree10 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree11 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree12 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree13 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree14 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree15 = "red_black_tree.rs" 178 8 180 9
  let%span sresolve16 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sred_black_tree17 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree18 = "red_black_tree.rs" 55 12 62 13
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord31] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord29] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord30] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord27] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord28] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord24] cmp_log'0 x y
  = o)  -> ([%#sord25] cmp_log'0 y z = o)  -> ([%#sord26] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord23] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use map.Map
  
  type t_K'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use T_red_black_tree__Tree as Tree'0
  
  type t_V'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree10] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree17] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree7] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree14] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree12] bst_invariant'0 self)
   -> ([%#sred_black_tree13] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  use map.Const
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree9] model_acc'0 self (Const.const (Option'0.C_None))
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree5] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree3] bst_invariant'0 self)
   -> ([%#sred_black_tree4] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'1 self) k = Option'0.C_Some v))
  
  use T_red_black_tree__Map as Map'0
  
  use prelude.prelude.Borrow
  
  predicate resolve'5 (_1 : t_V'0)
  
  predicate resolve'4 (self : Option'0.t_Option t_V'0) =
    [%#sresolve16] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 (_1 : Option'0.t_Option t_V'0) =
    resolve'4 _1
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree6] view'1 (T_red_black_tree__Map.t_Map__0 self)
  
  predicate resolve'0 [#"red_black_tree.rs" 784 4 784 28] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree2] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (view'0 self) k)
  
  predicate resolve'3 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree15] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Map'0.t_Map t_K'0 t_V'0) =
    match x with
      | Map'0.C_Map a -> resolve'1 a
      end
  
  constant self  : Map'0.t_Map t_K'0 t_V'0
  
  function resolve_coherence [#"red_black_tree.rs" 793 4 793 31] (self : Map'0.t_Map t_K'0 t_V'0) : ()
  
  goal vc_resolve_coherence : ([%#sred_black_tree0] structural_resolve'0 self)
   -> (let _ = has_mapping_model'0 in [%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi1501420612169366910__new [#"red_black_tree.rs" 803 4 803 24] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 802 14 802 43
  let%span sred_black_tree1 = "red_black_tree.rs" 803 20 803 24
  let%span sred_black_tree2 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree3 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree4 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree5 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree6 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree7 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree8 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree9 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree10 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree11 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree12 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree13 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree14 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree15 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree16 = "red_black_tree.rs" 327 12 335 13
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sboxed30 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  predicate inv'6 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'5 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed30] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord29] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord27] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord28] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord25] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord26] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord22] cmp_log'0 x y
  = o)  -> ([%#sord23] cmp_log'0 y z = o)  -> ([%#sord24] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord21] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord18] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord17] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree8] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree11] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree7] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree15] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree13] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree10] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree14] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree12] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree9] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree6] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'0 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree5] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'0 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'1 a_0
    end)
  
  use map.Const
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree4] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree3] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree2] view'1 (T_red_black_tree__Map.t_Map__0 self)
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec new (_1:()) (return'  (ret:Map'0.t_Map t_K'0 t_V'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- Option'0.C_None ] s1 | s1 =  [ &_2 <- Tree'0.C_Tree _3 ] s2 | s2 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- Map'0.C_Map _2 ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : Map'0.t_Map t_K'0 t_V'0 = any_l ()
    | & _2 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _3 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:Map'0.t_Map t_K'0 t_V'0)-> {[@expl:postcondition] [%#sred_black_tree1] inv'0 result}
      {[@expl:postcondition] [%#sred_black_tree0] view'0 result = Const.const (Option'0.C_None)}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__insert [#"red_black_tree.rs" 808 4 808 44] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 811 8 811 53
  let%span sred_black_tree1 = "red_black_tree.rs" 808 23 808 27
  let%span sred_black_tree2 = "red_black_tree.rs" 808 29 808 32
  let%span sred_black_tree3 = "red_black_tree.rs" 808 37 808 40
  let%span sred_black_tree4 = "red_black_tree.rs" 807 14 807 64
  let%span sred_black_tree5 = "red_black_tree.rs" 610 15 610 43
  let%span sred_black_tree6 = "red_black_tree.rs" 611 15 611 40
  let%span sred_black_tree7 = "red_black_tree.rs" 618 23 618 27
  let%span sred_black_tree8 = "red_black_tree.rs" 618 29 618 32
  let%span sred_black_tree9 = "red_black_tree.rs" 618 37 618 40
  let%span sred_black_tree10 = "red_black_tree.rs" 612 14 612 42
  let%span sred_black_tree11 = "red_black_tree.rs" 613 14 613 50
  let%span sred_black_tree12 = "red_black_tree.rs" 614 14 615 39
  let%span sred_black_tree13 = "red_black_tree.rs" 616 14 616 56
  let%span sred_black_tree14 = "red_black_tree.rs" 617 4 617 127
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption16 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sred_black_tree18 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree19 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree20 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree21 = "red_black_tree.rs" 761 8 761 29
  let%span smodel22 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sred_black_tree23 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree24 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree25 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree26 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree27 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree28 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree29 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree30 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve31 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree32 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree33 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree34 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree35 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree36 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree37 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree38 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree39 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree40 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant41 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sred_black_tree42 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree43 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree44 = "red_black_tree.rs" 368 20 368 61
  let%span sboxed45 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord56 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord57 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord58 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree59 = "red_black_tree.rs" 772 8 774 9
  
  type t_V'0
  
  predicate inv'5 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'4 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'0 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'11 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'0 left /\ inv'4 key /\ inv'5 val' /\ inv'0 right
    end
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord58] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord56] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord57] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord54] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord55] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord51] cmp_log'0 x y
  = o)  -> ([%#sord52] cmp_log'0 y z = o)  -> ([%#sord53] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord50] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord49] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord48] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree29] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree40] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree24] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree26] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree25] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree44] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree42] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree23] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'5 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree59] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'10 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'10 x] . inv'10 x
  = (invariant'5 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'0 a_0
    end)
  
  predicate invariant'4 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed45] inv'11 self
  
  predicate inv'9 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'9 x] . inv'9 x = invariant'4 x
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'6 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'8 x] . inv'8 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  predicate invariant'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant41] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'7 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'7 x] . inv'7 x
  = invariant'3 x
  
  predicate invariant'2 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant41] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'6 x] . inv'6 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sinvariant41] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'3 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : borrowed (Map'0.t_Map t_K'0 t_V'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant41] inv'9 self.current /\ inv'9 self.final
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'0 x
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'1 x] . inv'1 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = match x with
    | Tree'0.C_Tree node -> inv'1 node
    end
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree43] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree33] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree21] view'2 (T_red_black_tree__Map.t_Map__0 self)
  
  function view'1 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel22] view'0 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  use map.Map
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree35] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree34] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree38] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree36] bst_invariant'0 self)
   -> ([%#sred_black_tree37] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree20] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree18] bst_invariant'0 self)
   -> ([%#sred_black_tree19] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = Option'0.C_Some v))
  
  predicate resolve'3 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sresolve31] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    resolve'3 _1
  
  predicate resolve'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve31] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'2 _1
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'8 self}
    {[@expl:precondition] [%#soption17] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'2 result}
      {[%#soption17] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'8 result}
      {[%#soption16] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption15] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree28] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree27] CP'0.C_CPN c l r
  
  let rec insert_rec'0 (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[@expl:precondition] [%#sred_black_tree9] inv'5 val'}
    {[@expl:precondition] [%#sred_black_tree8] inv'4 key}
    {[@expl:precondition] [%#sred_black_tree7] inv'6 self}
    {[@expl:precondition] [%#sred_black_tree6] color_invariant'0 self.current}
    {[@expl:precondition] [%#sred_black_tree5] internal_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree14] forall k : t_DeepModelTy'0, v : t_V'0 . k = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      {[%#sred_black_tree13] has_mapping'0 self.final (deep_model'0 key) val'}
      {[%#sred_black_tree12] match_t'0 (cpn'0 (Color'0.C_Red) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.final
      /\ color'0 self.current = Color'0.C_Red
      \/ color_invariant'0 self.final}
      {[%#sred_black_tree11] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree10] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec insert (self:borrowed (Map'0.t_Map t_K'0 t_V'0)) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[%#sred_black_tree3] inv'5 val'}
    {[%#sred_black_tree2] inv'4 key}
    {[%#sred_black_tree1] inv'3 self}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'0 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_6 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = insert_rec'0 {_6} {key} {val'} (fun (_ret':()) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &_9 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'1 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_12 <- _ret' ] 
                    -{inv'1 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_12}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_11 <- _ret' ] s3)
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = unwrap'0 {_11} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_10 <- _ret' ] s1) | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_10.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_10 <- { _10 with current = Node'0.C_Node rleft'0 _9 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 =  [ &_13 <- [%#sred_black_tree0] Snapshot.new () ] s6
      | s6 = bb5 ]
      
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (Map'0.t_Map t_K'0 t_V'0) = self
    | & key : t_K'0 = key
    | & val' : t_V'0 = val'
    | & _5 : () = any_l ()
    | & _6 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _9 : Color'0.t_Color = any_l ()
    | & _10 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _11 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _12 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _13 : Snapshot.snap_ty () = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#sred_black_tree4] view'0 self.final
      = Map.set (view'1 self) (deep_model'0 key) (Option'0.C_Some val')}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete_max [#"red_black_tree.rs" 820 4 820 50] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 821 23 821 41
  let%span sred_black_tree1 = "red_black_tree.rs" 829 8 829 58
  let%span sred_black_tree2 = "red_black_tree.rs" 834 8 834 53
  let%span sred_black_tree3 = "red_black_tree.rs" 820 27 820 31
  let%span sred_black_tree4 = "red_black_tree.rs" 814 14 819 5
  let%span sred_black_tree5 = "red_black_tree.rs" 820 36 820 50
  let%span sred_black_tree6 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree7 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree8 = "red_black_tree.rs" 47 8 49 9
  let%span sred_black_tree9 = "red_black_tree.rs" 641 15 641 43
  let%span sred_black_tree10 = "red_black_tree.rs" 642 15 643 62
  let%span sred_black_tree11 = "red_black_tree.rs" 652 27 652 31
  let%span sred_black_tree12 = "red_black_tree.rs" 644 14 644 42
  let%span sred_black_tree13 = "red_black_tree.rs" 645 14 645 50
  let%span sred_black_tree14 = "red_black_tree.rs" 646 14 646 66
  let%span sred_black_tree15 = "red_black_tree.rs" 647 4 647 104
  let%span sred_black_tree16 = "red_black_tree.rs" 648 4 649 73
  let%span sred_black_tree17 = "red_black_tree.rs" 650 14 650 39
  let%span sred_black_tree18 = "red_black_tree.rs" 651 4 651 69
  let%span sred_black_tree19 = "red_black_tree.rs" 652 36 652 42
  let%span soption20 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption21 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span sred_black_tree23 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree24 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree25 = "red_black_tree.rs" 112 12 112 61
  let%span smodel26 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sred_black_tree27 = "red_black_tree.rs" 761 8 761 29
  let%span sresolve28 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree29 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree30 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree31 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree32 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree33 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree34 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree35 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree36 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree37 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree38 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree39 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree40 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree41 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree42 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree43 = "red_black_tree.rs" 91 12 100 13
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord56 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sinvariant57 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed58 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree59 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree60 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree61 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree62 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant63 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree64 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree65 = "red_black_tree.rs" 772 8 774 9
  
  type t_V'0
  
  predicate inv'14 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'13 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'12 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'12 x] . inv'12 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree29] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree60] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree36] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree35] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree34] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree64] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree59] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  type t_DeepModelTy'0
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree30] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree61] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree37] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree31] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'6 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree65] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'11 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate inv'9 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'9 x] . inv'9 x
  = (let (a, b) = x in inv'13 a /\ inv'14 b)
  
  predicate invariant'5 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant57] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant63] inv'5 self
  
  predicate inv'7 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'6 (_1 : Option'0.t_Option (t_K'0, t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : Option'0.t_Option (t_K'0, t_V'0) [inv'6 x] . inv'6 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord56] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord54] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord55] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord52] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord53] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord49] cmp_log'0 x y
  = o)  -> ([%#sord50] cmp_log'0 y z = o)  -> ([%#sord51] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord48] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant57] inv'3 self.current /\ inv'3 self.final
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed58] inv'12 self
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sinvariant57] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Map'0.t_Map t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant57] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Const
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree62] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree38] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree27] view'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function view'0 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel26] view'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree39] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree43] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree41] bst_invariant'0 self)
   -> ([%#sred_black_tree42] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree25] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree23] bst_invariant'0 self)
   -> ([%#sred_black_tree24] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = Option'0.C_Some v))
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'10 self}
    {[@expl:precondition] [%#soption22] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#soption22] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'10 result}
      {[%#soption21] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption20] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree33] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree32] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_max_rec'0 (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:precondition] [%#sred_black_tree11] inv'8 self}
    {[@expl:precondition] [%#sred_black_tree10] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree9] internal_invariant'0 self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree19] inv'9 result}
      {[%#sred_black_tree18] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#sred_black_tree17] color_invariant'0 self.final}
      {[%#sred_black_tree16] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree15] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[%#sred_black_tree14] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree13] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree12] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate same_mappings'0 [#"red_black_tree.rs" 46 4 46 43] (self : Tree'0.t_Tree t_K'0 t_V'0) (o : Tree'0.t_Tree t_K'0 t_V'0)
    
   =
    [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  use prelude.prelude.Snapshot
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve28] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree6] inv'7 self}
    any [ return' (result:bool)-> {[%#sred_black_tree7] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sresolve28] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve28] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max (self:borrowed (Map'0.t_Map t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (t_K'0, t_V'0)))= {[%#sred_black_tree3] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_6 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_6.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_6.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb19 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_6.current}
          (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id _6) 1}
              (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_11 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _11 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#sred_black_tree1] same_mappings'0 (T_red_black_tree__Map.t_Map__0 (Snapshot.inner old_self).current) (T_red_black_tree__Map.t_Map__0 self.current)}
        s1
      | s1 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_16 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s2))
      | s2 = delete_max_rec'0 {_16} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_20 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_23 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_23}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_22} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_21 <- _ret' ] s1) | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_21.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_21 <- { _21 with current = Node'0.C_Node rleft'0 _20 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _21} s2
      | s2 = -{resolve'2 _21}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_24 <- [%#sred_black_tree2] Snapshot.new () ] s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 =  [ &_0 <- Option'0.C_Some r ] s1 | s1 = bb17 ] 
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Map'0.t_Map t_K'0 t_V'0) = self
    | & old_self : Snapshot.snap_ty (borrowed (Map'0.t_Map t_K'0 t_V'0)) = any_l ()
    | & _6 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _9 : bool = any_l ()
    | & _11 : Color'0.t_Color = any_l ()
    | & r : (t_K'0, t_V'0) = any_l ()
    | & _16 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _18 : bool = any_l ()
    | & _20 : Color'0.t_Color = any_l ()
    | & _21 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _22 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _23 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _24 : Snapshot.snap_ty () = any_l () ]
    
    [ return' (result:Option'0.t_Option (t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree5] inv'6 result}
      {[@expl:postcondition] [%#sred_black_tree4] match result with
        | Option'0.C_Some (k, v) -> Map.get (view'0 self) (deep_model'0 k) = Option'0.C_Some v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (view'0 self) k2 = Option'0.C_None \/ le_log'0 k2 (deep_model'0 k))
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 k) (Option'0.C_None)
        | Option'0.C_None -> view'1 self.final = view'0 self /\ view'0 self = Const.const (Option'0.C_None)
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete_min [#"red_black_tree.rs" 845 4 845 50] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 846 8 846 53
  let%span sred_black_tree1 = "red_black_tree.rs" 845 27 845 31
  let%span sred_black_tree2 = "red_black_tree.rs" 838 14 844 5
  let%span sred_black_tree3 = "red_black_tree.rs" 845 36 845 50
  let%span sred_black_tree4 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree5 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree6 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree7 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree8 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree9 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree10 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree11 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree12 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree13 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree14 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree15 = "red_black_tree.rs" 675 4 675 104
  let%span sred_black_tree16 = "red_black_tree.rs" 676 4 677 73
  let%span sred_black_tree17 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree18 = "red_black_tree.rs" 679 4 679 69
  let%span sred_black_tree19 = "red_black_tree.rs" 680 36 680 42
  let%span soption20 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption21 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span smodel23 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sred_black_tree24 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree25 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree26 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree27 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree28 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree29 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree30 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree31 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree32 = "red_black_tree.rs" 91 12 100 13
  let%span sresolve33 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree34 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree35 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree36 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree37 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree38 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree39 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree40 = "red_black_tree.rs" 297 12 303 13
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree54 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree55 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant56 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed57 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree58 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree59 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant60 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree61 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree62 = "red_black_tree.rs" 772 8 774 9
  
  type t_V'0
  
  predicate inv'14 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'13 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'12 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'12 x] . inv'12 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree34] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree59] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree40] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree39] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree38] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree61] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree58] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  type t_DeepModelTy'0
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree26] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree54] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree25] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree35] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'6 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree62] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'11 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate inv'9 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'9 x] . inv'9 x
  = (let (a, b) = x in inv'13 a /\ inv'14 b)
  
  predicate invariant'5 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant56] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant60] inv'5 self
  
  predicate inv'7 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'6 (_1 : Option'0.t_Option (t_K'0, t_V'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : Option'0.t_Option (t_K'0, t_V'0) [inv'6 x] . inv'6 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'9 a_0
    end
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord53] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord51] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord52] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord49] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord50] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord46] cmp_log'0 x y
  = o)  -> ([%#sord47] cmp_log'0 y z = o)  -> ([%#sord48] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord45] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord43] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord42] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord41] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant56] inv'3 self.current /\ inv'3 self.final
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed57] inv'12 self
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sinvariant56] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Map'0.t_Map t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant56] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Const
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree55] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree27] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree24] view'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function view'0 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel23] view'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'10 self}
    {[@expl:precondition] [%#soption22] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#soption22] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'10 result}
      {[%#soption21] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption20] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree37] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree36] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_min_rec'0 (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:precondition] [%#sred_black_tree11] inv'8 self}
    {[@expl:precondition] [%#sred_black_tree10] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree9] internal_invariant'0 self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree19] inv'9 result}
      {[%#sred_black_tree18] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#sred_black_tree17] color_invariant'0 self.final}
      {[%#sred_black_tree16] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree15] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[%#sred_black_tree14] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree13] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree12] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve33] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree7] inv'7 self}
    any [ return' (result:bool)-> {[%#sred_black_tree8] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ] 
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sresolve33] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve33] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree29] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree28] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree30] bst_invariant'0 self)
   -> ([%#sred_black_tree31] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree6] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min (self:borrowed (Map'0.t_Map t_K'0 t_V'0)) (return'  (ret:Option'0.t_Option (t_K'0, t_V'0)))= {[%#sred_black_tree1] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_6 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_6.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_6.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb18 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_6.current}
          (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id _6) 1}
              (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_11 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _11 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_14 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = delete_min_rec'0 {_14} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_18 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_21 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_21}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_20} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_19 <- _ret' ] s1) | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_19.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_19 <- { _19 with current = Node'0.C_Node rleft'0 _18 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _19} s2
      | s2 = -{resolve'2 _19}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- Option'0.C_Some r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Map'0.t_Map t_K'0 t_V'0) = self
    | & _3 : Snapshot.snap_ty () = any_l ()
    | & _6 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _9 : bool = any_l ()
    | & _11 : Color'0.t_Color = any_l ()
    | & r : (t_K'0, t_V'0) = any_l ()
    | & _14 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _16 : bool = any_l ()
    | & _18 : Color'0.t_Color = any_l ()
    | & _19 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _20 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _21 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l () ]
    
    [ return' (result:Option'0.t_Option (t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree3] inv'6 result}
      {[@expl:postcondition] [%#sred_black_tree2] match result with
        | Option'0.C_Some (k, v) -> Map.get (view'0 self) (deep_model'0 k) = Option'0.C_Some v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (view'0 self) k2 = Option'0.C_None \/ le_log'0 (deep_model'0 k) k2)
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 k) (Option'0.C_None)
        | Option'0.C_None -> view'1 self.final = view'0 self /\ view'0 self = Const.const (Option'0.C_None)
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__delete [#"red_black_tree.rs" 868 4 868 55] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 869 8 869 53
  let%span sred_black_tree1 = "red_black_tree.rs" 868 23 868 27
  let%span sred_black_tree2 = "red_black_tree.rs" 868 29 868 32
  let%span sred_black_tree3 = "red_black_tree.rs" 862 14 866 5
  let%span sred_black_tree4 = "red_black_tree.rs" 867 14 867 59
  let%span sred_black_tree5 = "red_black_tree.rs" 868 41 868 55
  let%span sred_black_tree6 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree7 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree8 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree9 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree10 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree11 = "red_black_tree.rs" 694 15 694 43
  let%span sred_black_tree12 = "red_black_tree.rs" 695 15 696 62
  let%span sred_black_tree13 = "red_black_tree.rs" 706 23 706 27
  let%span sred_black_tree14 = "red_black_tree.rs" 706 29 706 32
  let%span sred_black_tree15 = "red_black_tree.rs" 697 14 697 42
  let%span sred_black_tree16 = "red_black_tree.rs" 698 14 698 50
  let%span sred_black_tree17 = "red_black_tree.rs" 699 14 702 5
  let%span sred_black_tree18 = "red_black_tree.rs" 703 4 703 129
  let%span sred_black_tree19 = "red_black_tree.rs" 704 14 704 39
  let%span sred_black_tree20 = "red_black_tree.rs" 705 4 705 69
  let%span sred_black_tree21 = "red_black_tree.rs" 706 41 706 55
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 58 16 58 77
  let%span soption23 = "../../../creusot-contracts/src/std/option.rs" 59 16 62 18
  let%span soption24 = "../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span smodel25 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span smodel26 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sred_black_tree27 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree28 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree29 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree30 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree31 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree32 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree33 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree34 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree35 = "red_black_tree.rs" 91 12 100 13
  let%span sresolve36 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree37 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree38 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree39 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree40 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree41 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree42 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree43 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree44 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree45 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant46 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed47 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree48 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree49 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant50 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree51 = "red_black_tree.rs" 368 20 368 61
  let%span sord52 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord53 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord54 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord55 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord56 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord57 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord58 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord59 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord60 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord61 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord62 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord63 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord64 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree65 = "red_black_tree.rs" 772 8 774 9
  
  type t_V'0
  
  predicate inv'15 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'14 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'13 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'13 x] . inv'13 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree37] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree49] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree43] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree42] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree41] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree51] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  type t_DeepModelTy'0
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree29] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree44] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree38] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'7 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree65] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'12 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'12 x] . inv'12 x
  = (invariant'7 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord64] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord62] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord63] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord60] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord61] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord57] cmp_log'0 x y
  = o)  -> ([%#sord58] cmp_log'0 y z = o)  -> ([%#sord59] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord56] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord55] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord54] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord53] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord52] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  predicate inv'11 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'11 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'11 x] . inv'11 x
  = (let (a, b) = x in inv'14 a /\ inv'15 b)
  
  use prelude.prelude.Borrow
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  use T_core__option__Option as Option'0
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'10 [@rewrite] : forall x : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant'6 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant46] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'9 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant50] inv'5 self
  
  predicate inv'8 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'7 (_1 : Option'0.t_Option (t_K'0, t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (t_K'0, t_V'0) [inv'7 x] . inv'7 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'11 a_0
    end
  
  predicate invariant'4 (self : t_K'0) =
    [%#sinvariant50] inv'14 self
  
  predicate inv'6 (_1 : t_K'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_K'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate inv'0 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'0 node
    end
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'3 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant46] inv'3 self.current /\ inv'3 self.final
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed47] inv'13 self
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sinvariant46] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'2 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : borrowed (Map'0.t_Map t_K'0 t_V'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'0 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'1 x] . inv'1 x
  = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'0 x] . inv'0 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree45] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree30] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree27] view'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function view'0 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel26] view'1 self.current
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel25] deep_model'0 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec unwrap'0 (self:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:borrowed (Node'0.t_Node t_K'0 t_V'0)))= {[@expl:precondition] inv'10 self}
    {[@expl:precondition] [%#soption24] self <> Option'0.C_None}
    any
    [ return' (result:borrowed (Node'0.t_Node t_K'0 t_V'0))-> {inv'4 result}
      {[%#soption24] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec as_mut'0 (self:borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) (return'  (ret:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))))= {[@expl:precondition] inv'1 self}
    any
    [ return' (result:Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)))-> {inv'10 result}
      {[%#soption23] self.current = Option'0.C_None
      \/ (exists r : borrowed (Node'0.t_Node t_K'0 t_V'0) . result = Option'0.C_Some r
      /\ self.current = Option'0.C_Some (r.current) /\ self.final = Option'0.C_Some (r.final))}
      {[%#soption22] self.current = Option'0.C_None  -> result = Option'0.C_None /\ self.final = Option'0.C_None}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : Color'0.t_Color) (l : CP'0.t_CP) (r : CP'0.t_CP) : CP'0.t_CP =
    [%#sred_black_tree40] CP'0.C_CPN c l r
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree39] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  let rec delete_rec'0 (self:borrowed (Tree'0.t_Tree t_K'0 t_V'0)) (key:t_K'0) (return'  (ret:Option'0.t_Option (t_K'0, t_V'0)))= {[@expl:precondition] [%#sred_black_tree14] inv'6 key}
    {[@expl:precondition] [%#sred_black_tree13] inv'9 self}
    {[@expl:precondition] [%#sred_black_tree12] match_t'0 (CP'0.C_CPL (Color'0.C_Red)) self.current
    \/ match_t'0 (cpn'0 (Color'0.C_Black) (CP'0.C_CPL (Color'0.C_Red)) (CP'0.C_CPL (Color'0.C_Black))) self.current}
    {[@expl:precondition] [%#sred_black_tree11] internal_invariant'0 self.current}
    any
    [ return' (result:Option'0.t_Option (t_K'0, t_V'0))-> {[%#sred_black_tree21] inv'7 result}
      {[%#sred_black_tree20] color'0 self.current = Color'0.C_Black  -> color'0 self.final = Color'0.C_Black}
      {[%#sred_black_tree19] color_invariant'0 self.final}
      {[%#sred_black_tree18] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'1 key <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree17] match result with
        | Option'0.C_None -> forall v : t_V'0 . not has_mapping'0 self.current (deep_model'1 key) v
        | Option'0.C_Some (k, v) -> deep_model'1 key = deep_model'0 k /\ has_mapping'0 self.current (deep_model'0 k) v
        end}
      {[%#sred_black_tree16] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree15] internal_invariant'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'5 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve36] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec is_red'0 (self:Tree'0.t_Tree t_K'0 t_V'0) (return'  (ret:bool))= {[@expl:precondition] [%#sred_black_tree9] inv'8 self}
    any
    [ return' (result:bool)-> {[%#sred_black_tree10] result = (color'0 self = Color'0.C_Red)} (! return' {result}) ]
    
  
  predicate resolve'4 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sresolve36] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    resolve'4 _1
  
  predicate resolve'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve36] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'3 _1
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree32] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree31] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree35] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree33] bst_invariant'0 self)
   -> ([%#sred_black_tree34] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree8] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree6] bst_invariant'0 self)
   -> ([%#sred_black_tree7] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec delete (self:borrowed (Map'0.t_Map t_K'0 t_V'0)) (key:t_K'0) (return'  (ret:Option'0.t_Option (t_K'0, t_V'0)))= {[%#sred_black_tree2] inv'6 key}
    {[%#sred_black_tree1] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_mut <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)> {rnode'0}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_8 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s1)))
      | s1 = any
        [ br0 -> {_8.current = Option'0.C_None } (! bb8)
        | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_8.current = Option'0.C_Some a} (! bb2) ]
         ]
      
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb17 ]
      
    | bb2 = bb3
    | bb3 = s0
      [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_8.current}
          (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
            {inv'3 r0'0}
            Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id _8) 1}
              (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_8 <- { _8 with current = Option'0.C_Some _ret'.final ; } ] 
                s1))
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            is_red'0 {rleft'0} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
      
    | bb6 = s0
      [ s0 =  [ &_13 <- Color'0.C_Red ] s1
      | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &node <- { node with current = Node'0.C_Node rleft'0 _13 rkey'0 rval'0 rright'0 ; } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
      
    | bb7 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'5 r0'0}
            Borrow.borrow_mut <Tree'0.t_Tree t_K'0 t_V'0> {r0'0}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_16 <- _ret' ] 
                -{inv'5 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 = delete_rec'0 {_16} {key} (fun (_ret':Option'0.t_Option (t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) -> is_red'0 {r0'0} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1))
      | s1 = bb10 ]
      
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_21 <- Color'0.C_Black ] s1
      | s1 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            Tree'0.t_Tree <t_K'0> <t_V'0> {r0'0}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'0 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id self) 1) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_24 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &self <- { self with current = Map'0.C_Map (Tree'0.C_Tree _ret'.final) ; } ] 
                    s2)))
      | s2 = as_mut'0 {_24}
          (fun (_ret':Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0))) ->  [ &_23 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = unwrap'0 {_23} (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_22 <- _ret' ] s1) | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {_22.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_22 <- { _22 with current = Node'0.C_Node rleft'0 _21 rkey'0 rval'0 rright'0 ; } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 _22} s2
      | s2 = -{resolve'2 _22}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
      
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & self : borrowed (Map'0.t_Map t_K'0 t_V'0) = self
    | & key : t_K'0 = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & _8 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _11 : bool = any_l ()
    | & _13 : Color'0.t_Color = any_l ()
    | & r : Option'0.t_Option (t_K'0, t_V'0) = any_l ()
    | & _16 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Color'0.t_Color = any_l ()
    | & _22 : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _23 : Option'0.t_Option (borrowed (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & _24 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l () ]
    
    [ return' (result:Option'0.t_Option (t_K'0, t_V'0))-> {[@expl:postcondition] [%#sred_black_tree5] inv'7 result}
      {[@expl:postcondition] [%#sred_black_tree4] view'1 self.final
      = Map.set (view'0 self) (deep_model'1 key) (Option'0.C_None)}
      {[@expl:postcondition] [%#sred_black_tree3] match result with
        | Option'0.C_Some (k, v) -> deep_model'0 k = deep_model'1 key
        /\ Map.get (view'0 self) (deep_model'1 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (view'0 self) (deep_model'1 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__get [#"red_black_tree.rs" 889 4 889 44] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 890 8 890 53
  let%span sred_black_tree1 = "red_black_tree.rs" 893 20 893 29
  let%span sred_black_tree2 = "red_black_tree.rs" 894 20 894 40
  let%span sred_black_tree3 = "red_black_tree.rs" 893 8 893 31
  let%span sred_black_tree4 = "red_black_tree.rs" 889 16 889 20
  let%span sred_black_tree5 = "red_black_tree.rs" 889 22 889 25
  let%span sred_black_tree6 = "red_black_tree.rs" 885 14 888 5
  let%span sred_black_tree7 = "red_black_tree.rs" 889 34 889 44
  let%span sred_black_tree8 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree9 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree10 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree11 = "red_black_tree.rs" 235 12 241 13
  let%span smodel12 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span sred_black_tree13 = "red_black_tree.rs" 37 12 41 13
  let%span scmp14 = "../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 91 8 91 22
  let%span sred_black_tree16 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree17 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree18 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree19 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree20 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree21 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree22 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree23 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree24 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant25 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sred_black_tree39 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree40 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree41 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree42 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree43 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree44 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree45 = "red_black_tree.rs" 368 20 368 61
  let%span sboxed46 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sred_black_tree47 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree48 = "red_black_tree.rs" 327 12 335 13
  
  type t_V'0
  
  predicate inv'9 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'7 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'5 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'11 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'5 left /\ inv'7 key /\ inv'9 val' /\ inv'5 right
    end
  
  predicate invariant'5 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed46] inv'11 self
  
  predicate inv'10 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'8 x] . inv'8 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'10 a_0
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree42] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree44] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree41] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree48] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree47] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree45] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree43] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  type t_DeepModelTy'0
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree22] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree40] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'4 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree39] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'6 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'5 a_0
    end)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Tree'0.C_Tree node -> inv'8 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'3 (self : t_V'0) =
    [%#sinvariant25] inv'9 self
  
  predicate inv'4 (_1 : t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_V'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord38] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord36] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord37] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord34] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord35] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord31] cmp_log'0 x y
  = o)  -> ([%#sord32] cmp_log'0 y z = o)  -> ([%#sord33] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord30] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord29] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord28] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord27] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord26] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option t_V'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option t_V'0 [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant'2 (self : t_K'0) =
    [%#sinvariant25] inv'7 self
  
  predicate inv'2 (_1 : t_K'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_K'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sinvariant25] inv'6 self
  
  predicate inv'1 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant25] inv'5 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree24] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree16] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'2 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree23] view'1 (T_red_black_tree__Map.t_Map__0 self)
  
  function view'0 (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel15] view'2 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#scmp14] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel12] deep_model'1 self
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree17] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree21] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree19] bst_invariant'0 self)
   -> ([%#sred_black_tree20] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree10] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree8] bst_invariant'0 self)
   -> ([%#sred_black_tree9] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'1 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec get (self:Map'0.t_Map t_K'0 t_V'0) (key:t_K'0) (return'  (ret:Option'0.t_Option t_V'0))= {[%#sred_black_tree5] inv'2 key}
    {[%#sred_black_tree4] inv'1 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self} (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->  [ &tree <- r0'0 ] s1)
      | s1 = bb2 ]
      
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant] [%#sred_black_tree3] forall v : t_V'0 . has_mapping'0 (T_red_black_tree__Map.t_Map__0 self) (deep_model'0 key) v
        = has_mapping'0 tree (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree2] bst_invariant'0 tree}
        {[@expl:loop invariant] [%#sred_black_tree1] inv'0 tree}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {tree}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->  [ &_13 <- rnode'0 ] s1)
          | s1 = any
            [ br0 -> {_13 = Option'0.C_None } (! bb14)
            | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_13 = Option'0.C_Some a} (! bb4) ]
             ]
          
        | bb4 = bb5
        | bb5 = s0
          [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_13}
              (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->  [ &node <- r0'0 ] s1)
          | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_19 <- rkey'0 ] 
                s2)
          | s2 = cmp'0 {key} {_19} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_16 <- _ret' ] s3)
          | s3 = bb6 ]
          
        | bb6 = any
          [ br0 -> {_16 = Ordering'0.C_Less } (! bb8)
          | br1 -> {_16 = Ordering'0.C_Equal } (! bb9)
          | br2 -> {_16 = Ordering'0.C_Greater } (! bb10) ]
          
        | bb10 = s0
          [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_27 <- rright'0 ] 
                s1)
          | s1 =  [ &tree <- _27 ] s2
          | s2 = bb13 ]
          
        | bb8 = bb11
        | bb11 = s0
          [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_22 <- rleft'0 ] 
                s1)
          | s1 =  [ &tree <- _22 ] s2
          | s2 = bb13 ]
          
        | bb13 = bb2 ]
         ]
      
    | bb14 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb15 ] 
    | bb9 = bb12
    | bb12 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
             [ &_25 <- rval'0 ] 
            s1)
      | s1 =  [ &_0 <- Option'0.C_Some _25 ] s2
      | s2 = bb15 ]
      
    | bb15 = return' {_0} ]
    )
    [ & _0 : Option'0.t_Option t_V'0 = any_l ()
    | & self : Map'0.t_Map t_K'0 t_V'0 = self
    | & key : t_K'0 = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & tree : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _13 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & node : Node'0.t_Node t_K'0 t_V'0 = any_l ()
    | & _16 : Ordering'0.t_Ordering = any_l ()
    | & _19 : t_K'0 = any_l ()
    | & _22 : Tree'0.t_Tree t_K'0 t_V'0 = any_l ()
    | & _25 : t_V'0 = any_l ()
    | & _27 : Tree'0.t_Tree t_K'0 t_V'0 = any_l () ]
    
    [ return' (result:Option'0.t_Option t_V'0)-> {[@expl:postcondition] [%#sred_black_tree7] inv'3 result}
      {[@expl:postcondition] [%#sred_black_tree6] match result with
        | Option'0.C_Some v -> Map.get (view'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (view'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi1501420612169366910__get_mut [#"red_black_tree.rs" 910 4 910 56] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 911 8 911 53
  let%span sred_black_tree1 = "red_black_tree.rs" 914 23 914 41
  let%span sred_black_tree2 = "red_black_tree.rs" 916 20 916 29
  let%span sred_black_tree3 = "red_black_tree.rs" 917 20 917 40
  let%span sred_black_tree4 = "red_black_tree.rs" 918 20 918 43
  let%span sred_black_tree5 = "red_black_tree.rs" 919 20 919 42
  let%span sred_black_tree6 = "red_black_tree.rs" 916 8 916 31
  let%span sred_black_tree7 = "red_black_tree.rs" 910 24 910 28
  let%span sred_black_tree8 = "red_black_tree.rs" 910 30 910 33
  let%span sred_black_tree9 = "red_black_tree.rs" 906 14 909 5
  let%span sred_black_tree10 = "red_black_tree.rs" 910 42 910 56
  let%span sred_black_tree11 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree12 = "red_black_tree.rs" 106 4 106 80
  let%span sred_black_tree13 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree14 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree15 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree16 = "red_black_tree.rs" 297 12 303 13
  let%span smodel17 = "../../../creusot-contracts/src/model.rs" 82 8 82 28
  let%span sred_black_tree18 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree19 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree20 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree21 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree22 = "red_black_tree.rs" 263 12 268 13
  let%span scmp23 = "../../../creusot-contracts/src/std/cmp.rs" 50 26 50 85
  let%span smodel24 = "../../../creusot-contracts/src/model.rs" 109 8 109 22
  let%span sred_black_tree25 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree26 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree27 = "red_black_tree.rs" 67 4 68 93
  let%span sred_black_tree28 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree29 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree30 = "red_black_tree.rs" 85 4 85 94
  let%span sred_black_tree31 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree32 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree33 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree34 = "red_black_tree.rs" 311 20 311 102
  let%span sresolve35 = "../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span sred_black_tree36 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant37 = "../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span sboxed38 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord40 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord41 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord42 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord43 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord44 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord45 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord46 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord47 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord48 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord49 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord51 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sinvariant52 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree53 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree54 = "red_black_tree.rs" 387 12 387 59
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'0 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  use T_red_black_tree__Node as Node'0
  
  use T_core__option__Option as Option'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree21] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree34] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree16] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree20] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree19] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree33] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree15] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  type t_DeepModelTy'0
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree18] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree32] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'1 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'1 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree14] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree54] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'7 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree53] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'12 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'12 x] . inv'12 x
  = (invariant'7 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'0 a_0
    end)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'13 (_1 : t_K'0)
  
  predicate inv'11 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'11 x] . inv'11 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'0 left /\ inv'13 key /\ inv'6 val' /\ inv'0 right
    end
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord51] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord49] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord50] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord47] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord48] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord44] cmp_log'0 x y
  = o)  -> ([%#sord45] cmp_log'0 y z = o)  -> ([%#sord46] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord43] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord42] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord41] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord40] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord39] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use prelude.prelude.Borrow
  
  predicate inv'7 (_1 : borrowed t_V'0)
  
  use T_core__option__Option as Option'0
  
  predicate inv'10 (_1 : Option'0.t_Option (borrowed t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : Option'0.t_Option (borrowed t_V'0) [inv'10 x] . inv'10 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'7 a_0
    end
  
  predicate invariant'6 (self : t_K'0) =
    [%#sinvariant52] inv'13 self
  
  predicate inv'9 (_1 : t_K'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_K'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'5 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sinvariant37] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'8 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0))
  
  axiom inv_axiom'7 [@rewrite] : forall x : borrowed (Map'0.t_Map t_K'0 t_V'0) [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate invariant'4 (self : borrowed t_V'0) =
    [%#sinvariant37] inv'6 self.current /\ inv'6 self.final
  
  axiom inv_axiom'6 [@rewrite] : forall x : borrowed t_V'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  predicate invariant'3 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sinvariant37] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)))
  
  axiom inv_axiom'5 [@rewrite] : forall x : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) [inv'5 x] . inv'5 x
  = invariant'3 x
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'2 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sinvariant37] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'4 [@rewrite] : forall x : borrowed (Node'0.t_Node t_K'0 t_V'0) [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed38] inv'11 self
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  predicate invariant'0 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sinvariant37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (Tree'0.t_Tree t_K'0 t_V'0) [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'0 x] . inv'0 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use map.Map
  
  use T_core__option__Option as Option'0
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree36] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree26] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree25] view'2 (T_red_black_tree__Map.t_Map__0 self)
  
  use map.Map
  
  function view'0 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0) =
    [%#smodel24] view'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'9 (self : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'4 (_1 : borrowed (Map'0.t_Map t_K'0 t_V'0)) =
    resolve'9 _1
  
  predicate resolve'8 (self : borrowed t_V'0) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'3 (_1 : borrowed t_V'0) =
    resolve'8 _1
  
  predicate resolve'7 (self : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) =
    resolve'7 _1
  
  predicate resolve'6 (self : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'6 _1
  
  predicate resolve'5 (self : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    [%#sresolve35] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (Tree'0.t_Tree t_K'0 t_V'0)) =
    resolve'5 _1
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:Ordering'0.t_Ordering))= {[@expl:precondition] inv'9 other}
    {[@expl:precondition] inv'9 self}
    any
    [ return' (result:Ordering'0.t_Ordering)-> {[%#scmp23] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
    
  
  use T_red_black_tree__CP as CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : CP'0.t_CP) (tree : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree22] match self with
      | CP'0.C_CPL color -> color'0 tree = color /\ color_invariant'0 tree
      | CP'0.C_CPN color l r -> exists node : Node'0.t_Node t_K'0 t_V'0 . T_red_black_tree__Tree.t_Tree__node tree
      = Option'0.C_Some node
      /\ T_red_black_tree__Node.t_Node__color node = color
      /\ match_t'0 l (T_red_black_tree__Node.t_Node__left node)
      /\ match_t'0 r (T_red_black_tree__Node.t_Node__right node)
      end
  
  use prelude.prelude.Snapshot
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel17] deep_model'1 self
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree28] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . [%#sred_black_tree27] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = Option'0.C_Some v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree31] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> ()
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (Option'0.C_Some val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0), k : t_DeepModelTy'0 . ([%#sred_black_tree29] bst_invariant'0 self)
   -> ([%#sred_black_tree30] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = Option'0.C_Some v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) : ()
    
   =
    [%#sred_black_tree13] let _ = model_acc_has_mapping'0 self (Const.const (Option'0.C_None)) k in has_mapping_model_acc'0 self (Const.const (Option'0.C_None)) k
  
  axiom has_mapping_model'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0, k : t_DeepModelTy'0 . ([%#sred_black_tree11] bst_invariant'0 self)
   -> ([%#sred_black_tree12] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = Option'0.C_Some v))
  
  meta "compute_max_steps" 1000000
  
  let rec get_mut (self:borrowed (Map'0.t_Map t_K'0 t_V'0)) (key:t_K'0) (return'  (ret:Option'0.t_Option (borrowed t_V'0)))= {[%#sred_black_tree8] inv'9 key}
    {[%#sred_black_tree7] inv'8 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] Snapshot.new () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Map'0.t_Map <t_K'0> <t_V'0> {self.current}
          (fun (r0'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'0 r0'0}
            Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &tree <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self <- { self with current = Map'0.C_Map _ret'.final ; } ] 
                s1))
      | s1 =  [ &old_tree <- [%#sred_black_tree1] Snapshot.new tree ] s2
      | s2 = bb2 ]
      
    | bb2 = bb3
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant] [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 tree.current k v
        = has_mapping'0 tree.final k v
         -> has_mapping'0 (Snapshot.inner old_tree).current k v = has_mapping'0 (Snapshot.inner old_tree).final k v}
        {[@expl:loop invariant] [%#sred_black_tree6] match_t'0 (CP'0.C_CPL (color'0 tree.current)) tree.final
         -> match_t'0 (CP'0.C_CPL (Color'0.C_Black)) (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] height'0 tree.current = height'0 tree.final
        /\ height_invariant'0 tree.final  -> height_invariant'0 (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] (forall k : t_DeepModelTy'0, v : t_V'0 . k = deep_model'0 key
        \/ has_mapping'0 tree.current k v = has_mapping'0 tree.final k v)
         -> bst_invariant'0 tree.final  -> bst_invariant'0 (Snapshot.inner old_tree).final}
        {[@expl:loop invariant] [%#sred_black_tree6] forall v : t_V'0 . has_mapping'0 tree.current (deep_model'0 key) v
        = has_mapping'0 (Snapshot.inner old_tree).current (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree6] forall v : t_V'0 . has_mapping'0 tree.final (deep_model'0 key) v
        = has_mapping'0 (Snapshot.inner old_tree).final (deep_model'0 key) v}
        {[@expl:loop invariant] [%#sred_black_tree5] color_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree4] height_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree3] bst_invariant'0 tree.current}
        {[@expl:loop invariant] [%#sred_black_tree2] inv'1 tree}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = Tree'0.t_Tree <t_K'0> <t_V'0> {tree.current}
              (fun (rnode'0:Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) ->
                {inv'2 rnode'0}
                Borrow.borrow_final
                  <Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)>
                  {rnode'0}
                  {Borrow.inherit_id (Borrow.get_id tree) 1}
                  (fun (_ret':borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))) ->
                     [ &_22 <- _ret' ] 
                    -{inv'2 _ret'.final}-
                     [ &tree <- { tree with current = Tree'0.C_Tree _ret'.final ; } ] 
                    s1))
          | s1 = any
            [ br0 -> {_22.current = Option'0.C_None } (! bb15)
            | br1 (a:Node'0.t_Node t_K'0 t_V'0)-> {_22.current = Option'0.C_Some a} (! bb5) ]
             ]
          
        | bb5 = bb6
        | bb6 = s0
          [ s0 = Option'0.v_Some <Node'0.t_Node t_K'0 t_V'0> {_22.current}
              (fun (r0'0:Node'0.t_Node t_K'0 t_V'0) ->
                {inv'3 r0'0}
                Borrow.borrow_final <Node'0.t_Node t_K'0 t_V'0> {r0'0} {Borrow.inherit_id (Borrow.get_id _22) 1}
                  (fun (_ret':borrowed (Node'0.t_Node t_K'0 t_V'0)) ->
                     [ &node <- _ret' ] 
                    -{inv'3 _ret'.final}-
                     [ &_22 <- { _22 with current = Option'0.C_Some _ret'.final ; } ] 
                    s1))
          | s1 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                 [ &_28 <- rkey'0 ] 
                s2)
          | s2 = cmp'0 {key} {_28} (fun (_ret':Ordering'0.t_Ordering) ->  [ &_25 <- _ret' ] s3)
          | s3 = bb7 ]
          
        | bb7 = any
          [ br0 -> {_25 = Ordering'0.C_Less } (! bb9)
          | br1 -> {_25 = Ordering'0.C_Equal } (! bb10)
          | br2 -> {_25 = Ordering'0.C_Greater } (! bb11) ]
          
        | bb11 = s0
          [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                {inv'0 rright'0}
                Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {rright'0} {Borrow.inherit_id (Borrow.get_id node) 5}
                  (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                     [ &_36 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 rval'0 _ret'.final ; } ] 
                    s1))
          | s1 = {inv'0 _36.current}
            Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_36.current} {Borrow.get_id _36}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_35 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_36 <- { _36 with current = _ret'.final ; } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _35 ] s5
          | s5 = {[@expl:type invariant] inv'1 _36} s6
          | s6 = -{resolve'0 _36}- s7
          | s7 = bb14 ]
          
        | bb9 = bb12
        | bb12 = s0
          [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
              (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
                {inv'0 rleft'0}
                Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {rleft'0} {Borrow.inherit_id (Borrow.get_id node) 1}
                  (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                     [ &_31 <- _ret' ] 
                    -{inv'0 _ret'.final}-
                     [ &node <- { node with current = Node'0.C_Node _ret'.final rcolor'0 rkey'0 rval'0 rright'0 ; } ] 
                    s1))
          | s1 = {inv'0 _31.current}
            Borrow.borrow_final <Tree'0.t_Tree t_K'0 t_V'0> {_31.current} {Borrow.get_id _31}
              (fun (_ret':borrowed (Tree'0.t_Tree t_K'0 t_V'0)) ->
                 [ &_30 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_31 <- { _31 with current = _ret'.final ; } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _30 ] s5
          | s5 = {[@expl:type invariant] inv'1 _31} s6
          | s6 = -{resolve'0 _31}- s7
          | s7 = bb14 ]
          
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'4 node} s1
          | s1 = -{resolve'1 node}- s2
          | s2 = {[@expl:type invariant] inv'5 _22} s3
          | s3 = -{resolve'2 _22}- s4
          | s4 = bb3 ]
           ]
         ]
      
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'5 _22} s1
      | s1 = -{resolve'2 _22}- s2
      | s2 =  [ &_0 <- Option'0.C_None ] s3
      | s3 = bb16 ]
      
    | bb10 = bb13
    | bb13 = s0
      [ s0 = Node'0.t_Node <t_K'0> <t_V'0> {node.current}
          (fun (rleft'0:Tree'0.t_Tree t_K'0 t_V'0) (rcolor'0:Color'0.t_Color) (rkey'0:t_K'0) (rval'0:t_V'0) (rright'0:Tree'0.t_Tree t_K'0 t_V'0) ->
            {inv'6 rval'0}
            Borrow.borrow_final <t_V'0> {rval'0} {Borrow.inherit_id (Borrow.get_id node) 4}
              (fun (_ret':borrowed t_V'0) ->
                 [ &_34 <- _ret' ] 
                -{inv'6 _ret'.final}-
                 [ &node <- { node with current = Node'0.C_Node rleft'0 rcolor'0 rkey'0 _ret'.final rright'0 ; } ] 
                s1))
      | s1 = {inv'6 _34.current}
        Borrow.borrow_final <t_V'0> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed t_V'0) ->
             [ &_33 <- _ret' ] 
            -{inv'6 _ret'.final}-
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s2)
      | s2 =  [ &_0 <- Option'0.C_Some _33 ] s3
      | s3 = {[@expl:type invariant] inv'7 _34} s4
      | s4 = -{resolve'3 _34}- s5
      | s5 = {[@expl:type invariant] inv'4 node} s6
      | s6 = -{resolve'1 node}- s7
      | s7 = {[@expl:type invariant] inv'5 _22} s8
      | s8 = -{resolve'2 _22}- s9
      | s9 = bb16 ]
      
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'1 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'8 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = return' {_0} ]
       ]
    )
    [ & _0 : Option'0.t_Option (borrowed t_V'0) = any_l ()
    | & self : borrowed (Map'0.t_Map t_K'0 t_V'0) = self
    | & key : t_K'0 = key
    | & _5 : Snapshot.snap_ty () = any_l ()
    | & tree : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & old_tree : Snapshot.snap_ty (borrowed (Tree'0.t_Tree t_K'0 t_V'0)) = any_l ()
    | & _22 : borrowed (Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) = any_l ()
    | & node : borrowed (Node'0.t_Node t_K'0 t_V'0) = any_l ()
    | & _25 : Ordering'0.t_Ordering = any_l ()
    | & _28 : t_K'0 = any_l ()
    | & _30 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _31 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _33 : borrowed t_V'0 = any_l ()
    | & _34 : borrowed t_V'0 = any_l ()
    | & _35 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l ()
    | & _36 : borrowed (Tree'0.t_Tree t_K'0 t_V'0) = any_l () ]
    
    [ return' (result:Option'0.t_Option (borrowed t_V'0))-> {[@expl:postcondition] [%#sred_black_tree10] inv'10 result}
      {[@expl:postcondition] [%#sred_black_tree9] match result with
        | Option'0.C_Some v -> Map.get (view'0 self) (deep_model'0 key) = Option'0.C_Some (v.current)
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 key) (Option'0.C_Some (v.final))
        | Option'0.C_None -> Map.get (view'0 self) (deep_model'0 key) = Option'0.C_None
        /\ view'1 self.final = view'0 self
        end}
      (! return' {result}) ]
    
end
module M_red_black_tree__qyi11959472507597060150__clone__refines [#"red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 12 9 12 14
  
  use T_red_black_tree__Color as Color'0
  
  predicate inv'1 (_1 : Color'0.t_Color)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Color'0.t_Color [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : Color'0.t_Color)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Color'0.t_Color [inv'0 x] . inv'0 x = true
  
  goal refines : [%#sred_black_tree0] forall self : Color'0.t_Color . inv'0 self
   -> (forall result : Color'0.t_Color . result = self  -> inv'1 result /\ result = self)
end
module M_red_black_tree__qyi14787627995992352676__resolve_coherence__refines [#"red_black_tree.rs" 187 4 187 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 187 4 187 31
  let%span sred_black_tree1 = "red_black_tree.rs" 178 8 180 9
  let%span sred_black_tree2 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve3 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sresolve5 = "../../../creusot-contracts/src/resolve.rs" 55 8 55 23
  let%span sred_black_tree6 = "red_black_tree.rs" 194 8 196 9
  let%span sred_black_tree7 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree8 = "red_black_tree.rs" 138 8 141 9
  let%span sboxed9 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  predicate inv'6 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'5 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'1 left /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'2 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'2 x] . inv'2 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'1 x] . inv'1 x
  = match x with
    | Tree'0.C_Tree node -> inv'2 node
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 (_1 : t_V'0)
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree2] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'0 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree8] has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'1_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree7] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'7 [#"red_black_tree.rs" 193 4 193 28] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'6 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'7 _1
  
  predicate resolve'5 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sresolve5] resolve'6 self
  
  predicate resolve'4 (_1 : Node'0.t_Node t_K'0 t_V'0) =
    resolve'5 _1
  
  predicate resolve'3 (self : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    [%#sresolve3] match self with
      | Option'0.C_Some x -> resolve'4 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'1 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0)) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Tree'0.t_Tree t_K'0 t_V'0) =
    match x with
      | Tree'0.C_Tree a -> resolve'1 a
      end
  
  goal refines : [%#sred_black_tree0] forall self : Tree'0.t_Tree t_K'0 t_V'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi16896830124134315792__resolve_coherence__refines [#"red_black_tree.rs" 203 4 203 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 203 4 203 31
  let%span sred_black_tree1 = "red_black_tree.rs" 194 8 196 9
  let%span sred_black_tree2 = "red_black_tree.rs" 135 4 136 86
  let%span sred_black_tree3 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree4 = "red_black_tree.rs" 178 8 180 9
  let%span sinvariant5 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree6 = "red_black_tree.rs" 37 12 41 13
  let%span sboxed7 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  type t_K'0
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'1 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  predicate invariant'1 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed7] inv'1 self
  
  predicate inv'6 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'6 x] . inv'6 x = invariant'1 x
  
  use T_core__option__Option as Option'0
  
  predicate inv'5 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'5 x] . inv'5 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'6 a_0
    end
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'5 node
    end
  
  predicate inv'4 (_1 : t_V'0)
  
  predicate inv'3 (_1 : t_K'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'1 x] . inv'1 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'3 key /\ inv'4 val' /\ inv'2 right
    end
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'0 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'2 (_1 : t_V'0)
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree6] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : Node'0.t_Node t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree3] has_mapping'1 (T_red_black_tree__Node.t_Node__left self) k v
    \/ has_mapping'1 (T_red_black_tree__Node.t_Node__right self) k v
    \/ k = deep_model'0 (T_red_black_tree__Node.t_Node__key self) /\ v = T_red_black_tree__Node.t_Node__val self
  
  axiom has_mapping'0_spec : forall self : Node'0.t_Node t_K'0 t_V'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree2] forall node : Node'0.t_Node t_K'0 t_V'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 (Tree'0.C_Tree (Option'0.C_Some node)) k v
  
  predicate resolve'0 [#"red_black_tree.rs" 193 4 193 28] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  use T_red_black_tree__Color as Color'0
  
  predicate resolve'4 (_1 : Color'0.t_Color) =
    true
  
  predicate resolve'3 (_1 : t_K'0)
  
  predicate resolve'5 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree4] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'5 _1
  
  predicate structural_resolve'0 (x : Node'0.t_Node t_K'0 t_V'0) =
    match x with
      | Node'0.C_Node a b c d e -> resolve'1 e /\ resolve'2 d /\ resolve'3 c /\ resolve'4 b /\ resolve'1 a
      end
  
  goal refines : [%#sred_black_tree0] forall self : Node'0.t_Node t_K'0 t_V'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi10312951825188598006__resolve_coherence__refines [#"red_black_tree.rs" 793 4 793 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 793 4 793 31
  let%span sred_black_tree1 = "red_black_tree.rs" 785 8 785 70
  let%span sred_black_tree2 = "red_black_tree.rs" 761 8 761 29
  let%span sred_black_tree3 = "red_black_tree.rs" 178 8 180 9
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span sred_black_tree5 = "red_black_tree.rs" 170 20 170 54
  let%span sresolve6 = "../../../creusot-contracts/src/resolve.rs" 69 8 72 9
  let%span sred_black_tree7 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree8 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree9 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree10 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree11 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree12 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree13 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree14 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree15 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree16 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree17 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree18 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree19 = "red_black_tree.rs" 327 12 335 13
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 15 14 15 64
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 25 14 25 61
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 35 14 35 61
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 45 14 45 64
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 49 14 49 45
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 53 15 53 32
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 54 15 54 32
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 55 14 55 31
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 59 15 59 45
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 60 14 60 47
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 64 15 64 48
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 65 14 65 44
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 69 14 69 59
  let%span sboxed33 = "../../../creusot-contracts/src/std/boxed.rs" 28 8 28 18
  
  type t_V'0
  
  predicate inv'7 (_1 : t_V'0)
  
  type t_K'0
  
  predicate inv'6 (_1 : t_K'0)
  
  use T_red_black_tree__Tree as Tree'0
  
  predicate inv'2 (_1 : Tree'0.t_Tree t_K'0 t_V'0)
  
  use T_red_black_tree__Node as Node'0
  
  predicate inv'5 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'5 x] . inv'5 x
  = match x with
    | Node'0.C_Node left color key val' right -> inv'2 left /\ inv'6 key /\ inv'7 val' /\ inv'2 right
    end
  
  predicate invariant'2 (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : Node'0.t_Node t_K'0 t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Node'0.t_Node t_K'0 t_V'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  type t_DeepModelTy'0
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (_2 : t_DeepModelTy'0) : Ordering'0.t_Ordering
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord32] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord30] cmp_log'0 x y
  = Ordering'0.C_Greater)  -> ([%#sord31] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord28] cmp_log'0 x y
  = Ordering'0.C_Less)  -> ([%#sord29] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : Ordering'0.t_Ordering . ([%#sord25] cmp_log'0 x y
  = o)  -> ([%#sord26] cmp_log'0 y z = o)  -> ([%#sord27] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord24] cmp_log'0 x x = Ordering'0.C_Equal
  
  function gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord23] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  function ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  function lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  function le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0) : bool
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option (Node'0.t_Node t_K'0 t_V'0) [inv'3 x] . inv'3 x
  = match x with
    | Option'0.C_None -> true
    | Option'0.C_Some a_0 -> inv'4 a_0
    end
  
  axiom inv_axiom'2 [@rewrite] : forall x : Tree'0.t_Tree t_K'0 t_V'0 [inv'2 x] . inv'2 x
  = match x with
    | Tree'0.C_Tree node -> inv'3 node
    end
  
  use T_red_black_tree__Color as Color'0
  
  use T_red_black_tree__Tree as T_red_black_tree__Tree
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : Tree'0.t_Tree t_K'0 t_V'0) : Color'0.t_Color =
    [%#sred_black_tree12] match T_red_black_tree__Tree.t_Tree__node self with
      | Option'0.C_Some (Node'0.C_Node _ color _ _ _) -> color
      | _ -> Color'0.C_Black
      end
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree15] color'0 (T_red_black_tree__Node.t_Node__right self) = Color'0.C_Black
    /\ (T_red_black_tree__Node.t_Node__color self = Color'0.C_Black
    \/ color'0 (T_red_black_tree__Node.t_Node__left self) = Color'0.C_Black)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree11] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  use prelude.prelude.Int
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : Tree'0.t_Tree t_K'0 t_V'0) : int =
    [%#sred_black_tree19] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> 0
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left color _ _ _)) -> match color with
        | Color'0.C_Red -> height'0 left
        | Color'0.C_Black -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : Tree'0.t_Tree t_K'0 t_V'0 . [%#sred_black_tree18] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree17] height'0 (T_red_black_tree__Node.t_Node__left self)
    = height'0 (T_red_black_tree__Node.t_Node__right self)
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree14] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  use T_red_black_tree__Node as T_red_black_tree__Node
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : Tree'0.t_Tree t_K'0 t_V'0) (k : t_DeepModelTy'0) (v : t_V'0)
    
   =
    [%#sred_black_tree7] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> false
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : Node'0.t_Node t_K'0 t_V'0) =
    [%#sred_black_tree16] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__left self) k v
     -> lt_log'0 k (deep_model'0 (T_red_black_tree__Node.t_Node__key self)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 (T_red_black_tree__Node.t_Node__right self) k v
     -> lt_log'0 (deep_model'0 (T_red_black_tree__Node.t_Node__key self)) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree13] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> true
      | Tree'0.C_Tree (Option'0.C_Some node) -> let Node'0.C_Node left _ _ _ right = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree10] bst_invariant'0 self /\ height_invariant'0 self
  
  use T_red_black_tree__Map as T_red_black_tree__Map
  
  use T_red_black_tree__Map as Map'0
  
  predicate invariant'1 [#"red_black_tree.rs" 771 4 771 30] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree9] internal_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color_invariant'0 (T_red_black_tree__Map.t_Map__0 self)
    /\ color'0 (T_red_black_tree__Map.t_Map__0 self) = Color'0.C_Black
  
  predicate inv'1 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | Map'0.C_Map a_0 -> inv'2 a_0
    end)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : Map'0.t_Map t_K'0 t_V'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Map'0.t_Map t_K'0 t_V'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'5 (_1 : t_V'0)
  
  use T_core__option__Option as Option'0
  
  predicate resolve'4 (self : Option'0.t_Option t_V'0) =
    [%#sresolve6] match self with
      | Option'0.C_Some x -> resolve'5 x
      | Option'0.C_None -> true
      end
  
  predicate resolve'2 (_1 : Option'0.t_Option t_V'0) =
    resolve'4 _1
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : Tree'0.t_Tree t_K'0 t_V'0) (accu : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree8] match self with
      | Tree'0.C_Tree (Option'0.C_None) -> accu
      | Tree'0.C_Tree (Option'0.C_Some (Node'0.C_Node left _ key val' right)) -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (Option'0.C_Some val') in model_acc'0 right accu2
      end
  
  use map.Const
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : Tree'0.t_Tree t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree5] model_acc'0 self (Const.const (Option'0.C_None))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : Map'0.t_Map t_K'0 t_V'0) : Map.map t_DeepModelTy'0 (Option'0.t_Option t_V'0)
    
   =
    [%#sred_black_tree2] view'1 (T_red_black_tree__Map.t_Map__0 self)
  
  predicate resolve'0 [#"red_black_tree.rs" 784 4 784 28] (self : Map'0.t_Map t_K'0 t_V'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (view'0 self) k)
  
  predicate resolve'3 [#"red_black_tree.rs" 177 4 177 28] (self : Tree'0.t_Tree t_K'0 t_V'0) =
    [%#sred_black_tree3] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : Tree'0.t_Tree t_K'0 t_V'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (x : Map'0.t_Map t_K'0 t_V'0) =
    match x with
      | Map'0.C_Map a -> resolve'1 a
      end
  
  goal refines : [%#sred_black_tree0] forall self : Map'0.t_Map t_K'0 t_V'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
