
module Borrows_NonZero_Type
  use prelude.Int
  use prelude.Int32
  type t_nonzero  =
    | C_NonZero int32
    
  let function nonzero_0 (self : t_nonzero) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_NonZero a -> a
      end
end
module Borrows_Impl0_Invariant_Stub
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero)
end
module Borrows_Impl0_Invariant_Interface
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero)
  val invariant' [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant' self }
    
end
module Borrows_Impl0_Invariant
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant' [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant' [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 27 4 27 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Borrows_NonZero_Type_Inv
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Borrows_NonZero_Type.t_nonzero
  axiom inv_t_nonzero [@rewrite] : forall self : Borrows_NonZero_Type.t_nonzero . Inv0.inv self = Invariant0.invariant' self
end
module Borrows_Impl1_New_Interface
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Borrows_NonZero_Type.t_nonzero
  val new [#"../borrows.rs" 17 4 17 30] (n : int32) : Borrows_NonZero_Type.t_nonzero
    requires {[#"../borrows.rs" 15 15 15 22] Int32.to_int n <> 0}
    ensures { [#"../borrows.rs" 16 14 16 27] Borrows_NonZero_Type.nonzero_0 result = n }
    ensures { [#"../borrows.rs" 17 26 17 30] Inv0.inv result }
    
end
module Borrows_Impl1_New
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec cfg new [#"../borrows.rs" 17 4 17 30] [@cfg:stackify] [@cfg:subregion_analysis] (n : int32) : Borrows_NonZero_Type.t_nonzero
    requires {[#"../borrows.rs" 15 15 15 22] Int32.to_int n <> 0}
    ensures { [#"../borrows.rs" 16 14 16 27] Borrows_NonZero_Type.nonzero_0 result = n }
    ensures { [#"../borrows.rs" 17 26 17 30] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Borrows_NonZero_Type.t_nonzero;
  var n : int32 = n;
  {
    goto BB0
  }
  BB0 {
    _0 <- Borrows_NonZero_Type.C_NonZero n;
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module TyInv_Borrow
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  axiom inv_borrow [@rewrite] : forall self : borrowed t . Inv0.inv self = (Inv1.inv ( * self) /\ Inv1.inv ( ^ self))
end
module Borrows_Impl1_InnerMut_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  val inner_mut [#"../borrows.rs" 23 4 23 43] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 23 26 23 30] Inv0.inv self}
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 22 14 22 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
end
module Borrows_Impl1_InnerMut
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg inner_mut [#"../borrows.rs" 23 4 23 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 23 26 23 30] Inv0.inv self}
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 22 14 22 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var self : borrowed (Borrows_NonZero_Type.t_nonzero) = self;
  var _2 : borrowed int32;
  var _5 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * self));
    self <- { self with current = (let Borrows_NonZero_Type.C_NonZero a =  * self in Borrows_NonZero_Type.C_NonZero ( ^ _5)) };
    _2 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _2) };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve0.resolve _5 };
    assume { Resolve0.resolve _2 };
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    return _0
  }
  
end
module Core_Num_Impl2_Max_Stub
  use prelude.Int
  use prelude.Int32
  val constant mAX'  : int32
end
module Core_Num_Impl2_Max
  use prelude.Int
  use prelude.Int32
  let constant mAX'  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../../creusot-contracts/src/model.rs" 98 8 98 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel_Stub
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel_Interface
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int
  val shallow_model (self : int32) : int
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Num_Impl24_ShallowModel
  use prelude.Int
  use prelude.Int32
  function shallow_model (self : int32) : int =
    Int32.to_int self
  val shallow_model (self : int32) : int
    ensures { result = shallow_model self }
    
end
module Borrows_Inc_Interface
  use prelude.Int32
  use prelude.Int
  use prelude.Borrow
  use prelude.Int
  clone Core_Num_Impl2_Max_Stub as Max0
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int
  val inc [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] ShallowModel0.shallow_model x < Int32.to_int Max0.mAX'}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x + 1 }
    
end
module Borrows_Inc
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg inc [#"../borrows.rs" 101 0 101 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] ShallowModel0.shallow_model x < Int32.to_int Max0.mAX'}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed int32 = x;
  {
    goto BB0
  }
  BB0 {
    x <- { x with current = ([#"../borrows.rs" 102 4 102 11]  * x + ([#"../borrows.rs" 102 10 102 11] (1 : int32))) };
    assume { Resolve0.resolve x };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Simple_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val simple [#"../borrows.rs" 31 0 31 30] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 29 11 29 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 30 11 30 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 31 14 31 15] Inv0.inv x}
    
end
module Borrows_Simple
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg simple [#"../borrows.rs" 31 0 31 30] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 29 11 29 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 30 11 30 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 31 14 31 15] Inv0.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x));
    x <- { x with current = (let Borrows_NonZero_Type.C_NonZero a =  * x in Borrows_NonZero_Type.C_NonZero ( ^ _6)) };
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 32 4 32 17] Inc0.inc _5);
    _5 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv0.inv x };
    assume { Resolve1.resolve x };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Hard_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val hard [#"../borrows.rs" 38 0 38 28] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 36 11 36 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 37 11 37 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 38 12 38 13] Inv0.inv x}
    
end
module Borrows_Hard
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Borrows_Impl1_InnerMut_Interface as InnerMut0 with
    predicate Inv0.inv = Inv1.inv
  let rec cfg hard [#"../borrows.rs" 38 0 38 28] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 36 11 36 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 37 11 37 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 38 12 38 13] Inv1.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  var _7 : borrowed (Borrows_NonZero_Type.t_nonzero);
  {
    goto BB0
  }
  BB0 {
    _7 <- borrow_mut ( * x);
    x <- { x with current = ( ^ _7) };
    assume { Inv0.inv ( ^ _7) };
    _6 <- ([#"../borrows.rs" 39 8 39 21] InnerMut0.inner_mut _7);
    _7 <- any borrowed (Borrows_NonZero_Type.t_nonzero);
    goto BB1
  }
  BB1 {
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 39 4 39 22] Inc0.inc _5);
    _5 <- any borrowed int32;
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv1.inv x };
    assume { Resolve1.resolve x };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module TyInv_Tuple2
  type t0
  type t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = t1
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (t0, t1)
  axiom inv_tuple2 [@rewrite] : forall self : (t0, t1) . Inv0.inv self = (let (a_0, a_1) = self in Inv1.inv a_0 /\ Inv2.inv a_1)
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 36 8 36 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Borrows_Tuple_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone Core_Num_Impl2_Max_Stub as Max0
  val tuple [#"../borrows.rs" 45 0 45 44] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 43 11 43 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 44 11 44 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 45 17 45 18] Inv0.inv x}
    
end
module Borrows_Tuple
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Borrows_NonZero_Type.t_nonzero,
    type t1 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv2.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg tuple [#"../borrows.rs" 45 0 45 44] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 43 11 43 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 44 11 44 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 45 17 45 18] Inv0.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    x <- (let (a, b) = x in (let Borrows_NonZero_Type.C_NonZero a = let (a, _) = x in a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 46 13 46 14] (0 : int32)), b));
    _6 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a)));
    x <- (let (a, b) = x in (a, { (let (_, a) = x in a) with current = (let Borrows_NonZero_Type.C_NonZero a =  * (let (_, a) = x in a) in Borrows_NonZero_Type.C_NonZero ( ^ _6)) }));
    _5 <- borrow_mut ( * _6);
    _6 <- { _6 with current = ( ^ _5) };
    _4 <- ([#"../borrows.rs" 47 4 47 20] Inc0.inc _5);
    _5 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv0.inv x };
    assume { Resolve1.resolve x };
    _0 <- ();
    return _0
  }
  
end
module Borrows_PartialMove_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone Core_Num_Impl2_Max_Stub as Max0
  val partial_move [#"../borrows.rs" 53 0 53 47] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 51 11 51 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 52 11 52 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 53 20 53 21] Inv0.inv x}
    
end
module Borrows_PartialMove
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Borrows_NonZero_Type.t_nonzero,
    type t1 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    predicate Inv2.inv = Inv2.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve1 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve2.resolve,
    predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg partial_move [#"../borrows.rs" 53 0 53 47] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 51 11 51 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 52 11 52 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 53 20 53 21] Inv0.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var a : Borrows_NonZero_Type.t_nonzero;
  var _5 : ();
  var _6 : borrowed int32;
  var _7 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    a <- (let (a, _) = x in a);
    x <- (let (a, b) = x in (any Borrows_NonZero_Type.t_nonzero, b));
    _7 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a)));
    x <- (let (a, b) = x in (a, { (let (_, a) = x in a) with current = (let Borrows_NonZero_Type.C_NonZero a =  * (let (_, a) = x in a) in Borrows_NonZero_Type.C_NonZero ( ^ _7)) }));
    _6 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _6) };
    _5 <- ([#"../borrows.rs" 55 4 55 20] Inc0.inc _6);
    _6 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _7 };
    assert { [@expl:type invariant] Inv0.inv x };
    assume { Resolve1.resolve x };
    a <- (let Borrows_NonZero_Type.C_NonZero a = a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 56 10 56 11] (0 : int32)));
    _0 <- ();
    return _0
  }
  
end
module Borrows_Destruct_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone Core_Num_Impl2_Max_Stub as Max0
  val destruct [#"../borrows.rs" 61 0 61 43] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 59 11 59 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 60 11 60 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 61 16 61 17] Inv0.inv x}
    
end
module Borrows_Destruct
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve3 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))
  clone TyInv_Tuple2 as TyInv_Tuple20 with
    type t0 = Borrows_NonZero_Type.t_nonzero,
    type t1 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv1.inv,
    axiom .
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve0 with
    type t1 = Borrows_NonZero_Type.t_nonzero,
    type t2 = borrowed (Borrows_NonZero_Type.t_nonzero),
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  let rec cfg destruct [#"../borrows.rs" 61 0 61 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 59 11 59 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 60 11 60 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 61 16 61 17] Inv0.inv x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var a : Borrows_NonZero_Type.t_nonzero;
  var b : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    a <- (let (a, _) = x in a);
    x <- (let (a, b) = x in (any Borrows_NonZero_Type.t_nonzero, b));
    b <- (let (_, a) = x in a);
    x <- (let (a, b) = x in (a, any borrowed (Borrows_NonZero_Type.t_nonzero)));
    assert { [@expl:type invariant] Inv0.inv x };
    assume { Resolve0.resolve x };
    a <- (let Borrows_NonZero_Type.C_NonZero a = a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 63 10 63 11] (0 : int32)));
    _8 <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * b));
    b <- { b with current = (let Borrows_NonZero_Type.C_NonZero a =  * b in Borrows_NonZero_Type.C_NonZero ( ^ _8)) };
    _7 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _7) };
    _6 <- ([#"../borrows.rs" 64 4 64 17] Inc0.inc _7);
    _7 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve _8 };
    assert { [@expl:type invariant] Inv1.inv b };
    assume { Resolve2.resolve b };
    _0 <- ();
    return _0
  }
  
end
module Borrows_FrozenDead_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone Core_Num_Impl2_Max_Stub as Max0
  val frozen_dead [#"../borrows.rs" 69 0 69 66] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) (y : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 67 11 67 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 68 11 68 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 69 27 69 28] Inv0.inv x}
    requires {[#"../borrows.rs" 69 47 69 48] Inv0.inv y}
    
end
module Borrows_FrozenDead
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  clone Borrows_Impl0_Invariant as Invariant0
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Borrows_NonZero_Type.t_nonzero
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (Borrows_NonZero_Type.t_nonzero)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_NonZero_Type.t_nonzero,
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    axiom .
  clone Borrows_NonZero_Type_Inv as Borrows_NonZero_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Borrows_NonZero_Type.t_nonzero
  let rec cfg frozen_dead [#"../borrows.rs" 69 0 69 66] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) (y : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 67 11 67 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 68 11 68 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 69 27 69 28] Inv1.inv x}
    requires {[#"../borrows.rs" 69 47 69 48] Inv1.inv y}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var y : borrowed (Borrows_NonZero_Type.t_nonzero) = y;
  var _a : borrowed int32;
  var _6 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _7 : ();
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    _a <- borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x));
    x <- { x with current = (let Borrows_NonZero_Type.C_NonZero a =  * x in Borrows_NonZero_Type.C_NonZero ( ^ _a)) };
    _6 <- borrow_mut ( * y);
    y <- { y with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    assert { [@expl:type invariant] Inv1.inv x };
    assume { Resolve0.resolve x };
    x <- _6;
    _6 <- any borrowed (Borrows_NonZero_Type.t_nonzero);
    assert { [@expl:type invariant] Inv1.inv x };
    assume { Resolve0.resolve x };
    _8 <- borrow_mut ( * _a);
    _a <- { _a with current = ( ^ _8) };
    _7 <- ([#"../borrows.rs" 75 4 75 11] Inc0.inc _8);
    _8 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve _a };
    _0 <- ();
    assert { [@expl:type invariant] Inv1.inv y };
    assume { Resolve0.resolve y };
    return _0
  }
  
end
module Borrows_SumTo10_Type
  use prelude.Int
  use prelude.Int32
  type t_sumto10  =
    | C_SumTo10 int32 int32
    
  let function sumto10_a (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_SumTo10 a _ -> a
      end
  let function sumto10_b (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_SumTo10 _ a -> a
      end
end
module Borrows_Impl2_Invariant_Stub
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10)
end
module Borrows_Impl2_Invariant_Interface
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10)
  val invariant' [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10) : bool
    ensures { result = invariant' self }
    
end
module Borrows_Impl2_Invariant
  use prelude.Int32
  use prelude.Int
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant' [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10) =
    [#"../borrows.rs" 87 20 87 43] Int32.to_int (Borrows_SumTo10_Type.sumto10_a self) + Int32.to_int (Borrows_SumTo10_Type.sumto10_b self) = 10
  val invariant' [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10) : bool
    ensures { result = invariant' self }
    
end
module Core_Num_Impl2_Min_Stub
  use prelude.Int
  use prelude.Int32
  val constant mIN'  : int32
end
module Core_Num_Impl2_Min
  use prelude.Int
  use prelude.Int32
  let constant mIN'  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (-2147483648 : int32)
end
module Borrows_Dec_Interface
  use prelude.Int32
  use prelude.Int
  use prelude.Borrow
  use prelude.Int
  clone Core_Num_Impl2_Min_Stub as Min0
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int
  val dec [#"../borrows.rs" 107 0 107 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 105 11 105 25] ShallowModel0.shallow_model x > Int32.to_int Min0.mIN'}
    ensures { [#"../borrows.rs" 106 10 106 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x - 1 }
    
end
module Borrows_Dec
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  use prelude.Int
  clone Core_Num_Impl2_Min as Min0
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  let rec cfg dec [#"../borrows.rs" 107 0 107 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 105 11 105 25] ShallowModel0.shallow_model x > Int32.to_int Min0.mIN'}
    ensures { [#"../borrows.rs" 106 10 106 25] Int32.to_int ( ^ x) = ShallowModel0.shallow_model x - 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed int32 = x;
  {
    goto BB0
  }
  BB0 {
    x <- { x with current = ([#"../borrows.rs" 108 4 108 11]  * x - ([#"../borrows.rs" 108 10 108 11] (1 : int32))) };
    assume { Resolve0.resolve x };
    _0 <- ();
    return _0
  }
  
end
module Borrows_SumTo10_Type_Inv
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  clone Borrows_Impl2_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Borrows_SumTo10_Type.t_sumto10
  axiom inv_t_sumto10 [@rewrite] : forall self : Borrows_SumTo10_Type.t_sumto10 . Inv0.inv self = Invariant0.invariant' self
end
module Borrows_Impl3_Foo_Interface
  use prelude.Borrow
  use prelude.Int32
  use prelude.Int
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (Borrows_SumTo10_Type.t_sumto10)
  clone Core_Num_Impl2_Max_Stub as Max0
  val foo [#"../borrows.rs" 93 4 93 25] (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : ()
    requires {[#"../borrows.rs" 92 15 92 34] Int32.to_int (Borrows_SumTo10_Type.sumto10_a ( * self)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 93 20 93 24] Inv0.inv self}
    
end
module Borrows_Impl3_Foo
  use prelude.Borrow
  use prelude.Int
  use prelude.Int32
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  clone Borrows_Impl2_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Borrows_SumTo10_Type.t_sumto10
  clone Borrows_SumTo10_Type_Inv as Borrows_SumTo10_Type_Inv0 with
    predicate Inv0.inv = Inv1.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Std1_Num_Impl24_ShallowModel as ShallowModel1
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (Borrows_SumTo10_Type.t_sumto10)
  clone TyInv_Borrow as TyInv_Borrow0 with
    type t = Borrows_SumTo10_Type.t_sumto10,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone Core_Num_Impl2_Min as Min0
  use prelude.Int
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel0 with
    type t = int32,
    type ShallowModelTy0.shallowModelTy = int,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Core_Num_Impl2_Max as Max0
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Borrows_SumTo10_Type.t_sumto10
  clone Borrows_Dec_Interface as Dec0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Min0.mIN' = Min0.mIN'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = int32
  clone Borrows_Inc_Interface as Inc0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg foo [#"../borrows.rs" 93 4 93 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : ()
    requires {[#"../borrows.rs" 92 15 92 34] Int32.to_int (Borrows_SumTo10_Type.sumto10_a ( * self)) < Int32.to_int Max0.mAX'}
    requires {[#"../borrows.rs" 93 20 93 24] Inv0.inv self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (Borrows_SumTo10_Type.t_sumto10) = self;
  var _3 : ();
  var _4 : borrowed int32;
  var _5 : borrowed int32;
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Borrows_SumTo10_Type.sumto10_a ( * self));
    self <- { self with current = (let Borrows_SumTo10_Type.C_SumTo10 a b =  * self in Borrows_SumTo10_Type.C_SumTo10 ( ^ _5) b) };
    _4 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _4) };
    _3 <- ([#"../borrows.rs" 94 8 94 24] Inc0.inc _4);
    _4 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _5 };
    _8 <- borrow_mut (Borrows_SumTo10_Type.sumto10_b ( * self));
    self <- { self with current = (let Borrows_SumTo10_Type.C_SumTo10 a b =  * self in Borrows_SumTo10_Type.C_SumTo10 a ( ^ _8)) };
    _7 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _7) };
    _6 <- ([#"../borrows.rs" 95 8 95 24] Dec0.dec _7);
    _7 <- any borrowed int32;
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve _8 };
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _0 <- ();
    return _0
  }
  
end
module Borrows_Impl0
  
end
module Borrows_Impl2
  
end
