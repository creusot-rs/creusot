
module Borrows_NonZero_Type
  use prelude.Int32
  use prelude.Int
  type t_nonzero  =
    | C_NonZero int32
    
  let function nonzero_0 (self : t_nonzero) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_NonZero a -> a
      end
end
module Borrows_Impl1_New
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv0 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : Borrows_NonZero_Type.t_nonzero . inv0 x = (invariant0 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Int32
  use prelude.Int
  let rec cfg new [#"../borrows.rs" 17 4 17 30] [@cfg:stackify] [@cfg:subregion_analysis] (n : int32) : Borrows_NonZero_Type.t_nonzero
    requires {[#"../borrows.rs" 15 15 15 22] Int32.to_int n <> 0}
    ensures { [#"../borrows.rs" 16 14 16 27] Borrows_NonZero_Type.nonzero_0 result = n }
    ensures { [#"../borrows.rs" 17 26 17 30] inv0 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Borrows_NonZero_Type.t_nonzero;
  var n : int32 = n;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 18 8 18 15] _0 <- ([#"../borrows.rs" 18 8 18 15] Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 18 13 18 14] n));
    return _0
  }
  
end
module Borrows_Impl1_InnerMut
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv1 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Borrows_NonZero_Type.t_nonzero . inv1 x = (invariant1 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Borrow
  predicate invariant0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv0 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  use prelude.Int32
  use prelude.Int
  predicate resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  let rec cfg inner_mut [#"../borrows.rs" 23 4 23 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 23 26 23 30] inv0 self}
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 22 14 22 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed int32;
  var self : borrowed (Borrows_NonZero_Type.t_nonzero) = self;
  var _2 : borrowed int32;
  var _5 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 24 8 24 19] _5 <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * self));
    [#"../borrows.rs" 24 8 24 19] self <- { self with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * self in Borrows_NonZero_Type.C_NonZero ( ^ _5)) };
    [#"../borrows.rs" 24 8 24 19] _2 <- Borrow.borrow_mut ( * _5);
    [#"../borrows.rs" 24 8 24 19] _5 <- { _5 with current =  ^ _2 };
    [#"../borrows.rs" 24 8 24 19] _0 <- Borrow.borrow_mut ( * _2);
    [#"../borrows.rs" 24 8 24 19] _2 <- { _2 with current =  ^ _0 };
    assume { resolve0 _5 };
    assume { resolve0 _2 };
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    return _0
  }
  
end
module Borrows_Inc
  use prelude.Int32
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  use prelude.Int
  use prelude.Borrow
  function shallow_model0 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model0 (self : borrowed int32) : int
    ensures { result = shallow_model0 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  let rec cfg inc [#"../borrows.rs" 101 0 101 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model0 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model0 x + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed int32 = x;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 102 4 102 11] x <- { x with current = ([#"../borrows.rs" 102 4 102 11]  * x + ([#"../borrows.rs" 102 10 102 11] [#"../borrows.rs" 102 10 102 11] (1 : int32))) };
    assume { resolve0 x };
    [#"../borrows.rs" 101 24 103 1] _0 <- ([#"../borrows.rs" 101 24 103 1] ());
    return _0
  }
  
end
module Borrows_Simple
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv1 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Borrows_NonZero_Type.t_nonzero . inv1 x = (invariant1 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Borrow
  predicate invariant0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv0 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  let rec cfg simple [#"../borrows.rs" 31 0 31 30] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 29 11 29 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int max0}
    requires {[#"../borrows.rs" 30 11 30 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 31 14 31 15] inv0 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 32 8 32 16] _6 <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x));
    [#"../borrows.rs" 32 8 32 16] x <- { x with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * x in Borrows_NonZero_Type.C_NonZero ( ^ _6)) };
    [#"../borrows.rs" 32 8 32 16] _5 <- Borrow.borrow_mut ( * _6);
    [#"../borrows.rs" 32 8 32 16] _6 <- { _6 with current =  ^ _5 };
    [#"../borrows.rs" 32 4 32 17] _4 <- ([#"../borrows.rs" 32 4 32 17] inc0 _5);
    _5 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve0 _6 };
    assert { [@expl:type invariant] inv0 x };
    assume { resolve1 x };
    [#"../borrows.rs" 31 31 34 1] _0 <- ([#"../borrows.rs" 31 31 34 1] ());
    return _0
  }
  
end
module Borrows_Hard
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv0 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use prelude.Int32
  predicate invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Borrows_NonZero_Type.t_nonzero . inv0 x = (invariant0 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  val inner_mut0 [#"../borrows.rs" 23 4 23 43] (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : borrowed int32
    requires {[#"../borrows.rs" 23 26 23 30] inv1 self}
    ensures { [#"../borrows.rs" 21 14 21 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * self)) = Int32.to_int ( * result) }
    ensures { [#"../borrows.rs" 22 14 22 38] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( ^ self)) = Int32.to_int ( ^ result) }
    
  let rec cfg hard [#"../borrows.rs" 38 0 38 28] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 36 11 36 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int max0}
    requires {[#"../borrows.rs" 37 11 37 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 38 12 38 13] inv1 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  var _7 : borrowed (Borrows_NonZero_Type.t_nonzero);
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 39 8 39 21] _7 <- Borrow.borrow_mut ( * x);
    [#"../borrows.rs" 39 8 39 21] x <- { x with current =  ^ _7 };
    assume { inv0 ( ^ _7) };
    [#"../borrows.rs" 39 8 39 21] _6 <- ([#"../borrows.rs" 39 8 39 21] inner_mut0 _7);
    _7 <- any borrowed (Borrows_NonZero_Type.t_nonzero);
    goto BB1
  }
  BB1 {
    [#"../borrows.rs" 39 8 39 21] _5 <- Borrow.borrow_mut ( * _6);
    [#"../borrows.rs" 39 8 39 21] _6 <- { _6 with current =  ^ _5 };
    [#"../borrows.rs" 39 4 39 22] _4 <- ([#"../borrows.rs" 39 4 39 22] inc0 _5);
    _5 <- any borrowed int32;
    goto BB2
  }
  BB2 {
    assume { resolve0 _6 };
    assert { [@expl:type invariant] inv1 x };
    assume { resolve1 x };
    [#"../borrows.rs" 38 29 41 1] _0 <- ([#"../borrows.rs" 38 29 41 1] ());
    return _0
  }
  
end
module Borrows_Tuple
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  use prelude.Borrow
  predicate invariant2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant2 self }
    
  predicate inv1 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv1 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv1 _x }
    
  predicate inv2 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv2 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv2 x = (inv1 ( * x) /\ inv1 ( ^ x))
  use prelude.Int32
  predicate invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : forall x : Borrows_NonZero_Type.t_nonzero . inv1 x = (invariant1 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  predicate invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)))
  val inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) . inv0 x = (let (a, b) = x in inv1 a /\ inv2 b)
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve3 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve3 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve2 (let (a, _) = self in a) /\ resolve3 (let (_, a) = self in a)
  val resolve1 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  let rec cfg tuple [#"../borrows.rs" 45 0 45 44] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 43 11 43 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int max0}
    requires {[#"../borrows.rs" 44 11 44 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 45 17 45 18] inv0 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var _4 : ();
  var _5 : borrowed int32;
  var _6 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 46 4 46 14] x <- (let (x0, x1) = x in ((let Borrows_NonZero_Type.C_NonZero x0 = let (a, _) = x in a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 46 4 46 14] [#"../borrows.rs" 46 13 46 14] (0 : int32))), x1));
    [#"../borrows.rs" 47 8 47 19] _6 <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a)));
    [#"../borrows.rs" 47 8 47 19] x <- (let (x0, x1) = x in (x0, { (let (_, a) = x in a) with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * (let (_, a) = x in a) in Borrows_NonZero_Type.C_NonZero ( ^ _6)) }));
    [#"../borrows.rs" 47 8 47 19] _5 <- Borrow.borrow_mut ( * _6);
    [#"../borrows.rs" 47 8 47 19] _6 <- { _6 with current =  ^ _5 };
    [#"../borrows.rs" 47 4 47 20] _4 <- ([#"../borrows.rs" 47 4 47 20] inc0 _5);
    _5 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve0 _6 };
    assert { [@expl:type invariant] inv0 x };
    assume { resolve1 x };
    [#"../borrows.rs" 45 45 49 1] _0 <- ([#"../borrows.rs" 45 45 49 1] ());
    return _0
  }
  
end
module Borrows_PartialMove
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  use prelude.Borrow
  predicate invariant2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant2 self }
    
  predicate inv1 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv1 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv1 _x }
    
  predicate inv2 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv2 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv2 x = (inv1 ( * x) /\ inv1 ( ^ x))
  use prelude.Int32
  predicate invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant1 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : forall x : Borrows_NonZero_Type.t_nonzero . inv1 x = (invariant1 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  predicate invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)))
  val inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) . inv0 x = (let (a, b) = x in inv1 a /\ inv2 b)
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve3 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve3 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve3 self }
    
  predicate resolve2 (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve2 (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve2 (let (a, _) = self in a) /\ resolve3 (let (_, a) = self in a)
  val resolve1 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  let rec cfg partial_move [#"../borrows.rs" 53 0 53 47] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 51 11 51 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int max0}
    requires {[#"../borrows.rs" 52 11 52 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 53 20 53 21] inv0 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var a : Borrows_NonZero_Type.t_nonzero;
  var _5 : ();
  var _6 : borrowed int32;
  var _7 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 54 16 54 19] a <- ([#"../borrows.rs" 54 16 54 19] let (a, _) = x in a);
    [#"../borrows.rs" 54 16 54 19] x <- (let (x0, x1) = x in (any Borrows_NonZero_Type.t_nonzero, x1));
    [#"../borrows.rs" 55 8 55 19] _7 <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a)));
    [#"../borrows.rs" 55 8 55 19] x <- (let (x0, x1) = x in (x0, { (let (_, a) = x in a) with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * (let (_, a) = x in a) in Borrows_NonZero_Type.C_NonZero ( ^ _7)) }));
    [#"../borrows.rs" 55 8 55 19] _6 <- Borrow.borrow_mut ( * _7);
    [#"../borrows.rs" 55 8 55 19] _7 <- { _7 with current =  ^ _6 };
    [#"../borrows.rs" 55 4 55 20] _5 <- ([#"../borrows.rs" 55 4 55 20] inc0 _6);
    _6 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve0 _7 };
    assert { [@expl:type invariant] inv0 x };
    assume { resolve1 x };
    [#"../borrows.rs" 56 4 56 11] a <- (let Borrows_NonZero_Type.C_NonZero x0 = a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 56 4 56 11] [#"../borrows.rs" 56 10 56 11] (0 : int32)));
    [#"../borrows.rs" 53 48 57 1] _0 <- ([#"../borrows.rs" 53 48 57 1] ());
    return _0
  }
  
end
module Borrows_Destruct
  use prelude.Int32
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  predicate invariant2 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant2 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv2 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Borrows_NonZero_Type.t_nonzero . inv2 x = (invariant2 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv1 x = (inv2 ( * x) /\ inv2 ( ^ x))
  predicate invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)))
  val inv0 (_x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) . inv0 x = (let (a, b) = x in inv2 a /\ inv1 b)
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve2 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve2 self }
    
  predicate resolve1 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed int32) : bool
    ensures { result = resolve1 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  predicate resolve3 (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 45 8 45 12] true
  val resolve3 (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = resolve3 self }
    
  predicate resolve0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 16 8 16 60] resolve3 (let (a, _) = self in a) /\ resolve2 (let (_, a) = self in a)
  val resolve0 (self : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : bool
    ensures { result = resolve0 self }
    
  let rec cfg destruct [#"../borrows.rs" 61 0 61 43] [@cfg:stackify] [@cfg:subregion_analysis] (x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero))) : ()
    requires {[#"../borrows.rs" 59 11 59 29] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) < Int32.to_int max0}
    requires {[#"../borrows.rs" 60 11 60 23] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * (let (_, a) = x in a))) <> - 1}
    requires {[#"../borrows.rs" 61 16 61 17] inv0 x}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : (Borrows_NonZero_Type.t_nonzero, borrowed (Borrows_NonZero_Type.t_nonzero)) = x;
  var a : Borrows_NonZero_Type.t_nonzero;
  var b : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 62 9 62 14] a <- ([#"../borrows.rs" 62 9 62 14] let (a, _) = x in a);
    [#"../borrows.rs" 62 9 62 14] x <- (let (x0, x1) = x in (any Borrows_NonZero_Type.t_nonzero, x1));
    [#"../borrows.rs" 62 16 62 17] b <- ([#"../borrows.rs" 62 16 62 17] let (_, a) = x in a);
    [#"../borrows.rs" 62 16 62 17] x <- (let (x0, x1) = x in (x0, any borrowed (Borrows_NonZero_Type.t_nonzero)));
    assert { [@expl:type invariant] inv0 x };
    assume { resolve0 x };
    [#"../borrows.rs" 63 4 63 11] a <- (let Borrows_NonZero_Type.C_NonZero x0 = a in Borrows_NonZero_Type.C_NonZero ([#"../borrows.rs" 63 4 63 11] [#"../borrows.rs" 63 10 63 11] (0 : int32)));
    [#"../borrows.rs" 64 8 64 16] _8 <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * b));
    [#"../borrows.rs" 64 8 64 16] b <- { b with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * b in Borrows_NonZero_Type.C_NonZero ( ^ _8)) };
    [#"../borrows.rs" 64 8 64 16] _7 <- Borrow.borrow_mut ( * _8);
    [#"../borrows.rs" 64 8 64 16] _8 <- { _8 with current =  ^ _7 };
    [#"../borrows.rs" 64 4 64 17] _6 <- ([#"../borrows.rs" 64 4 64 17] inc0 _7);
    _7 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve1 _8 };
    assert { [@expl:type invariant] inv1 b };
    assume { resolve2 b };
    [#"../borrows.rs" 61 44 65 1] _0 <- ([#"../borrows.rs" 61 44 65 1] ());
    return _0
  }
  
end
module Borrows_FrozenDead
  use Borrows_NonZero_Type as Borrows_NonZero_Type
  use prelude.Borrow
  predicate invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = invariant1 self }
    
  predicate inv0 (_x : Borrows_NonZero_Type.t_nonzero)
  val inv0 (_x : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = inv0 _x }
    
  predicate inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero))
  val inv1 (_x : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : borrowed (Borrows_NonZero_Type.t_nonzero) . inv1 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use prelude.Int32
  predicate invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) =
    [#"../borrows.rs" 10 20 10 32] Int32.to_int (Borrows_NonZero_Type.nonzero_0 self) <> 0
  val invariant0 [#"../borrows.rs" 9 4 9 30] (self : Borrows_NonZero_Type.t_nonzero) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Borrows_NonZero_Type.t_nonzero . inv0 x = (invariant0 x /\ match x with
    | Borrows_NonZero_Type.C_NonZero a_0 -> true
    end)
  use prelude.Int32
  use prelude.Int
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve1 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed int32) : bool
    ensures { result = resolve1 self }
    
  use prelude.Int
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  predicate resolve0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed (Borrows_NonZero_Type.t_nonzero)) : bool
    ensures { result = resolve0 self }
    
  let rec cfg frozen_dead [#"../borrows.rs" 69 0 69 66] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed (Borrows_NonZero_Type.t_nonzero)) (y : borrowed (Borrows_NonZero_Type.t_nonzero)) : ()
    requires {[#"../borrows.rs" 67 11 67 27] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) < Int32.to_int max0}
    requires {[#"../borrows.rs" 68 11 68 21] Int32.to_int (Borrows_NonZero_Type.nonzero_0 ( * x)) <> - 1}
    requires {[#"../borrows.rs" 69 27 69 28] inv1 x}
    requires {[#"../borrows.rs" 69 47 69 48] inv1 y}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed (Borrows_NonZero_Type.t_nonzero) = x;
  var y : borrowed (Borrows_NonZero_Type.t_nonzero) = y;
  var _a : borrowed int32;
  var _6 : borrowed (Borrows_NonZero_Type.t_nonzero);
  var _7 : ();
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 70 13 70 21] _a <- Borrow.borrow_mut (Borrows_NonZero_Type.nonzero_0 ( * x));
    [#"../borrows.rs" 70 13 70 21] x <- { x with current = (let Borrows_NonZero_Type.C_NonZero x0 =  * x in Borrows_NonZero_Type.C_NonZero ( ^ _a)) };
    [#"../borrows.rs" 74 8 74 9] _6 <- Borrow.borrow_mut ( * y);
    [#"../borrows.rs" 74 8 74 9] y <- { y with current =  ^ _6 };
    assume { inv0 ( ^ _6) };
    assert { [@expl:type invariant] inv1 x };
    assume { resolve0 x };
    [#"../borrows.rs" 73 4 74 9] x <- ([#"../borrows.rs" 73 4 74 9] _6);
    [#"../borrows.rs" 73 4 74 9] _6 <- any borrowed (Borrows_NonZero_Type.t_nonzero);
    assert { [@expl:type invariant] inv1 x };
    assume { resolve0 x };
    [#"../borrows.rs" 75 8 75 10] _8 <- Borrow.borrow_mut ( * _a);
    [#"../borrows.rs" 75 8 75 10] _a <- { _a with current =  ^ _8 };
    [#"../borrows.rs" 75 4 75 11] _7 <- ([#"../borrows.rs" 75 4 75 11] inc0 _8);
    _8 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve1 _a };
    [#"../borrows.rs" 69 67 76 1] _0 <- ([#"../borrows.rs" 69 67 76 1] ());
    assert { [@expl:type invariant] inv1 y };
    assume { resolve0 y };
    return _0
  }
  
end
module Borrows_SumTo10_Type
  use prelude.Int32
  use prelude.Int
  type t_sumto10  =
    | C_SumTo10 int32 int32
    
  let function sumto10_a (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_SumTo10 a _ -> a
      end
  let function sumto10_b (self : t_sumto10) : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_SumTo10 _ a -> a
      end
end
module Borrows_Dec
  use prelude.Int32
  use prelude.Int32
  use prelude.Int
  let constant min0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (-2147483648 : int32)
  use prelude.Int
  use prelude.Borrow
  function shallow_model0 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model0 (self : borrowed int32) : int
    ensures { result = shallow_model0 self }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  let rec cfg dec [#"../borrows.rs" 107 0 107 23] [@cfg:stackify] [@cfg:subregion_analysis] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 105 11 105 25] shallow_model0 x > Int32.to_int min0}
    ensures { [#"../borrows.rs" 106 10 106 25] Int32.to_int ( ^ x) = shallow_model0 x - 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var x : borrowed int32 = x;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 108 4 108 11] x <- { x with current = ([#"../borrows.rs" 108 4 108 11]  * x - ([#"../borrows.rs" 108 10 108 11] [#"../borrows.rs" 108 10 108 11] (1 : int32))) };
    assume { resolve0 x };
    [#"../borrows.rs" 107 24 109 1] _0 <- ([#"../borrows.rs" 107 24 109 1] ());
    return _0
  }
  
end
module Borrows_Impl3_Foo
  use prelude.Int
  use prelude.Int32
  use Borrows_SumTo10_Type as Borrows_SumTo10_Type
  predicate invariant1 [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10) =
    [#"../borrows.rs" 87 20 87 43] Int32.to_int (Borrows_SumTo10_Type.sumto10_a self) + Int32.to_int (Borrows_SumTo10_Type.sumto10_b self) = 10
  val invariant1 [#"../borrows.rs" 86 4 86 30] (self : Borrows_SumTo10_Type.t_sumto10) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : Borrows_SumTo10_Type.t_sumto10)
  val inv1 (_x : Borrows_SumTo10_Type.t_sumto10) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : Borrows_SumTo10_Type.t_sumto10 . inv1 x = (invariant1 x /\ match x with
    | Borrows_SumTo10_Type.C_SumTo10 a b -> true
    end)
  use prelude.Borrow
  predicate invariant0 (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant0 (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : borrowed (Borrows_SumTo10_Type.t_sumto10))
  val inv0 (_x : borrowed (Borrows_SumTo10_Type.t_sumto10)) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : borrowed (Borrows_SumTo10_Type.t_sumto10) . inv0 x = (inv1 ( * x) /\ inv1 ( ^ x))
  use prelude.Int32
  let constant max0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (2147483647 : int32)
  predicate resolve1 (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve1 (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : bool
    ensures { result = resolve1 self }
    
  use prelude.Int
  let constant min0  : int32 = [@vc:do_not_keep_trace] [@vc:sp]
    (-2147483648 : int32)
  function shallow_model1 (self : borrowed int32) : int =
    [#"../../../../../creusot-contracts/src/model.rs" 101 8 101 31] Int32.to_int ( * self)
  val shallow_model1 (self : borrowed int32) : int
    ensures { result = shallow_model1 self }
    
  val dec0 [#"../borrows.rs" 107 0 107 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 105 11 105 25] shallow_model1 x > Int32.to_int min0}
    ensures { [#"../borrows.rs" 106 10 106 25] Int32.to_int ( ^ x) = shallow_model1 x - 1 }
    
  predicate resolve0 (self : borrowed int32) =
    [#"../../../../../creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve0 (self : borrowed int32) : bool
    ensures { result = resolve0 self }
    
  val inc0 [#"../borrows.rs" 101 0 101 23] (x : borrowed int32) : ()
    requires {[#"../borrows.rs" 99 11 99 25] shallow_model1 x < Int32.to_int max0}
    ensures { [#"../borrows.rs" 100 10 100 25] Int32.to_int ( ^ x) = shallow_model1 x + 1 }
    
  let rec cfg foo [#"../borrows.rs" 93 4 93 25] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Borrows_SumTo10_Type.t_sumto10)) : ()
    requires {[#"../borrows.rs" 92 15 92 34] Int32.to_int (Borrows_SumTo10_Type.sumto10_a ( * self)) < Int32.to_int max0}
    requires {[#"../borrows.rs" 93 20 93 24] inv0 self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (Borrows_SumTo10_Type.t_sumto10) = self;
  var _3 : ();
  var _4 : borrowed int32;
  var _5 : borrowed int32;
  var _6 : ();
  var _7 : borrowed int32;
  var _8 : borrowed int32;
  {
    goto BB0
  }
  BB0 {
    [#"../borrows.rs" 94 12 94 23] _5 <- Borrow.borrow_mut (Borrows_SumTo10_Type.sumto10_a ( * self));
    [#"../borrows.rs" 94 12 94 23] self <- { self with current = (let Borrows_SumTo10_Type.C_SumTo10 x0 x1 =  * self in Borrows_SumTo10_Type.C_SumTo10 ( ^ _5) x1) };
    [#"../borrows.rs" 94 12 94 23] _4 <- Borrow.borrow_mut ( * _5);
    [#"../borrows.rs" 94 12 94 23] _5 <- { _5 with current =  ^ _4 };
    [#"../borrows.rs" 94 8 94 24] _3 <- ([#"../borrows.rs" 94 8 94 24] inc0 _4);
    _4 <- any borrowed int32;
    goto BB1
  }
  BB1 {
    assume { resolve0 _5 };
    [#"../borrows.rs" 95 12 95 23] _8 <- Borrow.borrow_mut (Borrows_SumTo10_Type.sumto10_b ( * self));
    [#"../borrows.rs" 95 12 95 23] self <- { self with current = (let Borrows_SumTo10_Type.C_SumTo10 x0 x1 =  * self in Borrows_SumTo10_Type.C_SumTo10 x0 ( ^ _8)) };
    [#"../borrows.rs" 95 12 95 23] _7 <- Borrow.borrow_mut ( * _8);
    [#"../borrows.rs" 95 12 95 23] _8 <- { _8 with current =  ^ _7 };
    [#"../borrows.rs" 95 8 95 24] _6 <- ([#"../borrows.rs" 95 8 95 24] dec0 _7);
    _7 <- any borrowed int32;
    goto BB2
  }
  BB2 {
    assume { resolve0 _8 };
    assert { [@expl:type invariant] inv0 self };
    assume { resolve1 self };
    [#"../borrows.rs" 93 26 96 5] _0 <- ([#"../borrows.rs" 93 26 96 5] ());
    return _0
  }
  
end
module Borrows_Impl0
  
end
module Borrows_Impl2
  
end
