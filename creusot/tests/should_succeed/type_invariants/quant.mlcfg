
module Quant_WithInvariant_Type
  type t_withinvariant  =
    | C_WithInvariant
    
end
module Quant_Impl0_Invariant_Stub
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  predicate invariant' [#"../quant.rs" 11 4 11 30] (self : Quant_WithInvariant_Type.t_withinvariant)
end
module Quant_Impl0_Invariant_Interface
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  predicate invariant' [#"../quant.rs" 11 4 11 30] (self : Quant_WithInvariant_Type.t_withinvariant)
  val invariant' [#"../quant.rs" 11 4 11 30] (self : Quant_WithInvariant_Type.t_withinvariant) : bool
    ensures { result = invariant' self }
    
end
module Quant_Impl0_Invariant
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  predicate invariant' [#"../quant.rs" 11 4 11 30] (self : Quant_WithInvariant_Type.t_withinvariant) =
    [#"../quant.rs" 12 8 12 12] true
  val invariant' [#"../quant.rs" 11 4 11 30] (self : Quant_WithInvariant_Type.t_withinvariant) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 40 4 40 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module Quant_WithInvariant_Type_Inv
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  axiom inv_t_withinvariant [@rewrite] : forall self : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv self = Invariant0.invariant' self
end
module Quant_Forall_Stub
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : ()
end
module Quant_Forall_Interface
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : ()
  val forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 18 0 18 50] forall x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv x -> Invariant0.invariant' x }
    ensures { result = forall' _1 }
    
  axiom forall'_spec : forall _1 : () . [#"../quant.rs" 18 0 18 50] forall x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv x -> Invariant0.invariant' x
end
module Quant_Forall
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : () =
    [#"../quant.rs" 16 0 16 6] ()
  val forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 18 0 18 50] forall x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv x -> Invariant0.invariant' x }
    ensures { result = forall' _1 }
    
  axiom forall'_spec : forall _1 : () . [#"../quant.rs" 18 0 18 50] forall x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv x -> Invariant0.invariant' x
end
module Quant_Forall_Impl
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  clone Quant_WithInvariant_Type_Inv as Quant_WithInvariant_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec ghost function forall' [#"../quant.rs" 19 0 19 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 18 0 18 50] forall x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv x -> Invariant0.invariant' x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../quant.rs" 16 0 16 6] ()
end
module Quant_Exists_Stub
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : ()
end
module Quant_Exists_Interface
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : ()
  val exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 23 0 23 42] exists _x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv _x /\ true }
    ensures { result = exists' _1 }
    
  axiom exists'_spec : forall _1 : () . [#"../quant.rs" 23 0 23 42] exists _x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv _x /\ true
end
module Quant_Exists
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  function exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : () =
    [#"../quant.rs" 21 0 21 6] ()
  val exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 23 0 23 42] exists _x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv _x /\ true }
    ensures { result = exists' _1 }
    
  axiom exists'_spec : forall _1 : () . [#"../quant.rs" 23 0 23 42] exists _x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv _x /\ true
end
module Quant_Exists_Impl
  use Quant_WithInvariant_Type as Quant_WithInvariant_Type
  clone Quant_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Quant_WithInvariant_Type.t_withinvariant
  clone Quant_WithInvariant_Type_Inv as Quant_WithInvariant_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec ghost function exists' [#"../quant.rs" 24 0 24 15] (_1 : ()) : ()
    ensures { [#"../quant.rs" 23 0 23 42] exists _x : Quant_WithInvariant_Type.t_withinvariant . Inv0.inv _x /\ true }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../quant.rs" 21 0 21 6] ()
end
module Quant_Impl0
  
end
