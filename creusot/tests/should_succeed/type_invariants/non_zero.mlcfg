
module NonZero_NonZeroU32_Type
  use prelude.Int
  use prelude.UInt32
  type t_nonzerou32  =
    | C_NonZeroU32 uint32
    
  let function nonzerou32_0 (self : t_nonzerou32) : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_NonZeroU32 a -> a
      end
end
module NonZero_Impl0_Invariant_Stub
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate invariant' [#"../non_zero.rs" 9 4 9 30] (self : NonZero_NonZeroU32_Type.t_nonzerou32)
end
module NonZero_Impl0_Invariant_Interface
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate invariant' [#"../non_zero.rs" 9 4 9 30] (self : NonZero_NonZeroU32_Type.t_nonzerou32)
  val invariant' [#"../non_zero.rs" 9 4 9 30] (self : NonZero_NonZeroU32_Type.t_nonzerou32) : bool
    ensures { result = invariant' self }
    
end
module NonZero_Impl0_Invariant
  use prelude.UInt32
  use prelude.Int
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate invariant' [#"../non_zero.rs" 9 4 9 30] (self : NonZero_NonZeroU32_Type.t_nonzerou32) =
    [#"../non_zero.rs" 10 20 10 31] UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 self) > 0
  val invariant' [#"../non_zero.rs" 9 4 9 30] (self : NonZero_NonZeroU32_Type.t_nonzerou32) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../../creusot-contracts/src/invariant.rs" 27 4 27 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module NonZero_NonZeroU32_Type_Inv
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  axiom inv_t_nonzerou32 [@rewrite] : forall self : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv self = Invariant0.invariant' self
end
module NonZero_Impl0_IsInhabited_Stub
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  function is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool
end
module NonZero_Impl0_IsInhabited_Interface
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  function is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool
  val is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool
    ensures { [#"../non_zero.rs" 16 4 16 45] exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x }
    ensures { [#"../non_zero.rs" 17 14 17 20] result }
    ensures { result = is_inhabited _1 }
    
  axiom is_inhabited_spec : forall _1 : () . ([#"../non_zero.rs" 17 14 17 20] is_inhabited _1) && ([#"../non_zero.rs" 16 4 16 45] exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x)
end
module NonZero_Impl0_IsInhabited
  use prelude.Int
  use prelude.UInt32
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant_Stub as Invariant0
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  function is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool =
    [#"../non_zero.rs" 22 8 22 37] Invariant0.invariant' (NonZero_NonZeroU32_Type.C_NonZeroU32 (1 : uint32))
  val is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool
    ensures { [#"../non_zero.rs" 16 4 16 45] exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x }
    ensures { [#"../non_zero.rs" 17 14 17 20] result }
    ensures { result = is_inhabited _1 }
    
  axiom is_inhabited_spec : forall _1 : () . ([#"../non_zero.rs" 17 14 17 20] is_inhabited _1) && ([#"../non_zero.rs" 16 4 16 45] exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x)
end
module NonZero_Impl0_IsInhabited_Impl
  use prelude.Int
  use prelude.UInt32
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec ghost function is_inhabited [#"../non_zero.rs" 18 4 20 20] (_1 : ()) : bool
    ensures { [#"../non_zero.rs" 16 4 16 45] exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x }
    ensures { [#"../non_zero.rs" 17 14 17 20] result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../non_zero.rs" 22 8 22 37] Invariant0.invariant' (NonZero_NonZeroU32_Type.C_NonZeroU32 (1 : uint32))
end
module NonZero_Impl1_New_Interface
  use prelude.UInt32
  use prelude.Int
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  val new [#"../non_zero.rs" 28 4 28 30] (n : uint32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 27 15 27 21] UInt32.to_int n > 0}
    ensures { [#"../non_zero.rs" 28 26 28 30] Inv0.inv result }
    
end
module NonZero_Impl1_New
  use prelude.Int
  use prelude.UInt32
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl0_IsInhabited as IsInhabited0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  let rec cfg new [#"../non_zero.rs" 28 4 28 30] [@cfg:stackify] [@cfg:subregion_analysis] (n : uint32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 27 15 27 21] UInt32.to_int n > 0}
    ensures { [#"../non_zero.rs" 28 26 28 30] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : NonZero_NonZeroU32_Type.t_nonzerou32;
  var n : uint32 = n;
  {
    goto BB0
  }
  BB0 {
    _0 <- NonZero_NonZeroU32_Type.C_NonZeroU32 n;
    return _0
  }
  
end
module Core_Num_Impl8_Max_Stub
  use prelude.Int
  use prelude.UInt32
  val constant mAX'  : uint32
end
module Core_Num_Impl8_Max
  use prelude.Int
  use prelude.UInt32
  let constant mAX'  : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    (4294967295 : uint32)
end
module NonZero_Impl1_Add_Interface
  use prelude.UInt32
  use prelude.Int
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone Core_Num_Impl8_Max_Stub as Max0
  val add [#"../non_zero.rs" 33 4 33 39] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 32 15 32 44] UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 self) + UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 rhs) <= UInt32.to_int Max0.mAX'}
    requires {[#"../non_zero.rs" 33 15 33 19] Inv0.inv self}
    requires {[#"../non_zero.rs" 33 21 33 24] Inv0.inv rhs}
    ensures { [#"../non_zero.rs" 33 35 33 39] Inv0.inv result }
    
end
module NonZero_Impl1_Add
  use prelude.Int
  use prelude.UInt32
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl0_IsInhabited as IsInhabited0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone Core_Num_Impl8_Max as Max0
  let rec cfg add [#"../non_zero.rs" 33 4 33 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 32 15 32 44] UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 self) + UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 rhs) <= UInt32.to_int Max0.mAX'}
    requires {[#"../non_zero.rs" 33 15 33 19] Inv0.inv self}
    requires {[#"../non_zero.rs" 33 21 33 24] Inv0.inv rhs}
    ensures { [#"../non_zero.rs" 33 35 33 39] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : NonZero_NonZeroU32_Type.t_nonzerou32;
  var self : NonZero_NonZeroU32_Type.t_nonzerou32 = self;
  var rhs : NonZero_NonZeroU32_Type.t_nonzerou32 = rhs;
  {
    goto BB0
  }
  BB0 {
    _0 <- NonZero_NonZeroU32_Type.C_NonZeroU32 ([#"../non_zero.rs" 34 13 34 27] NonZero_NonZeroU32_Type.nonzerou32_0 self + NonZero_NonZeroU32_Type.nonzerou32_0 rhs);
    return _0
  }
  
end
module NonZero_Impl1_SubPre_Stub
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate sub_pre [#"../non_zero.rs" 39 4 39 43] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32)
    
end
module NonZero_Impl1_SubPre_Interface
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate sub_pre [#"../non_zero.rs" 39 4 39 43] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32)
    
  val sub_pre [#"../non_zero.rs" 39 4 39 43] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : bool
    ensures { result = sub_pre self rhs }
    
end
module NonZero_Impl1_SubPre
  use prelude.UInt32
  use prelude.Int
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  predicate sub_pre [#"../non_zero.rs" 39 4 39 43] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32)
    
   =
    [#"../non_zero.rs" 40 20 40 36] UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 self) > UInt32.to_int (NonZero_NonZeroU32_Type.nonzerou32_0 rhs)
  val sub_pre [#"../non_zero.rs" 39 4 39 43] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : bool
    ensures { result = sub_pre self rhs }
    
end
module NonZero_Impl1_SubPreTrans_Stub
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl1_SubPre_Stub as SubPre0
  function sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    
end
module NonZero_Impl1_SubPreTrans_Interface
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl1_SubPre_Stub as SubPre0
  function sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    
  val sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    requires {[#"../non_zero.rs" 45 15 45 27] SubPre0.sub_pre a b}
    requires {[#"../non_zero.rs" 46 15 46 27] SubPre0.sub_pre b c}
    requires {[#"../non_zero.rs" 48 25 48 26] Inv0.inv a}
    requires {[#"../non_zero.rs" 48 34 48 35] Inv0.inv b}
    requires {[#"../non_zero.rs" 48 43 48 44] Inv0.inv c}
    ensures { [#"../non_zero.rs" 47 14 47 26] SubPre0.sub_pre a c }
    ensures { result = sub_pre_trans a b c }
    
  axiom sub_pre_trans_spec : forall a : NonZero_NonZeroU32_Type.t_nonzerou32, b : NonZero_NonZeroU32_Type.t_nonzerou32, c : NonZero_NonZeroU32_Type.t_nonzerou32 . ([#"../non_zero.rs" 45 15 45 27] SubPre0.sub_pre a b) -> ([#"../non_zero.rs" 46 15 46 27] SubPre0.sub_pre b c) -> ([#"../non_zero.rs" 48 25 48 26] Inv0.inv a) -> ([#"../non_zero.rs" 48 34 48 35] Inv0.inv b) -> ([#"../non_zero.rs" 48 43 48 44] Inv0.inv c) -> ([#"../non_zero.rs" 47 14 47 26] SubPre0.sub_pre a c)
end
module NonZero_Impl1_SubPreTrans
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl1_SubPre_Stub as SubPre0
  function sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    
   =
    [#"../non_zero.rs" 43 4 43 10] ()
  val sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    requires {[#"../non_zero.rs" 45 15 45 27] SubPre0.sub_pre a b}
    requires {[#"../non_zero.rs" 46 15 46 27] SubPre0.sub_pre b c}
    requires {[#"../non_zero.rs" 48 25 48 26] Inv0.inv a}
    requires {[#"../non_zero.rs" 48 34 48 35] Inv0.inv b}
    requires {[#"../non_zero.rs" 48 43 48 44] Inv0.inv c}
    ensures { [#"../non_zero.rs" 47 14 47 26] SubPre0.sub_pre a c }
    ensures { result = sub_pre_trans a b c }
    
  axiom sub_pre_trans_spec : forall a : NonZero_NonZeroU32_Type.t_nonzerou32, b : NonZero_NonZeroU32_Type.t_nonzerou32, c : NonZero_NonZeroU32_Type.t_nonzerou32 . ([#"../non_zero.rs" 45 15 45 27] SubPre0.sub_pre a b) -> ([#"../non_zero.rs" 46 15 46 27] SubPre0.sub_pre b c) -> ([#"../non_zero.rs" 48 25 48 26] Inv0.inv a) -> ([#"../non_zero.rs" 48 34 48 35] Inv0.inv b) -> ([#"../non_zero.rs" 48 43 48 44] Inv0.inv c) -> ([#"../non_zero.rs" 47 14 47 26] SubPre0.sub_pre a c)
end
module NonZero_Impl1_SubPreTrans_Impl
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl0_IsInhabited as IsInhabited0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_Impl1_SubPre as SubPre0
  let rec ghost function sub_pre_trans [#"../non_zero.rs" 48 4 48 51] (a : NonZero_NonZeroU32_Type.t_nonzerou32) (b : NonZero_NonZeroU32_Type.t_nonzerou32) (c : NonZero_NonZeroU32_Type.t_nonzerou32) : ()
    requires {[#"../non_zero.rs" 45 15 45 27] SubPre0.sub_pre a b}
    requires {[#"../non_zero.rs" 46 15 46 27] SubPre0.sub_pre b c}
    requires {[#"../non_zero.rs" 48 25 48 26] Inv0.inv a}
    requires {[#"../non_zero.rs" 48 34 48 35] Inv0.inv b}
    requires {[#"../non_zero.rs" 48 43 48 44] Inv0.inv c}
    ensures { [#"../non_zero.rs" 47 14 47 26] SubPre0.sub_pre a c }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../non_zero.rs" 43 4 43 10] ()
end
module NonZero_Impl1_Sub_Interface
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl1_SubPre_Stub as SubPre0
  val sub [#"../non_zero.rs" 52 4 52 39] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 51 15 51 32] SubPre0.sub_pre self rhs}
    requires {[#"../non_zero.rs" 52 15 52 19] Inv0.inv self}
    requires {[#"../non_zero.rs" 52 21 52 24] Inv0.inv rhs}
    ensures { [#"../non_zero.rs" 52 35 52 39] Inv0.inv result }
    
end
module NonZero_Impl1_Sub
  use prelude.Int
  use prelude.UInt32
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_Impl0_IsInhabited as IsInhabited0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone NonZero_Impl1_SubPre as SubPre0
  let rec cfg sub [#"../non_zero.rs" 52 4 52 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : NonZero_NonZeroU32_Type.t_nonzerou32) (rhs : NonZero_NonZeroU32_Type.t_nonzerou32) : NonZero_NonZeroU32_Type.t_nonzerou32
    requires {[#"../non_zero.rs" 51 15 51 32] SubPre0.sub_pre self rhs}
    requires {[#"../non_zero.rs" 52 15 52 19] Inv0.inv self}
    requires {[#"../non_zero.rs" 52 21 52 24] Inv0.inv rhs}
    ensures { [#"../non_zero.rs" 52 35 52 39] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : NonZero_NonZeroU32_Type.t_nonzerou32;
  var self : NonZero_NonZeroU32_Type.t_nonzerou32 = self;
  var rhs : NonZero_NonZeroU32_Type.t_nonzerou32 = rhs;
  {
    goto BB0
  }
  BB0 {
    _0 <- NonZero_NonZeroU32_Type.C_NonZeroU32 ([#"../non_zero.rs" 53 13 53 27] NonZero_NonZeroU32_Type.nonzerou32_0 self - NonZero_NonZeroU32_Type.nonzerou32_0 rhs);
    return _0
  }
  
end
module NonZero_Impl0
  use NonZero_NonZeroU32_Type as NonZero_NonZeroU32_Type
  clone NonZero_Impl0_Invariant as Invariant0
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = NonZero_NonZeroU32_Type.t_nonzerou32
  clone NonZero_NonZeroU32_Type_Inv as NonZero_NonZeroU32_Type_Inv0 with
    predicate Inv0.inv = Inv0.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  goal is_inhabited_refn : [#"../non_zero.rs" 18 4 20 20] forall _1' : () . forall result : bool . result /\ (exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x) -> result /\ (exists x : NonZero_NonZeroU32_Type.t_nonzerou32 . Inv0.inv x /\ Invariant0.invariant' x)
end
