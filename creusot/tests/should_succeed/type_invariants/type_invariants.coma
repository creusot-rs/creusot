
module TypeInvariants_WithInvariant_Type
  type t_withinvariant  =
    | C_WithInvariant
    
  function any_l (_ : 'b) : 'a
  let rec t_withinvariant (input:t_withinvariant) (ret  )= any
    [ good -> {C_WithInvariant  = input} (! ret) | bad -> {C_WithInvariant  <> input} {false} any ]
    
end
module TypeInvariants_Id
  use TypeInvariants_WithInvariant_Type as TypeInvariants_WithInvariant_Type
  predicate invariant'0 [#"../type_invariants.rs" 9 4 9 30] (self : TypeInvariants_WithInvariant_Type.t_withinvariant) =
    [#"../type_invariants.rs" 10 8 10 12] true
  let rec invariant'0 (self:TypeInvariants_WithInvariant_Type.t_withinvariant) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : TypeInvariants_WithInvariant_Type.t_withinvariant)
  let rec inv'0 (_x:TypeInvariants_WithInvariant_Type.t_withinvariant) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : TypeInvariants_WithInvariant_Type.t_withinvariant . inv'0 x
  = (invariant'0 x
  /\ match x with
    | TypeInvariants_WithInvariant_Type.C_WithInvariant -> true
    end)
  use prelude.Intrinsic
  let rec id (x:TypeInvariants_WithInvariant_Type.t_withinvariant) (return'  (ret:TypeInvariants_WithInvariant_Type.t_withinvariant))= {[#"../type_invariants.rs" 14 10 14 11] inv'0 x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- x ] 
        (any [ any_ (_any:TypeInvariants_WithInvariant_Type.t_withinvariant)-> (!  [ &x <- _any ] s1) ] )
      | s1 = return' {_0} ]
       ]
    )
    [ & _0 : TypeInvariants_WithInvariant_Type.t_withinvariant = any_l () : TypeInvariants_WithInvariant_Type.t_withinvariant
    | & x : TypeInvariants_WithInvariant_Type.t_withinvariant = x ]
    
    [ return' (result:TypeInvariants_WithInvariant_Type.t_withinvariant)-> {[@expl:postcondition] [#"../type_invariants.rs" 14 31 14 44] inv'0 result}
      (! return' {result}) ]
    
end
module TypeInvariants_Impl0
  
end
