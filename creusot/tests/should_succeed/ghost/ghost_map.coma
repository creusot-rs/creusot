module M_ghost_map__ghost_map [#"ghost_map.rs" 4 0 4 18]
  let%span sghost_map0 = "ghost_map.rs" 5 18 5 41
  let%span sfmap1 = "../../../../creusot-contracts/src/logic/fmap.rs" 208 14 208 31
  let%span sghost_map2 = "ghost_map.rs" 7 22 7 53
  let%span sghost_map3 = "ghost_map.rs" 8 25 8 26
  let%span sghost_map4 = "ghost_map.rs" 8 28 8 30
  let%span sghost_map5 = "ghost_map.rs" 10 22 10 47
  let%span sghost_map6 = "ghost_map.rs" 11 22 11 34
  let%span sghost_map7 = "ghost_map.rs" 12 28 12 29
  let%span sghost_map8 = "ghost_map.rs" 12 31 12 32
  let%span sghost_map9 = "ghost_map.rs" 12 34 12 35
  let%span sghost_map10 = "ghost_map.rs" 14 17 14 19
  let%span sghost_map11 = "ghost_map.rs" 16 22 16 47
  let%span sghost_map12 = "ghost_map.rs" 18 45 18 46
  let%span sghost_map13 = "ghost_map.rs" 18 48 18 50
  let%span sghost_map14 = "ghost_map.rs" 19 45 19 46
  let%span sghost_map15 = "ghost_map.rs" 19 48 19 51
  let%span sghost_map16 = "ghost_map.rs" 21 22 21 43
  let%span sghost_map17 = "ghost_map.rs" 22 22 22 50
  let%span sghost_map18 = "ghost_map.rs" 23 22 23 34
  let%span sghost_map19 = "ghost_map.rs" 24 22 24 48
  let%span sghost_map20 = "ghost_map.rs" 25 22 25 47
  let%span sghost_map21 = "ghost_map.rs" 30 22 30 42
  let%span sghost_map22 = "ghost_map.rs" 31 22 31 49
  let%span sghost_map23 = "ghost_map.rs" 32 22 32 42
  let%span sghost_map24 = "ghost_map.rs" 33 22 33 43
  let%span sghost_map25 = "ghost_map.rs" 38 22 38 31
  let%span sghost_map26 = "ghost_map.rs" 39 22 39 32
  let%span sghost_map27 = "ghost_map.rs" 40 22 40 32
  let%span sghost_map28 = "ghost_map.rs" 45 22 45 42
  let%span sghost_map29 = "ghost_map.rs" 46 22 46 34
  let%span sghost_map30 = "ghost_map.rs" 47 22 47 34
  let%span sghost31 = "../../../../creusot-contracts/src/ghost.rs" 183 9 183 15
  let%span sfmap32 = "../../../../creusot-contracts/src/logic/fmap.rs" 126 8 126 34
  let%span sfmap33 = "../../../../creusot-contracts/src/logic/fmap.rs" 120 8 120 35
  let%span sghost34 = "../../../../creusot-contracts/src/ghost.rs" 68 22 68 26
  let%span sghost35 = "../../../../creusot-contracts/src/ghost.rs" 68 4 68 48
  let%span sghost36 = "../../../../creusot-contracts/src/ghost.rs" 67 14 67 36
  let%span sfmap37 = "../../../../creusot-contracts/src/logic/fmap.rs" 347 35 347 38
  let%span sfmap38 = "../../../../creusot-contracts/src/logic/fmap.rs" 347 43 347 48
  let%span sfmap39 = "../../../../creusot-contracts/src/logic/fmap.rs" 347 4 349 17
  let%span sfmap40 = "../../../../creusot-contracts/src/logic/fmap.rs" 345 14 345 49
  let%span sfmap41 = "../../../../creusot-contracts/src/logic/fmap.rs" 346 14 346 40
  let%span sghost42 = "../../../../creusot-contracts/src/ghost.rs" 52 14 52 18
  let%span sghost43 = "../../../../creusot-contracts/src/ghost.rs" 52 4 52 36
  let%span sghost44 = "../../../../creusot-contracts/src/ghost.rs" 51 14 51 35
  let%span sfmap45 = "../../../../creusot-contracts/src/logic/fmap.rs" 235 14 235 34
  let%span sfmap46 = "../../../../creusot-contracts/src/logic/fmap.rs" 113 9 113 31
  let%span sfmap47 = "../../../../creusot-contracts/src/logic/fmap.rs" 319 36 319 39
  let%span sfmap48 = "../../../../creusot-contracts/src/logic/fmap.rs" 319 4 319 62
  let%span sfmap49 = "../../../../creusot-contracts/src/logic/fmap.rs" 307 4 316 11
  let%span sfmap50 = "../../../../creusot-contracts/src/logic/fmap.rs" 317 14 317 89
  let%span sfmap51 = "../../../../creusot-contracts/src/logic/fmap.rs" 318 14 318 44
  let%span sfmap52 = "../../../../creusot-contracts/src/logic/fmap.rs" 386 35 386 38
  let%span sfmap53 = "../../../../creusot-contracts/src/logic/fmap.rs" 386 4 388 17
  let%span sfmap54 = "../../../../creusot-contracts/src/logic/fmap.rs" 384 14 384 43
  let%span sfmap55 = "../../../../creusot-contracts/src/logic/fmap.rs" 385 14 385 41
  let%span sfmap56 = "../../../../creusot-contracts/src/logic/fmap.rs" 86 8 89 9
  let%span sfmap57 = "../../../../creusot-contracts/src/logic/fmap.rs" 256 33 256 36
  let%span sfmap58 = "../../../../creusot-contracts/src/logic/fmap.rs" 255 14 255 43
  let%span sfmap59 = "../../../../creusot-contracts/src/logic/fmap.rs" 285 28 285 31
  let%span sfmap60 = "../../../../creusot-contracts/src/logic/fmap.rs" 285 4 285 50
  let%span sfmap61 = "../../../../creusot-contracts/src/logic/fmap.rs" 277 4 284 11
  let%span sghost62 = "../../../../creusot-contracts/src/ghost.rs" 147 15 147 16
  let%span sghost63 = "../../../../creusot-contracts/src/ghost.rs" 147 4 147 28
  let%span sghost64 = "../../../../creusot-contracts/src/ghost.rs" 145 14 145 28
  let%span sfmap65 = "../../../../creusot-contracts/src/logic/fmap.rs" 36 14 36 31
  let%span sfmap66 = "../../../../creusot-contracts/src/logic/fmap.rs" 37 14 37 49
  let%span sfmap67 = "../../../../creusot-contracts/src/logic/fmap.rs" 185 14 185 38
  let%span sfmap68 = "../../../../creusot-contracts/src/logic/fmap.rs" 186 14 186 83
  let%span sfmap69 = "../../../../creusot-contracts/src/logic/fmap.rs" 188 8 188 35
  let%span sfmap70 = "../../../../creusot-contracts/src/logic/fmap.rs" 96 8 96 26
  let%span sfmap71 = "../../../../creusot-contracts/src/logic/fmap.rs" 64 14 64 71
  let%span sfmap72 = "../../../../creusot-contracts/src/logic/fmap.rs" 65 14 65 61
  let%span sfmap73 = "../../../../creusot-contracts/src/logic/fmap.rs" 66 14 66 66
  let%span sresolve74 = "../../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap75 = "../../../../creusot-contracts/src/logic/fmap.rs" 44 14 44 25
  let%span sfmap76 = "../../../../creusot-contracts/src/logic/fmap.rs" 103 8 103 35
  let%span sfmap77 = "../../../../creusot-contracts/src/logic/fmap.rs" 73 14 73 55
  let%span sfmap78 = "../../../../creusot-contracts/src/logic/fmap.rs" 74 14 74 84
  let%span sfmap79 = "../../../../creusot-contracts/src/logic/fmap.rs" 57 14 57 38
  let%span sutil80 = "../../../../creusot-contracts/src/util.rs" 14 14 14 30
  let%span sutil81 = "../../../../creusot-contracts/src/util.rs" 32 11 32 21
  let%span sutil82 = "../../../../creusot-contracts/src/util.rs" 33 10 33 28
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost31] self.t_GhostBox__0'0
  
  use prelude.prelude.Int
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap75] len'0 self >= 0
  
  use prelude.prelude.Int32
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 int32
  
  use map.Map
  
  function mk'0 (_m : Map.map int32 (t_Option'3)) : t_FMap'0
  
  function view'0 (self : t_FMap'0) : Map.map int32 (t_Option'3)
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap79] mk'0 (view'0 self) = self
  
  use map.Const
  
  function empty'0 (_1 : ()) : t_FMap'0
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap65] len'0 (empty'0 _1) = 0)
  && ([%#sfmap66] view'0 (empty'0 _1) = Const.const (C_None'3))
  
  use map.Map
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int32) : t_Option'3 =
    [%#sfmap70] Map.get (view'0 self) k
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap69] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap67] ext_eq'0 self other  -> self = other)
  && ([%#sfmap68] (forall k : int32 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap32] ext_eq'0 self (empty'0 ())
  
  let rec new'0 (_1:()) (return'  (ret:t_GhostBox'0))= any
    [ return' (result:t_GhostBox'0)-> {[%#sfmap1] is_empty'0 (inner_logic'0 result)} (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  function contains'0 [@inline:trivial] (self : t_FMap'0) (k : int32) : bool =
    [%#sfmap33] get_unsized'0 self k <> C_None'3
  
  predicate inv'0 (_1 : borrowed (t_GhostBox'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (t_GhostBox'0) [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : borrowed (t_FMap'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (t_FMap'0) [inv'1 x] . inv'1 x = true
  
  let rec deref_mut'0 (self:borrowed (t_GhostBox'0)) (return'  (ret:borrowed (t_FMap'0)))= {[@expl:deref_mut 'self' type invariant] [%#sghost34] inv'0 self}
    any
    [ return' (result:borrowed (t_FMap'0))-> {[%#sghost35] inv'1 result}
      {[%#sghost36] result
      = Borrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
  
  predicate inv'2 (_1 : int32)
  
  axiom inv_axiom'2 [@rewrite] : forall x : int32 [inv'2 x] . inv'2 x = true
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 int32
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = true
  
  function make_sized'0 (self : int32) : int32
  
  axiom make_sized'0_spec : forall self : int32 . [%#sutil80] make_sized'0 self = self
  
  use map.Map
  
  function insert'0 (self : t_FMap'0) (k : int32) (v : int32) : t_FMap'0
  
  axiom insert'0_spec : forall self : t_FMap'0, k : int32, v : int32 . ([%#sfmap71] view'0 (insert'0 self k v)
  = Map.set (view'0 self) k (C_Some'3 (make_sized'0 v)))
  && ([%#sfmap72] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#sfmap73] not contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self + 1)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : int32) : t_Option'0 =
    [%#sfmap56] match get_unsized'0 self k with
      | C_None'3 -> C_None'1
      | C_Some'3 x -> C_Some'1 x
      end
  
  let rec insert_ghost'0 (self:borrowed (t_FMap'0)) (key:int32) (value:int32) (return'  (ret:t_Option'0))= {[@expl:insert_ghost 'key' type invariant] [%#sfmap37] inv'2 key}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap38] inv'2 value}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap39] inv'3 result}
      {[%#sfmap40] self.final = insert'0 self.current key value}
      {[%#sfmap41] result = get'0 self.current key}
      (! return' {result}) ]
    
  
  predicate resolve'3 (self : borrowed (t_FMap'0)) =
    [%#sresolve74] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (t_FMap'0)) =
    resolve'3 _1
  
  predicate inv'4 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_GhostBox'0 [inv'4 x] . inv'4 x = true
  
  predicate inv'5 (_1 : t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_FMap'0 [inv'5 x] . inv'5 x = true
  
  let rec deref'0 (self:t_GhostBox'0) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost42] inv'4 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost43] inv'5 result}
      {[%#sghost44] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
    
  
  let rec len_ghost'0 (self:t_FMap'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sfmap45] result = len'0 self} (! return' {result}) ]
    
  
  function unwrap'0 (op : t_Option'3) : int32
  
  axiom unwrap'0_spec : forall op : t_Option'3 . ([%#sutil81] op <> C_None'3)
   -> ([%#sutil82] C_Some'3 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int32) : int32 =
    [%#sfmap76] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int32) : int32 =
    [%#sfmap46] lookup_unsized'0 self k
  
  predicate inv'6 (_1 : int32)
  
  axiom inv_axiom'6 [@rewrite] : forall x : int32 [inv'6 x] . inv'6 x = true
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 (borrowed int32)
  
  predicate inv'7 (_1 : t_Option'1)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'1 [inv'7 x] . inv'7 x = true
  
  let rec get_mut_ghost'0 (self:borrowed (t_FMap'0)) (key:int32) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap47] inv'6 key}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap48] inv'7 result}
      {[%#sfmap49] if contains'0 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'0 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap50] forall k : int32 . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap51] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'4 (self : borrowed int32) =
    [%#sresolve74] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed int32) =
    resolve'4 _1
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:borrowed int32))= any
    [ good (field_0:borrowed int32)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : borrowed int32 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
    
  
  function remove'0 (self : t_FMap'0) (k : int32) : t_FMap'0
  
  axiom remove'0_spec : forall self : t_FMap'0, k : int32 . ([%#sfmap77] view'0 (remove'0 self k)
  = Map.set (view'0 self) k (C_None'3))
  && ([%#sfmap78] len'0 (remove'0 self k) = (if contains'0 self k then len'0 self - 1 else len'0 self))
  
  let rec remove_ghost'0 (self:borrowed (t_FMap'0)) (key:int32) (return'  (ret:t_Option'0))= {[@expl:remove_ghost 'key' type invariant] [%#sfmap52] inv'6 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap53] inv'3 result}
      {[%#sfmap54] self.final = remove'0 self.current key}
      {[%#sfmap55] result = get'0 self.current key}
      (! return' {result}) ]
    
  
  let rec contains_ghost'0 (self:t_FMap'0) (key:int32) (return'  (ret:bool))= {[@expl:contains_ghost 'key' type invariant] [%#sfmap57] inv'6 key}
    any [ return' (result:bool)-> {[%#sfmap58] result = contains'0 self key} (! return' {result}) ] 
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 int32
  
  predicate inv'8 (_1 : t_Option'2)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Option'2 [inv'8 x] . inv'8 x = true
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int32) (return'  (ret:t_Option'2))= {[@expl:get_ghost 'key' type invariant] [%#sfmap59] inv'6 key}
    any
    [ return' (result:t_Option'2)-> {[%#sfmap60] inv'8 result}
      {[%#sfmap61] if contains'0 self key then
        match result with
          | C_None'2 -> false
          | C_Some'2 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'2
      }
      (! return' {result}) ]
    
  
  type closure0'1  =
    { field_0'0: borrowed (t_GhostBox'0) }
  
  predicate resolve'6 (self : borrowed (t_GhostBox'0)) =
    [%#sresolve74] self.final = self.current
  
  predicate resolve'5 (_1 : borrowed (t_GhostBox'0)) =
    resolve'6 _1
  
  predicate resolve'2 (_1 : closure0'1) =
    resolve'5 _1.field_0'0
  
  predicate inv'9 (_1 : ())
  
  axiom inv_axiom'9 [@rewrite] : forall x : () [inv'9 x] . inv'9 x = true
  
  type t_GhostBox'1  =
    { t_GhostBox__0'1: () }
  
  predicate inv'10 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_GhostBox'1 [inv'10 x] . inv'10 x = true
  
  let rec new'1 (x:()) (return'  (ret:t_GhostBox'1))= {[@expl:new 'x' type invariant] [%#sghost62] inv'9 x}
    any
    [ return' (result:t_GhostBox'1)-> {[%#sghost63] inv'10 result}
      {[%#sghost64] result.t_GhostBox__0'1 = x}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  let rec closure0'0 (_1:closure0'1) (return'  (ret:t_GhostBox'1))= bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map2] forall k : int32 . not contains'0 (inner_logic'0 (_1.field_0'0).current) k}
        s1
      | s1 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_8 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s2)
      | s2 = deref_mut'0 {_8} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_6 <- _ret' ]  [ &_7 <- { _7 with current = _ret'.final } ] s1)
      | s1 = insert_ghost'0 {_6} {[%#sghost_map3] (1 : int32)} {[%#sghost_map4] (21 : int32)}
          (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = -{resolve'0 _7}- s1
      | s1 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = len_ghost'0 {_11} (fun (_ret':int) ->  [ &length1 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map5] lookup'0 (inner_logic'0 (_1.field_0'0).current) (1 : int32)
        = (21 : int32)}
        s1
      | s1 = {[@expl:assertion] [%#sghost_map6] length1 = 1} s2
      | s2 =  [ &_20 <- (([%#sghost_map7] (1 : int32)), ([%#sghost_map8] (2 : int32)), ([%#sghost_map9] (3 : int32))) ] 
        s3
      | s3 =  [ &x1 <- let (r'0, _, _) = _20 in r'0 ] s4
      | s4 =  [ &x2 <- let (_, r'1, _) = _20 in r'1 ] s5
      | s5 =  [ &x3 <- let (_, _, r'2) = _20 in r'2 ] s6
      | s6 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_25 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s7)
      | s7 = deref_mut'0 {_25} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_24 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_24.current} {Borrow.get_id _24}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_23 <- _ret' ]  [ &_24 <- { _24 with current = _ret'.final } ] s1)
      | s1 =  [ &_27 <- x1 ] s2
      | s2 = get_mut_ghost'0 {_23} {_27} (fun (_ret':t_Option'1) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = any [ br0 -> {_22 = C_None'0 } (! bb9) | br1 (x0:borrowed int32)-> {_22 = C_Some'0 x0} (! bb7) ] 
    | bb9 = s0
      [ s0 = -{match _22 with
          | C_Some'0 x'0 -> resolve'1 x'0
          | _ -> true
          end}-
        s1
      | s1 = -{resolve'0 _24}- s2
      | s2 = bb10 ]
      
    | bb7 = bb8
    | bb8 = s0
      [ s0 = v_Some'0 {_22} (fun (r0'0:borrowed int32) ->  [ &x <- r0'0 ] s1)
      | s1 =  [ &x <- { x with current = ([%#sghost_map10] (42 : int32)) } ] s2
      | s2 = -{resolve'1 x}- s3
      | s3 = -{resolve'0 _24}- s4
      | s4 = bb10 ]
      
    | bb10 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map11] lookup'0 (inner_logic'0 (_1.field_0'0).current) (1 : int32)
        = (42 : int32)}
        s1
      | s1 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_35 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s2)
      | s2 = deref_mut'0 {_35} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_34 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_33 <- _ret' ]  [ &_34 <- { _34 with current = _ret'.final } ] s1)
      | s1 = insert_ghost'0 {_33} {[%#sghost_map12] (2 : int32)} {[%#sghost_map13] (50 : int32)}
          (fun (_ret':t_Option'0) ->  [ &inserted_none <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 _34}- s1
      | s1 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_39 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s2)
      | s2 = deref_mut'0 {_39} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_38 <- _ret' ] s3)
      | s3 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_38.current} {Borrow.get_id _38}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_37 <- _ret' ]  [ &_38 <- { _38 with current = _ret'.final } ] s1)
      | s1 = insert_ghost'0 {_37} {[%#sghost_map14] (2 : int32)} {[%#sghost_map15] (100 : int32)}
          (fun (_ret':t_Option'0) ->  [ &inserted_some <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 = -{resolve'0 _38}- s1
      | s1 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = s0 [ s0 = len_ghost'0 {_42} (fun (_ret':int) ->  [ &length2 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map16] inserted_none = C_None'1} s1
      | s1 = {[@expl:assertion] [%#sghost_map17] inserted_some = C_Some'1 (50 : int32)} s2
      | s2 = {[@expl:assertion] [%#sghost_map18] length2 = 2} s3
      | s3 = {[@expl:assertion] [%#sghost_map19] lookup'0 (inner_logic'0 (_1.field_0'0).current) (2 : int32)
        = (100 : int32)}
        s4
      | s4 = {[@expl:assertion] [%#sghost_map20] lookup'0 (inner_logic'0 (_1.field_0'0).current) (1 : int32)
        = (42 : int32)}
        s5
      | s5 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_57 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s6)
      | s6 = deref_mut'0 {_57} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_56 <- _ret' ] s7)
      | s7 = bb17 ]
      
    | bb17 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_56.current} {Borrow.get_id _56}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_55 <- _ret' ]  [ &_56 <- { _56 with current = _ret'.final } ] s1)
      | s1 =  [ &_59 <- x3 ] s2
      | s2 = remove_ghost'0 {_55} {_59} (fun (_ret':t_Option'0) ->  [ &remove_none1 <- _ret' ] s3)
      | s3 = bb18 ]
      
    | bb18 = s0
      [ s0 = -{resolve'0 _56}- s1
      | s1 = Borrow.borrow_mut <t_GhostBox'0> {(_1.field_0'0).current}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_63 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s2)
      | s2 = deref_mut'0 {_63} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_62 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_62.current} {Borrow.get_id _62}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_61 <- _ret' ]  [ &_62 <- { _62 with current = _ret'.final } ] s1)
      | s1 =  [ &_65 <- x2 ] s2
      | s2 = remove_ghost'0 {_61} {_65} (fun (_ret':t_Option'0) ->  [ &remove_some <- _ret' ] s3)
      | s3 = bb20 ]
      
    | bb20 = s0
      [ s0 = -{resolve'0 _62}- s1
      | s1 = Borrow.borrow_final <t_GhostBox'0> {(_1.field_0'0).current} {Borrow.get_id _1.field_0'0}
          (fun (_ret':borrowed (t_GhostBox'0)) ->
             [ &_69 <- _ret' ] 
             [ &_1 <- { field_0'0 = { _1.field_0'0 with current = _ret'.final } } ] 
            s2)
      | s2 = deref_mut'0 {_69} (fun (_ret':borrowed (t_FMap'0)) ->  [ &_68 <- _ret' ] s3)
      | s3 = bb21 ]
      
    | bb21 = s0
      [ s0 = Borrow.borrow_final <t_FMap'0> {_68.current} {Borrow.get_id _68}
          (fun (_ret':borrowed (t_FMap'0)) ->  [ &_67 <- _ret' ]  [ &_68 <- { _68 with current = _ret'.final } ] s1)
      | s1 =  [ &_71 <- x2 ] s2
      | s2 = remove_ghost'0 {_67} {_71} (fun (_ret':t_Option'0) ->  [ &remove_none2 <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 _68}- s1
      | s1 = {[@expl:assertion] [%#sghost_map21] remove_none1 = C_None'1} s2
      | s2 = {[@expl:assertion] [%#sghost_map22] remove_some = C_Some'1 (100 : int32)} s3
      | s3 = {[@expl:assertion] [%#sghost_map23] remove_none2 = C_None'1} s4
      | s4 = {[@expl:assertion] [%#sghost_map24] get'0 (inner_logic'0 (_1.field_0'0).current) (2 : int32) = C_None'1} s5
      | s5 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_82 <- _ret' ] s6)
      | s6 = bb23 ]
      
    | bb23 = s0
      [ s0 =  [ &_85 <- x1 ] s1
      | s1 = contains_ghost'0 {_82} {_85} (fun (_ret':bool) ->  [ &contains1 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0 [ s0 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_88 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 =  [ &_91 <- x2 ] s1
      | s1 = contains_ghost'0 {_88} {_91} (fun (_ret':bool) ->  [ &contains2 <- _ret' ] s2)
      | s2 = bb26 ]
      
    | bb26 = s0 [ s0 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_94 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0
      [ s0 =  [ &_97 <- x3 ] s1
      | s1 = contains_ghost'0 {_94} {_97} (fun (_ret':bool) ->  [ &contains3 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map25] contains1} s1
      | s1 = {[@expl:assertion] [%#sghost_map26] not contains2} s2
      | s2 = {[@expl:assertion] [%#sghost_map27] not contains3} s3
      | s3 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_106 <- _ret' ] s4)
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &_109 <- x1 ] s1
      | s1 = get_ghost'0 {_106} {_109} (fun (_ret':t_Option'2) ->  [ &get1 <- _ret' ] s2)
      | s2 = bb30 ]
      
    | bb30 = s0 [ s0 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_112 <- _ret' ] s1) | s1 = bb31 ] 
    | bb31 = s0
      [ s0 =  [ &_115 <- x2 ] s1
      | s1 = get_ghost'0 {_112} {_115} (fun (_ret':t_Option'2) ->  [ &get2 <- _ret' ] s2)
      | s2 = bb32 ]
      
    | bb32 = s0 [ s0 = deref'0 {(_1.field_0'0).current} (fun (_ret':t_FMap'0) ->  [ &_118 <- _ret' ] s1) | s1 = bb33 ] 
    | bb33 = s0
      [ s0 =  [ &_121 <- x3 ] s1
      | s1 = get_ghost'0 {_118} {_121} (fun (_ret':t_Option'2) ->  [ &get3 <- _ret' ] s2)
      | s2 = bb34 ]
      
    | bb34 = s0
      [ s0 = -{resolve'2 _1}- s1
      | s1 = {[@expl:assertion] [%#sghost_map28] get1 = C_Some'2 (42 : int32)} s2
      | s2 = {[@expl:assertion] [%#sghost_map29] get2 = C_None'2} s3
      | s3 = {[@expl:assertion] [%#sghost_map30] get3 = C_None'2} s4
      | s4 = new'1 {_2} (fun (_ret':t_GhostBox'1) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb35 ]
      
    | bb35 = return' {_0} ]
    
    [ & _0 : t_GhostBox'1 = any_l ()
    | & _1 : closure0'1 = _1
    | & _2 : () = any_l ()
    | & _5 : t_Option'0 = any_l ()
    | & _6 : borrowed (t_FMap'0) = any_l ()
    | & _7 : borrowed (t_FMap'0) = any_l ()
    | & _8 : borrowed (t_GhostBox'0) = any_l ()
    | & length1 : int = any_l ()
    | & _11 : t_FMap'0 = any_l ()
    | & x1 : int32 = any_l ()
    | & x2 : int32 = any_l ()
    | & x3 : int32 = any_l ()
    | & _20 : (int32, int32, int32) = any_l ()
    | & _22 : t_Option'1 = any_l ()
    | & _23 : borrowed (t_FMap'0) = any_l ()
    | & _24 : borrowed (t_FMap'0) = any_l ()
    | & _25 : borrowed (t_GhostBox'0) = any_l ()
    | & _27 : int32 = any_l ()
    | & x : borrowed int32 = any_l ()
    | & inserted_none : t_Option'0 = any_l ()
    | & _33 : borrowed (t_FMap'0) = any_l ()
    | & _34 : borrowed (t_FMap'0) = any_l ()
    | & _35 : borrowed (t_GhostBox'0) = any_l ()
    | & inserted_some : t_Option'0 = any_l ()
    | & _37 : borrowed (t_FMap'0) = any_l ()
    | & _38 : borrowed (t_FMap'0) = any_l ()
    | & _39 : borrowed (t_GhostBox'0) = any_l ()
    | & length2 : int = any_l ()
    | & _42 : t_FMap'0 = any_l ()
    | & remove_none1 : t_Option'0 = any_l ()
    | & _55 : borrowed (t_FMap'0) = any_l ()
    | & _56 : borrowed (t_FMap'0) = any_l ()
    | & _57 : borrowed (t_GhostBox'0) = any_l ()
    | & _59 : int32 = any_l ()
    | & remove_some : t_Option'0 = any_l ()
    | & _61 : borrowed (t_FMap'0) = any_l ()
    | & _62 : borrowed (t_FMap'0) = any_l ()
    | & _63 : borrowed (t_GhostBox'0) = any_l ()
    | & _65 : int32 = any_l ()
    | & remove_none2 : t_Option'0 = any_l ()
    | & _67 : borrowed (t_FMap'0) = any_l ()
    | & _68 : borrowed (t_FMap'0) = any_l ()
    | & _69 : borrowed (t_GhostBox'0) = any_l ()
    | & _71 : int32 = any_l ()
    | & contains1 : bool = any_l ()
    | & _82 : t_FMap'0 = any_l ()
    | & _85 : int32 = any_l ()
    | & contains2 : bool = any_l ()
    | & _88 : t_FMap'0 = any_l ()
    | & _91 : int32 = any_l ()
    | & contains3 : bool = any_l ()
    | & _94 : t_FMap'0 = any_l ()
    | & _97 : int32 = any_l ()
    | & get1 : t_Option'2 = any_l ()
    | & _106 : t_FMap'0 = any_l ()
    | & _109 : int32 = any_l ()
    | & get2 : t_Option'2 = any_l ()
    | & _112 : t_FMap'0 = any_l ()
    | & _115 : int32 = any_l ()
    | & get3 : t_Option'2 = any_l ()
    | & _118 : t_FMap'0 = any_l ()
    | & _121 : int32 = any_l () ]
     [ return' (result:t_GhostBox'1)-> return' {result} ] 
  
  meta "compute_max_steps" 1000000
  
  let rec ghost_map'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = new'0 {[%#sghost_map0] ()} (fun (_ret':t_GhostBox'0) ->  [ &map <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <t_GhostBox'0> {map}
          (fun (_ret':borrowed (t_GhostBox'0)) ->  [ &_4 <- _ret' ]  [ &map <- _ret'.final ] s1)
      | s1 =  [ &_3 <- { field_0'0 = _4 } ] s2
      | s2 = closure0'0 {_3} (fun (_ret':t_GhostBox'1) ->  [ &_2 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & map : t_GhostBox'0 = any_l ()
    | & _2 : t_GhostBox'1 = any_l ()
    | & _3 : closure0'1 = any_l ()
    | & _4 : borrowed (t_GhostBox'0) = any_l ()
    | & _5 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
