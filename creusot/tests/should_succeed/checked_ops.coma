module M_checked_ops__test_u8_add_example [#"checked_ops.rs" 5 0 5 28]
  let%span schecked_ops0 = "checked_ops.rs" 6 12 6 15
  let%span schecked_ops1 = "checked_ops.rs" 6 28 6 30
  let%span schecked_ops2 = "checked_ops.rs" 6 44 6 46
  let%span schecked_ops3 = "checked_ops.rs" 7 12 7 17
  let%span schecked_ops4 = "checked_ops.rs" 7 30 7 32
  let%span schecked_ops5 = "checked_ops.rs" 9 12 9 15
  let%span schecked_ops6 = "checked_ops.rs" 9 29 9 31
  let%span schecked_ops7 = "checked_ops.rs" 9 36 9 38
  let%span schecked_ops8 = "checked_ops.rs" 10 12 10 17
  let%span schecked_ops9 = "checked_ops.rs" 10 31 10 33
  let%span schecked_ops10 = "checked_ops.rs" 10 38 10 39
  let%span schecked_ops11 = "checked_ops.rs" 12 12 12 15
  let%span schecked_ops12 = "checked_ops.rs" 12 31 12 33
  let%span schecked_ops13 = "checked_ops.rs" 12 38 12 40
  let%span schecked_ops14 = "checked_ops.rs" 13 12 13 17
  let%span schecked_ops15 = "checked_ops.rs" 13 33 13 35
  let%span schecked_ops16 = "checked_ops.rs" 13 40 13 43
  let%span schecked_ops17 = "checked_ops.rs" 15 14 15 17
  let%span schecked_ops18 = "checked_ops.rs" 15 34 15 36
  let%span schecked_ops19 = "checked_ops.rs" 16 21 16 23
  let%span schecked_ops20 = "checked_ops.rs" 16 36 16 41
  let%span schecked_ops21 = "checked_ops.rs" 17 14 17 19
  let%span schecked_ops22 = "checked_ops.rs" 17 36 17 38
  let%span schecked_ops23 = "checked_ops.rs" 18 21 18 22
  let%span schecked_ops24 = "checked_ops.rs" 18 35 18 39
  let%span schecked_ops25 = "checked_ops.rs" 18 4 18 40
  let%span schecked_ops26 = "checked_ops.rs" 16 4 16 42
  let%span schecked_ops27 = "checked_ops.rs" 13 4 13 44
  let%span schecked_ops28 = "checked_ops.rs" 12 4 12 41
  let%span schecked_ops29 = "checked_ops.rs" 10 4 10 40
  let%span schecked_ops30 = "checked_ops.rs" 9 4 9 39
  let%span schecked_ops31 = "checked_ops.rs" 7 4 7 44
  let%span schecked_ops32 = "checked_ops.rs" 6 4 6 47
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum34 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption35 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption36 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum37 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum38 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum39 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum40 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum41 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum42 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum43 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum44 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum45 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum46 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum47 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum48 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum33] (result = C_None'0)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum34] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self + UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : UInt8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : UInt8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption35] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'1 result} {[%#soption35] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption36] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum37] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum38] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum39] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum40] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum41] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum42] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum43] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum44] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum45] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum46] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum47] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum48] (let (_, a) = result in a)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (5 : UInt8.t)} {[%#schecked_ops1] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':UInt8.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[%#schecked_ops2] (15 : UInt8.t)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0 {[%#schecked_ops3] (250 : UInt8.t)} {[%#schecked_ops4] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops5] (5 : UInt8.t)} {[%#schecked_ops6] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (15 : UInt8.t)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops8] (250 : UInt8.t)} {[%#schecked_ops9] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (4 : UInt8.t)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops11] (5 : UInt8.t)} {[%#schecked_ops12] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (15 : UInt8.t)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops14] (250 : UInt8.t)} {[%#schecked_ops15] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (255 : UInt8.t)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops17] (5 : UInt8.t)} {[%#schecked_ops18] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (15 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops21] (250 : UInt8.t)} {[%#schecked_ops22] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (4 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] true) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : UInt8.t = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : UInt8.t = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : UInt8.t = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (UInt8.t, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_add_overflow [#"checked_ops.rs" 23 0 23 34]
  let%span schecked_ops0 = "checked_ops.rs" 24 12 24 17
  let%span schecked_ops1 = "checked_ops.rs" 25 12 25 17
  let%span schecked_ops2 = "checked_ops.rs" 25 41 25 42
  let%span schecked_ops3 = "checked_ops.rs" 26 12 26 17
  let%span schecked_ops4 = "checked_ops.rs" 26 39 26 42
  let%span schecked_ops5 = "checked_ops.rs" 27 14 27 19
  let%span schecked_ops6 = "checked_ops.rs" 28 25 28 26
  let%span schecked_ops7 = "checked_ops.rs" 28 39 28 43
  let%span schecked_ops8 = "checked_ops.rs" 28 4 28 44
  let%span schecked_ops9 = "checked_ops.rs" 26 4 26 43
  let%span schecked_ops10 = "checked_ops.rs" 25 4 25 43
  let%span schecked_ops11 = "checked_ops.rs" 24 4 24 43
  let%span schecked_ops12 = "checked_ops.rs" 22 11 22 18
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum17 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum13] (result = C_None'0)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum14] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self + UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption15] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum16] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum17] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum18] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum19] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum20] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum21] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum22] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum23] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum24] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum25] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum26] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum27] (let (_, a) = result in a)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_overflow'0 (a:UInt8.t) (return'  (ret:()))= {[@expl:test_u8_add_overflow requires] [%#schecked_ops12] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (255 : UInt8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (255 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {a} {[%#schecked_ops2] (1 : UInt8.t)} (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s1)
      | s1 = UInt8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s2)
      | s2 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops3] (255 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_18} {[%#schecked_ops4] (255 : UInt8.t)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb10) | br1 -> {_17} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops5] (255 : UInt8.t)} {a}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {a} {[%#schecked_ops6] (1 : UInt8.t)} (fun (_ret':UInt8.t) ->  [ &_26 <- _ret' ] s1)
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_26} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = any [ br0 -> {_24 = false} (! bb15) | br1 -> {_24} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_28 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops7] true) ] s1
      | s1 = any [ br0 -> {_28 = false} (! bb14) | br1 -> {_28} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops8] false} any
    | bb10 = {[%#schecked_ops9] false} any
    | bb7 = {[%#schecked_ops10] false} any
    | bb4 = {[%#schecked_ops11] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : UInt8.t = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : UInt8.t = any_l ()
    | & _28 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_add [#"checked_ops.rs" 34 0 34 47]
  let%span schecked_ops0 = "checked_ops.rs" 33 10 33 56
  let%span snum1 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec wrapping_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum1] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum2] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum3] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum4] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_add'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : UInt8.t = any_l () | & a : UInt8.t = a | & b : UInt8.t = b ] 
    [ return' (result:UInt8.t)-> {[@expl:test_u8_wrapping_add ensures] [%#schecked_ops0] UInt8.t'int result
      = UInt8.t'int a + UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a + UInt8.t'int b - 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_u8_overflowing_add [#"checked_ops.rs" 39 0 39 44]
  let%span schecked_ops0 = "checked_ops.rs" 41 4 41 65
  let%span schecked_ops1 = "checked_ops.rs" 40 4 40 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec overflowing_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum2] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum3] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum4] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum5] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum7] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self + UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum8] UInt8.t'int self + UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self + UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self + UInt8.t'int rhs}
      {[%#snum9] UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum10] UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self + UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  let rec checked_add'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (UInt8.t'int self + UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self + UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum12] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self + UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_add'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & b : UInt8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (UInt8.t, bool) = any_l ()
    | & _9 : UInt8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (UInt8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_example [#"checked_ops.rs" 45 0 45 28]
  let%span schecked_ops0 = "checked_ops.rs" 46 12 46 15
  let%span schecked_ops1 = "checked_ops.rs" 46 28 46 30
  let%span schecked_ops2 = "checked_ops.rs" 47 12 47 17
  let%span schecked_ops3 = "checked_ops.rs" 47 30 47 32
  let%span schecked_ops4 = "checked_ops.rs" 47 46 47 49
  let%span schecked_ops5 = "checked_ops.rs" 49 12 49 15
  let%span schecked_ops6 = "checked_ops.rs" 49 29 49 31
  let%span schecked_ops7 = "checked_ops.rs" 49 36 49 39
  let%span schecked_ops8 = "checked_ops.rs" 50 12 50 17
  let%span schecked_ops9 = "checked_ops.rs" 50 31 50 33
  let%span schecked_ops10 = "checked_ops.rs" 50 38 50 41
  let%span schecked_ops11 = "checked_ops.rs" 52 12 52 15
  let%span schecked_ops12 = "checked_ops.rs" 52 31 52 33
  let%span schecked_ops13 = "checked_ops.rs" 52 38 52 39
  let%span schecked_ops14 = "checked_ops.rs" 53 12 53 17
  let%span schecked_ops15 = "checked_ops.rs" 53 33 53 35
  let%span schecked_ops16 = "checked_ops.rs" 53 40 53 43
  let%span schecked_ops17 = "checked_ops.rs" 55 14 55 17
  let%span schecked_ops18 = "checked_ops.rs" 55 34 55 36
  let%span schecked_ops19 = "checked_ops.rs" 56 21 56 24
  let%span schecked_ops20 = "checked_ops.rs" 56 37 56 41
  let%span schecked_ops21 = "checked_ops.rs" 57 14 57 19
  let%span schecked_ops22 = "checked_ops.rs" 57 36 57 38
  let%span schecked_ops23 = "checked_ops.rs" 58 21 58 24
  let%span schecked_ops24 = "checked_ops.rs" 58 37 58 42
  let%span schecked_ops25 = "checked_ops.rs" 58 4 58 43
  let%span schecked_ops26 = "checked_ops.rs" 56 4 56 42
  let%span schecked_ops27 = "checked_ops.rs" 53 4 53 44
  let%span schecked_ops28 = "checked_ops.rs" 52 4 52 40
  let%span schecked_ops29 = "checked_ops.rs" 50 4 50 42
  let%span schecked_ops30 = "checked_ops.rs" 49 4 49 40
  let%span schecked_ops31 = "checked_ops.rs" 47 4 47 50
  let%span schecked_ops32 = "checked_ops.rs" 46 4 46 42
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum34 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption35 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption36 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum37 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum38 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum39 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum40 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum41 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum42 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum43 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum44 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum45 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum46 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum47 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum48 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum33] (result = C_None'0)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum34] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self - UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption35] result = (self = C_None'0)} (! return' {result}) ] 
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x = true
  
  predicate inv'2 (_1 : UInt8.t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : UInt8.t [inv'2 x] . inv'2 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'1 self}
    {[@expl:unwrap requires] [%#soption36] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'2 result} {[%#soption36] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum37] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum38] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum39] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum40] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum41] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum42] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum43] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum44] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum45] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum46] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum47] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum48] (let (_, a) = result in a)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (5 : UInt8.t)} {[%#schecked_ops1] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops2] (250 : UInt8.t)} {[%#schecked_ops3] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':UInt8.t) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[%#schecked_ops4] (240 : UInt8.t)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops5] (5 : UInt8.t)} {[%#schecked_ops6] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (251 : UInt8.t)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops8] (250 : UInt8.t)} {[%#schecked_ops9] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (240 : UInt8.t)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops11] (5 : UInt8.t)} {[%#schecked_ops12] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops14] (250 : UInt8.t)} {[%#schecked_ops15] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (240 : UInt8.t)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops17] (5 : UInt8.t)} {[%#schecked_ops18] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (251 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] true) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops21] (250 : UInt8.t)} {[%#schecked_ops22] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (240 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] false) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : UInt8.t = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : UInt8.t = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : UInt8.t = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (UInt8.t, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_overflow [#"checked_ops.rs" 63 0 63 34]
  let%span schecked_ops0 = "checked_ops.rs" 64 12 64 15
  let%span schecked_ops1 = "checked_ops.rs" 65 12 65 15
  let%span schecked_ops2 = "checked_ops.rs" 65 35 65 38
  let%span schecked_ops3 = "checked_ops.rs" 65 45 65 46
  let%span schecked_ops4 = "checked_ops.rs" 66 12 66 15
  let%span schecked_ops5 = "checked_ops.rs" 66 37 66 38
  let%span schecked_ops6 = "checked_ops.rs" 67 14 67 17
  let%span schecked_ops7 = "checked_ops.rs" 68 21 68 24
  let%span schecked_ops8 = "checked_ops.rs" 68 31 68 32
  let%span schecked_ops9 = "checked_ops.rs" 68 45 68 49
  let%span schecked_ops10 = "checked_ops.rs" 68 4 68 50
  let%span schecked_ops11 = "checked_ops.rs" 66 4 66 39
  let%span schecked_ops12 = "checked_ops.rs" 65 4 65 47
  let%span schecked_ops13 = "checked_ops.rs" 64 4 64 41
  let%span schecked_ops14 = "checked_ops.rs" 62 11 62 18
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum15] (result = C_None'0)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum16] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self - UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum18] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum19] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum20] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum21] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum22] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum23] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum24] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum25] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum26] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum27] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum28] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum29] (let (_, a) = result in a)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_overflow'0 (a:UInt8.t) (return'  (ret:()))= {[@expl:test_u8_sub_overflow requires] [%#schecked_ops14] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (0 : UInt8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (0 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {[%#schecked_ops2] (255 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_14 <- _ret' ] s1)
      | s1 = UInt8.add {_14} {[%#schecked_ops3] (1 : UInt8.t)} (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s2)
      | s2 = UInt8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (0 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_19} {[%#schecked_ops5] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (0 : UInt8.t)} {a}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {[%#schecked_ops7] (255 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_28 <- _ret' ] s1)
      | s1 = UInt8.add {_28} {[%#schecked_ops8] (1 : UInt8.t)} (fun (_ret':UInt8.t) ->  [ &_27 <- _ret' ] s2)
      | s2 = UInt8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : UInt8.t = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _14 : UInt8.t = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : UInt8.t = any_l ()
    | & _28 : UInt8.t = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_sub [#"checked_ops.rs" 74 0 74 47]
  let%span schecked_ops0 = "checked_ops.rs" 73 10 73 56
  let%span snum1 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec wrapping_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum1] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum2] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum3] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum4] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_sub'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : UInt8.t = any_l () | & a : UInt8.t = a | & b : UInt8.t = b ] 
    [ return' (result:UInt8.t)-> {[@expl:test_u8_wrapping_sub ensures] [%#schecked_ops0] UInt8.t'int result
      = UInt8.t'int a - UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a - UInt8.t'int b + 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_u8_overflowing_sub [#"checked_ops.rs" 79 0 79 44]
  let%span schecked_ops0 = "checked_ops.rs" 81 4 81 65
  let%span schecked_ops1 = "checked_ops.rs" 80 4 80 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec overflowing_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum2] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum3] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum4] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum5] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum7] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self - UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum8] UInt8.t'int self - UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self - UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self - UInt8.t'int rhs}
      {[%#snum9] UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum10] UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self - UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  let rec checked_sub'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (UInt8.t'int self - UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self - UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum12] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self - UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_sub'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & b : UInt8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (UInt8.t, bool) = any_l ()
    | & _9 : UInt8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (UInt8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_example [#"checked_ops.rs" 85 0 85 28]
  let%span schecked_ops0 = "checked_ops.rs" 86 12 86 15
  let%span schecked_ops1 = "checked_ops.rs" 86 28 86 30
  let%span schecked_ops2 = "checked_ops.rs" 86 44 86 46
  let%span schecked_ops3 = "checked_ops.rs" 87 12 87 16
  let%span schecked_ops4 = "checked_ops.rs" 87 29 87 31
  let%span schecked_ops5 = "checked_ops.rs" 89 12 89 15
  let%span schecked_ops6 = "checked_ops.rs" 89 29 89 31
  let%span schecked_ops7 = "checked_ops.rs" 89 36 89 38
  let%span schecked_ops8 = "checked_ops.rs" 90 12 90 16
  let%span schecked_ops9 = "checked_ops.rs" 90 30 90 32
  let%span schecked_ops10 = "checked_ops.rs" 90 37 90 40
  let%span schecked_ops11 = "checked_ops.rs" 92 12 92 15
  let%span schecked_ops12 = "checked_ops.rs" 92 31 92 33
  let%span schecked_ops13 = "checked_ops.rs" 92 38 92 40
  let%span schecked_ops14 = "checked_ops.rs" 93 12 93 16
  let%span schecked_ops15 = "checked_ops.rs" 93 32 93 34
  let%span schecked_ops16 = "checked_ops.rs" 93 39 93 42
  let%span schecked_ops17 = "checked_ops.rs" 95 14 95 17
  let%span schecked_ops18 = "checked_ops.rs" 95 34 95 36
  let%span schecked_ops19 = "checked_ops.rs" 96 21 96 23
  let%span schecked_ops20 = "checked_ops.rs" 96 36 96 41
  let%span schecked_ops21 = "checked_ops.rs" 97 14 97 18
  let%span schecked_ops22 = "checked_ops.rs" 97 35 97 37
  let%span schecked_ops23 = "checked_ops.rs" 98 21 98 24
  let%span schecked_ops24 = "checked_ops.rs" 98 37 98 41
  let%span schecked_ops25 = "checked_ops.rs" 98 4 98 42
  let%span schecked_ops26 = "checked_ops.rs" 96 4 96 42
  let%span schecked_ops27 = "checked_ops.rs" 93 4 93 43
  let%span schecked_ops28 = "checked_ops.rs" 92 4 92 41
  let%span schecked_ops29 = "checked_ops.rs" 90 4 90 41
  let%span schecked_ops30 = "checked_ops.rs" 89 4 89 39
  let%span schecked_ops31 = "checked_ops.rs" 87 4 87 43
  let%span schecked_ops32 = "checked_ops.rs" 86 4 86 47
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum34 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption35 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption36 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum37 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum38 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum39 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum40 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum41 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum42 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum43 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum44 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum45 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum46 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum47 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum48 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum33] (result = C_None'0)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum34] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self * UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : UInt8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : UInt8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption35] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'1 result} {[%#soption35] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption36] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum37] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum38] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum39] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum40] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum41] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum42] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum43] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum44] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum45] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum46] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum47] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum48] (let (_, a) = result in a)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (5 : UInt8.t)} {[%#schecked_ops1] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':UInt8.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[%#schecked_ops2] (50 : UInt8.t)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops3] (50 : UInt8.t)} {[%#schecked_ops4] (10 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops5] (5 : UInt8.t)} {[%#schecked_ops6] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (50 : UInt8.t)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops8] (50 : UInt8.t)} {[%#schecked_ops9] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (244 : UInt8.t)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops11] (5 : UInt8.t)} {[%#schecked_ops12] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (50 : UInt8.t)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops14] (50 : UInt8.t)} {[%#schecked_ops15] (10 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (255 : UInt8.t)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops17] (5 : UInt8.t)} {[%#schecked_ops18] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (50 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops21] (50 : UInt8.t)} {[%#schecked_ops22] (10 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (244 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] true) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : UInt8.t = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : UInt8.t = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : UInt8.t = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (UInt8.t, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_zero [#"checked_ops.rs" 102 0 102 30]
  let%span schecked_ops0 = "checked_ops.rs" 103 12 103 15
  let%span schecked_ops1 = "checked_ops.rs" 103 43 103 44
  let%span schecked_ops2 = "checked_ops.rs" 104 12 104 15
  let%span schecked_ops3 = "checked_ops.rs" 104 35 104 36
  let%span schecked_ops4 = "checked_ops.rs" 105 12 105 15
  let%span schecked_ops5 = "checked_ops.rs" 105 37 105 38
  let%span schecked_ops6 = "checked_ops.rs" 106 14 106 17
  let%span schecked_ops7 = "checked_ops.rs" 107 21 107 22
  let%span schecked_ops8 = "checked_ops.rs" 107 35 107 40
  let%span schecked_ops9 = "checked_ops.rs" 107 4 107 41
  let%span schecked_ops10 = "checked_ops.rs" 105 4 105 39
  let%span schecked_ops11 = "checked_ops.rs" 104 4 104 37
  let%span schecked_ops12 = "checked_ops.rs" 103 4 103 45
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum17 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec checked_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum13] (result = C_None'0)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum14] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self * UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : UInt8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : UInt8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption15] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'1 result} {[%#soption15] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum16] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum17] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum18] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum19] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum20] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum21] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum22] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX'0 : UInt8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum23] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum24] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum25] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum26] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum27] (let (_, a) = result in a)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_zero'0 (a:UInt8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (0 : UInt8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':UInt8.t) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_4} {[%#schecked_ops1] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1)
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops2] (0 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_10 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.eq {_10} {[%#schecked_ops3] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops4] (0 : UInt8.t)} {a} (fun (_ret':UInt8.t) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_15} {[%#schecked_ops5] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops6] (0 : UInt8.t)} {a}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops7] (0 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops8] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops9] false} any
    | bb10 = {[%#schecked_ops10] false} any
    | bb7 = {[%#schecked_ops11] false} any
    | bb4 = {[%#schecked_ops12] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & _3 : bool = any_l ()
    | & _4 : UInt8.t = any_l ()
    | & _5 : t_Option'0 = any_l ()
    | & _9 : bool = any_l ()
    | & _10 : UInt8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_overflowing_mul [#"checked_ops.rs" 111 0 111 44]
  let%span schecked_ops0 = "checked_ops.rs" 113 4 113 65
  let%span schecked_ops1 = "checked_ops.rs" 112 4 112 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  let rec overflowing_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= any
    [ return' (result:(UInt8.t, bool))-> {[%#snum2] UInt8.t'int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum3] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum4] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum5] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int (let (a, _) = result in a)
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= any
    [ return' (result:UInt8.t)-> {[%#snum7] UInt8.t'int result
      = EuclideanDivision.mod (UInt8.t'int self * UInt8.t'int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum8] UInt8.t'int self * UInt8.t'int rhs >= UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int self * UInt8.t'int rhs <= UInt8.t'int (v_MAX'0 : UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self * UInt8.t'int rhs}
      {[%#snum9] UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      + k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      {[%#snum10] UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t)
       -> (exists k : int . k > 0
      /\ UInt8.t'int result
      = UInt8.t'int self * UInt8.t'int rhs
      - k * (UInt8.t'int (v_MAX'0 : UInt8.t) - UInt8.t'int (v_MIN'0 : UInt8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  let rec checked_mul'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (UInt8.t'int self * UInt8.t'int rhs < UInt8.t'int (v_MIN'0 : UInt8.t)
      \/ UInt8.t'int self * UInt8.t'int rhs > UInt8.t'int (v_MAX'0 : UInt8.t))}
      {[%#snum12] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = UInt8.t'int self * UInt8.t'int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_mul'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & b : UInt8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (UInt8.t, bool) = any_l ()
    | & _9 : UInt8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (UInt8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_example [#"checked_ops.rs" 117 0 117 28]
  let%span schecked_ops0 = "checked_ops.rs" 118 12 118 15
  let%span schecked_ops1 = "checked_ops.rs" 118 28 118 29
  let%span schecked_ops2 = "checked_ops.rs" 119 12 119 15
  let%span schecked_ops3 = "checked_ops.rs" 119 28 119 29
  let%span schecked_ops4 = "checked_ops.rs" 119 43 119 44
  let%span schecked_ops5 = "checked_ops.rs" 120 12 120 15
  let%span schecked_ops6 = "checked_ops.rs" 120 29 120 30
  let%span schecked_ops7 = "checked_ops.rs" 120 35 120 36
  let%span schecked_ops8 = "checked_ops.rs" 121 12 121 15
  let%span schecked_ops9 = "checked_ops.rs" 121 31 121 32
  let%span schecked_ops10 = "checked_ops.rs" 121 37 121 38
  let%span schecked_ops11 = "checked_ops.rs" 122 14 122 17
  let%span schecked_ops12 = "checked_ops.rs" 122 34 122 35
  let%span schecked_ops13 = "checked_ops.rs" 123 21 123 22
  let%span schecked_ops14 = "checked_ops.rs" 123 35 123 40
  let%span schecked_ops15 = "checked_ops.rs" 123 4 123 41
  let%span schecked_ops16 = "checked_ops.rs" 121 4 121 39
  let%span schecked_ops17 = "checked_ops.rs" 120 4 120 37
  let%span schecked_ops18 = "checked_ops.rs" 119 4 119 45
  let%span schecked_ops19 = "checked_ops.rs" 118 4 118 41
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption22 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption23 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 120 27 120 36
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 122 26 122 83
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 124 26 124 89
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 130 27 130 36
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 132 26 132 89
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 134 26 134 89
  let%span snum30 = "../../../creusot-contracts/src/std/num.rs" 140 27 140 36
  let%span snum31 = "../../../creusot-contracts/src/std/num.rs" 142 26 142 85
  let%span snum32 = "../../../creusot-contracts/src/std/num.rs" 144 26 144 91
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 146 26 146 74
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  let rec checked_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum20] (result = C_None'0)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum21] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption22] result = (self = C_None'0)} (! return' {result}) ] 
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x = true
  
  predicate inv'2 (_1 : UInt8.t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : UInt8.t [inv'2 x] . inv'2 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'1 self}
    {[@expl:unwrap requires] [%#soption23] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'2 result} {[%#soption23] C_Some'0 result = self} (! return' {result}) ] 
  
  let rec wrapping_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:wrapping_div requires] [%#snum24] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:UInt8.t)-> {[%#snum25] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int self}
      {[%#snum26] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:saturating_div requires] [%#snum27] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:UInt8.t)-> {[%#snum28] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum29] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  let rec overflowing_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= {[@expl:overflowing_div requires] [%#snum30] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:(UInt8.t, bool))-> {[%#snum31] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int rhs = - 1  -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self}
      {[%#snum32] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int (let (a, _) = result in a) = div (UInt8.t'int self) (UInt8.t'int rhs)}
      {[%#snum33] (let (_, a) = result in a)
      = (UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {[%#schecked_ops0] (5 : UInt8.t)} {[%#schecked_ops1] (0 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div'0 {[%#schecked_ops2] (5 : UInt8.t)} {[%#schecked_ops3] (2 : UInt8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':UInt8.t) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[%#schecked_ops4] (2 : UInt8.t)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops5] (5 : UInt8.t)} {[%#schecked_ops6] (2 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (2 : UInt8.t)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops8] (5 : UInt8.t)} {[%#schecked_ops9] (2 : UInt8.t)}
          (fun (_ret':UInt8.t) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (2 : UInt8.t)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops11] (5 : UInt8.t)} {[%#schecked_ops12] (2 : UInt8.t)}
          (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops13] (2 : UInt8.t)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb19) | br1 -> {_21} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops14] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb18) | br1 -> {_23} (! bb17) ]  ]
      
    | bb17 = return' {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops15] false} any
    | bb14 = {[%#schecked_ops16] false} any
    | bb11 = {[%#schecked_ops17] false} any
    | bb8 = {[%#schecked_ops18] false} any
    | bb4 = {[%#schecked_ops19] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : UInt8.t = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : UInt8.t = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : UInt8.t = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_no_overflow [#"checked_ops.rs" 128 0 128 44]
  let%span schecked_ops0 = "checked_ops.rs" 129 41 129 46
  let%span schecked_ops1 = "checked_ops.rs" 130 33 130 38
  let%span schecked_ops2 = "checked_ops.rs" 131 35 131 40
  let%span schecked_ops3 = "checked_ops.rs" 133 21 133 26
  let%span schecked_ops4 = "checked_ops.rs" 133 39 133 44
  let%span schecked_ops5 = "checked_ops.rs" 133 4 133 45
  let%span schecked_ops6 = "checked_ops.rs" 131 4 131 41
  let%span schecked_ops7 = "checked_ops.rs" 130 4 130 39
  let%span schecked_ops8 = "checked_ops.rs" 129 4 129 47
  let%span schecked_ops9 = "checked_ops.rs" 127 11 127 18
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 120 27 120 36
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 122 26 122 83
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 124 26 124 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 130 27 130 36
  let%span snum17 = "../../../creusot-contracts/src/std/num.rs" 132 26 132 89
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 134 26 134 89
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 140 27 140 36
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 142 26 142 85
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 144 26 144 91
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 146 26 146 74
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  let rec checked_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum10] (result = C_None'0)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum11] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : UInt8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : UInt8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:UInt8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption12] self <> C_None'0}
    any [ return' (result:UInt8.t)-> {inv'1 result} {[%#soption12] C_Some'0 result = self} (! return' {result}) ] 
  
  let rec wrapping_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:wrapping_div requires] [%#snum13] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:UInt8.t)-> {[%#snum14] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int self}
      {[%#snum15] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:saturating_div requires] [%#snum16] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:UInt8.t)-> {[%#snum17] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int (v_MIN'0 : UInt8.t)}
      {[%#snum18] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  let rec overflowing_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:(UInt8.t, bool)))= {[@expl:overflowing_div requires] [%#snum19] UInt8.t'int rhs
    <> 0}
    any
    [ return' (result:(UInt8.t, bool))-> {[%#snum20] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t)
      /\ UInt8.t'int rhs = - 1  -> UInt8.t'int (let (a, _) = result in a) = UInt8.t'int self}
      {[%#snum21] UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int (let (a, _) = result in a) = div (UInt8.t'int self) (UInt8.t'int rhs)}
      {[%#snum22] (let (_, a) = result in a)
      = (UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_no_overflow'0 (a:UInt8.t) (b:UInt8.t) (return'  (ret:()))= {[@expl:test_u8_div_no_overflow requires] [%#schecked_ops9] UInt8.t'int b
    <> 0}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_7 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':UInt8.t) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- b ] s1
      | s1 = UInt8.eq {_12} {[%#schecked_ops0] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops0] not _13} s3
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = UInt8.div {a} {_12} (fun (_ret':UInt8.t) ->  [ &_10 <- _ret' ] s1)
      | s1 = UInt8.eq {_6} {_10} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb4) ]  ]
      
    | bb4 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_17 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_22 <- b ] s1
      | s1 = UInt8.eq {_22} {[%#schecked_ops1] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops1] not _23} s3
      | s3 = bb7 ]
      
    | bb7 = s0
      [ s0 = UInt8.div {a} {_22} (fun (_ret':UInt8.t) ->  [ &_20 <- _ret' ] s1)
      | s1 = UInt8.eq {_17} {_20} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s2)
      | s2 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':UInt8.t) ->  [ &_27 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_32 <- b ] s1
      | s1 = UInt8.eq {_32} {[%#schecked_ops2] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops2] not _33} s3
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.div {a} {_32} (fun (_ret':UInt8.t) ->  [ &_30 <- _ret' ] s1)
      | s1 = UInt8.eq {_27} {_30} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s2)
      | s2 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(UInt8.t, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 =  [ &_43 <- b ] s1
      | s1 = UInt8.eq {_43} {[%#schecked_ops3] (0 : UInt8.t)} (fun (_ret':bool) ->  [ &_44 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops3] not _44} s3
      | s3 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.div {a} {_43} (fun (_ret':UInt8.t) ->  [ &_41 <- _ret' ] s1)
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_41} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s2)
      | s2 = any [ br0 -> {_39 = false} (! bb19) | br1 -> {_39} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 =  [ &_45 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops4] false) ] s1
      | s1 = any [ br0 -> {_45 = false} (! bb18) | br1 -> {_45} (! bb17) ]  ]
      
    | bb17 = return' {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops5] false} any
    | bb13 = {[%#schecked_ops6] false} any
    | bb9 = {[%#schecked_ops7] false} any
    | bb5 = {[%#schecked_ops8] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : UInt8.t = a
    | & b : UInt8.t = b
    | & _5 : bool = any_l ()
    | & _6 : UInt8.t = any_l ()
    | & _7 : t_Option'0 = any_l ()
    | & _10 : UInt8.t = any_l ()
    | & _12 : UInt8.t = any_l ()
    | & _13 : bool = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : UInt8.t = any_l ()
    | & _20 : UInt8.t = any_l ()
    | & _22 : UInt8.t = any_l ()
    | & _23 : bool = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : UInt8.t = any_l ()
    | & _30 : UInt8.t = any_l ()
    | & _32 : UInt8.t = any_l ()
    | & _33 : bool = any_l ()
    | & res : (UInt8.t, bool) = any_l ()
    | & _39 : bool = any_l ()
    | & _41 : UInt8.t = any_l ()
    | & _43 : UInt8.t = any_l ()
    | & _44 : bool = any_l ()
    | & _45 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_zero [#"checked_ops.rs" 137 0 137 30]
  let%span schecked_ops0 = "checked_ops.rs" 138 26 138 27
  let%span schecked_ops1 = "checked_ops.rs" 138 4 138 39
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  use prelude.prelude.UInt8
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  let rec checked_div'0 (self:UInt8.t) (rhs:UInt8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum2] (result = C_None'0)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self = UInt8.t'int (v_MIN'0 : UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum3] forall r : UInt8.t . result = C_Some'0 r  -> UInt8.t'int r = div (UInt8.t'int self) (UInt8.t'int rhs)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption4] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_zero'0 (a:UInt8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[%#schecked_ops0] (0 : UInt8.t)} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return' {_0}
    | bb4 = {[%#schecked_ops1] false} any ]
    ) [ & _0 : () = any_l () | & a : UInt8.t = a | & _3 : bool = any_l () | & _5 : t_Option'0 = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
module M_checked_ops__test_i8_add_example [#"checked_ops.rs" 142 0 142 28]
  let%span schecked_ops0 = "checked_ops.rs" 143 12 143 15
  let%span schecked_ops1 = "checked_ops.rs" 143 28 143 30
  let%span schecked_ops2 = "checked_ops.rs" 143 44 143 46
  let%span schecked_ops3 = "checked_ops.rs" 144 12 144 17
  let%span schecked_ops4 = "checked_ops.rs" 144 30 144 32
  let%span schecked_ops5 = "checked_ops.rs" 145 12 145 20
  let%span schecked_ops6 = "checked_ops.rs" 145 33 145 36
  let%span schecked_ops7 = "checked_ops.rs" 147 12 147 15
  let%span schecked_ops8 = "checked_ops.rs" 147 29 147 31
  let%span schecked_ops9 = "checked_ops.rs" 147 36 147 38
  let%span schecked_ops10 = "checked_ops.rs" 148 12 148 17
  let%span schecked_ops11 = "checked_ops.rs" 148 31 148 33
  let%span schecked_ops12 = "checked_ops.rs" 148 38 148 42
  let%span schecked_ops13 = "checked_ops.rs" 149 12 149 20
  let%span schecked_ops14 = "checked_ops.rs" 149 34 149 37
  let%span schecked_ops15 = "checked_ops.rs" 149 42 149 45
  let%span schecked_ops16 = "checked_ops.rs" 151 12 151 15
  let%span schecked_ops17 = "checked_ops.rs" 151 31 151 33
  let%span schecked_ops18 = "checked_ops.rs" 151 38 151 40
  let%span schecked_ops19 = "checked_ops.rs" 152 12 152 17
  let%span schecked_ops20 = "checked_ops.rs" 152 33 152 35
  let%span schecked_ops21 = "checked_ops.rs" 152 40 152 43
  let%span schecked_ops22 = "checked_ops.rs" 153 12 153 20
  let%span schecked_ops23 = "checked_ops.rs" 153 36 153 39
  let%span schecked_ops24 = "checked_ops.rs" 153 44 153 48
  let%span schecked_ops25 = "checked_ops.rs" 155 14 155 17
  let%span schecked_ops26 = "checked_ops.rs" 155 34 155 36
  let%span schecked_ops27 = "checked_ops.rs" 156 21 156 23
  let%span schecked_ops28 = "checked_ops.rs" 156 36 156 41
  let%span schecked_ops29 = "checked_ops.rs" 157 14 157 19
  let%span schecked_ops30 = "checked_ops.rs" 157 36 157 38
  let%span schecked_ops31 = "checked_ops.rs" 158 21 158 25
  let%span schecked_ops32 = "checked_ops.rs" 158 38 158 42
  let%span schecked_ops33 = "checked_ops.rs" 159 14 159 22
  let%span schecked_ops34 = "checked_ops.rs" 159 39 159 42
  let%span schecked_ops35 = "checked_ops.rs" 160 21 160 24
  let%span schecked_ops36 = "checked_ops.rs" 160 37 160 41
  let%span schecked_ops37 = "checked_ops.rs" 160 4 160 42
  let%span schecked_ops38 = "checked_ops.rs" 158 4 158 43
  let%span schecked_ops39 = "checked_ops.rs" 156 4 156 42
  let%span schecked_ops40 = "checked_ops.rs" 153 4 153 49
  let%span schecked_ops41 = "checked_ops.rs" 152 4 152 44
  let%span schecked_ops42 = "checked_ops.rs" 151 4 151 41
  let%span schecked_ops43 = "checked_ops.rs" 149 4 149 46
  let%span schecked_ops44 = "checked_ops.rs" 148 4 148 43
  let%span schecked_ops45 = "checked_ops.rs" 147 4 147 39
  let%span schecked_ops46 = "checked_ops.rs" 145 4 145 48
  let%span schecked_ops47 = "checked_ops.rs" 144 4 144 44
  let%span schecked_ops48 = "checked_ops.rs" 143 4 143 47
  let%span snum49 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum50 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption51 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption52 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum53 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum54 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum55 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum56 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum57 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum58 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum59 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum60 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum61 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum62 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum63 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum64 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum49] (result = C_None'0)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum50] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Int8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Int8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption51] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'1 result} {[%#soption51] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption52] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum53] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum54] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum55] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum56] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum57] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum58] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum59] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum60] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum61] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#snum62] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum63] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum64] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (5 : Int8.t)} {[%#schecked_ops1] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':Int8.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (15 : Int8.t)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0 {[%#schecked_ops3] (120 : Int8.t)} {[%#schecked_ops4] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_add'0 {[%#schecked_ops5] (-120 : Int8.t)} {[%#schecked_ops6] (-10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops7] (5 : Int8.t)} {[%#schecked_ops8] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops9] (15 : Int8.t)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops10] (120 : Int8.t)} {[%#schecked_ops11] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops12] (-126 : Int8.t)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops13] (-120 : Int8.t)} {[%#schecked_ops14] (-10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops15] (126 : Int8.t)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops16] (5 : Int8.t)} {[%#schecked_ops17] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops18] (15 : Int8.t)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops19] (120 : Int8.t)} {[%#schecked_ops20] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops21] (127 : Int8.t)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops22] (-120 : Int8.t)} {[%#schecked_ops23] (-10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops24] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops25] (5 : Int8.t)} {[%#schecked_ops26] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops27] (15 : Int8.t)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops28] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops29] (120 : Int8.t)} {[%#schecked_ops30] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops31] (-126 : Int8.t)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops32] true) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops33] (-120 : Int8.t)} {[%#schecked_ops34] (-10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops35] (126 : Int8.t)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops36] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops37] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops38] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops39] false} any
    | bb30 = {[%#schecked_ops40] false} any
    | bb27 = {[%#schecked_ops41] false} any
    | bb24 = {[%#schecked_ops42] false} any
    | bb21 = {[%#schecked_ops43] false} any
    | bb18 = {[%#schecked_ops44] false} any
    | bb15 = {[%#schecked_ops45] false} any
    | bb12 = {[%#schecked_ops46] false} any
    | bb8 = {[%#schecked_ops47] false} any
    | bb4 = {[%#schecked_ops48] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : Int8.t = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : t_Option'0 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : Int8.t = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : Int8.t = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : Int8.t = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : Int8.t = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : Int8.t = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (Int8.t, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (Int8.t, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_pos [#"checked_ops.rs" 165 0 165 38]
  let%span schecked_ops0 = "checked_ops.rs" 166 12 166 17
  let%span schecked_ops1 = "checked_ops.rs" 167 12 167 17
  let%span schecked_ops2 = "checked_ops.rs" 167 41 167 44
  let%span schecked_ops3 = "checked_ops.rs" 167 47 167 48
  let%span schecked_ops4 = "checked_ops.rs" 168 12 168 17
  let%span schecked_ops5 = "checked_ops.rs" 168 39 168 42
  let%span schecked_ops6 = "checked_ops.rs" 169 14 169 19
  let%span schecked_ops7 = "checked_ops.rs" 170 25 170 28
  let%span schecked_ops8 = "checked_ops.rs" 170 31 170 32
  let%span schecked_ops9 = "checked_ops.rs" 170 45 170 49
  let%span schecked_ops10 = "checked_ops.rs" 170 4 170 50
  let%span schecked_ops11 = "checked_ops.rs" 168 4 168 43
  let%span schecked_ops12 = "checked_ops.rs" 167 4 167 49
  let%span schecked_ops13 = "checked_ops.rs" 166 4 166 43
  let%span schecked_ops14 = "checked_ops.rs" 164 11 164 17
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum15] (result = C_None'0)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum16] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum18] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum19] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum20] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum21] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum22] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum23] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum24] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum25] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum26] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#snum27] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum28] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum29] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_pos'0 (a:Int8.t) (return'  (ret:()))= {[@expl:test_i8_add_overflow_pos requires] [%#schecked_ops14] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (127 : Int8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {a} {[%#schecked_ops2] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.sub {_14} {[%#schecked_ops3] (2 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops4] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (127 : Int8.t)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops6] (127 : Int8.t)} {a}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {a} {[%#schecked_ops7] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.sub {_28} {[%#schecked_ops8] (2 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : Int8.t = any_l ()
    | & _13 : Int8.t = any_l ()
    | & _14 : Int8.t = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : Int8.t = any_l ()
    | & _28 : Int8.t = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_neg [#"checked_ops.rs" 175 0 175 38]
  let%span schecked_ops0 = "checked_ops.rs" 176 12 176 20
  let%span schecked_ops1 = "checked_ops.rs" 177 12 177 20
  let%span schecked_ops2 = "checked_ops.rs" 177 44 177 47
  let%span schecked_ops3 = "checked_ops.rs" 177 50 177 51
  let%span schecked_ops4 = "checked_ops.rs" 178 12 178 20
  let%span schecked_ops5 = "checked_ops.rs" 178 42 178 46
  let%span schecked_ops6 = "checked_ops.rs" 179 14 179 22
  let%span schecked_ops7 = "checked_ops.rs" 180 25 180 28
  let%span schecked_ops8 = "checked_ops.rs" 180 31 180 32
  let%span schecked_ops9 = "checked_ops.rs" 180 45 180 49
  let%span schecked_ops10 = "checked_ops.rs" 180 4 180 50
  let%span schecked_ops11 = "checked_ops.rs" 178 4 178 47
  let%span schecked_ops12 = "checked_ops.rs" 177 4 177 52
  let%span schecked_ops13 = "checked_ops.rs" 176 4 176 46
  let%span schecked_ops14 = "checked_ops.rs" 174 11 174 17
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum15] (result = C_None'0)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum16] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum18] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum19] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum20] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum21] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum22] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum23] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum24] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum25] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum26] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#snum27] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum28] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum29] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_neg'0 (a:Int8.t) (return'  (ret:()))= {[@expl:test_i8_add_overflow_neg requires] [%#schecked_ops14] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (-128 : Int8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (-128 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {a} {[%#schecked_ops2] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops3] (1 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops4] (-128 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops6] (-128 : Int8.t)} {a}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {a} {[%#schecked_ops7] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops8] (1 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : Int8.t = any_l ()
    | & _13 : Int8.t = any_l ()
    | & _14 : Int8.t = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : Int8.t = any_l ()
    | & _28 : Int8.t = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_add [#"checked_ops.rs" 186 0 186 47]
  let%span schecked_ops0 = "checked_ops.rs" 185 10 185 84
  let%span snum1 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec wrapping_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum1] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum2] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum3] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum4] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_add'0 (a:Int8.t) (b:Int8.t) (return'  (ret:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : Int8.t = any_l () | & a : Int8.t = a | & b : Int8.t = b ] 
    [ return' (result:Int8.t)-> {[@expl:test_i8_wrapping_add ensures] [%#schecked_ops0] Int8.to_int result
      = Int8.to_int a + Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_i8_overflowing_add [#"checked_ops.rs" 191 0 191 44]
  let%span schecked_ops0 = "checked_ops.rs" 193 4 193 65
  let%span schecked_ops1 = "checked_ops.rs" 192 4 192 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec overflowing_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum2] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum3] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#snum4] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum5] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum7] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum8] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#snum9] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum10] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  let rec checked_add'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum12] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_add'0 (a:Int8.t) (b:Int8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & b : Int8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (Int8.t, bool) = any_l ()
    | & _9 : Int8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (Int8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_example [#"checked_ops.rs" 197 0 197 28]
  let%span schecked_ops0 = "checked_ops.rs" 198 12 198 15
  let%span schecked_ops1 = "checked_ops.rs" 198 28 198 30
  let%span schecked_ops2 = "checked_ops.rs" 198 44 198 46
  let%span schecked_ops3 = "checked_ops.rs" 199 12 199 17
  let%span schecked_ops4 = "checked_ops.rs" 199 30 199 32
  let%span schecked_ops5 = "checked_ops.rs" 199 46 199 49
  let%span schecked_ops6 = "checked_ops.rs" 200 12 200 20
  let%span schecked_ops7 = "checked_ops.rs" 200 33 200 35
  let%span schecked_ops8 = "checked_ops.rs" 202 12 202 15
  let%span schecked_ops9 = "checked_ops.rs" 202 29 202 31
  let%span schecked_ops10 = "checked_ops.rs" 202 36 202 38
  let%span schecked_ops11 = "checked_ops.rs" 203 12 203 17
  let%span schecked_ops12 = "checked_ops.rs" 203 31 203 33
  let%span schecked_ops13 = "checked_ops.rs" 203 38 203 41
  let%span schecked_ops14 = "checked_ops.rs" 204 12 204 20
  let%span schecked_ops15 = "checked_ops.rs" 204 34 204 36
  let%span schecked_ops16 = "checked_ops.rs" 204 41 204 44
  let%span schecked_ops17 = "checked_ops.rs" 206 12 206 15
  let%span schecked_ops18 = "checked_ops.rs" 206 31 206 33
  let%span schecked_ops19 = "checked_ops.rs" 206 38 206 40
  let%span schecked_ops20 = "checked_ops.rs" 207 12 207 17
  let%span schecked_ops21 = "checked_ops.rs" 207 33 207 35
  let%span schecked_ops22 = "checked_ops.rs" 207 40 207 43
  let%span schecked_ops23 = "checked_ops.rs" 208 12 208 20
  let%span schecked_ops24 = "checked_ops.rs" 208 36 208 38
  let%span schecked_ops25 = "checked_ops.rs" 208 43 208 47
  let%span schecked_ops26 = "checked_ops.rs" 210 14 210 17
  let%span schecked_ops27 = "checked_ops.rs" 210 34 210 36
  let%span schecked_ops28 = "checked_ops.rs" 211 21 211 23
  let%span schecked_ops29 = "checked_ops.rs" 211 36 211 41
  let%span schecked_ops30 = "checked_ops.rs" 212 14 212 19
  let%span schecked_ops31 = "checked_ops.rs" 212 36 212 38
  let%span schecked_ops32 = "checked_ops.rs" 213 21 213 24
  let%span schecked_ops33 = "checked_ops.rs" 213 37 213 42
  let%span schecked_ops34 = "checked_ops.rs" 214 14 214 22
  let%span schecked_ops35 = "checked_ops.rs" 214 39 214 41
  let%span schecked_ops36 = "checked_ops.rs" 215 21 215 24
  let%span schecked_ops37 = "checked_ops.rs" 215 37 215 41
  let%span schecked_ops38 = "checked_ops.rs" 215 4 215 42
  let%span schecked_ops39 = "checked_ops.rs" 213 4 213 43
  let%span schecked_ops40 = "checked_ops.rs" 211 4 211 42
  let%span schecked_ops41 = "checked_ops.rs" 208 4 208 48
  let%span schecked_ops42 = "checked_ops.rs" 207 4 207 44
  let%span schecked_ops43 = "checked_ops.rs" 206 4 206 41
  let%span schecked_ops44 = "checked_ops.rs" 204 4 204 45
  let%span schecked_ops45 = "checked_ops.rs" 203 4 203 42
  let%span schecked_ops46 = "checked_ops.rs" 202 4 202 39
  let%span schecked_ops47 = "checked_ops.rs" 200 4 200 47
  let%span schecked_ops48 = "checked_ops.rs" 199 4 199 50
  let%span schecked_ops49 = "checked_ops.rs" 198 4 198 47
  let%span snum50 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum51 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption52 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption53 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum54 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum55 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum56 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum57 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum58 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum59 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum60 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum61 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum62 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum63 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum64 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum65 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum50] (result = C_None'0)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum51] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Int8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Int8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption52] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'1 result} {[%#soption52] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption53] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum54] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum55] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum56] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum57] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum58] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum59] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum60] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum61] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum62] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#snum63] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum64] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum65] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (5 : Int8.t)} {[%#schecked_ops1] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':Int8.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (-5 : Int8.t)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops3] (120 : Int8.t)} {[%#schecked_ops4] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':Int8.t) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[%#schecked_ops5] (110 : Int8.t)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops6] (-120 : Int8.t)} {[%#schecked_ops7] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops8] (5 : Int8.t)} {[%#schecked_ops9] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops10] (-5 : Int8.t)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops11] (120 : Int8.t)} {[%#schecked_ops12] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops13] (110 : Int8.t)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops14] (-120 : Int8.t)} {[%#schecked_ops15] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops16] (126 : Int8.t)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops17] (5 : Int8.t)} {[%#schecked_ops18] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops19] (-5 : Int8.t)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops20] (120 : Int8.t)} {[%#schecked_ops21] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops22] (110 : Int8.t)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops23] (-120 : Int8.t)} {[%#schecked_ops24] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops25] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops26] (5 : Int8.t)} {[%#schecked_ops27] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops28] (-5 : Int8.t)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops29] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops30] (120 : Int8.t)} {[%#schecked_ops31] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops32] (110 : Int8.t)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops33] false) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops34] (-120 : Int8.t)} {[%#schecked_ops35] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops36] (126 : Int8.t)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops37] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops38] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops39] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops40] false} any
    | bb30 = {[%#schecked_ops41] false} any
    | bb27 = {[%#schecked_ops42] false} any
    | bb24 = {[%#schecked_ops43] false} any
    | bb21 = {[%#schecked_ops44] false} any
    | bb18 = {[%#schecked_ops45] false} any
    | bb15 = {[%#schecked_ops46] false} any
    | bb12 = {[%#schecked_ops47] false} any
    | bb8 = {[%#schecked_ops48] false} any
    | bb4 = {[%#schecked_ops49] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : Int8.t = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : Int8.t = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : t_Option'0 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : Int8.t = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : Int8.t = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : Int8.t = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : Int8.t = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : Int8.t = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (Int8.t, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (Int8.t, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_pos [#"checked_ops.rs" 220 0 220 38]
  let%span schecked_ops0 = "checked_ops.rs" 221 12 221 20
  let%span schecked_ops1 = "checked_ops.rs" 222 12 222 20
  let%span schecked_ops2 = "checked_ops.rs" 222 40 222 43
  let%span schecked_ops3 = "checked_ops.rs" 222 50 222 51
  let%span schecked_ops4 = "checked_ops.rs" 223 12 223 20
  let%span schecked_ops5 = "checked_ops.rs" 223 42 223 46
  let%span schecked_ops6 = "checked_ops.rs" 224 14 224 22
  let%span schecked_ops7 = "checked_ops.rs" 225 21 225 24
  let%span schecked_ops8 = "checked_ops.rs" 225 31 225 32
  let%span schecked_ops9 = "checked_ops.rs" 225 45 225 49
  let%span schecked_ops10 = "checked_ops.rs" 225 4 225 50
  let%span schecked_ops11 = "checked_ops.rs" 223 4 223 47
  let%span schecked_ops12 = "checked_ops.rs" 222 4 222 52
  let%span schecked_ops13 = "checked_ops.rs" 221 4 221 46
  let%span schecked_ops14 = "checked_ops.rs" 219 11 219 17
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum15] (result = C_None'0)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum16] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum18] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum19] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum20] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum21] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum22] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum23] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum24] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum25] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum26] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#snum27] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum28] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum29] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_pos'0 (a:Int8.t) (return'  (ret:()))= {[@expl:test_i8_sub_overflow_pos requires] [%#schecked_ops14] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (-128 : Int8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (-128 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {[%#schecked_ops2] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops3] (1 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (-128 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (-128 : Int8.t)} {a}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {[%#schecked_ops7] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops8] (1 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : Int8.t = any_l ()
    | & _13 : Int8.t = any_l ()
    | & _14 : Int8.t = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : Int8.t = any_l ()
    | & _28 : Int8.t = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_neg [#"checked_ops.rs" 230 0 230 38]
  let%span schecked_ops0 = "checked_ops.rs" 231 12 231 17
  let%span schecked_ops1 = "checked_ops.rs" 232 12 232 17
  let%span schecked_ops2 = "checked_ops.rs" 232 39 232 40
  let%span schecked_ops3 = "checked_ops.rs" 232 48 232 51
  let%span schecked_ops4 = "checked_ops.rs" 233 12 233 17
  let%span schecked_ops5 = "checked_ops.rs" 233 39 233 42
  let%span schecked_ops6 = "checked_ops.rs" 234 14 234 19
  let%span schecked_ops7 = "checked_ops.rs" 235 23 235 24
  let%span schecked_ops8 = "checked_ops.rs" 235 32 235 35
  let%span schecked_ops9 = "checked_ops.rs" 235 48 235 52
  let%span schecked_ops10 = "checked_ops.rs" 235 4 235 53
  let%span schecked_ops11 = "checked_ops.rs" 233 4 233 43
  let%span schecked_ops12 = "checked_ops.rs" 232 4 232 52
  let%span schecked_ops13 = "checked_ops.rs" 231 4 231 43
  let%span schecked_ops14 = "checked_ops.rs" 229 11 229 17
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption17 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum28 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum29 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum15] (result = C_None'0)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum16] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum18] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum19] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum20] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum21] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum22] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum23] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum24] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum25] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum26] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#snum27] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum28] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum29] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_neg'0 (a:Int8.t) (return'  (ret:()))= {[@expl:test_i8_sub_overflow_neg requires] [%#schecked_ops14] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (127 : Int8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {[%#schecked_ops2] (2 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_15 <- _ret' ] s1)
      | s1 = Int8.neg {_15} (fun (_ret:Int8.t) ->  [ &_14 <- _ret ] s2)
      | s2 = Int8.sub {_14} {[%#schecked_ops3] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_13 <- _ret' ] s3)
      | s3 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (127 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_20 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_20} {[%#schecked_ops5] (127 : Int8.t)} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1)
      | s1 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (127 : Int8.t)} {a}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {[%#schecked_ops7] (2 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_30 <- _ret' ] s1)
      | s1 = Int8.neg {_30} (fun (_ret:Int8.t) ->  [ &_29 <- _ret ] s2)
      | s2 = Int8.sub {_29} {[%#schecked_ops8] (127 : Int8.t)} (fun (_ret':Int8.t) ->  [ &_28 <- _ret' ] s3)
      | s3 = Int8.eq {let (r'0, _) = res in r'0} {_28} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s4)
      | s4 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_32 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_32 = false} (! bb14) | br1 -> {_32} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & _4 : bool = any_l ()
    | & _6 : t_Option'0 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : Int8.t = any_l ()
    | & _13 : Int8.t = any_l ()
    | & _14 : Int8.t = any_l ()
    | & _15 : Int8.t = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _26 : bool = any_l ()
    | & _28 : Int8.t = any_l ()
    | & _29 : Int8.t = any_l ()
    | & _30 : Int8.t = any_l ()
    | & _32 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_sub [#"checked_ops.rs" 241 0 241 47]
  let%span schecked_ops0 = "checked_ops.rs" 240 10 240 84
  let%span snum1 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec wrapping_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum1] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum2] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum3] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum4] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_sub'0 (a:Int8.t) (b:Int8.t) (return'  (ret:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : Int8.t = any_l () | & a : Int8.t = a | & b : Int8.t = b ] 
    [ return' (result:Int8.t)-> {[@expl:test_i8_wrapping_sub ensures] [%#schecked_ops0] Int8.to_int result
      = Int8.to_int a - Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_i8_overflowing_sub [#"checked_ops.rs" 246 0 246 44]
  let%span schecked_ops0 = "checked_ops.rs" 248 4 248 65
  let%span schecked_ops1 = "checked_ops.rs" 247 4 247 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec overflowing_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum2] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum3] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#snum4] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum5] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum7] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum8] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#snum9] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum10] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  let rec checked_sub'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum12] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_sub'0 (a:Int8.t) (b:Int8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & b : Int8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (Int8.t, bool) = any_l ()
    | & _9 : Int8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (Int8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_example [#"checked_ops.rs" 252 0 252 28]
  let%span schecked_ops0 = "checked_ops.rs" 253 12 253 15
  let%span schecked_ops1 = "checked_ops.rs" 253 28 253 30
  let%span schecked_ops2 = "checked_ops.rs" 253 44 253 46
  let%span schecked_ops3 = "checked_ops.rs" 254 12 254 16
  let%span schecked_ops4 = "checked_ops.rs" 254 29 254 31
  let%span schecked_ops5 = "checked_ops.rs" 255 12 255 16
  let%span schecked_ops6 = "checked_ops.rs" 255 29 255 32
  let%span schecked_ops7 = "checked_ops.rs" 257 12 257 15
  let%span schecked_ops8 = "checked_ops.rs" 257 29 257 31
  let%span schecked_ops9 = "checked_ops.rs" 257 36 257 38
  let%span schecked_ops10 = "checked_ops.rs" 258 12 258 16
  let%span schecked_ops11 = "checked_ops.rs" 258 30 258 32
  let%span schecked_ops12 = "checked_ops.rs" 258 37 258 40
  let%span schecked_ops13 = "checked_ops.rs" 259 12 259 16
  let%span schecked_ops14 = "checked_ops.rs" 259 30 259 33
  let%span schecked_ops15 = "checked_ops.rs" 259 38 259 40
  let%span schecked_ops16 = "checked_ops.rs" 261 12 261 15
  let%span schecked_ops17 = "checked_ops.rs" 261 31 261 33
  let%span schecked_ops18 = "checked_ops.rs" 261 38 261 40
  let%span schecked_ops19 = "checked_ops.rs" 262 12 262 16
  let%span schecked_ops20 = "checked_ops.rs" 262 32 262 34
  let%span schecked_ops21 = "checked_ops.rs" 262 39 262 42
  let%span schecked_ops22 = "checked_ops.rs" 263 12 263 16
  let%span schecked_ops23 = "checked_ops.rs" 263 32 263 35
  let%span schecked_ops24 = "checked_ops.rs" 263 40 263 44
  let%span schecked_ops25 = "checked_ops.rs" 265 14 265 17
  let%span schecked_ops26 = "checked_ops.rs" 265 34 265 36
  let%span schecked_ops27 = "checked_ops.rs" 266 21 266 23
  let%span schecked_ops28 = "checked_ops.rs" 266 36 266 41
  let%span schecked_ops29 = "checked_ops.rs" 267 14 267 18
  let%span schecked_ops30 = "checked_ops.rs" 267 35 267 37
  let%span schecked_ops31 = "checked_ops.rs" 268 21 268 24
  let%span schecked_ops32 = "checked_ops.rs" 268 37 268 41
  let%span schecked_ops33 = "checked_ops.rs" 269 14 269 18
  let%span schecked_ops34 = "checked_ops.rs" 269 35 269 38
  let%span schecked_ops35 = "checked_ops.rs" 270 21 270 23
  let%span schecked_ops36 = "checked_ops.rs" 270 36 270 40
  let%span schecked_ops37 = "checked_ops.rs" 270 4 270 41
  let%span schecked_ops38 = "checked_ops.rs" 268 4 268 42
  let%span schecked_ops39 = "checked_ops.rs" 266 4 266 42
  let%span schecked_ops40 = "checked_ops.rs" 263 4 263 45
  let%span schecked_ops41 = "checked_ops.rs" 262 4 262 43
  let%span schecked_ops42 = "checked_ops.rs" 261 4 261 41
  let%span schecked_ops43 = "checked_ops.rs" 259 4 259 41
  let%span schecked_ops44 = "checked_ops.rs" 258 4 258 41
  let%span schecked_ops45 = "checked_ops.rs" 257 4 257 39
  let%span schecked_ops46 = "checked_ops.rs" 255 4 255 44
  let%span schecked_ops47 = "checked_ops.rs" 254 4 254 43
  let%span schecked_ops48 = "checked_ops.rs" 253 4 253 47
  let%span snum49 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum50 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption51 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption52 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span snum53 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum54 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum55 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum56 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum57 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum58 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum59 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum60 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum61 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum62 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum63 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum64 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum49] (result = C_None'0)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum50] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Int8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Int8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption51] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'1 result} {[%#soption51] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.Borrow
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'2 self}
    any [ return' (result:bool)-> {[%#soption52] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum53] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum54] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#snum55] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum56] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum57] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#snum58] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum59] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum60] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum61] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#snum62] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum63] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum64] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (5 : Int8.t)} {[%#schecked_ops1] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':Int8.t) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (50 : Int8.t)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops3] (50 : Int8.t)} {[%#schecked_ops4] (10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops5] (50 : Int8.t)} {[%#schecked_ops6] (-10 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops7] (5 : Int8.t)} {[%#schecked_ops8] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops9] (50 : Int8.t)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops10] (50 : Int8.t)} {[%#schecked_ops11] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops12] (-12 : Int8.t)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops13] (50 : Int8.t)} {[%#schecked_ops14] (-10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops15] (12 : Int8.t)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops16] (5 : Int8.t)} {[%#schecked_ops17] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops18] (50 : Int8.t)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops19] (50 : Int8.t)} {[%#schecked_ops20] (10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops21] (127 : Int8.t)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops22] (50 : Int8.t)} {[%#schecked_ops23] (-10 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops24] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops25] (5 : Int8.t)} {[%#schecked_ops26] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops27] (50 : Int8.t)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops28] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops29] (50 : Int8.t)} {[%#schecked_ops30] (10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops31] (-12 : Int8.t)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops32] true) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops33] (50 : Int8.t)} {[%#schecked_ops34] (-10 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops35] (12 : Int8.t)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops36] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops37] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops38] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops39] false} any
    | bb30 = {[%#schecked_ops40] false} any
    | bb27 = {[%#schecked_ops41] false} any
    | bb24 = {[%#schecked_ops42] false} any
    | bb21 = {[%#schecked_ops43] false} any
    | bb18 = {[%#schecked_ops44] false} any
    | bb15 = {[%#schecked_ops45] false} any
    | bb12 = {[%#schecked_ops46] false} any
    | bb8 = {[%#schecked_ops47] false} any
    | bb4 = {[%#schecked_ops48] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : Int8.t = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : t_Option'0 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : Int8.t = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : Int8.t = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : Int8.t = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : Int8.t = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : Int8.t = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (Int8.t, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (Int8.t, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_zero [#"checked_ops.rs" 274 0 274 30]
  let%span schecked_ops0 = "checked_ops.rs" 275 12 275 15
  let%span schecked_ops1 = "checked_ops.rs" 275 43 275 44
  let%span schecked_ops2 = "checked_ops.rs" 276 12 276 15
  let%span schecked_ops3 = "checked_ops.rs" 276 35 276 36
  let%span schecked_ops4 = "checked_ops.rs" 277 12 277 15
  let%span schecked_ops5 = "checked_ops.rs" 277 37 277 38
  let%span schecked_ops6 = "checked_ops.rs" 278 14 278 17
  let%span schecked_ops7 = "checked_ops.rs" 279 21 279 22
  let%span schecked_ops8 = "checked_ops.rs" 279 35 279 40
  let%span schecked_ops9 = "checked_ops.rs" 279 4 279 41
  let%span schecked_ops10 = "checked_ops.rs" 277 4 277 39
  let%span schecked_ops11 = "checked_ops.rs" 276 4 276 37
  let%span schecked_ops12 = "checked_ops.rs" 275 4 275 45
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption15 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum17 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 214 20 215 51
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 218 26 218 83
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 219 26 219 83
  let%span snum23 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum24 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum25 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum26 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum27 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec checked_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum13] (result = C_None'0)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum14] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Int8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Int8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption15] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'1 result} {[%#soption15] C_Some'0 result = self} (! return' {result}) ] 
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  let rec wrapping_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum16] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum17] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#snum18] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum19] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum20] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#snum21] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum22] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : Int8.t)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum23] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum24] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#snum25] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum26] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum27] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_zero'0 (a:Int8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (0 : Int8.t)} {a} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':Int8.t) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_4} {[%#schecked_ops1] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1)
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops2] (0 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_10 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.eq {_10} {[%#schecked_ops3] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops4] (0 : Int8.t)} {a} (fun (_ret':Int8.t) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_15} {[%#schecked_ops5] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops6] (0 : Int8.t)} {a}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops7] (0 : Int8.t)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops8] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops9] false} any
    | bb10 = {[%#schecked_ops10] false} any
    | bb7 = {[%#schecked_ops11] false} any
    | bb4 = {[%#schecked_ops12] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & _3 : bool = any_l ()
    | & _4 : Int8.t = any_l ()
    | & _5 : t_Option'0 = any_l ()
    | & _9 : bool = any_l ()
    | & _10 : Int8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_overflowing_mul [#"checked_ops.rs" 283 0 283 44]
  let%span schecked_ops0 = "checked_ops.rs" 285 4 285 65
  let%span schecked_ops1 = "checked_ops.rs" 284 4 284 56
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 228 20 228 95
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 232 20 233 53
  let%span snum4 = "../../../creusot-contracts/src/std/num.rs" 239 20 241 94
  let%span snum5 = "../../../creusot-contracts/src/std/num.rs" 244 20 246 94
  let%span snum6 = "../../../creusot-contracts/src/std/num.rs" 250 20 250 98
  let%span snum7 = "../../../creusot-contracts/src/std/num.rs" 186 20 186 93
  let%span snum8 = "../../../creusot-contracts/src/std/num.rs" 190 20 191 51
  let%span snum9 = "../../../creusot-contracts/src/std/num.rs" 197 20 199 92
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 202 20 204 92
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 174 20 175 89
  let%span snum12 = "../../../creusot-contracts/src/std/num.rs" 178 26 178 87
  let%span soption13 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : UInt32.t = (8 : UInt32.t)
  
  use prelude.prelude.UInt32
  
  use int.Power
  
  use int.EuclideanDivision
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  let rec overflowing_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= any
    [ return' (result:(Int8.t, bool))-> {[%#snum2] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum3] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#snum4] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum5] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum6] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= any
    [ return' (result:Int8.t)-> {[%#snum7] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.t'int (v_BITS'0 : UInt32.t)))
      + Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum8] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : Int8.t)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#snum9] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      {[%#snum10] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : Int8.t) - Int8.to_int (v_MIN'0 : Int8.t) + 1))}
      (! return' {result}) ]
    
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  let rec checked_mul'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum11] (result = C_None'0)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : Int8.t)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : Int8.t))}
      {[%#snum12] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption13] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_mul'0 (a:Int8.t) (b:Int8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & b : Int8.t = b
    | & _4 : bool = any_l ()
    | & _6 : (Int8.t, bool) = any_l ()
    | & _9 : Int8.t = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (Int8.t, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : t_Option'0 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_example [#"checked_ops.rs" 289 0 289 28]
  let%span schecked_ops0 = "checked_ops.rs" 290 12 290 15
  let%span schecked_ops1 = "checked_ops.rs" 290 28 290 29
  let%span schecked_ops2 = "checked_ops.rs" 291 12 291 15
  let%span schecked_ops3 = "checked_ops.rs" 291 28 291 29
  let%span schecked_ops4 = "checked_ops.rs" 291 43 291 44
  let%span schecked_ops5 = "checked_ops.rs" 292 12 292 15
  let%span schecked_ops6 = "checked_ops.rs" 292 28 292 30
  let%span schecked_ops7 = "checked_ops.rs" 292 44 292 46
  let%span schecked_ops8 = "checked_ops.rs" 293 12 293 20
  let%span schecked_ops9 = "checked_ops.rs" 293 33 293 35
  let%span schecked_ops10 = "checked_ops.rs" 295 12 295 15
  let%span schecked_ops11 = "checked_ops.rs" 295 29 295 30
  let%span schecked_ops12 = "checked_ops.rs" 295 35 295 36
  let%span schecked_ops13 = "checked_ops.rs" 296 12 296 15
  let%span schecked_ops14 = "checked_ops.rs" 296 29 296 31
  let%span schecked_ops15 = "checked_ops.rs" 296 36 296 38
  let%span schecked_ops16 = "checked_ops.rs" 297 12 297 20
  let%span schecked_ops17 = "checked_ops.rs" 297 34 297 36
  let%span schecked_ops18 = "checked_ops.rs" 297 41 297 45
  let%span schecked_ops19 = "checked_ops.rs" 299 12 299 15
  let%span schecked_ops20 = "checked_ops.rs" 299 31 299 32
  let%span schecked_ops21 = "checked_ops.rs" 299 37 299 38
  let%span schecked_ops22 = "checked_ops.rs" 300 12 300 15
  let%span schecked_ops23 = "checked_ops.rs" 300 31 300 33
  let%span schecked_ops24 = "checked_ops.rs" 300 38 300 40
  let%span schecked_ops25 = "checked_ops.rs" 301 12 301 20
  let%span schecked_ops26 = "checked_ops.rs" 301 36 301 38
  let%span schecked_ops27 = "checked_ops.rs" 301 43 301 47
  let%span schecked_ops28 = "checked_ops.rs" 303 14 303 17
  let%span schecked_ops29 = "checked_ops.rs" 303 34 303 35
  let%span schecked_ops30 = "checked_ops.rs" 304 21 304 22
  let%span schecked_ops31 = "checked_ops.rs" 304 35 304 40
  let%span schecked_ops32 = "checked_ops.rs" 305 14 305 17
  let%span schecked_ops33 = "checked_ops.rs" 305 34 305 36
  let%span schecked_ops34 = "checked_ops.rs" 306 21 306 23
  let%span schecked_ops35 = "checked_ops.rs" 306 36 306 41
  let%span schecked_ops36 = "checked_ops.rs" 307 14 307 22
  let%span schecked_ops37 = "checked_ops.rs" 307 39 307 41
  let%span schecked_ops38 = "checked_ops.rs" 308 21 308 25
  let%span schecked_ops39 = "checked_ops.rs" 308 38 308 42
  let%span schecked_ops40 = "checked_ops.rs" 308 4 308 43
  let%span schecked_ops41 = "checked_ops.rs" 306 4 306 42
  let%span schecked_ops42 = "checked_ops.rs" 304 4 304 41
  let%span schecked_ops43 = "checked_ops.rs" 301 4 301 48
  let%span schecked_ops44 = "checked_ops.rs" 300 4 300 41
  let%span schecked_ops45 = "checked_ops.rs" 299 4 299 39
  let%span schecked_ops46 = "checked_ops.rs" 297 4 297 46
  let%span schecked_ops47 = "checked_ops.rs" 296 4 296 39
  let%span schecked_ops48 = "checked_ops.rs" 295 4 295 37
  let%span schecked_ops49 = "checked_ops.rs" 293 4 293 47
  let%span schecked_ops50 = "checked_ops.rs" 292 4 292 47
  let%span schecked_ops51 = "checked_ops.rs" 291 4 291 45
  let%span schecked_ops52 = "checked_ops.rs" 290 4 290 41
  let%span snum53 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum54 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption55 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span soption56 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum57 = "../../../creusot-contracts/src/std/num.rs" 120 27 120 36
  let%span snum58 = "../../../creusot-contracts/src/std/num.rs" 122 26 122 83
  let%span snum59 = "../../../creusot-contracts/src/std/num.rs" 124 26 124 89
  let%span snum60 = "../../../creusot-contracts/src/std/num.rs" 130 27 130 36
  let%span snum61 = "../../../creusot-contracts/src/std/num.rs" 132 26 132 89
  let%span snum62 = "../../../creusot-contracts/src/std/num.rs" 134 26 134 89
  let%span snum63 = "../../../creusot-contracts/src/std/num.rs" 140 27 140 36
  let%span snum64 = "../../../creusot-contracts/src/std/num.rs" 142 26 142 85
  let%span snum65 = "../../../creusot-contracts/src/std/num.rs" 144 26 144 91
  let%span snum66 = "../../../creusot-contracts/src/std/num.rs" 146 26 146 74
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  let rec checked_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum53] (result = C_None'0)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum54] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption55] result = (self = C_None'0)} (! return' {result}) ] 
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x = true
  
  predicate inv'2 (_1 : Int8.t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Int8.t [inv'2 x] . inv'2 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'1 self}
    {[@expl:unwrap requires] [%#soption56] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'2 result} {[%#soption56] C_Some'0 result = self} (! return' {result}) ] 
  
  let rec wrapping_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= {[@expl:wrapping_div requires] [%#snum57] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:Int8.t)-> {[%#snum58] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self}
      {[%#snum59] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= {[@expl:saturating_div requires] [%#snum60] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:Int8.t)-> {[%#snum61] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum62] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  let rec overflowing_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= {[@expl:overflowing_div requires] [%#snum63] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(Int8.t, bool))-> {[%#snum64] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      {[%#snum65] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#snum66] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_example'0 (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {[%#schecked_ops0] (5 : Int8.t)} {[%#schecked_ops1] (0 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div'0 {[%#schecked_ops2] (5 : Int8.t)} {[%#schecked_ops3] (2 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':Int8.t) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[%#schecked_ops4] (2 : Int8.t)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_div'0 {[%#schecked_ops5] (5 : Int8.t)} {[%#schecked_ops6] (-2 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':Int8.t) ->  [ &_13 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 = Int8.eq {_13} {[%#schecked_ops7] (-2 : Int8.t)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ]
      
    | bb11 = s0
      [ s0 = checked_div'0 {[%#schecked_ops8] (-128 : Int8.t)} {[%#schecked_ops9] (-1 : Int8.t)}
          (fun (_ret':t_Option'0) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0 [ s0 = is_none'0 {_19} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = any [ br0 -> {_17 = false} (! bb16) | br1 -> {_17} (! bb15) ] 
    | bb15 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops10] (5 : Int8.t)} {[%#schecked_ops11] (2 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb17 ]
      
    | bb17 = s0
      [ s0 = Int8.eq {_23} {[%#schecked_ops12] (2 : Int8.t)} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1)
      | s1 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb18) ]  ]
      
    | bb18 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops13] (5 : Int8.t)} {[%#schecked_ops14] (-2 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_27 <- _ret' ] s1)
      | s1 = bb20 ]
      
    | bb20 = s0
      [ s0 = Int8.eq {_27} {[%#schecked_ops15] (-2 : Int8.t)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1)
      | s1 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb21) ]  ]
      
    | bb21 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops16] (-128 : Int8.t)} {[%#schecked_ops17] (-1 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_31 <- _ret' ] s1)
      | s1 = bb23 ]
      
    | bb23 = s0
      [ s0 = Int8.eq {_31} {[%#schecked_ops18] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1)
      | s1 = any [ br0 -> {_30 = false} (! bb25) | br1 -> {_30} (! bb24) ]  ]
      
    | bb24 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops19] (5 : Int8.t)} {[%#schecked_ops20] (2 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_35 <- _ret' ] s1)
      | s1 = bb26 ]
      
    | bb26 = s0
      [ s0 = Int8.eq {_35} {[%#schecked_ops21] (2 : Int8.t)} (fun (_ret':bool) ->  [ &_34 <- _ret' ] s1)
      | s1 = any [ br0 -> {_34 = false} (! bb28) | br1 -> {_34} (! bb27) ]  ]
      
    | bb27 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops22] (5 : Int8.t)} {[%#schecked_ops23] (-2 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_39 <- _ret' ] s1)
      | s1 = bb29 ]
      
    | bb29 = s0
      [ s0 = Int8.eq {_39} {[%#schecked_ops24] (-2 : Int8.t)} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s1)
      | s1 = any [ br0 -> {_38 = false} (! bb31) | br1 -> {_38} (! bb30) ]  ]
      
    | bb30 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops25] (-128 : Int8.t)} {[%#schecked_ops26] (-1 : Int8.t)}
          (fun (_ret':Int8.t) ->  [ &_43 <- _ret' ] s1)
      | s1 = bb32 ]
      
    | bb32 = s0
      [ s0 = Int8.eq {_43} {[%#schecked_ops27] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb34) | br1 -> {_42} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops28] (5 : Int8.t)} {[%#schecked_ops29] (2 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb35 ]
      
    | bb35 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops30] (2 : Int8.t)}
          (fun (_ret':bool) ->  [ &_47 <- _ret' ] s1)
      | s1 = any [ br0 -> {_47 = false} (! bb39) | br1 -> {_47} (! bb36) ]  ]
      
    | bb36 = s0
      [ s0 =  [ &_49 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops31] false) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb38) | br1 -> {_49} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops32] (5 : Int8.t)} {[%#schecked_ops33] (-2 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb41 ]
      
    | bb41 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops34] (-2 : Int8.t)}
          (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = any [ br0 -> {_54 = false} (! bb45) | br1 -> {_54} (! bb42) ]  ]
      
    | bb42 = s0
      [ s0 =  [ &_56 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops35] false) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb44) | br1 -> {_56} (! bb43) ]  ]
      
    | bb43 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops36] (-128 : Int8.t)} {[%#schecked_ops37] (-1 : Int8.t)}
          (fun (_ret':(Int8.t, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb47 ]
      
    | bb47 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops38] (-128 : Int8.t)}
          (fun (_ret':bool) ->  [ &_61 <- _ret' ] s1)
      | s1 = any [ br0 -> {_61 = false} (! bb51) | br1 -> {_61} (! bb48) ]  ]
      
    | bb48 = s0
      [ s0 =  [ &_63 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops39] true) ] s1
      | s1 = any [ br0 -> {_63 = false} (! bb50) | br1 -> {_63} (! bb49) ]  ]
      
    | bb49 = return' {_0}
    | bb50 = bb52
    | bb51 = bb52
    | bb52 = {[%#schecked_ops40] false} any
    | bb44 = bb46
    | bb45 = bb46
    | bb46 = {[%#schecked_ops41] false} any
    | bb38 = bb40
    | bb39 = bb40
    | bb40 = {[%#schecked_ops42] false} any
    | bb34 = {[%#schecked_ops43] false} any
    | bb31 = {[%#schecked_ops44] false} any
    | bb28 = {[%#schecked_ops45] false} any
    | bb25 = {[%#schecked_ops46] false} any
    | bb22 = {[%#schecked_ops47] false} any
    | bb19 = {[%#schecked_ops48] false} any
    | bb16 = {[%#schecked_ops49] false} any
    | bb12 = {[%#schecked_ops50] false} any
    | bb8 = {[%#schecked_ops51] false} any
    | bb4 = {[%#schecked_ops52] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : t_Option'0 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : Int8.t = any_l ()
    | & _9 : t_Option'0 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : Int8.t = any_l ()
    | & _14 : t_Option'0 = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : t_Option'0 = any_l ()
    | & _22 : bool = any_l ()
    | & _23 : Int8.t = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : Int8.t = any_l ()
    | & _30 : bool = any_l ()
    | & _31 : Int8.t = any_l ()
    | & _34 : bool = any_l ()
    | & _35 : Int8.t = any_l ()
    | & _38 : bool = any_l ()
    | & _39 : Int8.t = any_l ()
    | & _42 : bool = any_l ()
    | & _43 : Int8.t = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _47 : bool = any_l ()
    | & _49 : bool = any_l ()
    | & res1 : (Int8.t, bool) = any_l ()
    | & _54 : bool = any_l ()
    | & _56 : bool = any_l ()
    | & res2 : (Int8.t, bool) = any_l ()
    | & _61 : bool = any_l ()
    | & _63 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_no_overflow [#"checked_ops.rs" 313 0 313 44]
  let%span schecked_ops0 = "checked_ops.rs" 314 41 314 46
  let%span schecked_ops1 = "checked_ops.rs" 315 33 315 38
  let%span schecked_ops2 = "checked_ops.rs" 316 35 316 40
  let%span schecked_ops3 = "checked_ops.rs" 318 21 318 26
  let%span schecked_ops4 = "checked_ops.rs" 318 39 318 44
  let%span schecked_ops5 = "checked_ops.rs" 318 4 318 45
  let%span schecked_ops6 = "checked_ops.rs" 316 4 316 41
  let%span schecked_ops7 = "checked_ops.rs" 315 4 315 39
  let%span schecked_ops8 = "checked_ops.rs" 314 4 314 47
  let%span schecked_ops9 = "checked_ops.rs" 312 11 312 46
  let%span snum10 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum11 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption12 = "../../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span snum13 = "../../../creusot-contracts/src/std/num.rs" 120 27 120 36
  let%span snum14 = "../../../creusot-contracts/src/std/num.rs" 122 26 122 83
  let%span snum15 = "../../../creusot-contracts/src/std/num.rs" 124 26 124 89
  let%span snum16 = "../../../creusot-contracts/src/std/num.rs" 130 27 130 36
  let%span snum17 = "../../../creusot-contracts/src/std/num.rs" 132 26 132 89
  let%span snum18 = "../../../creusot-contracts/src/std/num.rs" 134 26 134 89
  let%span snum19 = "../../../creusot-contracts/src/std/num.rs" 140 27 140 36
  let%span snum20 = "../../../creusot-contracts/src/std/num.rs" 142 26 142 85
  let%span snum21 = "../../../creusot-contracts/src/std/num.rs" 144 26 144 91
  let%span snum22 = "../../../creusot-contracts/src/std/num.rs" 146 26 146 74
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  let rec checked_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum10] (result = C_None'0)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum11] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Int8.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Int8.t [inv'1 x] . inv'1 x = true
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int8.t))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption12] self <> C_None'0}
    any [ return' (result:Int8.t)-> {inv'1 result} {[%#soption12] C_Some'0 result = self} (! return' {result}) ] 
  
  let rec wrapping_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= {[@expl:wrapping_div requires] [%#snum13] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:Int8.t)-> {[%#snum14] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self}
      {[%#snum15] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:Int8.t))= {[@expl:saturating_div requires] [%#snum16] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:Int8.t)-> {[%#snum17] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : Int8.t)}
      {[%#snum18] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  let rec overflowing_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:(Int8.t, bool)))= {[@expl:overflowing_div requires] [%#snum19] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(Int8.t, bool))-> {[%#snum20] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      {[%#snum21] Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#snum22] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_no_overflow'0 (a:Int8.t) (b:Int8.t) (return'  (ret:()))= {[@expl:test_i8_div_no_overflow requires] [%#schecked_ops9] Int8.to_int b
    <> 0
    /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div'0 {a} {b} (fun (_ret':t_Option'0) ->  [ &_7 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':Int8.t) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_11 <- a ] s1
      | s1 =  [ &_12 <- b ] s2
      | s2 = Int8.eq {_12} {[%#schecked_ops0] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops0] not _13} s4
      | s4 = bb3 ]
      
    | bb3 = s0
      [ s0 = Int8.eq {_12} {[%#schecked_ops0] (-1 : Int8.t)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.eq {_11} {[%#schecked_ops0] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 =  [ &_16 <- _14 && _15 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops0] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = Int8.div {_11} {_12} (fun (_ret':Int8.t) ->  [ &_10 <- _ret' ] s1)
      | s1 = Int8.eq {_6} {_10} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb6) | br1 -> {_5} (! bb5) ]  ]
      
    | bb5 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_20 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_24 <- a ] s1
      | s1 =  [ &_25 <- b ] s2
      | s2 = Int8.eq {_25} {[%#schecked_ops1] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops1] not _26} s4
      | s4 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_25} {[%#schecked_ops1] (-1 : Int8.t)} (fun (_ret':bool) ->  [ &_27 <- _ret' ] s1)
      | s1 = Int8.eq {_24} {[%#schecked_ops1] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s2)
      | s2 =  [ &_29 <- _27 && _28 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops1] not _29} s4
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = Int8.div {_24} {_25} (fun (_ret':Int8.t) ->  [ &_23 <- _ret' ] s1)
      | s1 = Int8.eq {_20} {_23} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s2)
      | s2 = any [ br0 -> {_19 = false} (! bb11) | br1 -> {_19} (! bb10) ]  ]
      
    | bb10 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':Int8.t) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_37 <- a ] s1
      | s1 =  [ &_38 <- b ] s2
      | s2 = Int8.eq {_38} {[%#schecked_ops2] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops2] not _39} s4
      | s4 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops2] (-1 : Int8.t)} (fun (_ret':bool) ->  [ &_40 <- _ret' ] s1)
      | s1 = Int8.eq {_37} {[%#schecked_ops2] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_41 <- _ret' ] s2)
      | s2 =  [ &_42 <- _40 && _41 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops2] not _42} s4
      | s4 = bb14 ]
      
    | bb14 = s0
      [ s0 = Int8.div {_37} {_38} (fun (_ret':Int8.t) ->  [ &_36 <- _ret' ] s1)
      | s1 = Int8.eq {_33} {_36} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s2)
      | s2 = any [ br0 -> {_32 = false} (! bb16) | br1 -> {_32} (! bb15) ]  ]
      
    | bb15 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(Int8.t, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_51 <- a ] s1
      | s1 =  [ &_52 <- b ] s2
      | s2 = Int8.eq {_52} {[%#schecked_ops3] (0 : Int8.t)} (fun (_ret':bool) ->  [ &_53 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops3] not _53} s4
      | s4 = bb18 ]
      
    | bb18 = s0
      [ s0 = Int8.eq {_52} {[%#schecked_ops3] (-1 : Int8.t)} (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = Int8.eq {_51} {[%#schecked_ops3] (-128 : Int8.t)} (fun (_ret':bool) ->  [ &_55 <- _ret' ] s2)
      | s2 =  [ &_56 <- _54 && _55 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops3] not _56} s4
      | s4 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.div {_51} {_52} (fun (_ret':Int8.t) ->  [ &_50 <- _ret' ] s1)
      | s1 = Int8.eq {let (r'0, _) = res in r'0} {_50} (fun (_ret':bool) ->  [ &_48 <- _ret' ] s2)
      | s2 = any [ br0 -> {_48 = false} (! bb23) | br1 -> {_48} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &_57 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops4] false) ] s1
      | s1 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb21) ]  ]
      
    | bb21 = return' {_0}
    | bb22 = bb24
    | bb23 = bb24
    | bb24 = {[%#schecked_ops5] false} any
    | bb16 = {[%#schecked_ops6] false} any
    | bb11 = {[%#schecked_ops7] false} any
    | bb6 = {[%#schecked_ops8] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : Int8.t = a
    | & b : Int8.t = b
    | & _5 : bool = any_l ()
    | & _6 : Int8.t = any_l ()
    | & _7 : t_Option'0 = any_l ()
    | & _10 : Int8.t = any_l ()
    | & _11 : Int8.t = any_l ()
    | & _12 : Int8.t = any_l ()
    | & _13 : bool = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _16 : bool = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : Int8.t = any_l ()
    | & _23 : Int8.t = any_l ()
    | & _24 : Int8.t = any_l ()
    | & _25 : Int8.t = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _29 : bool = any_l ()
    | & _32 : bool = any_l ()
    | & _33 : Int8.t = any_l ()
    | & _36 : Int8.t = any_l ()
    | & _37 : Int8.t = any_l ()
    | & _38 : Int8.t = any_l ()
    | & _39 : bool = any_l ()
    | & _40 : bool = any_l ()
    | & _41 : bool = any_l ()
    | & _42 : bool = any_l ()
    | & res : (Int8.t, bool) = any_l ()
    | & _48 : bool = any_l ()
    | & _50 : Int8.t = any_l ()
    | & _51 : Int8.t = any_l ()
    | & _52 : Int8.t = any_l ()
    | & _53 : bool = any_l ()
    | & _54 : bool = any_l ()
    | & _55 : bool = any_l ()
    | & _56 : bool = any_l ()
    | & _57 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_zero [#"checked_ops.rs" 322 0 322 30]
  let%span schecked_ops0 = "checked_ops.rs" 323 26 323 27
  let%span schecked_ops1 = "checked_ops.rs" 323 4 323 39
  let%span snum2 = "../../../creusot-contracts/src/std/num.rs" 112 26 112 97
  let%span snum3 = "../../../creusot-contracts/src/std/num.rs" 114 26 114 83
  let%span soption4 = "../../../creusot-contracts/src/std/option.rs" 51 26 51 51
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int8.t
  
  use prelude.prelude.Int8
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  let rec checked_div'0 (self:Int8.t) (rhs:Int8.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#snum2] (result = C_None'0)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum3] forall r : Int8.t . result = C_Some'0 r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Borrow
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = true
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'0 self}
    any [ return' (result:bool)-> {[%#soption4] result = (self = C_None'0)} (! return' {result}) ] 
  
  use prelude.prelude.Intrinsic
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_zero'0 (a:Int8.t) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[%#schecked_ops0] (0 : Int8.t)} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return' {_0}
    | bb4 = {[%#schecked_ops1] false} any ]
    ) [ & _0 : () = any_l () | & a : Int8.t = a | & _3 : bool = any_l () | & _5 : t_Option'0 = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
