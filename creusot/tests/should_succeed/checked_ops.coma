
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  function any_l (_ : 'b) : 'a
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module CheckedOps_TestU8AddExample
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'2 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option uint8 . inv'2 x = true
  predicate invariant'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : uint8)
  let rec inv'1 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : uint8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.UInt8
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_add_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0
          {[#"../checked_ops.rs" 6 12 6 15] (5 : uint8)}
          {[#"../checked_ops.rs" 6 28 6 30] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':uint8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[#"../checked_ops.rs" 6 44 6 46] (15 : uint8)}
          (fun (_ret':bool) ->  [ &_2 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_3 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0
          {[#"../checked_ops.rs" 7 12 7 17] (250 : uint8)}
          {[#"../checked_ops.rs" 7 30 7 32] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ] 
    | bb7 = s0
      [ s0 = wrapping_add'0
          {[#"../checked_ops.rs" 9 12 9 15] (5 : uint8)}
          {[#"../checked_ops.rs" 9 29 9 31] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[#"../checked_ops.rs" 9 36 9 38] (15 : uint8)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_add'0
          {[#"../checked_ops.rs" 10 12 10 17] (250 : uint8)}
          {[#"../checked_ops.rs" 10 31 10 33] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[#"../checked_ops.rs" 10 38 10 39] (4 : uint8)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_17 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_add'0
          {[#"../checked_ops.rs" 12 12 12 15] (5 : uint8)}
          {[#"../checked_ops.rs" 12 31 12 33] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[#"../checked_ops.rs" 12 38 12 40] (15 : uint8)}
          (fun (_ret':bool) ->  [ &_20 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_21 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_add'0
          {[#"../checked_ops.rs" 13 12 13 17] (250 : uint8)}
          {[#"../checked_ops.rs" 13 33 13 35] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[#"../checked_ops.rs" 13 40 13 43] (255 : uint8)}
          (fun (_ret':bool) ->  [ &_24 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_25 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_add'0
          {[#"../checked_ops.rs" 15 14 15 17] (5 : uint8)}
          {[#"../checked_ops.rs" 15 34 15 36] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 16 21 16 23] (15 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 16 36 16 41] false) ] s2
      | s2 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_add'0
          {[#"../checked_ops.rs" 17 14 17 19] (250 : uint8)}
          {[#"../checked_ops.rs" 17 36 17 38] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 18 21 18 22] (4 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 18 35 18 39] true) ] s2
      | s2 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 5 29 19 1] () ] s1 | s1 = return' {_0} ] 
    | bb30 = s0 [ s0 = bb32 ] 
    | bb31 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb32 ] 
    | bb32 = s0 [ s0 = {[#"../checked_ops.rs" 18 4 18 40] false} any ] 
    | bb24 = s0 [ s0 = bb26 ] 
    | bb25 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb26 ] 
    | bb26 = s0 [ s0 = {[#"../checked_ops.rs" 16 4 16 42] false} any ] 
    | bb20 = s0 [ s0 = {[#"../checked_ops.rs" 13 4 13 44] false} any ] 
    | bb17 = s0 [ s0 = {[#"../checked_ops.rs" 12 4 12 41] false} any ] 
    | bb14 = s0 [ s0 = {[#"../checked_ops.rs" 10 4 10 40] false} any ] 
    | bb11 = s0 [ s0 = {[#"../checked_ops.rs" 9 4 9 39] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 7 4 7 44] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 6 4 6 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _3 : uint8 = any_l () : uint8
    | & _4 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _7 : bool = any_l () : bool
    | & _9 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _12 : bool = any_l () : bool
    | & _13 : uint8 = any_l () : uint8
    | & _16 : bool = any_l () : bool
    | & _17 : uint8 = any_l () : uint8
    | & _20 : bool = any_l () : bool
    | & _21 : uint8 = any_l () : uint8
    | & _24 : bool = any_l () : bool
    | & _25 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _29 : bool = any_l () : bool
    | & _31 : bool = any_l () : bool
    | & res1 : (uint8, bool) = any_l () : (uint8, bool)
    | & _36 : bool = any_l () : bool
    | & _38 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8AddOverflow
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.UInt8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_add_overflow (a:uint8) (return'  (ret:()))= {[#"../checked_ops.rs" 22 11 22 18] UInt8.to_int a <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[#"../checked_ops.rs" 24 12 24 17] (255 : uint8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[#"../checked_ops.rs" 25 12 25 17] (255 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {a} {[#"../checked_ops.rs" 25 41 25 42] (1 : uint8)} (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = UInt8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any
            [ any_ (_any:uint8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s2) ] )) ]
            ))
      | s2 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[#"../checked_ops.rs" 26 12 26 17] (255 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_18} {[#"../checked_ops.rs" 26 39 26 42] (255 : uint8)}
          (fun (_ret':bool) ->  [ &_17 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_18 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_17 = false} (! bb10) | br1 -> {_17} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[#"../checked_ops.rs" 27 14 27 19] (255 : uint8)} {a}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {a} {[#"../checked_ops.rs" 28 25 28 26] (1 : uint8)} (fun (_ret':uint8) ->  [ &_26 <- _ret' ] s1)
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_26}
          (fun (_ret':bool) ->  [ &_24 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_26 <- _any ] s2) ] ))
      | s2 = any [ br0 -> {_24 = false} (! bb15) | br1 -> {_24} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_28 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 28 39 28 43] true) ] s2
      | s2 = any [ br0 -> {_28 = false} (! bb14) | br1 -> {_28} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 23 35 29 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 28 4 28 44] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 26 4 26 43] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 25 4 25 43] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 24 4 24 43] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _10 : bool = any_l () : bool
    | & _11 : uint8 = any_l () : uint8
    | & _13 : uint8 = any_l () : uint8
    | & _17 : bool = any_l () : bool
    | & _18 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _24 : bool = any_l () : bool
    | & _26 : uint8 = any_l () : uint8
    | & _28 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8WrappingAdd
  use prelude.UInt8
  use prelude.Intrinsic
  use prelude.UInt8
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec test_u8_wrapping_add (a:uint8) (b:uint8) (return'  (ret:uint8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':uint8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = return' {_0} ]  ]
    ) [ & _0 : uint8 = any_l () : uint8 | & a : uint8 = a | & b : uint8 = b ] 
    [ return' (result:uint8)-> {[@expl:postcondition] [#"../checked_ops.rs" 33 10 33 56] UInt8.to_int result
      = UInt8.to_int a + UInt8.to_int b
      \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256}
      (! return' {result}) ]
    
end
module CheckedOps_TestU8OverflowingAdd
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use prelude.UInt8
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self + UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self + UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self + UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec test_u8_overflowing_add (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_add'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_add'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 39 45 42 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 41 4 41 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 40 4 40 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (uint8, bool) = any_l () : (uint8, bool)
    | & _9 : uint8 = any_l () : uint8
    | & _14 : bool = any_l () : bool
    | & _16 : (uint8, bool) = any_l () : (uint8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8SubExample
  use prelude.UInt8
  predicate invariant'2 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : uint8)
  let rec inv'2 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : uint8 . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'1 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'1 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option uint8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.UInt8
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_sub_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0
          {[#"../checked_ops.rs" 46 12 46 15] (5 : uint8)}
          {[#"../checked_ops.rs" 46 28 46 30] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = checked_sub'0
          {[#"../checked_ops.rs" 47 12 47 17] (250 : uint8)}
          {[#"../checked_ops.rs" 47 30 47 32] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':uint8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[#"../checked_ops.rs" 47 46 47 49] (240 : uint8)}
          (fun (_ret':bool) ->  [ &_7 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_sub'0
          {[#"../checked_ops.rs" 49 12 49 15] (5 : uint8)}
          {[#"../checked_ops.rs" 49 29 49 31] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[#"../checked_ops.rs" 49 36 49 39] (251 : uint8)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_sub'0
          {[#"../checked_ops.rs" 50 12 50 17] (250 : uint8)}
          {[#"../checked_ops.rs" 50 31 50 33] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[#"../checked_ops.rs" 50 38 50 41] (240 : uint8)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_17 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_sub'0
          {[#"../checked_ops.rs" 52 12 52 15] (5 : uint8)}
          {[#"../checked_ops.rs" 52 31 52 33] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[#"../checked_ops.rs" 52 38 52 39] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_20 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_21 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_sub'0
          {[#"../checked_ops.rs" 53 12 53 17] (250 : uint8)}
          {[#"../checked_ops.rs" 53 33 53 35] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[#"../checked_ops.rs" 53 40 53 43] (240 : uint8)}
          (fun (_ret':bool) ->  [ &_24 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_25 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_sub'0
          {[#"../checked_ops.rs" 55 14 55 17] (5 : uint8)}
          {[#"../checked_ops.rs" 55 34 55 36] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 56 21 56 24] (251 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 56 37 56 41] true) ] s2
      | s2 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_sub'0
          {[#"../checked_ops.rs" 57 14 57 19] (250 : uint8)}
          {[#"../checked_ops.rs" 57 36 57 38] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 58 21 58 24] (240 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 58 37 58 42] false) ] s2
      | s2 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 45 29 59 1] () ] s1 | s1 = return' {_0} ] 
    | bb30 = s0 [ s0 = bb32 ] 
    | bb31 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb32 ] 
    | bb32 = s0 [ s0 = {[#"../checked_ops.rs" 58 4 58 43] false} any ] 
    | bb24 = s0 [ s0 = bb26 ] 
    | bb25 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb26 ] 
    | bb26 = s0 [ s0 = {[#"../checked_ops.rs" 56 4 56 42] false} any ] 
    | bb20 = s0 [ s0 = {[#"../checked_ops.rs" 53 4 53 44] false} any ] 
    | bb17 = s0 [ s0 = {[#"../checked_ops.rs" 52 4 52 40] false} any ] 
    | bb14 = s0 [ s0 = {[#"../checked_ops.rs" 50 4 50 42] false} any ] 
    | bb11 = s0 [ s0 = {[#"../checked_ops.rs" 49 4 49 40] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 47 4 47 50] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 46 4 46 42] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _4 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _7 : bool = any_l () : bool
    | & _8 : uint8 = any_l () : uint8
    | & _9 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _12 : bool = any_l () : bool
    | & _13 : uint8 = any_l () : uint8
    | & _16 : bool = any_l () : bool
    | & _17 : uint8 = any_l () : uint8
    | & _20 : bool = any_l () : bool
    | & _21 : uint8 = any_l () : uint8
    | & _24 : bool = any_l () : bool
    | & _25 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _29 : bool = any_l () : bool
    | & _31 : bool = any_l () : bool
    | & res1 : (uint8, bool) = any_l () : (uint8, bool)
    | & _36 : bool = any_l () : bool
    | & _38 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8SubOverflow
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.UInt8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_sub_overflow (a:uint8) (return'  (ret:()))= {[#"../checked_ops.rs" 62 11 62 18] UInt8.to_int a <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[#"../checked_ops.rs" 64 12 64 15] (0 : uint8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[#"../checked_ops.rs" 65 12 65 15] (0 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {[#"../checked_ops.rs" 65 35 65 38] (255 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_14 <- _ret' ] s1)
      | s1 = UInt8.add {_14} {[#"../checked_ops.rs" 65 45 65 46] (1 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_14 <- _any ] s2) ] ))
      | s2 = UInt8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any
            [ any_ (_any:uint8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s3) ] )) ]
            ))
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[#"../checked_ops.rs" 66 12 66 15] (0 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_19} {[#"../checked_ops.rs" 66 37 66 38] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_18 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_19 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[#"../checked_ops.rs" 67 14 67 17] (0 : uint8)} {a}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {[#"../checked_ops.rs" 68 21 68 24] (255 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_28 <- _ret' ] s1)
      | s1 = UInt8.add {_28} {[#"../checked_ops.rs" 68 31 68 32] (1 : uint8)}
          (fun (_ret':uint8) ->  [ &_27 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_28 <- _any ] s2) ] ))
      | s2 = UInt8.eq {let (r'0, _) = res in r'0} {_27}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_27 <- _any ] s3) ] ))
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 68 45 68 49] true) ] s2
      | s2 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 63 35 69 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 68 4 68 50] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 66 4 66 39] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 65 4 65 47] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 64 4 64 41] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _10 : bool = any_l () : bool
    | & _11 : uint8 = any_l () : uint8
    | & _13 : uint8 = any_l () : uint8
    | & _14 : uint8 = any_l () : uint8
    | & _18 : bool = any_l () : bool
    | & _19 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _25 : bool = any_l () : bool
    | & _27 : uint8 = any_l () : uint8
    | & _28 : uint8 = any_l () : uint8
    | & _30 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8WrappingSub
  use prelude.UInt8
  use prelude.Intrinsic
  use prelude.UInt8
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec test_u8_wrapping_sub (a:uint8) (b:uint8) (return'  (ret:uint8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':uint8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = return' {_0} ]  ]
    ) [ & _0 : uint8 = any_l () : uint8 | & a : uint8 = a | & b : uint8 = b ] 
    [ return' (result:uint8)-> {[@expl:postcondition] [#"../checked_ops.rs" 73 10 73 56] UInt8.to_int result
      = UInt8.to_int a - UInt8.to_int b
      \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256}
      (! return' {result}) ]
    
end
module CheckedOps_TestU8OverflowingSub
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use prelude.UInt8
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self - UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self - UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self - UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec test_u8_overflowing_sub (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_sub'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_sub'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 79 45 82 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 81 4 81 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 80 4 80 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (uint8, bool) = any_l () : (uint8, bool)
    | & _9 : uint8 = any_l () : uint8
    | & _14 : bool = any_l () : bool
    | & _16 : (uint8, bool) = any_l () : (uint8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8MulExample
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'2 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option uint8 . inv'2 x = true
  predicate invariant'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : uint8)
  let rec inv'1 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : uint8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.UInt8
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_mul_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0
          {[#"../checked_ops.rs" 86 12 86 15] (5 : uint8)}
          {[#"../checked_ops.rs" 86 28 86 30] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':uint8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[#"../checked_ops.rs" 86 44 86 46] (50 : uint8)}
          (fun (_ret':bool) ->  [ &_2 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_3 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0
          {[#"../checked_ops.rs" 87 12 87 16] (50 : uint8)}
          {[#"../checked_ops.rs" 87 29 87 31] (10 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ] 
    | bb7 = s0
      [ s0 = wrapping_mul'0
          {[#"../checked_ops.rs" 89 12 89 15] (5 : uint8)}
          {[#"../checked_ops.rs" 89 29 89 31] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[#"../checked_ops.rs" 89 36 89 38] (50 : uint8)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_mul'0
          {[#"../checked_ops.rs" 90 12 90 16] (50 : uint8)}
          {[#"../checked_ops.rs" 90 30 90 32] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[#"../checked_ops.rs" 90 37 90 40] (244 : uint8)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_17 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_mul'0
          {[#"../checked_ops.rs" 92 12 92 15] (5 : uint8)}
          {[#"../checked_ops.rs" 92 31 92 33] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[#"../checked_ops.rs" 92 38 92 40] (50 : uint8)}
          (fun (_ret':bool) ->  [ &_20 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_21 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_mul'0
          {[#"../checked_ops.rs" 93 12 93 16] (50 : uint8)}
          {[#"../checked_ops.rs" 93 32 93 34] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[#"../checked_ops.rs" 93 39 93 42] (255 : uint8)}
          (fun (_ret':bool) ->  [ &_24 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_25 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_mul'0
          {[#"../checked_ops.rs" 95 14 95 17] (5 : uint8)}
          {[#"../checked_ops.rs" 95 34 95 36] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 96 21 96 23] (50 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 96 36 96 41] false) ] s2
      | s2 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_mul'0
          {[#"../checked_ops.rs" 97 14 97 18] (50 : uint8)}
          {[#"../checked_ops.rs" 97 35 97 37] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 98 21 98 24] (244 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 98 37 98 41] true) ] s2
      | s2 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 85 29 99 1] () ] s1 | s1 = return' {_0} ] 
    | bb30 = s0 [ s0 = bb32 ] 
    | bb31 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb32 ] 
    | bb32 = s0 [ s0 = {[#"../checked_ops.rs" 98 4 98 42] false} any ] 
    | bb24 = s0 [ s0 = bb26 ] 
    | bb25 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb26 ] 
    | bb26 = s0 [ s0 = {[#"../checked_ops.rs" 96 4 96 42] false} any ] 
    | bb20 = s0 [ s0 = {[#"../checked_ops.rs" 93 4 93 43] false} any ] 
    | bb17 = s0 [ s0 = {[#"../checked_ops.rs" 92 4 92 41] false} any ] 
    | bb14 = s0 [ s0 = {[#"../checked_ops.rs" 90 4 90 41] false} any ] 
    | bb11 = s0 [ s0 = {[#"../checked_ops.rs" 89 4 89 39] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 87 4 87 43] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 86 4 86 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _3 : uint8 = any_l () : uint8
    | & _4 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _7 : bool = any_l () : bool
    | & _9 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _12 : bool = any_l () : bool
    | & _13 : uint8 = any_l () : uint8
    | & _16 : bool = any_l () : bool
    | & _17 : uint8 = any_l () : uint8
    | & _20 : bool = any_l () : bool
    | & _21 : uint8 = any_l () : uint8
    | & _24 : bool = any_l () : bool
    | & _25 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _29 : bool = any_l () : bool
    | & _31 : bool = any_l () : bool
    | & res1 : (uint8, bool) = any_l () : (uint8, bool)
    | & _36 : bool = any_l () : bool
    | & _38 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8MulZero
  use prelude.UInt8
  predicate invariant'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : uint8)
  let rec inv'1 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : uint8 . inv'1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.UInt8
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec saturating_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] UInt8.to_int self
      * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (max'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  let rec test_u8_mul_zero (a:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[#"../checked_ops.rs" 103 12 103 15] (0 : uint8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':uint8) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_4} {[#"../checked_ops.rs" 103 43 103 44] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_3 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_4 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[#"../checked_ops.rs" 104 12 104 15] (0 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_10 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.eq {_10} {[#"../checked_ops.rs" 104 35 104 36] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_9 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_10 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[#"../checked_ops.rs" 105 12 105 15] (0 : uint8)} {a}
          (fun (_ret':uint8) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_15} {[#"../checked_ops.rs" 105 37 105 38] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_14 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_15 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[#"../checked_ops.rs" 106 14 106 17] (0 : uint8)} {a}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 107 21 107 22] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 107 35 107 40] false) ] s2
      | s2 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 102 31 108 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 107 4 107 41] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 105 4 105 39] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 104 4 104 37] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 103 4 103 45] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & _3 : bool = any_l () : bool
    | & _4 : uint8 = any_l () : uint8
    | & _5 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _9 : bool = any_l () : bool
    | & _10 : uint8 = any_l () : uint8
    | & _14 : bool = any_l () : bool
    | & _15 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _21 : bool = any_l () : bool
    | & _23 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8OverflowingMul
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : uint8 = (255 : uint8)
  constant min'0 : uint8 = (0 : uint8)
  use prelude.UInt8
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] UInt8.to_int self
      * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (min'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (max'0 : uint8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] UInt8.to_int self * UInt8.to_int rhs
      > UInt8.to_int (max'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs - k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] UInt8.to_int self * UInt8.to_int rhs
      < UInt8.to_int (min'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs + k * (UInt8.to_int (max'0 : uint8) - UInt8.to_int (min'0 : uint8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] UInt8.to_int self * UInt8.to_int rhs
      >= UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (max'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec test_u8_overflowing_mul (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_mul'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_mul'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 111 45 114 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 113 4 113 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 112 4 112 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (uint8, bool) = any_l () : (uint8, bool)
    | & _9 : uint8 = any_l () : uint8
    | & _14 : bool = any_l () : bool
    | & _16 : (uint8, bool) = any_l () : (uint8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8DivExample
  use prelude.UInt8
  predicate invariant'2 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : uint8)
  let rec inv'2 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : uint8 . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'1 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'1 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option uint8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : uint8 = (0 : uint8)
  use prelude.UInt8
  let rec overflowing_div'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 95 27 95 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 101 26 101 74] (let (_, a) = result in a)
      = (UInt8.to_int self = UInt8.to_int (min'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 99 26 99 91] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 97 16 97 87] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self}
      (! return' {result}) ]
    
  let rec saturating_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 85 27 85 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 89 26 89 89] UInt8.to_int self
      = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 87 16 87 91] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec wrapping_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 75 27 75 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 79 26 79 89] UInt8.to_int self
      = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 77 16 77 85] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int result = UInt8.to_int self}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (min'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_u8_div_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 118 12 118 15] (5 : uint8)}
          {[#"../checked_ops.rs" 118 28 118 29] (0 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 119 12 119 15] (5 : uint8)}
          {[#"../checked_ops.rs" 119 28 119 29] (2 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':uint8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[#"../checked_ops.rs" 119 43 119 44] (2 : uint8)}
          (fun (_ret':bool) ->  [ &_7 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_div'0
          {[#"../checked_ops.rs" 120 12 120 15] (5 : uint8)}
          {[#"../checked_ops.rs" 120 29 120 30] (2 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[#"../checked_ops.rs" 120 35 120 36] (2 : uint8)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = saturating_div'0
          {[#"../checked_ops.rs" 121 12 121 15] (5 : uint8)}
          {[#"../checked_ops.rs" 121 31 121 32] (2 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[#"../checked_ops.rs" 121 37 121 38] (2 : uint8)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_17 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = overflowing_div'0
          {[#"../checked_ops.rs" 122 14 122 17] (5 : uint8)}
          {[#"../checked_ops.rs" 122 34 122 35] (2 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 123 21 123 22] (2 : uint8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb19) | br1 -> {_21} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 123 35 123 40] false) ] s2
      | s2 = any [ br0 -> {_23 = false} (! bb18) | br1 -> {_23} (! bb17) ]  ]
      
    | bb17 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 117 29 124 1] () ] s1 | s1 = return' {_0} ] 
    | bb18 = s0 [ s0 = bb20 ] 
    | bb19 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb20 ] 
    | bb20 = s0 [ s0 = {[#"../checked_ops.rs" 123 4 123 41] false} any ] 
    | bb14 = s0 [ s0 = {[#"../checked_ops.rs" 121 4 121 39] false} any ] 
    | bb11 = s0 [ s0 = {[#"../checked_ops.rs" 120 4 120 37] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 119 4 119 45] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 118 4 118 41] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _4 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _7 : bool = any_l () : bool
    | & _8 : uint8 = any_l () : uint8
    | & _9 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _12 : bool = any_l () : bool
    | & _13 : uint8 = any_l () : uint8
    | & _16 : bool = any_l () : bool
    | & _17 : uint8 = any_l () : uint8
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _21 : bool = any_l () : bool
    | & _23 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8DivNoOverflow
  use prelude.UInt8
  predicate invariant'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : uint8)
  let rec inv'1 (_x:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : uint8 . inv'1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.UInt8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : uint8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (uint8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(uint8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : uint8 = (0 : uint8)
  let rec overflowing_div'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 95 27 95 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:(uint8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 101 26 101 74] (let (_, a) = result in a)
      = (UInt8.to_int self = UInt8.to_int (min'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 99 26 99 91] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 97 16 97 87] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self}
      (! return' {result}) ]
    
  let rec saturating_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 85 27 85 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 89 26 89 89] UInt8.to_int self
      = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 87 16 87 91] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int result = UInt8.to_int (min'0 : uint8)}
      (! return' {result}) ]
    
  let rec wrapping_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 75 27 75 36] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 79 26 79 89] UInt8.to_int self
      = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 77 16 77 85] UInt8.to_int self = UInt8.to_int (min'0 : uint8)
      /\ UInt8.to_int rhs = - 1  -> UInt8.to_int result = UInt8.to_int self}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:uint8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:uint8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (min'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_u8_div_no_overflow (a:uint8) (b:uint8) (return'  (ret:()))= {[#"../checked_ops.rs" 127 11 127 18] UInt8.to_int b
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_7 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':uint8) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- b ] s1
      | s1 = UInt8.eq {_12} {[#"../checked_ops.rs" 129 41 129 46] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [#"../checked_ops.rs" 129 41 129 46] not _13} s3
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = UInt8.div {a} {_12}
          (fun (_ret':uint8) ->  [ &_10 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_12 <- _any ] s1) ] ))
      | s1 = UInt8.eq {_6} {_10}
          (fun (_ret':bool) ->
             [ &_5 <- _ret' ] 
            (any [ any_ (_any:uint8)-> (!  [ &_6 <- _any ] (any [ any_ (_any:uint8)-> (!  [ &_10 <- _any ] s2) ] )) ] ))
      | s2 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb4) ]  ]
      
    | bb4 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_22 <- b ] s1
      | s1 = UInt8.eq {_22} {[#"../checked_ops.rs" 130 33 130 38] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_23 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [#"../checked_ops.rs" 130 33 130 38] not _23} s3
      | s3 = bb7 ]
      
    | bb7 = s0
      [ s0 = UInt8.div {a} {_22}
          (fun (_ret':uint8) ->  [ &_20 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_22 <- _any ] s1) ] ))
      | s1 = UInt8.eq {_17} {_20}
          (fun (_ret':bool) ->
             [ &_16 <- _ret' ] 
            (any
            [ any_ (_any:uint8)-> (!  [ &_17 <- _any ] (any [ any_ (_any:uint8)-> (!  [ &_20 <- _any ] s2) ] )) ]
            ))
      | s2 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':uint8) ->  [ &_27 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_32 <- b ] s1
      | s1 = UInt8.eq {_32} {[#"../checked_ops.rs" 131 35 131 40] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_33 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [#"../checked_ops.rs" 131 35 131 40] not _33} s3
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.div {a} {_32}
          (fun (_ret':uint8) ->  [ &_30 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_32 <- _any ] s1) ] ))
      | s1 = UInt8.eq {_27} {_30}
          (fun (_ret':bool) ->
             [ &_26 <- _ret' ] 
            (any
            [ any_ (_any:uint8)-> (!  [ &_27 <- _any ] (any [ any_ (_any:uint8)-> (!  [ &_30 <- _any ] s2) ] )) ]
            ))
      | s2 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 =  [ &_43 <- b ] s1
      | s1 = UInt8.eq {_43} {[#"../checked_ops.rs" 133 21 133 26] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_44 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [#"../checked_ops.rs" 133 21 133 26] not _44} s3
      | s3 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.div {a} {_43}
          (fun (_ret':uint8) ->  [ &_41 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_43 <- _any ] s1) ] ))
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_41}
          (fun (_ret':bool) ->  [ &_39 <- _ret' ] (any [ any_ (_any:uint8)-> (!  [ &_41 <- _any ] s2) ] ))
      | s2 = any [ br0 -> {_39 = false} (! bb19) | br1 -> {_39} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_45 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 133 39 133 44] false) ] s2
      | s2 = any [ br0 -> {_45 = false} (! bb18) | br1 -> {_45} (! bb17) ]  ]
      
    | bb17 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 128 45 134 1] () ] s1 | s1 = return' {_0} ] 
    | bb18 = s0 [ s0 = bb20 ] 
    | bb19 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb20 ] 
    | bb20 = s0 [ s0 = {[#"../checked_ops.rs" 133 4 133 45] false} any ] 
    | bb13 = s0 [ s0 = {[#"../checked_ops.rs" 131 4 131 41] false} any ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 130 4 130 39] false} any ] 
    | bb5 = s0 [ s0 = {[#"../checked_ops.rs" 129 4 129 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _5 : bool = any_l () : bool
    | & _6 : uint8 = any_l () : uint8
    | & _7 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8
    | & _10 : uint8 = any_l () : uint8
    | & _12 : uint8 = any_l () : uint8
    | & _13 : bool = any_l () : bool
    | & _16 : bool = any_l () : bool
    | & _17 : uint8 = any_l () : uint8
    | & _20 : uint8 = any_l () : uint8
    | & _22 : uint8 = any_l () : uint8
    | & _23 : bool = any_l () : bool
    | & _26 : bool = any_l () : bool
    | & _27 : uint8 = any_l () : uint8
    | & _30 : uint8 = any_l () : uint8
    | & _32 : uint8 = any_l () : uint8
    | & _33 : bool = any_l () : bool
    | & res : (uint8, bool) = any_l () : (uint8, bool)
    | & _39 : bool = any_l () : bool
    | & _41 : uint8 = any_l () : uint8
    | & _43 : uint8 = any_l () : uint8
    | & _44 : bool = any_l () : bool
    | & _45 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestU8DivZero
  use prelude.UInt8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option uint8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option uint8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option uint8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option uint8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : uint8 = (0 : uint8)
  use prelude.UInt8
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Core_Option_Option_Type.t_option uint8))= any
    [ return' (result:Core_Option_Option_Type.t_option uint8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : uint8 . result
      = Core_Option_Option_Type.C_Some r  -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (min'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_u8_div_zero (a:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[#"../checked_ops.rs" 138 26 138 27] (0 : uint8)}
          (fun (_ret':Core_Option_Option_Type.t_option uint8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 137 31 139 1] () ] s1 | s1 = return' {_0} ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 138 4 138 39] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : uint8 = a
    | & _3 : bool = any_l () : bool
    | & _5 : Core_Option_Option_Type.t_option uint8 = any_l () : Core_Option_Option_Type.t_option uint8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8AddExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'2 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option int8 . inv'2 x = true
  predicate invariant'1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : int8)
  let rec inv'1 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : int8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.Int8
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_add_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0
          {[#"../checked_ops.rs" 143 12 143 15] (5 : int8)}
          {[#"../checked_ops.rs" 143 28 143 30] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[#"../checked_ops.rs" 143 44 143 46] (15 : int8)}
          (fun (_ret':bool) ->  [ &_2 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_3 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0
          {[#"../checked_ops.rs" 144 12 144 17] (120 : int8)}
          {[#"../checked_ops.rs" 144 30 144 32] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ] 
    | bb7 = s0
      [ s0 = checked_add'0
          {[#"../checked_ops.rs" 145 12 145 20] (-120 : int8)}
          {[#"../checked_ops.rs" 145 33 145 36] (-10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 = wrapping_add'0
          {[#"../checked_ops.rs" 147 12 147 15] (5 : int8)}
          {[#"../checked_ops.rs" 147 29 147 31] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[#"../checked_ops.rs" 147 36 147 38] (15 : int8)}
          (fun (_ret':bool) ->  [ &_17 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_18 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_add'0
          {[#"../checked_ops.rs" 148 12 148 17] (120 : int8)}
          {[#"../checked_ops.rs" 148 31 148 33] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[#"../checked_ops.rs" 148 38 148 42] (-126 : int8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_22 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_add'0
          {[#"../checked_ops.rs" 149 12 149 20] (-120 : int8)}
          {[#"../checked_ops.rs" 149 34 149 37] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[#"../checked_ops.rs" 149 42 149 45] (126 : int8)}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_26 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_add'0
          {[#"../checked_ops.rs" 151 12 151 15] (5 : int8)}
          {[#"../checked_ops.rs" 151 31 151 33] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[#"../checked_ops.rs" 151 38 151 40] (15 : int8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_30 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_add'0
          {[#"../checked_ops.rs" 152 12 152 17] (120 : int8)}
          {[#"../checked_ops.rs" 152 33 152 35] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[#"../checked_ops.rs" 152 40 152 43] (127 : int8)}
          (fun (_ret':bool) ->  [ &_33 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_34 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_add'0
          {[#"../checked_ops.rs" 153 12 153 20] (-120 : int8)}
          {[#"../checked_ops.rs" 153 36 153 39] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[#"../checked_ops.rs" 153 44 153 48] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_37 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_38 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_add'0
          {[#"../checked_ops.rs" 155 14 155 17] (5 : int8)}
          {[#"../checked_ops.rs" 155 34 155 36] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 156 21 156 23] (15 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 156 36 156 41] false) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_add'0
          {[#"../checked_ops.rs" 157 14 157 19] (120 : int8)}
          {[#"../checked_ops.rs" 157 36 157 38] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 158 21 158 25] (-126 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 158 38 158 42] true) ] s2
      | s2 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_add'0
          {[#"../checked_ops.rs" 159 14 159 22] (-120 : int8)}
          {[#"../checked_ops.rs" 159 39 159 42] (-10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[#"../checked_ops.rs" 160 21 160 24] (126 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 = -{resolve'0 res2}- s1
      | s1 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([#"../checked_ops.rs" 160 37 160 41] true) ] s2
      | s2 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 142 29 161 1] () ] s1 | s1 = return' {_0} ] 
    | bb46 = s0 [ s0 = bb48 ] 
    | bb47 = s0 [ s0 = -{resolve'0 res2}- s1 | s1 = bb48 ] 
    | bb48 = s0 [ s0 = {[#"../checked_ops.rs" 160 4 160 42] false} any ] 
    | bb40 = s0 [ s0 = bb42 ] 
    | bb41 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb42 ] 
    | bb42 = s0 [ s0 = {[#"../checked_ops.rs" 158 4 158 43] false} any ] 
    | bb34 = s0 [ s0 = bb36 ] 
    | bb35 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb36 ] 
    | bb36 = s0 [ s0 = {[#"../checked_ops.rs" 156 4 156 42] false} any ] 
    | bb30 = s0 [ s0 = {[#"../checked_ops.rs" 153 4 153 49] false} any ] 
    | bb27 = s0 [ s0 = {[#"../checked_ops.rs" 152 4 152 44] false} any ] 
    | bb24 = s0 [ s0 = {[#"../checked_ops.rs" 151 4 151 41] false} any ] 
    | bb21 = s0 [ s0 = {[#"../checked_ops.rs" 149 4 149 46] false} any ] 
    | bb18 = s0 [ s0 = {[#"../checked_ops.rs" 148 4 148 43] false} any ] 
    | bb15 = s0 [ s0 = {[#"../checked_ops.rs" 147 4 147 39] false} any ] 
    | bb12 = s0 [ s0 = {[#"../checked_ops.rs" 145 4 145 48] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 144 4 144 44] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 143 4 143 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _3 : int8 = any_l () : int8
    | & _4 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _7 : bool = any_l () : bool
    | & _9 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _12 : bool = any_l () : bool
    | & _14 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _17 : bool = any_l () : bool
    | & _18 : int8 = any_l () : int8
    | & _21 : bool = any_l () : bool
    | & _22 : int8 = any_l () : int8
    | & _25 : bool = any_l () : bool
    | & _26 : int8 = any_l () : int8
    | & _29 : bool = any_l () : bool
    | & _30 : int8 = any_l () : int8
    | & _33 : bool = any_l () : bool
    | & _34 : int8 = any_l () : int8
    | & _37 : bool = any_l () : bool
    | & _38 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _42 : bool = any_l () : bool
    | & _44 : bool = any_l () : bool
    | & res1 : (int8, bool) = any_l () : (int8, bool)
    | & _49 : bool = any_l () : bool
    | & _51 : bool = any_l () : bool
    | & res2 : (int8, bool) = any_l () : (int8, bool)
    | & _56 : bool = any_l () : bool
    | & _58 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8AddOverflowPos
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_add_overflow_pos (a:int8) (return'  (ret:()))= {[#"../checked_ops.rs" 164 11 164 17] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[#"../checked_ops.rs" 166 12 166 17] (127 : int8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[#"../checked_ops.rs" 167 12 167 17] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {a} {[#"../checked_ops.rs" 167 41 167 44] (127 : int8)}
          (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.sub {_14} {[#"../checked_ops.rs" 167 47 167 48] (2 : int8)}
          (fun (_ret':int8) ->  [ &_13 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_14 <- _any ] s2) ] ))
      | s2 = Int8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_13 <- _any ] s3) ] )) ] ))
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[#"../checked_ops.rs" 168 12 168 17] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[#"../checked_ops.rs" 168 39 168 42] (127 : int8)}
          (fun (_ret':bool) ->  [ &_18 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_19 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[#"../checked_ops.rs" 169 14 169 19] (127 : int8)} {a}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {a} {[#"../checked_ops.rs" 170 25 170 28] (127 : int8)}
          (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.sub {_28} {[#"../checked_ops.rs" 170 31 170 32] (2 : int8)}
          (fun (_ret':int8) ->  [ &_27 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_28 <- _any ] s2) ] ))
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_27 <- _any ] s3) ] ))
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 170 45 170 49] true) ] s2
      | s2 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 165 39 171 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 170 4 170 50] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 168 4 168 43] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 167 4 167 49] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 166 4 166 43] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _10 : bool = any_l () : bool
    | & _11 : int8 = any_l () : int8
    | & _13 : int8 = any_l () : int8
    | & _14 : int8 = any_l () : int8
    | & _18 : bool = any_l () : bool
    | & _19 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _25 : bool = any_l () : bool
    | & _27 : int8 = any_l () : int8
    | & _28 : int8 = any_l () : int8
    | & _30 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8AddOverflowNeg
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_add_overflow_neg (a:int8) (return'  (ret:()))= {[#"../checked_ops.rs" 174 11 174 17] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[#"../checked_ops.rs" 176 12 176 20] (-128 : int8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[#"../checked_ops.rs" 177 12 177 20] (-128 : int8)} {a}
          (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {a} {[#"../checked_ops.rs" 177 44 177 47] (127 : int8)}
          (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[#"../checked_ops.rs" 177 50 177 51] (1 : int8)}
          (fun (_ret':int8) ->  [ &_13 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_14 <- _any ] s2) ] ))
      | s2 = Int8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_13 <- _any ] s3) ] )) ] ))
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[#"../checked_ops.rs" 178 12 178 20] (-128 : int8)} {a}
          (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[#"../checked_ops.rs" 178 42 178 46] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_18 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_19 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[#"../checked_ops.rs" 179 14 179 22] (-128 : int8)} {a}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {a} {[#"../checked_ops.rs" 180 25 180 28] (127 : int8)}
          (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[#"../checked_ops.rs" 180 31 180 32] (1 : int8)}
          (fun (_ret':int8) ->  [ &_27 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_28 <- _any ] s2) ] ))
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_27 <- _any ] s3) ] ))
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 180 45 180 49] true) ] s2
      | s2 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 175 39 181 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 180 4 180 50] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 178 4 178 47] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 177 4 177 52] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 176 4 176 46] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _10 : bool = any_l () : bool
    | & _11 : int8 = any_l () : int8
    | & _13 : int8 = any_l () : int8
    | & _14 : int8 = any_l () : int8
    | & _18 : bool = any_l () : bool
    | & _19 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _25 : bool = any_l () : bool
    | & _27 : int8 = any_l () : int8
    | & _28 : int8 = any_l () : int8
    | & _30 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8WrappingAdd
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Int8
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec test_i8_wrapping_add (a:int8) (b:int8) (return'  (ret:int8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':int8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = return' {_0} ]  ]
    ) [ & _0 : int8 = any_l () : int8 | & a : int8 = a | & b : int8 = b ] 
    [ return' (result:int8)-> {[@expl:postcondition] [#"../checked_ops.rs" 185 10 185 84] Int8.to_int result
      = Int8.to_int a + Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256}
      (! return' {result}) ]
    
end
module CheckedOps_TestI8OverflowingAdd
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use prelude.Int8
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self + Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self + Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self + Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec test_i8_overflowing_add (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_add'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_add'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 191 45 194 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 193 4 193 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 192 4 192 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (int8, bool) = any_l () : (int8, bool)
    | & _9 : int8 = any_l () : int8
    | & _14 : bool = any_l () : bool
    | & _16 : (int8, bool) = any_l () : (int8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8SubExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'2 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option int8 . inv'2 x = true
  predicate invariant'1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : int8)
  let rec inv'1 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : int8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.Int8
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_sub_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0
          {[#"../checked_ops.rs" 198 12 198 15] (5 : int8)}
          {[#"../checked_ops.rs" 198 28 198 30] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[#"../checked_ops.rs" 198 44 198 46] (-5 : int8)}
          (fun (_ret':bool) ->  [ &_2 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_3 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_sub'0
          {[#"../checked_ops.rs" 199 12 199 17] (120 : int8)}
          {[#"../checked_ops.rs" 199 30 199 32] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':int8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[#"../checked_ops.rs" 199 46 199 49] (110 : int8)}
          (fun (_ret':bool) ->  [ &_7 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_sub'0
          {[#"../checked_ops.rs" 200 12 200 20] (-120 : int8)}
          {[#"../checked_ops.rs" 200 33 200 35] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 = wrapping_sub'0
          {[#"../checked_ops.rs" 202 12 202 15] (5 : int8)}
          {[#"../checked_ops.rs" 202 29 202 31] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[#"../checked_ops.rs" 202 36 202 38] (-5 : int8)}
          (fun (_ret':bool) ->  [ &_17 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_18 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_sub'0
          {[#"../checked_ops.rs" 203 12 203 17] (120 : int8)}
          {[#"../checked_ops.rs" 203 31 203 33] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[#"../checked_ops.rs" 203 38 203 41] (110 : int8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_22 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_sub'0
          {[#"../checked_ops.rs" 204 12 204 20] (-120 : int8)}
          {[#"../checked_ops.rs" 204 34 204 36] (10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[#"../checked_ops.rs" 204 41 204 44] (126 : int8)}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_26 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_sub'0
          {[#"../checked_ops.rs" 206 12 206 15] (5 : int8)}
          {[#"../checked_ops.rs" 206 31 206 33] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[#"../checked_ops.rs" 206 38 206 40] (-5 : int8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_30 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_sub'0
          {[#"../checked_ops.rs" 207 12 207 17] (120 : int8)}
          {[#"../checked_ops.rs" 207 33 207 35] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[#"../checked_ops.rs" 207 40 207 43] (110 : int8)}
          (fun (_ret':bool) ->  [ &_33 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_34 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_sub'0
          {[#"../checked_ops.rs" 208 12 208 20] (-120 : int8)}
          {[#"../checked_ops.rs" 208 36 208 38] (10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[#"../checked_ops.rs" 208 43 208 47] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_37 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_38 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_sub'0
          {[#"../checked_ops.rs" 210 14 210 17] (5 : int8)}
          {[#"../checked_ops.rs" 210 34 210 36] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 211 21 211 23] (-5 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 211 36 211 41] false) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_sub'0
          {[#"../checked_ops.rs" 212 14 212 19] (120 : int8)}
          {[#"../checked_ops.rs" 212 36 212 38] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 213 21 213 24] (110 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 213 37 213 42] false) ] s2
      | s2 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_sub'0
          {[#"../checked_ops.rs" 214 14 214 22] (-120 : int8)}
          {[#"../checked_ops.rs" 214 39 214 41] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[#"../checked_ops.rs" 215 21 215 24] (126 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 = -{resolve'0 res2}- s1
      | s1 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([#"../checked_ops.rs" 215 37 215 41] true) ] s2
      | s2 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 197 29 216 1] () ] s1 | s1 = return' {_0} ] 
    | bb46 = s0 [ s0 = bb48 ] 
    | bb47 = s0 [ s0 = -{resolve'0 res2}- s1 | s1 = bb48 ] 
    | bb48 = s0 [ s0 = {[#"../checked_ops.rs" 215 4 215 42] false} any ] 
    | bb40 = s0 [ s0 = bb42 ] 
    | bb41 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb42 ] 
    | bb42 = s0 [ s0 = {[#"../checked_ops.rs" 213 4 213 43] false} any ] 
    | bb34 = s0 [ s0 = bb36 ] 
    | bb35 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb36 ] 
    | bb36 = s0 [ s0 = {[#"../checked_ops.rs" 211 4 211 42] false} any ] 
    | bb30 = s0 [ s0 = {[#"../checked_ops.rs" 208 4 208 48] false} any ] 
    | bb27 = s0 [ s0 = {[#"../checked_ops.rs" 207 4 207 44] false} any ] 
    | bb24 = s0 [ s0 = {[#"../checked_ops.rs" 206 4 206 41] false} any ] 
    | bb21 = s0 [ s0 = {[#"../checked_ops.rs" 204 4 204 45] false} any ] 
    | bb18 = s0 [ s0 = {[#"../checked_ops.rs" 203 4 203 42] false} any ] 
    | bb15 = s0 [ s0 = {[#"../checked_ops.rs" 202 4 202 39] false} any ] 
    | bb12 = s0 [ s0 = {[#"../checked_ops.rs" 200 4 200 47] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 199 4 199 50] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 198 4 198 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _3 : int8 = any_l () : int8
    | & _4 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _7 : bool = any_l () : bool
    | & _8 : int8 = any_l () : int8
    | & _9 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _12 : bool = any_l () : bool
    | & _14 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _17 : bool = any_l () : bool
    | & _18 : int8 = any_l () : int8
    | & _21 : bool = any_l () : bool
    | & _22 : int8 = any_l () : int8
    | & _25 : bool = any_l () : bool
    | & _26 : int8 = any_l () : int8
    | & _29 : bool = any_l () : bool
    | & _30 : int8 = any_l () : int8
    | & _33 : bool = any_l () : bool
    | & _34 : int8 = any_l () : int8
    | & _37 : bool = any_l () : bool
    | & _38 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _42 : bool = any_l () : bool
    | & _44 : bool = any_l () : bool
    | & res1 : (int8, bool) = any_l () : (int8, bool)
    | & _49 : bool = any_l () : bool
    | & _51 : bool = any_l () : bool
    | & res2 : (int8, bool) = any_l () : (int8, bool)
    | & _56 : bool = any_l () : bool
    | & _58 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8SubOverflowPos
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_sub_overflow_pos (a:int8) (return'  (ret:()))= {[#"../checked_ops.rs" 219 11 219 17] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[#"../checked_ops.rs" 221 12 221 20] (-128 : int8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[#"../checked_ops.rs" 222 12 222 20] (-128 : int8)} {a}
          (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {[#"../checked_ops.rs" 222 40 222 43] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[#"../checked_ops.rs" 222 50 222 51] (1 : int8)}
          (fun (_ret':int8) ->  [ &_13 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_14 <- _any ] s2) ] ))
      | s2 = Int8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_13 <- _any ] s3) ] )) ] ))
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[#"../checked_ops.rs" 223 12 223 20] (-128 : int8)} {a}
          (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[#"../checked_ops.rs" 223 42 223 46] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_18 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_19 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[#"../checked_ops.rs" 224 14 224 22] (-128 : int8)} {a}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {[#"../checked_ops.rs" 225 21 225 24] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[#"../checked_ops.rs" 225 31 225 32] (1 : int8)}
          (fun (_ret':int8) ->  [ &_27 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_28 <- _any ] s2) ] ))
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_27 <- _any ] s3) ] ))
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 225 45 225 49] true) ] s2
      | s2 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 220 39 226 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 225 4 225 50] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 223 4 223 47] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 222 4 222 52] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 221 4 221 46] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _10 : bool = any_l () : bool
    | & _11 : int8 = any_l () : int8
    | & _13 : int8 = any_l () : int8
    | & _14 : int8 = any_l () : int8
    | & _18 : bool = any_l () : bool
    | & _19 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _25 : bool = any_l () : bool
    | & _27 : int8 = any_l () : int8
    | & _28 : int8 = any_l () : int8
    | & _30 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8SubOverflowNeg
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_sub_overflow_neg (a:int8) (return'  (ret:()))= {[#"../checked_ops.rs" 229 11 229 17] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[#"../checked_ops.rs" 231 12 231 17] (127 : int8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[#"../checked_ops.rs" 232 12 232 17] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {[#"../checked_ops.rs" 232 39 232 40] (2 : int8)} {a} (fun (_ret':int8) ->  [ &_15 <- _ret' ] s1)
      | s1 = Int8.neg {_15}
          (fun (_ret:int8) ->  [ &_14 <- _ret ] (any [ any_ (_any:int8)-> (!  [ &_15 <- _any ] s2) ] ))
      | s2 = Int8.sub {_14} {[#"../checked_ops.rs" 232 48 232 51] (127 : int8)}
          (fun (_ret':int8) ->  [ &_13 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_14 <- _any ] s3) ] ))
      | s3 = Int8.eq {_11} {_13}
          (fun (_ret':bool) ->
             [ &_10 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_13 <- _any ] s4) ] )) ] ))
      | s4 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[#"../checked_ops.rs" 233 12 233 17] (127 : int8)} {a}
          (fun (_ret':int8) ->  [ &_20 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_20} {[#"../checked_ops.rs" 233 39 233 42] (127 : int8)}
          (fun (_ret':bool) ->  [ &_19 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_20 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[#"../checked_ops.rs" 234 14 234 19] (127 : int8)} {a}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {[#"../checked_ops.rs" 235 23 235 24] (2 : int8)} {a} (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = Int8.neg {_30}
          (fun (_ret:int8) ->  [ &_29 <- _ret ] (any [ any_ (_any:int8)-> (!  [ &_30 <- _any ] s2) ] ))
      | s2 = Int8.sub {_29} {[#"../checked_ops.rs" 235 32 235 35] (127 : int8)}
          (fun (_ret':int8) ->  [ &_28 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_29 <- _any ] s3) ] ))
      | s3 = Int8.eq {let (r'0, _) = res in r'0} {_28}
          (fun (_ret':bool) ->  [ &_26 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_28 <- _any ] s4) ] ))
      | s4 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_32 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 235 48 235 52] true) ] s2
      | s2 = any [ br0 -> {_32 = false} (! bb14) | br1 -> {_32} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 230 39 236 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 235 4 235 53] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 233 4 233 43] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 232 4 232 52] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 231 4 231 43] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _4 : bool = any_l () : bool
    | & _6 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _10 : bool = any_l () : bool
    | & _11 : int8 = any_l () : int8
    | & _13 : int8 = any_l () : int8
    | & _14 : int8 = any_l () : int8
    | & _15 : int8 = any_l () : int8
    | & _19 : bool = any_l () : bool
    | & _20 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _26 : bool = any_l () : bool
    | & _28 : int8 = any_l () : int8
    | & _29 : int8 = any_l () : int8
    | & _30 : int8 = any_l () : int8
    | & _32 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8WrappingSub
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Int8
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec test_i8_wrapping_sub (a:int8) (b:int8) (return'  (ret:int8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':int8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = return' {_0} ]  ]
    ) [ & _0 : int8 = any_l () : int8 | & a : int8 = a | & b : int8 = b ] 
    [ return' (result:int8)-> {[@expl:postcondition] [#"../checked_ops.rs" 240 10 240 84] Int8.to_int result
      = Int8.to_int a - Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256}
      (! return' {result}) ]
    
end
module CheckedOps_TestI8OverflowingSub
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use prelude.Int8
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self - Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self - Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self - Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec test_i8_overflowing_sub (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_sub'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_sub'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 246 45 249 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 248 4 248 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 247 4 247 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (int8, bool) = any_l () : (int8, bool)
    | & _9 : int8 = any_l () : int8
    | & _14 : bool = any_l () : bool
    | & _16 : (int8, bool) = any_l () : (int8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8MulExample
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'2 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'2 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Core_Option_Option_Type.t_option int8 . inv'2 x = true
  predicate invariant'1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : int8)
  let rec inv'1 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : int8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.Int8
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_mul_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0
          {[#"../checked_ops.rs" 253 12 253 15] (5 : int8)}
          {[#"../checked_ops.rs" 253 28 253 30] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[#"../checked_ops.rs" 253 44 253 46] (50 : int8)}
          (fun (_ret':bool) ->  [ &_2 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_3 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0
          {[#"../checked_ops.rs" 254 12 254 16] (50 : int8)}
          {[#"../checked_ops.rs" 254 29 254 31] (10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ] 
    | bb7 = s0
      [ s0 = checked_mul'0
          {[#"../checked_ops.rs" 255 12 255 16] (50 : int8)}
          {[#"../checked_ops.rs" 255 29 255 32] (-10 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ] 
    | bb11 = s0
      [ s0 = wrapping_mul'0
          {[#"../checked_ops.rs" 257 12 257 15] (5 : int8)}
          {[#"../checked_ops.rs" 257 29 257 31] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[#"../checked_ops.rs" 257 36 257 38] (50 : int8)}
          (fun (_ret':bool) ->  [ &_17 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_18 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_mul'0
          {[#"../checked_ops.rs" 258 12 258 16] (50 : int8)}
          {[#"../checked_ops.rs" 258 30 258 32] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[#"../checked_ops.rs" 258 37 258 40] (-12 : int8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_22 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_mul'0
          {[#"../checked_ops.rs" 259 12 259 16] (50 : int8)}
          {[#"../checked_ops.rs" 259 30 259 33] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[#"../checked_ops.rs" 259 38 259 40] (12 : int8)}
          (fun (_ret':bool) ->  [ &_25 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_26 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_mul'0
          {[#"../checked_ops.rs" 261 12 261 15] (5 : int8)}
          {[#"../checked_ops.rs" 261 31 261 33] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[#"../checked_ops.rs" 261 38 261 40] (50 : int8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_30 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_mul'0
          {[#"../checked_ops.rs" 262 12 262 16] (50 : int8)}
          {[#"../checked_ops.rs" 262 32 262 34] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[#"../checked_ops.rs" 262 39 262 42] (127 : int8)}
          (fun (_ret':bool) ->  [ &_33 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_34 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_mul'0
          {[#"../checked_ops.rs" 263 12 263 16] (50 : int8)}
          {[#"../checked_ops.rs" 263 32 263 35] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[#"../checked_ops.rs" 263 40 263 44] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_37 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_38 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_mul'0
          {[#"../checked_ops.rs" 265 14 265 17] (5 : int8)}
          {[#"../checked_ops.rs" 265 34 265 36] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 266 21 266 23] (50 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 266 36 266 41] false) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_mul'0
          {[#"../checked_ops.rs" 267 14 267 18] (50 : int8)}
          {[#"../checked_ops.rs" 267 35 267 37] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 268 21 268 24] (-12 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 268 37 268 41] true) ] s2
      | s2 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_mul'0
          {[#"../checked_ops.rs" 269 14 269 18] (50 : int8)}
          {[#"../checked_ops.rs" 269 35 269 38] (-10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[#"../checked_ops.rs" 270 21 270 23] (12 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 = -{resolve'0 res2}- s1
      | s1 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([#"../checked_ops.rs" 270 36 270 40] true) ] s2
      | s2 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 252 29 271 1] () ] s1 | s1 = return' {_0} ] 
    | bb46 = s0 [ s0 = bb48 ] 
    | bb47 = s0 [ s0 = -{resolve'0 res2}- s1 | s1 = bb48 ] 
    | bb48 = s0 [ s0 = {[#"../checked_ops.rs" 270 4 270 41] false} any ] 
    | bb40 = s0 [ s0 = bb42 ] 
    | bb41 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb42 ] 
    | bb42 = s0 [ s0 = {[#"../checked_ops.rs" 268 4 268 42] false} any ] 
    | bb34 = s0 [ s0 = bb36 ] 
    | bb35 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb36 ] 
    | bb36 = s0 [ s0 = {[#"../checked_ops.rs" 266 4 266 42] false} any ] 
    | bb30 = s0 [ s0 = {[#"../checked_ops.rs" 263 4 263 45] false} any ] 
    | bb27 = s0 [ s0 = {[#"../checked_ops.rs" 262 4 262 43] false} any ] 
    | bb24 = s0 [ s0 = {[#"../checked_ops.rs" 261 4 261 41] false} any ] 
    | bb21 = s0 [ s0 = {[#"../checked_ops.rs" 259 4 259 41] false} any ] 
    | bb18 = s0 [ s0 = {[#"../checked_ops.rs" 258 4 258 41] false} any ] 
    | bb15 = s0 [ s0 = {[#"../checked_ops.rs" 257 4 257 39] false} any ] 
    | bb12 = s0 [ s0 = {[#"../checked_ops.rs" 255 4 255 44] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 254 4 254 43] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 253 4 253 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _3 : int8 = any_l () : int8
    | & _4 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _7 : bool = any_l () : bool
    | & _9 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _12 : bool = any_l () : bool
    | & _14 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _17 : bool = any_l () : bool
    | & _18 : int8 = any_l () : int8
    | & _21 : bool = any_l () : bool
    | & _22 : int8 = any_l () : int8
    | & _25 : bool = any_l () : bool
    | & _26 : int8 = any_l () : int8
    | & _29 : bool = any_l () : bool
    | & _30 : int8 = any_l () : int8
    | & _33 : bool = any_l () : bool
    | & _34 : int8 = any_l () : int8
    | & _37 : bool = any_l () : bool
    | & _38 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _42 : bool = any_l () : bool
    | & _44 : bool = any_l () : bool
    | & res1 : (int8, bool) = any_l () : (int8, bool)
    | & _49 : bool = any_l () : bool
    | & _51 : bool = any_l () : bool
    | & res2 : (int8, bool) = any_l () : (int8, bool)
    | & _56 : bool = any_l () : bool
    | & _58 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8MulZero
  use prelude.Int8
  predicate invariant'1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : int8)
  let rec inv'1 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : int8 . inv'1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  use prelude.Int8
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec saturating_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 174 16 174 85] Int8.to_int self
      * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)  -> Int8.to_int result = Int8.to_int (max'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 173 16 173 85] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 168 16 171 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  let rec test_i8_mul_zero (a:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[#"../checked_ops.rs" 275 12 275 15] (0 : int8)} {a}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':int8) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_4} {[#"../checked_ops.rs" 275 43 275 44] (0 : int8)}
          (fun (_ret':bool) ->  [ &_3 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_4 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[#"../checked_ops.rs" 276 12 276 15] (0 : int8)} {a}
          (fun (_ret':int8) ->  [ &_10 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.eq {_10} {[#"../checked_ops.rs" 276 35 276 36] (0 : int8)}
          (fun (_ret':bool) ->  [ &_9 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_10 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[#"../checked_ops.rs" 277 12 277 15] (0 : int8)} {a}
          (fun (_ret':int8) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_15} {[#"../checked_ops.rs" 277 37 277 38] (0 : int8)}
          (fun (_ret':bool) ->  [ &_14 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_15 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[#"../checked_ops.rs" 278 14 278 17] (0 : int8)} {a}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 279 21 279 22] (0 : int8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 279 35 279 40] false) ] s2
      | s2 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 274 31 280 1] () ] s1 | s1 = return' {_0} ] 
    | bb14 = s0 [ s0 = bb16 ] 
    | bb15 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 279 4 279 41] false} any ] 
    | bb10 = s0 [ s0 = {[#"../checked_ops.rs" 277 4 277 39] false} any ] 
    | bb7 = s0 [ s0 = {[#"../checked_ops.rs" 276 4 276 37] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 275 4 275 45] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _3 : bool = any_l () : bool
    | & _4 : int8 = any_l () : int8
    | & _5 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _9 : bool = any_l () : bool
    | & _10 : int8 = any_l () : int8
    | & _14 : bool = any_l () : bool
    | & _15 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _21 : bool = any_l () : bool
    | & _23 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8OverflowingMul
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant max'0 : int8 = (127 : int8)
  constant min'0 : int8 = (-128 : int8)
  use prelude.Int8
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 133 16 133 89] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 129 20 130 89] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      (! return' {result}) ]
    
  use int.EuclideanDivision
  use int.Power
  use prelude.UInt32
  use prelude.UInt32
  constant bits'0 : uint32 = (8 : uint32)
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 156 16 160 18] Int8.to_int self
      * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 151 16 155 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 144 16 147 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 141 20 141 93] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 205 20 205 98] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (min'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (max'0 : int8))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 198 16 202 18] Int8.to_int self * Int8.to_int rhs
      > Int8.to_int (max'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 193 16 197 18] Int8.to_int self * Int8.to_int rhs
      < Int8.to_int (min'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (max'0 : int8) - Int8.to_int (min'0 : int8) + 1))}
      {[#"../../../../creusot-contracts/src/std/num.rs" 186 16 189 18] Int8.to_int self * Int8.to_int rhs
      >= Int8.to_int (min'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (max'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[#"../../../../creusot-contracts/src/std/num.rs" 183 20 183 95] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (bits'0 : uint32)))
      + Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec test_i8_overflowing_mul (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = -{resolve'0 _6}- s1 | s1 = wrapping_mul'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s2) | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9}
          (fun (_ret':bool) ->  [ &_4 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_9 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = -{resolve'0 _16}- s1
      | s1 = checked_mul'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] (any [ any_ (_any:bool)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 283 45 286 1] () ] s1 | s1 = return' {_0} ] 
    | bb9 = s0 [ s0 = {[#"../checked_ops.rs" 285 4 285 65] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 284 4 284 56] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l () : bool
    | & _6 : (int8, bool) = any_l () : (int8, bool)
    | & _9 : int8 = any_l () : int8
    | & _14 : bool = any_l () : bool
    | & _16 : (int8, bool) = any_l () : (int8, bool)
    | & _19 : bool = any_l () : bool
    | & _21 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8DivExample
  use prelude.Int8
  predicate invariant'2 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : int8)
  let rec inv'2 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : int8 . inv'2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'1 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'1 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Core_Option_Option_Type.t_option int8 . inv'1 x = true
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : int8 = (-128 : int8)
  use prelude.Int8
  let rec overflowing_div'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 95 27 95 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 101 26 101 74] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (min'0 : int8) /\ Int8.to_int rhs = - 1)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 99 26 99 91] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 97 16 97 87] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      (! return' {result}) ]
    
  let rec saturating_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 85 27 85 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 89 26 89 89] Int8.to_int self
      = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 87 16 87 91] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec wrapping_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 75 27 75 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 79 26 79 89] Int8.to_int self
      = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 77 16 77 85] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int result = Int8.to_int self}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'1 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'2 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (min'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_i8_div_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 290 12 290 15] (5 : int8)}
          {[#"../checked_ops.rs" 290 28 290 29] (0 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 291 12 291 15] (5 : int8)}
          {[#"../checked_ops.rs" 291 28 291 29] (2 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':int8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[#"../checked_ops.rs" 291 43 291 44] (2 : int8)}
          (fun (_ret':bool) ->  [ &_7 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 292 12 292 15] (5 : int8)}
          {[#"../checked_ops.rs" 292 28 292 30] (-2 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 = Int8.eq {_13} {[#"../checked_ops.rs" 292 44 292 46] (-2 : int8)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ]
      
    | bb11 = s0
      [ s0 = checked_div'0
          {[#"../checked_ops.rs" 293 12 293 20] (-128 : int8)}
          {[#"../checked_ops.rs" 293 33 293 35] (-1 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0 [ s0 = is_none'0 {_19} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0 [ s0 = any [ br0 -> {_17 = false} (! bb16) | br1 -> {_17} (! bb15) ]  ] 
    | bb15 = s0
      [ s0 = wrapping_div'0
          {[#"../checked_ops.rs" 295 12 295 15] (5 : int8)}
          {[#"../checked_ops.rs" 295 29 295 30] (2 : int8)}
          (fun (_ret':int8) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb17 ]
      
    | bb17 = s0
      [ s0 = Int8.eq {_23} {[#"../checked_ops.rs" 295 35 295 36] (2 : int8)}
          (fun (_ret':bool) ->  [ &_22 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_23 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb18) ]  ]
      
    | bb18 = s0
      [ s0 = wrapping_div'0
          {[#"../checked_ops.rs" 296 12 296 15] (5 : int8)}
          {[#"../checked_ops.rs" 296 29 296 31] (-2 : int8)}
          (fun (_ret':int8) ->  [ &_27 <- _ret' ] s1)
      | s1 = bb20 ]
      
    | bb20 = s0
      [ s0 = Int8.eq {_27} {[#"../checked_ops.rs" 296 36 296 38] (-2 : int8)}
          (fun (_ret':bool) ->  [ &_26 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_27 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb21) ]  ]
      
    | bb21 = s0
      [ s0 = wrapping_div'0
          {[#"../checked_ops.rs" 297 12 297 20] (-128 : int8)}
          {[#"../checked_ops.rs" 297 34 297 36] (-1 : int8)}
          (fun (_ret':int8) ->  [ &_31 <- _ret' ] s1)
      | s1 = bb23 ]
      
    | bb23 = s0
      [ s0 = Int8.eq {_31} {[#"../checked_ops.rs" 297 41 297 45] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_30 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_31 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_30 = false} (! bb25) | br1 -> {_30} (! bb24) ]  ]
      
    | bb24 = s0
      [ s0 = saturating_div'0
          {[#"../checked_ops.rs" 299 12 299 15] (5 : int8)}
          {[#"../checked_ops.rs" 299 31 299 32] (2 : int8)}
          (fun (_ret':int8) ->  [ &_35 <- _ret' ] s1)
      | s1 = bb26 ]
      
    | bb26 = s0
      [ s0 = Int8.eq {_35} {[#"../checked_ops.rs" 299 37 299 38] (2 : int8)}
          (fun (_ret':bool) ->  [ &_34 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_35 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_34 = false} (! bb28) | br1 -> {_34} (! bb27) ]  ]
      
    | bb27 = s0
      [ s0 = saturating_div'0
          {[#"../checked_ops.rs" 300 12 300 15] (5 : int8)}
          {[#"../checked_ops.rs" 300 31 300 33] (-2 : int8)}
          (fun (_ret':int8) ->  [ &_39 <- _ret' ] s1)
      | s1 = bb29 ]
      
    | bb29 = s0
      [ s0 = Int8.eq {_39} {[#"../checked_ops.rs" 300 38 300 40] (-2 : int8)}
          (fun (_ret':bool) ->  [ &_38 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_39 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_38 = false} (! bb31) | br1 -> {_38} (! bb30) ]  ]
      
    | bb30 = s0
      [ s0 = saturating_div'0
          {[#"../checked_ops.rs" 301 12 301 20] (-128 : int8)}
          {[#"../checked_ops.rs" 301 36 301 38] (-1 : int8)}
          (fun (_ret':int8) ->  [ &_43 <- _ret' ] s1)
      | s1 = bb32 ]
      
    | bb32 = s0
      [ s0 = Int8.eq {_43} {[#"../checked_ops.rs" 301 43 301 47] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_43 <- _any ] s1) ] ))
      | s1 = any [ br0 -> {_42 = false} (! bb34) | br1 -> {_42} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_div'0
          {[#"../checked_ops.rs" 303 14 303 17] (5 : int8)}
          {[#"../checked_ops.rs" 303 34 303 35] (2 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb35 ]
      
    | bb35 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[#"../checked_ops.rs" 304 21 304 22] (2 : int8)}
          (fun (_ret':bool) ->  [ &_47 <- _ret' ] s1)
      | s1 = any [ br0 -> {_47 = false} (! bb39) | br1 -> {_47} (! bb36) ]  ]
      
    | bb36 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_49 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 304 35 304 40] false) ] s2
      | s2 = any [ br0 -> {_49 = false} (! bb38) | br1 -> {_49} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 = overflowing_div'0
          {[#"../checked_ops.rs" 305 14 305 17] (5 : int8)}
          {[#"../checked_ops.rs" 305 34 305 36] (-2 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb41 ]
      
    | bb41 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[#"../checked_ops.rs" 306 21 306 23] (-2 : int8)}
          (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = any [ br0 -> {_54 = false} (! bb45) | br1 -> {_54} (! bb42) ]  ]
      
    | bb42 = s0
      [ s0 = -{resolve'0 res1}- s1
      | s1 =  [ &_56 <- Bool.eq (let (_, r'0) = res1 in r'0) ([#"../checked_ops.rs" 306 36 306 41] false) ] s2
      | s2 = any [ br0 -> {_56 = false} (! bb44) | br1 -> {_56} (! bb43) ]  ]
      
    | bb43 = s0
      [ s0 = overflowing_div'0
          {[#"../checked_ops.rs" 307 14 307 22] (-128 : int8)}
          {[#"../checked_ops.rs" 307 39 307 41] (-1 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb47 ]
      
    | bb47 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[#"../checked_ops.rs" 308 21 308 25] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_61 <- _ret' ] s1)
      | s1 = any [ br0 -> {_61 = false} (! bb51) | br1 -> {_61} (! bb48) ]  ]
      
    | bb48 = s0
      [ s0 = -{resolve'0 res2}- s1
      | s1 =  [ &_63 <- Bool.eq (let (_, r'0) = res2 in r'0) ([#"../checked_ops.rs" 308 38 308 42] true) ] s2
      | s2 = any [ br0 -> {_63 = false} (! bb50) | br1 -> {_63} (! bb49) ]  ]
      
    | bb49 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 289 29 309 1] () ] s1 | s1 = return' {_0} ] 
    | bb50 = s0 [ s0 = bb52 ] 
    | bb51 = s0 [ s0 = -{resolve'0 res2}- s1 | s1 = bb52 ] 
    | bb52 = s0 [ s0 = {[#"../checked_ops.rs" 308 4 308 43] false} any ] 
    | bb44 = s0 [ s0 = bb46 ] 
    | bb45 = s0 [ s0 = -{resolve'0 res1}- s1 | s1 = bb46 ] 
    | bb46 = s0 [ s0 = {[#"../checked_ops.rs" 306 4 306 42] false} any ] 
    | bb38 = s0 [ s0 = bb40 ] 
    | bb39 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb40 ] 
    | bb40 = s0 [ s0 = {[#"../checked_ops.rs" 304 4 304 41] false} any ] 
    | bb34 = s0 [ s0 = {[#"../checked_ops.rs" 301 4 301 48] false} any ] 
    | bb31 = s0 [ s0 = {[#"../checked_ops.rs" 300 4 300 41] false} any ] 
    | bb28 = s0 [ s0 = {[#"../checked_ops.rs" 299 4 299 39] false} any ] 
    | bb25 = s0 [ s0 = {[#"../checked_ops.rs" 297 4 297 46] false} any ] 
    | bb22 = s0 [ s0 = {[#"../checked_ops.rs" 296 4 296 39] false} any ] 
    | bb19 = s0 [ s0 = {[#"../checked_ops.rs" 295 4 295 37] false} any ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 293 4 293 47] false} any ] 
    | bb12 = s0 [ s0 = {[#"../checked_ops.rs" 292 4 292 47] false} any ] 
    | bb8 = s0 [ s0 = {[#"../checked_ops.rs" 291 4 291 45] false} any ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 290 4 290 41] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & _2 : bool = any_l () : bool
    | & _4 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _7 : bool = any_l () : bool
    | & _8 : int8 = any_l () : int8
    | & _9 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _12 : bool = any_l () : bool
    | & _13 : int8 = any_l () : int8
    | & _14 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _17 : bool = any_l () : bool
    | & _19 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _22 : bool = any_l () : bool
    | & _23 : int8 = any_l () : int8
    | & _26 : bool = any_l () : bool
    | & _27 : int8 = any_l () : int8
    | & _30 : bool = any_l () : bool
    | & _31 : int8 = any_l () : int8
    | & _34 : bool = any_l () : bool
    | & _35 : int8 = any_l () : int8
    | & _38 : bool = any_l () : bool
    | & _39 : int8 = any_l () : int8
    | & _42 : bool = any_l () : bool
    | & _43 : int8 = any_l () : int8
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _47 : bool = any_l () : bool
    | & _49 : bool = any_l () : bool
    | & res1 : (int8, bool) = any_l () : (int8, bool)
    | & _54 : bool = any_l () : bool
    | & _56 : bool = any_l () : bool
    | & res2 : (int8, bool) = any_l () : (int8, bool)
    | & _61 : bool = any_l () : bool
    | & _63 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8DivNoOverflow
  use prelude.Int8
  predicate invariant'1 (self : int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : int8)
  let rec inv'1 (_x:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : int8 . inv'1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Int8
  use prelude.Intrinsic
  use prelude.Bool
  predicate resolve'2 (self : bool) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'2 (self:bool) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : int8) =
    [#"../../../../creusot-contracts/src/resolve.rs" 46 8 46 12] true
  let rec resolve'1 (self:int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  predicate resolve'0 (self : (int8, bool)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 17 8 17 60] resolve'1 (let (a, _) = self in a)
    /\ resolve'2 (let (_, a) = self in a)
  let rec resolve'0 (self:(int8, bool)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : int8 = (-128 : int8)
  let rec overflowing_div'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 95 27 95 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(int8, bool))-> {[#"../../../../creusot-contracts/src/std/num.rs" 101 26 101 74] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (min'0 : int8) /\ Int8.to_int rhs = - 1)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 99 26 99 91] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 97 16 97 87] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      (! return' {result}) ]
    
  let rec saturating_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 85 27 85 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 89 26 89 89] Int8.to_int self
      = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 87 16 87 91] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int result = Int8.to_int (min'0 : int8)}
      (! return' {result}) ]
    
  let rec wrapping_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/num.rs" 75 27 75 36] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 79 26 79 89] Int8.to_int self
      = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 77 16 77 85] Int8.to_int self = Int8.to_int (min'0 : int8)
      /\ Int8.to_int rhs = - 1  -> Int8.to_int result = Int8.to_int self}
      (! return' {result}) ]
    
  let rec unwrap'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:int8))= {[@expl:precondition] inv'0 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] self
    <> Core_Option_Option_Type.C_None}
    any
    [ return' (result:int8)-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/option.rs" 29 0 140 1] Core_Option_Option_Type.C_Some result = self}
      (! return' {result}) ]
    
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (min'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_i8_div_no_overflow (a:int8) (b:int8) (return'  (ret:()))= {[#"../checked_ops.rs" 312 11 312 46] Int8.to_int b
    <> 0
    /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {b} (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_7 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':int8) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_11 <- a ] s1
      | s1 =  [ &_12 <- b ] s2
      | s2 = Int8.eq {_12} {[#"../checked_ops.rs" 314 41 314 46] (0 : int8)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [#"../checked_ops.rs" 314 41 314 46] not _13} s4
      | s4 = bb3 ]
      
    | bb3 = s0
      [ s0 = Int8.eq {_12} {[#"../checked_ops.rs" 314 41 314 46] (-1 : int8)}
          (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.eq {_11} {[#"../checked_ops.rs" 314 41 314 46] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 =  [ &_16 <- _14 && _15 ] 
        (any [ any_ (_any:bool)-> (!  [ &_14 <- _any ] (any [ any_ (_any:bool)-> (!  [ &_15 <- _any ] s3) ] )) ] )
      | s3 = {[@expl:Div overflow] [#"../checked_ops.rs" 314 41 314 46] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = Int8.div {_11} {_12}
          (fun (_ret':int8) ->
             [ &_10 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_11 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_12 <- _any ] s1) ] )) ] ))
      | s1 = Int8.eq {_6} {_10}
          (fun (_ret':bool) ->
             [ &_5 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_6 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_10 <- _any ] s2) ] )) ] ))
      | s2 = any [ br0 -> {_5 = false} (! bb6) | br1 -> {_5} (! bb5) ]  ]
      
    | bb5 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':int8) ->  [ &_20 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_24 <- a ] s1
      | s1 =  [ &_25 <- b ] s2
      | s2 = Int8.eq {_25} {[#"../checked_ops.rs" 315 33 315 38] (0 : int8)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [#"../checked_ops.rs" 315 33 315 38] not _26} s4
      | s4 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_25} {[#"../checked_ops.rs" 315 33 315 38] (-1 : int8)}
          (fun (_ret':bool) ->  [ &_27 <- _ret' ] s1)
      | s1 = Int8.eq {_24} {[#"../checked_ops.rs" 315 33 315 38] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_28 <- _ret' ] s2)
      | s2 =  [ &_29 <- _27 && _28 ] 
        (any [ any_ (_any:bool)-> (!  [ &_27 <- _any ] (any [ any_ (_any:bool)-> (!  [ &_28 <- _any ] s3) ] )) ] )
      | s3 = {[@expl:Div overflow] [#"../checked_ops.rs" 315 33 315 38] not _29} s4
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = Int8.div {_24} {_25}
          (fun (_ret':int8) ->
             [ &_23 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_24 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_25 <- _any ] s1) ] )) ] ))
      | s1 = Int8.eq {_20} {_23}
          (fun (_ret':bool) ->
             [ &_19 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_20 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_23 <- _any ] s2) ] )) ] ))
      | s2 = any [ br0 -> {_19 = false} (! bb11) | br1 -> {_19} (! bb10) ]  ]
      
    | bb10 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':int8) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_37 <- a ] s1
      | s1 =  [ &_38 <- b ] s2
      | s2 = Int8.eq {_38} {[#"../checked_ops.rs" 316 35 316 40] (0 : int8)} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [#"../checked_ops.rs" 316 35 316 40] not _39} s4
      | s4 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_38} {[#"../checked_ops.rs" 316 35 316 40] (-1 : int8)}
          (fun (_ret':bool) ->  [ &_40 <- _ret' ] s1)
      | s1 = Int8.eq {_37} {[#"../checked_ops.rs" 316 35 316 40] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_41 <- _ret' ] s2)
      | s2 =  [ &_42 <- _40 && _41 ] 
        (any [ any_ (_any:bool)-> (!  [ &_40 <- _any ] (any [ any_ (_any:bool)-> (!  [ &_41 <- _any ] s3) ] )) ] )
      | s3 = {[@expl:Div overflow] [#"../checked_ops.rs" 316 35 316 40] not _42} s4
      | s4 = bb14 ]
      
    | bb14 = s0
      [ s0 = Int8.div {_37} {_38}
          (fun (_ret':int8) ->
             [ &_36 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_37 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_38 <- _any ] s1) ] )) ] ))
      | s1 = Int8.eq {_33} {_36}
          (fun (_ret':bool) ->
             [ &_32 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_33 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_36 <- _any ] s2) ] )) ] ))
      | s2 = any [ br0 -> {_32 = false} (! bb16) | br1 -> {_32} (! bb15) ]  ]
      
    | bb15 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_51 <- a ] s1
      | s1 =  [ &_52 <- b ] s2
      | s2 = Int8.eq {_52} {[#"../checked_ops.rs" 318 21 318 26] (0 : int8)} (fun (_ret':bool) ->  [ &_53 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [#"../checked_ops.rs" 318 21 318 26] not _53} s4
      | s4 = bb18 ]
      
    | bb18 = s0
      [ s0 = Int8.eq {_52} {[#"../checked_ops.rs" 318 21 318 26] (-1 : int8)}
          (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = Int8.eq {_51} {[#"../checked_ops.rs" 318 21 318 26] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_55 <- _ret' ] s2)
      | s2 =  [ &_56 <- _54 && _55 ] 
        (any [ any_ (_any:bool)-> (!  [ &_54 <- _any ] (any [ any_ (_any:bool)-> (!  [ &_55 <- _any ] s3) ] )) ] )
      | s3 = {[@expl:Div overflow] [#"../checked_ops.rs" 318 21 318 26] not _56} s4
      | s4 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.div {_51} {_52}
          (fun (_ret':int8) ->
             [ &_50 <- _ret' ] 
            (any [ any_ (_any:int8)-> (!  [ &_51 <- _any ] (any [ any_ (_any:int8)-> (!  [ &_52 <- _any ] s1) ] )) ] ))
      | s1 = Int8.eq {let (r'0, _) = res in r'0} {_50}
          (fun (_ret':bool) ->  [ &_48 <- _ret' ] (any [ any_ (_any:int8)-> (!  [ &_50 <- _any ] s2) ] ))
      | s2 = any [ br0 -> {_48 = false} (! bb23) | br1 -> {_48} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = -{resolve'0 res}- s1
      | s1 =  [ &_57 <- Bool.eq (let (_, r'0) = res in r'0) ([#"../checked_ops.rs" 318 39 318 44] false) ] s2
      | s2 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb21) ]  ]
      
    | bb21 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 313 45 319 1] () ] s1 | s1 = return' {_0} ] 
    | bb22 = s0 [ s0 = bb24 ] 
    | bb23 = s0 [ s0 = -{resolve'0 res}- s1 | s1 = bb24 ] 
    | bb24 = s0 [ s0 = {[#"../checked_ops.rs" 318 4 318 45] false} any ] 
    | bb16 = s0 [ s0 = {[#"../checked_ops.rs" 316 4 316 41] false} any ] 
    | bb11 = s0 [ s0 = {[#"../checked_ops.rs" 315 4 315 39] false} any ] 
    | bb6 = s0 [ s0 = {[#"../checked_ops.rs" 314 4 314 47] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & b : int8 = b
    | & _5 : bool = any_l () : bool
    | & _6 : int8 = any_l () : int8
    | & _7 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8
    | & _10 : int8 = any_l () : int8
    | & _11 : int8 = any_l () : int8
    | & _12 : int8 = any_l () : int8
    | & _13 : bool = any_l () : bool
    | & _14 : bool = any_l () : bool
    | & _15 : bool = any_l () : bool
    | & _16 : bool = any_l () : bool
    | & _19 : bool = any_l () : bool
    | & _20 : int8 = any_l () : int8
    | & _23 : int8 = any_l () : int8
    | & _24 : int8 = any_l () : int8
    | & _25 : int8 = any_l () : int8
    | & _26 : bool = any_l () : bool
    | & _27 : bool = any_l () : bool
    | & _28 : bool = any_l () : bool
    | & _29 : bool = any_l () : bool
    | & _32 : bool = any_l () : bool
    | & _33 : int8 = any_l () : int8
    | & _36 : int8 = any_l () : int8
    | & _37 : int8 = any_l () : int8
    | & _38 : int8 = any_l () : int8
    | & _39 : bool = any_l () : bool
    | & _40 : bool = any_l () : bool
    | & _41 : bool = any_l () : bool
    | & _42 : bool = any_l () : bool
    | & res : (int8, bool) = any_l () : (int8, bool)
    | & _48 : bool = any_l () : bool
    | & _50 : int8 = any_l () : int8
    | & _51 : int8 = any_l () : int8
    | & _52 : int8 = any_l () : int8
    | & _53 : bool = any_l () : bool
    | & _54 : bool = any_l () : bool
    | & _55 : bool = any_l () : bool
    | & _56 : bool = any_l () : bool
    | & _57 : bool = any_l () : bool ]
     [ return' (result:())-> (! return' {result}) ] 
end
module CheckedOps_TestI8DivZero
  use prelude.Int8
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'0 (self : Core_Option_Option_Type.t_option int8) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Core_Option_Option_Type.t_option int8)
  let rec inv'0 (_x:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Core_Option_Option_Type.t_option int8 . inv'0 x = true
  use prelude.Intrinsic
  use prelude.Borrow
  let rec is_none'0 (self:Core_Option_Option_Type.t_option int8) (return'  (ret:bool))= {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/option.rs" 38 26 38 51] result
      = (self = Core_Option_Option_Type.C_None)}
      (! return' {result}) ]
    
  use prelude.Int
  constant min'0 : int8 = (-128 : int8)
  use prelude.Int8
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Core_Option_Option_Type.t_option int8))= any
    [ return' (result:Core_Option_Option_Type.t_option int8)-> {[#"../../../../creusot-contracts/src/std/num.rs" 69 16 69 85] forall r : int8 . result
      = Core_Option_Option_Type.C_Some r  -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[#"../../../../creusot-contracts/src/std/num.rs" 67 26 67 97] (result = Core_Option_Option_Type.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (min'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  let rec test_i8_div_zero (a:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[#"../checked_ops.rs" 323 26 323 27] (0 : int8)}
          (fun (_ret':Core_Option_Option_Type.t_option int8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [#"../checked_ops.rs" 322 31 324 1] () ] s1 | s1 = return' {_0} ] 
    | bb4 = s0 [ s0 = {[#"../checked_ops.rs" 323 4 323 39] false} any ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & a : int8 = a
    | & _3 : bool = any_l () : bool
    | & _5 : Core_Option_Option_Type.t_option int8 = any_l () : Core_Option_Option_Type.t_option int8 ]
     [ return' (result:())-> (! return' {result}) ] 
end
