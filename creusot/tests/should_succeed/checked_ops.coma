
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_checked_ops__test_u8_add_example [#"../checked_ops.rs" 5 0 5 28]
  let%span schecked_ops0 = "../checked_ops.rs" 6 12 6 15
  let%span schecked_ops1 = "../checked_ops.rs" 6 28 6 30
  let%span schecked_ops2 = "../checked_ops.rs" 6 44 6 46
  let%span schecked_ops3 = "../checked_ops.rs" 7 12 7 17
  let%span schecked_ops4 = "../checked_ops.rs" 7 30 7 32
  let%span schecked_ops5 = "../checked_ops.rs" 9 12 9 15
  let%span schecked_ops6 = "../checked_ops.rs" 9 29 9 31
  let%span schecked_ops7 = "../checked_ops.rs" 9 36 9 38
  let%span schecked_ops8 = "../checked_ops.rs" 10 12 10 17
  let%span schecked_ops9 = "../checked_ops.rs" 10 31 10 33
  let%span schecked_ops10 = "../checked_ops.rs" 10 38 10 39
  let%span schecked_ops11 = "../checked_ops.rs" 12 12 12 15
  let%span schecked_ops12 = "../checked_ops.rs" 12 31 12 33
  let%span schecked_ops13 = "../checked_ops.rs" 12 38 12 40
  let%span schecked_ops14 = "../checked_ops.rs" 13 12 13 17
  let%span schecked_ops15 = "../checked_ops.rs" 13 33 13 35
  let%span schecked_ops16 = "../checked_ops.rs" 13 40 13 43
  let%span schecked_ops17 = "../checked_ops.rs" 15 14 15 17
  let%span schecked_ops18 = "../checked_ops.rs" 15 34 15 36
  let%span schecked_ops19 = "../checked_ops.rs" 16 21 16 23
  let%span schecked_ops20 = "../checked_ops.rs" 16 36 16 41
  let%span schecked_ops21 = "../checked_ops.rs" 17 14 17 19
  let%span schecked_ops22 = "../checked_ops.rs" 17 36 17 38
  let%span schecked_ops23 = "../checked_ops.rs" 18 21 18 22
  let%span schecked_ops24 = "../checked_ops.rs" 18 35 18 39
  let%span schecked_ops25 = "../checked_ops.rs" 18 4 18 40
  let%span schecked_ops26 = "../checked_ops.rs" 16 4 16 42
  let%span schecked_ops27 = "../checked_ops.rs" 13 4 13 44
  let%span schecked_ops28 = "../checked_ops.rs" 12 4 12 41
  let%span schecked_ops29 = "../checked_ops.rs" 10 4 10 40
  let%span schecked_ops30 = "../checked_ops.rs" 9 4 9 39
  let%span schecked_ops31 = "../checked_ops.rs" 7 4 7 44
  let%span schecked_ops32 = "../checked_ops.rs" 6 4 6 47
  let%span span33 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span34 = "" 0 0 0 0
  let%span span35 = "" 0 0 0 0
  let%span span36 = "" 0 0 0 0
  let%span span37 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span38 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span39 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span40 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span41 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span42 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span43 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span44 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span45 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span46 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span47 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span48 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span49 = "" 0 0 0 0
  let%span span50 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span51 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span52 = "" 0 0 0 0
  let%span span53 = "" 0 0 0 0
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Option'0.t_Option uint8) =
    [%#span33] inv'0 self
  
  predicate inv'2 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : uint8 [inv'1 x] . inv'1 x = true
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span34] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span35] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span36] (8 : uint32)
  
  use prelude.prelude.UInt8
  
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span41] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span40] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span39] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span38] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span37] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span44] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span43] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span42] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span48] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span47] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span46] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span45] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span49] inv'2 self}
    any [ return' (result:bool)-> {[%#span50] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span52] inv'0 self}
    {[@expl:precondition] [%#span51] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span53] inv'1 result}
      {[%#span51] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span55] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span54] (result = Option'0.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (5 : uint8)} {[%#schecked_ops1] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':uint8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[%#schecked_ops2] (15 : uint8)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0 {[%#schecked_ops3] (250 : uint8)} {[%#schecked_ops4] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops5] (5 : uint8)} {[%#schecked_ops6] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (15 : uint8)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops8] (250 : uint8)} {[%#schecked_ops9] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (4 : uint8)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops11] (5 : uint8)} {[%#schecked_ops12] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (15 : uint8)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops14] (250 : uint8)} {[%#schecked_ops15] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (255 : uint8)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops17] (5 : uint8)} {[%#schecked_ops18] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (15 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops21] (250 : uint8)} {[%#schecked_ops22] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (4 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] true) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : uint8 = any_l ()
    | & _4 : Option'0.t_Option uint8 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : Option'0.t_Option uint8 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : uint8 = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : uint8 = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : uint8 = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (uint8, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_add_overflow [#"../checked_ops.rs" 23 0 23 34]
  let%span schecked_ops0 = "../checked_ops.rs" 24 12 24 17
  let%span schecked_ops1 = "../checked_ops.rs" 25 12 25 17
  let%span schecked_ops2 = "../checked_ops.rs" 25 41 25 42
  let%span schecked_ops3 = "../checked_ops.rs" 26 12 26 17
  let%span schecked_ops4 = "../checked_ops.rs" 26 39 26 42
  let%span schecked_ops5 = "../checked_ops.rs" 27 14 27 19
  let%span schecked_ops6 = "../checked_ops.rs" 28 25 28 26
  let%span schecked_ops7 = "../checked_ops.rs" 28 39 28 43
  let%span schecked_ops8 = "../checked_ops.rs" 28 4 28 44
  let%span schecked_ops9 = "../checked_ops.rs" 26 4 26 43
  let%span schecked_ops10 = "../checked_ops.rs" 25 4 25 43
  let%span schecked_ops11 = "../checked_ops.rs" 24 4 24 43
  let%span schecked_ops12 = "../checked_ops.rs" 22 11 22 18
  let%span span13 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span14 = "" 0 0 0 0
  let%span span15 = "" 0 0 0 0
  let%span span16 = "" 0 0 0 0
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span29 = "" 0 0 0 0
  let%span span30 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span31 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span32 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span13] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span14] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span15] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span16] (8 : uint32)
  
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span21] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span20] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span19] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span18] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span17] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span24] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span23] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span22] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span28] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span27] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span26] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span25] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span29] inv'0 self}
    any [ return' (result:bool)-> {[%#span30] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span32] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span31] (result = Option'0.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_overflow (a:uint8) (return'  (ret:()))= {[%#schecked_ops12] UInt8.to_int a <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (255 : uint8)} {a}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (255 : uint8)} {a} (fun (_ret':uint8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {a} {[%#schecked_ops2] (1 : uint8)} (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = UInt8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s2)
      | s2 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops3] (255 : uint8)} {a} (fun (_ret':uint8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_18} {[%#schecked_ops4] (255 : uint8)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb10) | br1 -> {_17} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops5] (255 : uint8)} {a}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {a} {[%#schecked_ops6] (1 : uint8)} (fun (_ret':uint8) ->  [ &_26 <- _ret' ] s1)
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_26} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = any [ br0 -> {_24 = false} (! bb15) | br1 -> {_24} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_28 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops7] true) ] s1
      | s1 = any [ br0 -> {_28 = false} (! bb14) | br1 -> {_28} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops8] false} any
    | bb10 = {[%#schecked_ops9] false} any
    | bb7 = {[%#schecked_ops10] false} any
    | bb4 = {[%#schecked_ops11] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option uint8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : uint8 = any_l ()
    | & _13 : uint8 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _24 : bool = any_l ()
    | & _26 : uint8 = any_l ()
    | & _28 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_add [#"../checked_ops.rs" 34 0 34 47]
  let%span schecked_ops0 = "../checked_ops.rs" 33 10 33 56
  let%span span1 = "" 0 0 0 0
  let%span span2 = "" 0 0 0 0
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span5 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span1] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span2] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span3] (8 : uint32)
  
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span7] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span6] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span5] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span4] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_add (a:uint8) (b:uint8) (return'  (ret:uint8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':uint8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : uint8 = any_l () | & a : uint8 = a | & b : uint8 = b ] 
    [ return' (result:uint8)-> {[@expl:postcondition] [%#schecked_ops0] UInt8.to_int result
      = UInt8.to_int a + UInt8.to_int b
      \/ UInt8.to_int result = UInt8.to_int a + UInt8.to_int b - 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_u8_overflowing_add [#"../checked_ops.rs" 39 0 39 44]
  let%span schecked_ops0 = "../checked_ops.rs" 41 4 41 65
  let%span schecked_ops1 = "../checked_ops.rs" 40 4 40 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span5] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span6] (0 : uint8)
  
  use prelude.prelude.UInt8
  
  let rec checked_add'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span8] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_add'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span13] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span12] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span11] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span10] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span17] UInt8.to_int self + UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span16] UInt8.to_int self + UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self + UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span15] UInt8.to_int self + UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self + UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self + UInt8.to_int rhs}
      {[%#span14] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self + UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_add (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add'0 {a} {b} (fun (_ret':Option'0.t_Option uint8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l ()
    | & _6 : (uint8, bool) = any_l ()
    | & _9 : uint8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (uint8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option uint8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_example [#"../checked_ops.rs" 45 0 45 28]
  let%span schecked_ops0 = "../checked_ops.rs" 46 12 46 15
  let%span schecked_ops1 = "../checked_ops.rs" 46 28 46 30
  let%span schecked_ops2 = "../checked_ops.rs" 47 12 47 17
  let%span schecked_ops3 = "../checked_ops.rs" 47 30 47 32
  let%span schecked_ops4 = "../checked_ops.rs" 47 46 47 49
  let%span schecked_ops5 = "../checked_ops.rs" 49 12 49 15
  let%span schecked_ops6 = "../checked_ops.rs" 49 29 49 31
  let%span schecked_ops7 = "../checked_ops.rs" 49 36 49 39
  let%span schecked_ops8 = "../checked_ops.rs" 50 12 50 17
  let%span schecked_ops9 = "../checked_ops.rs" 50 31 50 33
  let%span schecked_ops10 = "../checked_ops.rs" 50 38 50 41
  let%span schecked_ops11 = "../checked_ops.rs" 52 12 52 15
  let%span schecked_ops12 = "../checked_ops.rs" 52 31 52 33
  let%span schecked_ops13 = "../checked_ops.rs" 52 38 52 39
  let%span schecked_ops14 = "../checked_ops.rs" 53 12 53 17
  let%span schecked_ops15 = "../checked_ops.rs" 53 33 53 35
  let%span schecked_ops16 = "../checked_ops.rs" 53 40 53 43
  let%span schecked_ops17 = "../checked_ops.rs" 55 14 55 17
  let%span schecked_ops18 = "../checked_ops.rs" 55 34 55 36
  let%span schecked_ops19 = "../checked_ops.rs" 56 21 56 24
  let%span schecked_ops20 = "../checked_ops.rs" 56 37 56 41
  let%span schecked_ops21 = "../checked_ops.rs" 57 14 57 19
  let%span schecked_ops22 = "../checked_ops.rs" 57 36 57 38
  let%span schecked_ops23 = "../checked_ops.rs" 58 21 58 24
  let%span schecked_ops24 = "../checked_ops.rs" 58 37 58 42
  let%span schecked_ops25 = "../checked_ops.rs" 58 4 58 43
  let%span schecked_ops26 = "../checked_ops.rs" 56 4 56 42
  let%span schecked_ops27 = "../checked_ops.rs" 53 4 53 44
  let%span schecked_ops28 = "../checked_ops.rs" 52 4 52 40
  let%span schecked_ops29 = "../checked_ops.rs" 50 4 50 42
  let%span schecked_ops30 = "../checked_ops.rs" 49 4 49 40
  let%span schecked_ops31 = "../checked_ops.rs" 47 4 47 50
  let%span schecked_ops32 = "../checked_ops.rs" 46 4 46 42
  let%span span33 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span34 = "" 0 0 0 0
  let%span span35 = "" 0 0 0 0
  let%span span36 = "" 0 0 0 0
  let%span span37 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span38 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span39 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span40 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span41 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span42 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span43 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span44 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span45 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span46 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span47 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span48 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span49 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span50 = "" 0 0 0 0
  let%span span51 = "" 0 0 0 0
  let%span span52 = "" 0 0 0 0
  let%span span53 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  predicate inv'2 (_1 : uint8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : uint8 [inv'2 x] . inv'2 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span33] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span34] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span35] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span36] (8 : uint32)
  
  use prelude.prelude.UInt8
  
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span41] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span40] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span39] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span38] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span37] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span44] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span43] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span42] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span48] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span47] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span46] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span45] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span50] inv'1 self}
    {[@expl:precondition] [%#span49] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span51] inv'2 result}
      {[%#span49] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span52] inv'0 self}
    any [ return' (result:bool)-> {[%#span53] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span55] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span54] (result = Option'0.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (5 : uint8)} {[%#schecked_ops1] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops2] (250 : uint8)} {[%#schecked_ops3] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':uint8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[%#schecked_ops4] (240 : uint8)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops5] (5 : uint8)} {[%#schecked_ops6] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (251 : uint8)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops8] (250 : uint8)} {[%#schecked_ops9] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (240 : uint8)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops11] (5 : uint8)} {[%#schecked_ops12] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (0 : uint8)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops14] (250 : uint8)} {[%#schecked_ops15] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (240 : uint8)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops17] (5 : uint8)} {[%#schecked_ops18] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (251 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] true) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops21] (250 : uint8)} {[%#schecked_ops22] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (240 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] false) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : Option'0.t_Option uint8 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : uint8 = any_l ()
    | & _9 : Option'0.t_Option uint8 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : uint8 = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : uint8 = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : uint8 = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (uint8, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_overflow [#"../checked_ops.rs" 63 0 63 34]
  let%span schecked_ops0 = "../checked_ops.rs" 64 12 64 15
  let%span schecked_ops1 = "../checked_ops.rs" 65 12 65 15
  let%span schecked_ops2 = "../checked_ops.rs" 65 35 65 38
  let%span schecked_ops3 = "../checked_ops.rs" 65 45 65 46
  let%span schecked_ops4 = "../checked_ops.rs" 66 12 66 15
  let%span schecked_ops5 = "../checked_ops.rs" 66 37 66 38
  let%span schecked_ops6 = "../checked_ops.rs" 67 14 67 17
  let%span schecked_ops7 = "../checked_ops.rs" 68 21 68 24
  let%span schecked_ops8 = "../checked_ops.rs" 68 31 68 32
  let%span schecked_ops9 = "../checked_ops.rs" 68 45 68 49
  let%span schecked_ops10 = "../checked_ops.rs" 68 4 68 50
  let%span schecked_ops11 = "../checked_ops.rs" 66 4 66 39
  let%span schecked_ops12 = "../checked_ops.rs" 65 4 65 47
  let%span schecked_ops13 = "../checked_ops.rs" 64 4 64 41
  let%span schecked_ops14 = "../checked_ops.rs" 62 11 62 18
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "" 0 0 0 0
  let%span span17 = "" 0 0 0 0
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span31 = "" 0 0 0 0
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span33 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span34 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span15] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span16] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span17] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span18] (8 : uint32)
  
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span23] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span22] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span21] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span20] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span19] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span26] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span25] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span24] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span30] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span29] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span28] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span27] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span31] inv'0 self}
    any [ return' (result:bool)-> {[%#span32] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span34] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span33] (result = Option'0.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_overflow (a:uint8) (return'  (ret:()))= {[%#schecked_ops14] UInt8.to_int a <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (0 : uint8)} {a}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (0 : uint8)} {a} (fun (_ret':uint8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.sub {[%#schecked_ops2] (255 : uint8)} {a} (fun (_ret':uint8) ->  [ &_14 <- _ret' ] s1)
      | s1 = UInt8.add {_14} {[%#schecked_ops3] (1 : uint8)} (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s2)
      | s2 = UInt8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (0 : uint8)} {a} (fun (_ret':uint8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_19} {[%#schecked_ops5] (0 : uint8)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (0 : uint8)} {a} (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.sub {[%#schecked_ops7] (255 : uint8)} {a} (fun (_ret':uint8) ->  [ &_28 <- _ret' ] s1)
      | s1 = UInt8.add {_28} {[%#schecked_ops8] (1 : uint8)} (fun (_ret':uint8) ->  [ &_27 <- _ret' ] s2)
      | s2 = UInt8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option uint8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : uint8 = any_l ()
    | & _13 : uint8 = any_l ()
    | & _14 : uint8 = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : uint8 = any_l ()
    | & _28 : uint8 = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_sub [#"../checked_ops.rs" 74 0 74 47]
  let%span schecked_ops0 = "../checked_ops.rs" 73 10 73 56
  let%span span1 = "" 0 0 0 0
  let%span span2 = "" 0 0 0 0
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span5 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span1] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span2] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span3] (8 : uint32)
  
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span7] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span6] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span5] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span4] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_sub (a:uint8) (b:uint8) (return'  (ret:uint8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':uint8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : uint8 = any_l () | & a : uint8 = a | & b : uint8 = b ] 
    [ return' (result:uint8)-> {[@expl:postcondition] [%#schecked_ops0] UInt8.to_int result
      = UInt8.to_int a - UInt8.to_int b
      \/ UInt8.to_int result = UInt8.to_int a - UInt8.to_int b + 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_u8_overflowing_sub [#"../checked_ops.rs" 79 0 79 44]
  let%span schecked_ops0 = "../checked_ops.rs" 81 4 81 65
  let%span schecked_ops1 = "../checked_ops.rs" 80 4 80 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span5] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span6] (0 : uint8)
  
  use prelude.prelude.UInt8
  
  let rec checked_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span8] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span13] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span12] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span11] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span10] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span17] UInt8.to_int self - UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span16] UInt8.to_int self - UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self - UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span15] UInt8.to_int self - UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self - UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self - UInt8.to_int rhs}
      {[%#span14] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self - UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_sub (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub'0 {a} {b} (fun (_ret':Option'0.t_Option uint8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l ()
    | & _6 : (uint8, bool) = any_l ()
    | & _9 : uint8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (uint8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option uint8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_example [#"../checked_ops.rs" 85 0 85 28]
  let%span schecked_ops0 = "../checked_ops.rs" 86 12 86 15
  let%span schecked_ops1 = "../checked_ops.rs" 86 28 86 30
  let%span schecked_ops2 = "../checked_ops.rs" 86 44 86 46
  let%span schecked_ops3 = "../checked_ops.rs" 87 12 87 16
  let%span schecked_ops4 = "../checked_ops.rs" 87 29 87 31
  let%span schecked_ops5 = "../checked_ops.rs" 89 12 89 15
  let%span schecked_ops6 = "../checked_ops.rs" 89 29 89 31
  let%span schecked_ops7 = "../checked_ops.rs" 89 36 89 38
  let%span schecked_ops8 = "../checked_ops.rs" 90 12 90 16
  let%span schecked_ops9 = "../checked_ops.rs" 90 30 90 32
  let%span schecked_ops10 = "../checked_ops.rs" 90 37 90 40
  let%span schecked_ops11 = "../checked_ops.rs" 92 12 92 15
  let%span schecked_ops12 = "../checked_ops.rs" 92 31 92 33
  let%span schecked_ops13 = "../checked_ops.rs" 92 38 92 40
  let%span schecked_ops14 = "../checked_ops.rs" 93 12 93 16
  let%span schecked_ops15 = "../checked_ops.rs" 93 32 93 34
  let%span schecked_ops16 = "../checked_ops.rs" 93 39 93 42
  let%span schecked_ops17 = "../checked_ops.rs" 95 14 95 17
  let%span schecked_ops18 = "../checked_ops.rs" 95 34 95 36
  let%span schecked_ops19 = "../checked_ops.rs" 96 21 96 23
  let%span schecked_ops20 = "../checked_ops.rs" 96 36 96 41
  let%span schecked_ops21 = "../checked_ops.rs" 97 14 97 18
  let%span schecked_ops22 = "../checked_ops.rs" 97 35 97 37
  let%span schecked_ops23 = "../checked_ops.rs" 98 21 98 24
  let%span schecked_ops24 = "../checked_ops.rs" 98 37 98 41
  let%span schecked_ops25 = "../checked_ops.rs" 98 4 98 42
  let%span schecked_ops26 = "../checked_ops.rs" 96 4 96 42
  let%span schecked_ops27 = "../checked_ops.rs" 93 4 93 43
  let%span schecked_ops28 = "../checked_ops.rs" 92 4 92 41
  let%span schecked_ops29 = "../checked_ops.rs" 90 4 90 41
  let%span schecked_ops30 = "../checked_ops.rs" 89 4 89 39
  let%span schecked_ops31 = "../checked_ops.rs" 87 4 87 43
  let%span schecked_ops32 = "../checked_ops.rs" 86 4 86 47
  let%span span33 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span34 = "" 0 0 0 0
  let%span span35 = "" 0 0 0 0
  let%span span36 = "" 0 0 0 0
  let%span span37 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span38 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span39 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span40 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span41 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span42 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span43 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span44 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span45 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span46 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span47 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span48 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span49 = "" 0 0 0 0
  let%span span50 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span51 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span52 = "" 0 0 0 0
  let%span span53 = "" 0 0 0 0
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Option'0.t_Option uint8) =
    [%#span33] inv'0 self
  
  predicate inv'2 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : uint8 [inv'1 x] . inv'1 x = true
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span34] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span35] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span36] (8 : uint32)
  
  use prelude.prelude.UInt8
  
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span41] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span40] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span39] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span38] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span37] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span44] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span43] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span42] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span48] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span47] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span46] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span45] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span49] inv'2 self}
    any [ return' (result:bool)-> {[%#span50] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span52] inv'0 self}
    {[@expl:precondition] [%#span51] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span53] inv'1 result}
      {[%#span51] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span55] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span54] (result = Option'0.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (5 : uint8)} {[%#schecked_ops1] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':uint8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_3} {[%#schecked_ops2] (50 : uint8)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops3] (50 : uint8)} {[%#schecked_ops4] (10 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops5] (5 : uint8)} {[%#schecked_ops6] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (50 : uint8)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops8] (50 : uint8)} {[%#schecked_ops9] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (244 : uint8)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops11] (5 : uint8)} {[%#schecked_ops12] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {_21} {[%#schecked_ops13] (50 : uint8)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1)
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops14] (50 : uint8)} {[%#schecked_ops15] (10 : uint8)}
          (fun (_ret':uint8) ->  [ &_25 <- _ret' ] s1)
      | s1 = bb18 ]
      
    | bb18 = s0
      [ s0 = UInt8.eq {_25} {[%#schecked_ops16] (255 : uint8)} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops17] (5 : uint8)} {[%#schecked_ops18] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb21 ]
      
    | bb21 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops19] (50 : uint8)}
          (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
      
    | bb22 = s0
      [ s0 =  [ &_31 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops20] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops21] (50 : uint8)} {[%#schecked_ops22] (10 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops23] (244 : uint8)}
          (fun (_ret':bool) ->  [ &_36 <- _ret' ] s1)
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 =  [ &_38 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops24] true) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
      
    | bb29 = return' {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops25] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops26] false} any
    | bb20 = {[%#schecked_ops27] false} any
    | bb17 = {[%#schecked_ops28] false} any
    | bb14 = {[%#schecked_ops29] false} any
    | bb11 = {[%#schecked_ops30] false} any
    | bb8 = {[%#schecked_ops31] false} any
    | bb4 = {[%#schecked_ops32] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : uint8 = any_l ()
    | & _4 : Option'0.t_Option uint8 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : Option'0.t_Option uint8 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : uint8 = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : uint8 = any_l ()
    | & _20 : bool = any_l ()
    | & _21 : uint8 = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : bool = any_l ()
    | & res1 : (uint8, bool) = any_l ()
    | & _36 : bool = any_l ()
    | & _38 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_zero [#"../checked_ops.rs" 102 0 102 30]
  let%span schecked_ops0 = "../checked_ops.rs" 103 12 103 15
  let%span schecked_ops1 = "../checked_ops.rs" 103 43 103 44
  let%span schecked_ops2 = "../checked_ops.rs" 104 12 104 15
  let%span schecked_ops3 = "../checked_ops.rs" 104 35 104 36
  let%span schecked_ops4 = "../checked_ops.rs" 105 12 105 15
  let%span schecked_ops5 = "../checked_ops.rs" 105 37 105 38
  let%span schecked_ops6 = "../checked_ops.rs" 106 14 106 17
  let%span schecked_ops7 = "../checked_ops.rs" 107 21 107 22
  let%span schecked_ops8 = "../checked_ops.rs" 107 35 107 40
  let%span schecked_ops9 = "../checked_ops.rs" 107 4 107 41
  let%span schecked_ops10 = "../checked_ops.rs" 105 4 105 39
  let%span schecked_ops11 = "../checked_ops.rs" 104 4 104 37
  let%span schecked_ops12 = "../checked_ops.rs" 103 4 103 45
  let%span span13 = "" 0 0 0 0
  let%span span14 = "" 0 0 0 0
  let%span span15 = "" 0 0 0 0
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span28 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span29 = "" 0 0 0 0
  let%span span30 = "" 0 0 0 0
  let%span span31 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span32 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.UInt8
  
  predicate inv'1 (_1 : uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : uint8 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span13] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span14] (0 : uint8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span15] (8 : uint32)
  
  use prelude.prelude.UInt8
  
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span20] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span19] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span18] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span17] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span16] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span23] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MAX'0 : uint8)}
      {[%#span22] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      {[%#span21] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span27] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span26] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span25] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span24] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span29] inv'0 self}
    {[@expl:precondition] [%#span28] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span30] inv'1 result}
      {[%#span28] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span32] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span31] (result = Option'0.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_zero (a:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (0 : uint8)} {a}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':uint8) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {_4} {[%#schecked_ops1] (0 : uint8)} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1)
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops2] (0 : uint8)} {a} (fun (_ret':uint8) ->  [ &_10 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = UInt8.eq {_10} {[%#schecked_ops3] (0 : uint8)} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops4] (0 : uint8)} {a} (fun (_ret':uint8) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = UInt8.eq {_15} {[%#schecked_ops5] (0 : uint8)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops6] (0 : uint8)} {a} (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops7] (0 : uint8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops8] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops9] false} any
    | bb10 = {[%#schecked_ops10] false} any
    | bb7 = {[%#schecked_ops11] false} any
    | bb4 = {[%#schecked_ops12] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & _3 : bool = any_l ()
    | & _4 : uint8 = any_l ()
    | & _5 : Option'0.t_Option uint8 = any_l ()
    | & _9 : bool = any_l ()
    | & _10 : uint8 = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_overflowing_mul [#"../checked_ops.rs" 111 0 111 44]
  let%span schecked_ops0 = "../checked_ops.rs" 113 4 113 65
  let%span schecked_ops1 = "../checked_ops.rs" 112 4 112 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : uint8 = [%#span5] (255 : uint8)
  
  constant v_MIN'0 : uint8 = [%#span6] (0 : uint8)
  
  use prelude.prelude.UInt8
  
  let rec checked_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span8] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= any
    [ return' (result:uint8)-> {[%#span13] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span12] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int result
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span11] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int result = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span10] UInt8.to_int result
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= any
    [ return' (result:(uint8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
      \/ UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8))}
      {[%#span17] UInt8.to_int self * UInt8.to_int rhs > UInt8.to_int (v_MAX'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      - k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span16] UInt8.to_int self * UInt8.to_int rhs < UInt8.to_int (v_MIN'0 : uint8)
       -> (exists k : int . k > 0
      /\ UInt8.to_int (let (a, _) = result in a)
      = UInt8.to_int self * UInt8.to_int rhs
      + k * (UInt8.to_int (v_MAX'0 : uint8) - UInt8.to_int (v_MIN'0 : uint8) + 1))}
      {[%#span15] UInt8.to_int self * UInt8.to_int rhs >= UInt8.to_int (v_MIN'0 : uint8)
      /\ UInt8.to_int self * UInt8.to_int rhs <= UInt8.to_int (v_MAX'0 : uint8)
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self * UInt8.to_int rhs}
      {[%#span14] UInt8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (UInt8.to_int self * UInt8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_mul (a:uint8) (b:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul'0 {a} {b} (fun (_ret':uint8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul'0 {a} {b} (fun (_ret':Option'0.t_Option uint8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _4 : bool = any_l ()
    | & _6 : (uint8, bool) = any_l ()
    | & _9 : uint8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (uint8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option uint8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_example [#"../checked_ops.rs" 117 0 117 28]
  let%span schecked_ops0 = "../checked_ops.rs" 118 12 118 15
  let%span schecked_ops1 = "../checked_ops.rs" 118 28 118 29
  let%span schecked_ops2 = "../checked_ops.rs" 119 12 119 15
  let%span schecked_ops3 = "../checked_ops.rs" 119 28 119 29
  let%span schecked_ops4 = "../checked_ops.rs" 119 43 119 44
  let%span schecked_ops5 = "../checked_ops.rs" 120 12 120 15
  let%span schecked_ops6 = "../checked_ops.rs" 120 29 120 30
  let%span schecked_ops7 = "../checked_ops.rs" 120 35 120 36
  let%span schecked_ops8 = "../checked_ops.rs" 121 12 121 15
  let%span schecked_ops9 = "../checked_ops.rs" 121 31 121 32
  let%span schecked_ops10 = "../checked_ops.rs" 121 37 121 38
  let%span schecked_ops11 = "../checked_ops.rs" 122 14 122 17
  let%span schecked_ops12 = "../checked_ops.rs" 122 34 122 35
  let%span schecked_ops13 = "../checked_ops.rs" 123 21 123 22
  let%span schecked_ops14 = "../checked_ops.rs" 123 35 123 40
  let%span schecked_ops15 = "../checked_ops.rs" 123 4 123 41
  let%span schecked_ops16 = "../checked_ops.rs" 121 4 121 39
  let%span schecked_ops17 = "../checked_ops.rs" 120 4 120 37
  let%span schecked_ops18 = "../checked_ops.rs" 119 4 119 45
  let%span schecked_ops19 = "../checked_ops.rs" 118 4 118 41
  let%span span20 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span21 = "" 0 0 0 0
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 95 27 95 36
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 97 16 97 87
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 99 26 99 91
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 101 26 101 74
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 85 27 85 36
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 87 16 87 91
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 89 26 89 89
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 75 27 75 36
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 77 16 77 85
  let%span span31 = "../../../../creusot-contracts/src/std/num.rs" 79 26 79 89
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span33 = "" 0 0 0 0
  let%span span34 = "" 0 0 0 0
  let%span span35 = "" 0 0 0 0
  let%span span36 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span37 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span38 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.UInt8
  
  predicate inv'2 (_1 : uint8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : uint8 [inv'2 x] . inv'2 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span20] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : uint8 = [%#span21] (0 : uint8)
  
  use prelude.prelude.UInt8
  
  let rec overflowing_div'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= {[@expl:precondition] [%#span22] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:(uint8, bool))-> {[%#span25] (let (_, a) = result in a)
      = (UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      {[%#span24] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span23] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span26] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[%#span28] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span27] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec wrapping_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span29] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[%#span31] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span30] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int result = UInt8.to_int self}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span33] inv'1 self}
    {[@expl:precondition] [%#span32] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span34] inv'2 result}
      {[%#span32] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span35] inv'0 self}
    any [ return' (result:bool)-> {[%#span36] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span38] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span37] (result = Option'0.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {[%#schecked_ops0] (5 : uint8)} {[%#schecked_ops1] (0 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div'0 {[%#schecked_ops2] (5 : uint8)} {[%#schecked_ops3] (2 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':uint8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = UInt8.eq {_8} {[%#schecked_ops4] (2 : uint8)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops5] (5 : uint8)} {[%#schecked_ops6] (2 : uint8)}
          (fun (_ret':uint8) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0
      [ s0 = UInt8.eq {_13} {[%#schecked_ops7] (2 : uint8)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops8] (5 : uint8)} {[%#schecked_ops9] (2 : uint8)}
          (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1)
      | s1 = bb12 ]
      
    | bb12 = s0
      [ s0 = UInt8.eq {_17} {[%#schecked_ops10] (2 : uint8)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
      
    | bb13 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops11] (5 : uint8)} {[%#schecked_ops12] (2 : uint8)}
          (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops13] (2 : uint8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb19) | br1 -> {_21} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops14] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb18) | br1 -> {_23} (! bb17) ]  ]
      
    | bb17 = return' {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops15] false} any
    | bb14 = {[%#schecked_ops16] false} any
    | bb11 = {[%#schecked_ops17] false} any
    | bb8 = {[%#schecked_ops18] false} any
    | bb4 = {[%#schecked_ops19] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : Option'0.t_Option uint8 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : uint8 = any_l ()
    | & _9 : Option'0.t_Option uint8 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : uint8 = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : uint8 = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_no_overflow [#"../checked_ops.rs" 128 0 128 44]
  let%span schecked_ops0 = "../checked_ops.rs" 129 41 129 46
  let%span schecked_ops1 = "../checked_ops.rs" 130 33 130 38
  let%span schecked_ops2 = "../checked_ops.rs" 131 35 131 40
  let%span schecked_ops3 = "../checked_ops.rs" 133 21 133 26
  let%span schecked_ops4 = "../checked_ops.rs" 133 39 133 44
  let%span schecked_ops5 = "../checked_ops.rs" 133 4 133 45
  let%span schecked_ops6 = "../checked_ops.rs" 131 4 131 41
  let%span schecked_ops7 = "../checked_ops.rs" 130 4 130 39
  let%span schecked_ops8 = "../checked_ops.rs" 129 4 129 47
  let%span schecked_ops9 = "../checked_ops.rs" 127 11 127 18
  let%span span10 = "" 0 0 0 0
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 95 27 95 36
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 97 16 97 87
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 99 26 99 91
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 101 26 101 74
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 85 27 85 36
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 87 16 87 91
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 89 26 89 89
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 75 27 75 36
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 77 16 77 85
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 79 26 79 89
  let%span span21 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span22 = "" 0 0 0 0
  let%span span23 = "" 0 0 0 0
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.UInt8
  
  predicate inv'1 (_1 : uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : uint8 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.UInt8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : uint8 = [%#span10] (0 : uint8)
  
  let rec overflowing_div'0 (self:uint8) (rhs:uint8) (return'  (ret:(uint8, bool)))= {[@expl:precondition] [%#span11] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:(uint8, bool))-> {[%#span14] (let (_, a) = result in a)
      = (UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      {[%#span13] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int (let (a, _) = result in a) = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span12] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int (let (a, _) = result in a) = UInt8.to_int self}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span15] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[%#span17] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span16] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int result = UInt8.to_int (v_MIN'0 : uint8)}
      (! return' {result}) ]
    
  
  let rec wrapping_div'0 (self:uint8) (rhs:uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span18] UInt8.to_int rhs
    <> 0}
    any
    [ return' (result:uint8)-> {[%#span20] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
      \/ UInt8.to_int result = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span19] UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1
       -> UInt8.to_int result = UInt8.to_int self}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option uint8) (return'  (ret:uint8))= {[@expl:precondition] [%#span22] inv'0 self}
    {[@expl:precondition] [%#span21] self <> Option'0.C_None}
    any
    [ return' (result:uint8)-> {[%#span23] inv'1 result}
      {[%#span21] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span25] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span24] (result = Option'0.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_no_overflow (a:uint8) (b:uint8) (return'  (ret:()))= {[%#schecked_ops9] UInt8.to_int b <> 0}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div'0 {a} {b} (fun (_ret':Option'0.t_Option uint8) ->  [ &_7 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':uint8) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- b ] s1
      | s1 = UInt8.eq {_12} {[%#schecked_ops0] (0 : uint8)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops0] not _13} s3
      | s3 = bb3 ]
      
    | bb3 = s0
      [ s0 = UInt8.div {a} {_12} (fun (_ret':uint8) ->  [ &_10 <- _ret' ] s1)
      | s1 = UInt8.eq {_6} {_10} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb4) ]  ]
      
    | bb4 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':uint8) ->  [ &_17 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_22 <- b ] s1
      | s1 = UInt8.eq {_22} {[%#schecked_ops1] (0 : uint8)} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops1] not _23} s3
      | s3 = bb7 ]
      
    | bb7 = s0
      [ s0 = UInt8.div {a} {_22} (fun (_ret':uint8) ->  [ &_20 <- _ret' ] s1)
      | s1 = UInt8.eq {_17} {_20} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s2)
      | s2 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':uint8) ->  [ &_27 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_32 <- b ] s1
      | s1 = UInt8.eq {_32} {[%#schecked_ops2] (0 : uint8)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops2] not _33} s3
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = UInt8.div {a} {_32} (fun (_ret':uint8) ->  [ &_30 <- _ret' ] s1)
      | s1 = UInt8.eq {_27} {_30} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s2)
      | s2 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(uint8, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 =  [ &_43 <- b ] s1
      | s1 = UInt8.eq {_43} {[%#schecked_ops3] (0 : uint8)} (fun (_ret':bool) ->  [ &_44 <- _ret' ] s2)
      | s2 = {[@expl:division by zero] [%#schecked_ops3] not _44} s3
      | s3 = bb15 ]
      
    | bb15 = s0
      [ s0 = UInt8.div {a} {_43} (fun (_ret':uint8) ->  [ &_41 <- _ret' ] s1)
      | s1 = UInt8.eq {let (r'0, _) = res in r'0} {_41} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s2)
      | s2 = any [ br0 -> {_39 = false} (! bb19) | br1 -> {_39} (! bb16) ]  ]
      
    | bb16 = s0
      [ s0 =  [ &_45 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops4] false) ] s1
      | s1 = any [ br0 -> {_45 = false} (! bb18) | br1 -> {_45} (! bb17) ]  ]
      
    | bb17 = return' {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops5] false} any
    | bb13 = {[%#schecked_ops6] false} any
    | bb9 = {[%#schecked_ops7] false} any
    | bb5 = {[%#schecked_ops8] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : uint8 = a
    | & b : uint8 = b
    | & _5 : bool = any_l ()
    | & _6 : uint8 = any_l ()
    | & _7 : Option'0.t_Option uint8 = any_l ()
    | & _10 : uint8 = any_l ()
    | & _12 : uint8 = any_l ()
    | & _13 : bool = any_l ()
    | & _16 : bool = any_l ()
    | & _17 : uint8 = any_l ()
    | & _20 : uint8 = any_l ()
    | & _22 : uint8 = any_l ()
    | & _23 : bool = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : uint8 = any_l ()
    | & _30 : uint8 = any_l ()
    | & _32 : uint8 = any_l ()
    | & _33 : bool = any_l ()
    | & res : (uint8, bool) = any_l ()
    | & _39 : bool = any_l ()
    | & _41 : uint8 = any_l ()
    | & _43 : uint8 = any_l ()
    | & _44 : bool = any_l ()
    | & _45 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_zero [#"../checked_ops.rs" 137 0 137 30]
  let%span schecked_ops0 = "../checked_ops.rs" 138 26 138 27
  let%span schecked_ops1 = "../checked_ops.rs" 138 4 138 39
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.UInt8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option uint8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option uint8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option uint8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec is_none'0 (self:Option'0.t_Option uint8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : uint8 = [%#span5] (0 : uint8)
  
  use prelude.prelude.UInt8
  
  let rec checked_div'0 (self:uint8) (rhs:uint8) (return'  (ret:Option'0.t_Option uint8))= any
    [ return' (result:Option'0.t_Option uint8)-> {[%#span7] forall r : uint8 . result = Option'0.C_Some r
       -> UInt8.to_int r = div (UInt8.to_int self) (UInt8.to_int rhs)}
      {[%#span6] (result = Option'0.C_None)
      = (UInt8.to_int rhs = 0 \/ UInt8.to_int self = UInt8.to_int (v_MIN'0 : uint8) /\ UInt8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_zero (a:uint8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[%#schecked_ops0] (0 : uint8)}
          (fun (_ret':Option'0.t_Option uint8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return' {_0}
    | bb4 = {[%#schecked_ops1] false} any ]
    ) [ & _0 : () = any_l () | & a : uint8 = a | & _3 : bool = any_l () | & _5 : Option'0.t_Option uint8 = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
module M_checked_ops__test_i8_add_example [#"../checked_ops.rs" 142 0 142 28]
  let%span schecked_ops0 = "../checked_ops.rs" 143 12 143 15
  let%span schecked_ops1 = "../checked_ops.rs" 143 28 143 30
  let%span schecked_ops2 = "../checked_ops.rs" 143 44 143 46
  let%span schecked_ops3 = "../checked_ops.rs" 144 12 144 17
  let%span schecked_ops4 = "../checked_ops.rs" 144 30 144 32
  let%span schecked_ops5 = "../checked_ops.rs" 145 12 145 20
  let%span schecked_ops6 = "../checked_ops.rs" 145 33 145 36
  let%span schecked_ops7 = "../checked_ops.rs" 147 12 147 15
  let%span schecked_ops8 = "../checked_ops.rs" 147 29 147 31
  let%span schecked_ops9 = "../checked_ops.rs" 147 36 147 38
  let%span schecked_ops10 = "../checked_ops.rs" 148 12 148 17
  let%span schecked_ops11 = "../checked_ops.rs" 148 31 148 33
  let%span schecked_ops12 = "../checked_ops.rs" 148 38 148 42
  let%span schecked_ops13 = "../checked_ops.rs" 149 12 149 20
  let%span schecked_ops14 = "../checked_ops.rs" 149 34 149 37
  let%span schecked_ops15 = "../checked_ops.rs" 149 42 149 45
  let%span schecked_ops16 = "../checked_ops.rs" 151 12 151 15
  let%span schecked_ops17 = "../checked_ops.rs" 151 31 151 33
  let%span schecked_ops18 = "../checked_ops.rs" 151 38 151 40
  let%span schecked_ops19 = "../checked_ops.rs" 152 12 152 17
  let%span schecked_ops20 = "../checked_ops.rs" 152 33 152 35
  let%span schecked_ops21 = "../checked_ops.rs" 152 40 152 43
  let%span schecked_ops22 = "../checked_ops.rs" 153 12 153 20
  let%span schecked_ops23 = "../checked_ops.rs" 153 36 153 39
  let%span schecked_ops24 = "../checked_ops.rs" 153 44 153 48
  let%span schecked_ops25 = "../checked_ops.rs" 155 14 155 17
  let%span schecked_ops26 = "../checked_ops.rs" 155 34 155 36
  let%span schecked_ops27 = "../checked_ops.rs" 156 21 156 23
  let%span schecked_ops28 = "../checked_ops.rs" 156 36 156 41
  let%span schecked_ops29 = "../checked_ops.rs" 157 14 157 19
  let%span schecked_ops30 = "../checked_ops.rs" 157 36 157 38
  let%span schecked_ops31 = "../checked_ops.rs" 158 21 158 25
  let%span schecked_ops32 = "../checked_ops.rs" 158 38 158 42
  let%span schecked_ops33 = "../checked_ops.rs" 159 14 159 22
  let%span schecked_ops34 = "../checked_ops.rs" 159 39 159 42
  let%span schecked_ops35 = "../checked_ops.rs" 160 21 160 24
  let%span schecked_ops36 = "../checked_ops.rs" 160 37 160 41
  let%span schecked_ops37 = "../checked_ops.rs" 160 4 160 42
  let%span schecked_ops38 = "../checked_ops.rs" 158 4 158 43
  let%span schecked_ops39 = "../checked_ops.rs" 156 4 156 42
  let%span schecked_ops40 = "../checked_ops.rs" 153 4 153 49
  let%span schecked_ops41 = "../checked_ops.rs" 152 4 152 44
  let%span schecked_ops42 = "../checked_ops.rs" 151 4 151 41
  let%span schecked_ops43 = "../checked_ops.rs" 149 4 149 46
  let%span schecked_ops44 = "../checked_ops.rs" 148 4 148 43
  let%span schecked_ops45 = "../checked_ops.rs" 147 4 147 39
  let%span schecked_ops46 = "../checked_ops.rs" 145 4 145 48
  let%span schecked_ops47 = "../checked_ops.rs" 144 4 144 44
  let%span schecked_ops48 = "../checked_ops.rs" 143 4 143 47
  let%span span49 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span50 = "" 0 0 0 0
  let%span span51 = "" 0 0 0 0
  let%span span52 = "" 0 0 0 0
  let%span span53 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span56 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span57 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span58 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span59 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span60 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span61 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span62 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span63 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span64 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span65 = "" 0 0 0 0
  let%span span66 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span67 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span68 = "" 0 0 0 0
  let%span span69 = "" 0 0 0 0
  let%span span70 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span71 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Option'0.t_Option int8) =
    [%#span49] inv'0 self
  
  predicate inv'2 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int8 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int8 [inv'1 x] . inv'1 x = true
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span50] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span51] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span52] (8 : uint32)
  
  use prelude.prelude.Int8
  
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span57] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span56] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span55] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span54] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#span53] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span60] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span59] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span58] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span64] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span63] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span62] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#span61] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span65] inv'2 self}
    any [ return' (result:bool)-> {[%#span66] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span68] inv'0 self}
    {[@expl:precondition] [%#span67] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span69] inv'1 result}
      {[%#span67] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span71] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[%#span70] (result = Option'0.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (5 : int8)} {[%#schecked_ops1] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (15 : int8)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_add'0 {[%#schecked_ops3] (120 : int8)} {[%#schecked_ops4] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_add'0 {[%#schecked_ops5] (-120 : int8)} {[%#schecked_ops6] (-10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops7] (5 : int8)} {[%#schecked_ops8] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops9] (15 : int8)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops10] (120 : int8)} {[%#schecked_ops11] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops12] (-126 : int8)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops13] (-120 : int8)} {[%#schecked_ops14] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops15] (126 : int8)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops16] (5 : int8)} {[%#schecked_ops17] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops18] (15 : int8)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops19] (120 : int8)} {[%#schecked_ops20] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops21] (127 : int8)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops22] (-120 : int8)} {[%#schecked_ops23] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops24] (-128 : int8)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops25] (5 : int8)} {[%#schecked_ops26] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops27] (15 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops28] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops29] (120 : int8)} {[%#schecked_ops30] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops31] (-126 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops32] true) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops33] (-120 : int8)} {[%#schecked_ops34] (-10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops35] (126 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops36] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops37] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops38] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops39] false} any
    | bb30 = {[%#schecked_ops40] false} any
    | bb27 = {[%#schecked_ops41] false} any
    | bb24 = {[%#schecked_ops42] false} any
    | bb21 = {[%#schecked_ops43] false} any
    | bb18 = {[%#schecked_ops44] false} any
    | bb15 = {[%#schecked_ops45] false} any
    | bb12 = {[%#schecked_ops46] false} any
    | bb8 = {[%#schecked_ops47] false} any
    | bb4 = {[%#schecked_ops48] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : int8 = any_l ()
    | & _4 : Option'0.t_Option int8 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : Option'0.t_Option int8 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : Option'0.t_Option int8 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : int8 = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int8 = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : int8 = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : int8 = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : int8 = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (int8, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (int8, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_pos [#"../checked_ops.rs" 165 0 165 38]
  let%span schecked_ops0 = "../checked_ops.rs" 166 12 166 17
  let%span schecked_ops1 = "../checked_ops.rs" 167 12 167 17
  let%span schecked_ops2 = "../checked_ops.rs" 167 41 167 44
  let%span schecked_ops3 = "../checked_ops.rs" 167 47 167 48
  let%span schecked_ops4 = "../checked_ops.rs" 168 12 168 17
  let%span schecked_ops5 = "../checked_ops.rs" 168 39 168 42
  let%span schecked_ops6 = "../checked_ops.rs" 169 14 169 19
  let%span schecked_ops7 = "../checked_ops.rs" 170 25 170 28
  let%span schecked_ops8 = "../checked_ops.rs" 170 31 170 32
  let%span schecked_ops9 = "../checked_ops.rs" 170 45 170 49
  let%span schecked_ops10 = "../checked_ops.rs" 170 4 170 50
  let%span schecked_ops11 = "../checked_ops.rs" 168 4 168 43
  let%span schecked_ops12 = "../checked_ops.rs" 167 4 167 49
  let%span schecked_ops13 = "../checked_ops.rs" 166 4 166 43
  let%span schecked_ops14 = "../checked_ops.rs" 164 11 164 17
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "" 0 0 0 0
  let%span span17 = "" 0 0 0 0
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span31 = "" 0 0 0 0
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span33 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span34 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span15] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span16] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span17] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span18] (8 : uint32)
  
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span23] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span22] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span21] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span20] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#span19] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span26] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span25] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span24] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span30] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span29] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span28] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#span27] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span31] inv'0 self}
    any [ return' (result:bool)-> {[%#span32] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span34] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[%#span33] (result = Option'0.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_pos (a:int8) (return'  (ret:()))= {[%#schecked_ops14] Int8.to_int a > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (127 : int8)} {a}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {a} {[%#schecked_ops2] (127 : int8)} (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.sub {_14} {[%#schecked_ops3] (2 : int8)} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops4] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (127 : int8)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops6] (127 : int8)} {a} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {a} {[%#schecked_ops7] (127 : int8)} (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.sub {_28} {[%#schecked_ops8] (2 : int8)} (fun (_ret':int8) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int8 = any_l ()
    | & _13 : int8 = any_l ()
    | & _14 : int8 = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : int8 = any_l ()
    | & _28 : int8 = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_neg [#"../checked_ops.rs" 175 0 175 38]
  let%span schecked_ops0 = "../checked_ops.rs" 176 12 176 20
  let%span schecked_ops1 = "../checked_ops.rs" 177 12 177 20
  let%span schecked_ops2 = "../checked_ops.rs" 177 44 177 47
  let%span schecked_ops3 = "../checked_ops.rs" 177 50 177 51
  let%span schecked_ops4 = "../checked_ops.rs" 178 12 178 20
  let%span schecked_ops5 = "../checked_ops.rs" 178 42 178 46
  let%span schecked_ops6 = "../checked_ops.rs" 179 14 179 22
  let%span schecked_ops7 = "../checked_ops.rs" 180 25 180 28
  let%span schecked_ops8 = "../checked_ops.rs" 180 31 180 32
  let%span schecked_ops9 = "../checked_ops.rs" 180 45 180 49
  let%span schecked_ops10 = "../checked_ops.rs" 180 4 180 50
  let%span schecked_ops11 = "../checked_ops.rs" 178 4 178 47
  let%span schecked_ops12 = "../checked_ops.rs" 177 4 177 52
  let%span schecked_ops13 = "../checked_ops.rs" 176 4 176 46
  let%span schecked_ops14 = "../checked_ops.rs" 174 11 174 17
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "" 0 0 0 0
  let%span span17 = "" 0 0 0 0
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span31 = "" 0 0 0 0
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span33 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span34 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span15] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span16] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span17] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span18] (8 : uint32)
  
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span23] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span22] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span21] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span20] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#span19] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span26] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span25] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span24] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span30] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span29] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span28] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#span27] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span31] inv'0 self}
    any [ return' (result:bool)-> {[%#span32] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span34] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[%#span33] (result = Option'0.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_neg (a:int8) (return'  (ret:()))= {[%#schecked_ops14] Int8.to_int a < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add'0 {[%#schecked_ops0] (-128 : int8)} {a}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add'0 {[%#schecked_ops1] (-128 : int8)} {a} (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {a} {[%#schecked_ops2] (127 : int8)} (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops3] (1 : int8)} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_add'0 {[%#schecked_ops4] (-128 : int8)} {a} (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (-128 : int8)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_add'0 {[%#schecked_ops6] (-128 : int8)} {a} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {a} {[%#schecked_ops7] (127 : int8)} (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops8] (1 : int8)} (fun (_ret':int8) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int8 = any_l ()
    | & _13 : int8 = any_l ()
    | & _14 : int8 = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : int8 = any_l ()
    | & _28 : int8 = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_add [#"../checked_ops.rs" 186 0 186 47]
  let%span schecked_ops0 = "../checked_ops.rs" 185 10 185 84
  let%span span1 = "" 0 0 0 0
  let%span span2 = "" 0 0 0 0
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span5 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span1] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span2] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span3] (8 : uint32)
  
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span7] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span6] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span5] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#span4] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_add (a:int8) (b:int8) (return'  (ret:int8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':int8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : int8 = any_l () | & a : int8 = a | & b : int8 = b ] 
    [ return' (result:int8)-> {[@expl:postcondition] [%#schecked_ops0] Int8.to_int result
      = Int8.to_int a + Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_i8_overflowing_add [#"../checked_ops.rs" 191 0 191 44]
  let%span schecked_ops0 = "../checked_ops.rs" 193 4 193 65
  let%span schecked_ops1 = "../checked_ops.rs" 192 4 192 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span5] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span6] (-128 : int8)
  
  use prelude.prelude.Int8
  
  let rec checked_add'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span8] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self + Int8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_add'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span13] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span12] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span11] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self + Int8.to_int rhs}
      {[%#span10] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec overflowing_add'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span17] Int8.to_int self + Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span16] Int8.to_int self + Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self + Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span15] Int8.to_int self + Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self + Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self + Int8.to_int rhs}
      {[%#span14] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self + Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_add (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_add'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add'0 {a} {b} (fun (_ret':Option'0.t_Option int8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l ()
    | & _6 : (int8, bool) = any_l ()
    | & _9 : int8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (int8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option int8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_example [#"../checked_ops.rs" 197 0 197 28]
  let%span schecked_ops0 = "../checked_ops.rs" 198 12 198 15
  let%span schecked_ops1 = "../checked_ops.rs" 198 28 198 30
  let%span schecked_ops2 = "../checked_ops.rs" 198 44 198 46
  let%span schecked_ops3 = "../checked_ops.rs" 199 12 199 17
  let%span schecked_ops4 = "../checked_ops.rs" 199 30 199 32
  let%span schecked_ops5 = "../checked_ops.rs" 199 46 199 49
  let%span schecked_ops6 = "../checked_ops.rs" 200 12 200 20
  let%span schecked_ops7 = "../checked_ops.rs" 200 33 200 35
  let%span schecked_ops8 = "../checked_ops.rs" 202 12 202 15
  let%span schecked_ops9 = "../checked_ops.rs" 202 29 202 31
  let%span schecked_ops10 = "../checked_ops.rs" 202 36 202 38
  let%span schecked_ops11 = "../checked_ops.rs" 203 12 203 17
  let%span schecked_ops12 = "../checked_ops.rs" 203 31 203 33
  let%span schecked_ops13 = "../checked_ops.rs" 203 38 203 41
  let%span schecked_ops14 = "../checked_ops.rs" 204 12 204 20
  let%span schecked_ops15 = "../checked_ops.rs" 204 34 204 36
  let%span schecked_ops16 = "../checked_ops.rs" 204 41 204 44
  let%span schecked_ops17 = "../checked_ops.rs" 206 12 206 15
  let%span schecked_ops18 = "../checked_ops.rs" 206 31 206 33
  let%span schecked_ops19 = "../checked_ops.rs" 206 38 206 40
  let%span schecked_ops20 = "../checked_ops.rs" 207 12 207 17
  let%span schecked_ops21 = "../checked_ops.rs" 207 33 207 35
  let%span schecked_ops22 = "../checked_ops.rs" 207 40 207 43
  let%span schecked_ops23 = "../checked_ops.rs" 208 12 208 20
  let%span schecked_ops24 = "../checked_ops.rs" 208 36 208 38
  let%span schecked_ops25 = "../checked_ops.rs" 208 43 208 47
  let%span schecked_ops26 = "../checked_ops.rs" 210 14 210 17
  let%span schecked_ops27 = "../checked_ops.rs" 210 34 210 36
  let%span schecked_ops28 = "../checked_ops.rs" 211 21 211 23
  let%span schecked_ops29 = "../checked_ops.rs" 211 36 211 41
  let%span schecked_ops30 = "../checked_ops.rs" 212 14 212 19
  let%span schecked_ops31 = "../checked_ops.rs" 212 36 212 38
  let%span schecked_ops32 = "../checked_ops.rs" 213 21 213 24
  let%span schecked_ops33 = "../checked_ops.rs" 213 37 213 42
  let%span schecked_ops34 = "../checked_ops.rs" 214 14 214 22
  let%span schecked_ops35 = "../checked_ops.rs" 214 39 214 41
  let%span schecked_ops36 = "../checked_ops.rs" 215 21 215 24
  let%span schecked_ops37 = "../checked_ops.rs" 215 37 215 41
  let%span schecked_ops38 = "../checked_ops.rs" 215 4 215 42
  let%span schecked_ops39 = "../checked_ops.rs" 213 4 213 43
  let%span schecked_ops40 = "../checked_ops.rs" 211 4 211 42
  let%span schecked_ops41 = "../checked_ops.rs" 208 4 208 48
  let%span schecked_ops42 = "../checked_ops.rs" 207 4 207 44
  let%span schecked_ops43 = "../checked_ops.rs" 206 4 206 41
  let%span schecked_ops44 = "../checked_ops.rs" 204 4 204 45
  let%span schecked_ops45 = "../checked_ops.rs" 203 4 203 42
  let%span schecked_ops46 = "../checked_ops.rs" 202 4 202 39
  let%span schecked_ops47 = "../checked_ops.rs" 200 4 200 47
  let%span schecked_ops48 = "../checked_ops.rs" 199 4 199 50
  let%span schecked_ops49 = "../checked_ops.rs" 198 4 198 47
  let%span span50 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span51 = "" 0 0 0 0
  let%span span52 = "" 0 0 0 0
  let%span span53 = "" 0 0 0 0
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span56 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span57 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span58 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span59 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span60 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span61 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span62 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span63 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span64 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span65 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span66 = "" 0 0 0 0
  let%span span67 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span68 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span69 = "" 0 0 0 0
  let%span span70 = "" 0 0 0 0
  let%span span71 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span72 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Option'0.t_Option int8) =
    [%#span50] inv'0 self
  
  predicate inv'2 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int8 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int8 [inv'1 x] . inv'1 x = true
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span51] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span52] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span53] (8 : uint32)
  
  use prelude.prelude.Int8
  
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span58] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span57] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span56] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span55] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#span54] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span61] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span60] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span59] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span65] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span64] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span63] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#span62] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span66] inv'2 self}
    any [ return' (result:bool)-> {[%#span67] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span69] inv'0 self}
    {[@expl:precondition] [%#span68] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span70] inv'1 result}
      {[%#span68] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span72] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[%#span71] (result = Option'0.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (5 : int8)} {[%#schecked_ops1] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (-5 : int8)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops3] (120 : int8)} {[%#schecked_ops4] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':int8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[%#schecked_ops5] (110 : int8)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops6] (-120 : int8)} {[%#schecked_ops7] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops8] (5 : int8)} {[%#schecked_ops9] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops10] (-5 : int8)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops11] (120 : int8)} {[%#schecked_ops12] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops13] (110 : int8)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops14] (-120 : int8)} {[%#schecked_ops15] (10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops16] (126 : int8)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops17] (5 : int8)} {[%#schecked_ops18] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops19] (-5 : int8)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops20] (120 : int8)} {[%#schecked_ops21] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops22] (110 : int8)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops23] (-120 : int8)} {[%#schecked_ops24] (10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops25] (-128 : int8)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops26] (5 : int8)} {[%#schecked_ops27] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops28] (-5 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops29] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops30] (120 : int8)} {[%#schecked_ops31] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops32] (110 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops33] false) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops34] (-120 : int8)} {[%#schecked_ops35] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops36] (126 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops37] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops38] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops39] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops40] false} any
    | bb30 = {[%#schecked_ops41] false} any
    | bb27 = {[%#schecked_ops42] false} any
    | bb24 = {[%#schecked_ops43] false} any
    | bb21 = {[%#schecked_ops44] false} any
    | bb18 = {[%#schecked_ops45] false} any
    | bb15 = {[%#schecked_ops46] false} any
    | bb12 = {[%#schecked_ops47] false} any
    | bb8 = {[%#schecked_ops48] false} any
    | bb4 = {[%#schecked_ops49] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : int8 = any_l ()
    | & _4 : Option'0.t_Option int8 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : int8 = any_l ()
    | & _9 : Option'0.t_Option int8 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : Option'0.t_Option int8 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : int8 = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int8 = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : int8 = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : int8 = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : int8 = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (int8, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (int8, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_pos [#"../checked_ops.rs" 220 0 220 38]
  let%span schecked_ops0 = "../checked_ops.rs" 221 12 221 20
  let%span schecked_ops1 = "../checked_ops.rs" 222 12 222 20
  let%span schecked_ops2 = "../checked_ops.rs" 222 40 222 43
  let%span schecked_ops3 = "../checked_ops.rs" 222 50 222 51
  let%span schecked_ops4 = "../checked_ops.rs" 223 12 223 20
  let%span schecked_ops5 = "../checked_ops.rs" 223 42 223 46
  let%span schecked_ops6 = "../checked_ops.rs" 224 14 224 22
  let%span schecked_ops7 = "../checked_ops.rs" 225 21 225 24
  let%span schecked_ops8 = "../checked_ops.rs" 225 31 225 32
  let%span schecked_ops9 = "../checked_ops.rs" 225 45 225 49
  let%span schecked_ops10 = "../checked_ops.rs" 225 4 225 50
  let%span schecked_ops11 = "../checked_ops.rs" 223 4 223 47
  let%span schecked_ops12 = "../checked_ops.rs" 222 4 222 52
  let%span schecked_ops13 = "../checked_ops.rs" 221 4 221 46
  let%span schecked_ops14 = "../checked_ops.rs" 219 11 219 17
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "" 0 0 0 0
  let%span span17 = "" 0 0 0 0
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span31 = "" 0 0 0 0
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span33 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span34 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span15] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span16] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span17] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span18] (8 : uint32)
  
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span23] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span22] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span21] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span20] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#span19] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span26] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span25] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span24] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span30] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span29] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span28] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#span27] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span31] inv'0 self}
    any [ return' (result:bool)-> {[%#span32] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span34] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[%#span33] (result = Option'0.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_pos (a:int8) (return'  (ret:()))= {[%#schecked_ops14] Int8.to_int a > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (-128 : int8)} {a}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (-128 : int8)} {a} (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.sub {[%#schecked_ops2] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops3] (1 : int8)} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s2)
      | s2 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s3)
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (-128 : int8)} {a} (fun (_ret':int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_19} {[%#schecked_ops5] (-128 : int8)} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1)
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (-128 : int8)} {a} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.sub {[%#schecked_ops7] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_28 <- _ret' ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops8] (1 : int8)} (fun (_ret':int8) ->  [ &_27 <- _ret' ] s2)
      | s2 = Int8.eq {let (r'0, _) = res in r'0} {_27} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s3)
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_30 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int8 = any_l ()
    | & _13 : int8 = any_l ()
    | & _14 : int8 = any_l ()
    | & _18 : bool = any_l ()
    | & _19 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : int8 = any_l ()
    | & _28 : int8 = any_l ()
    | & _30 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_neg [#"../checked_ops.rs" 230 0 230 38]
  let%span schecked_ops0 = "../checked_ops.rs" 231 12 231 17
  let%span schecked_ops1 = "../checked_ops.rs" 232 12 232 17
  let%span schecked_ops2 = "../checked_ops.rs" 232 39 232 40
  let%span schecked_ops3 = "../checked_ops.rs" 232 48 232 51
  let%span schecked_ops4 = "../checked_ops.rs" 233 12 233 17
  let%span schecked_ops5 = "../checked_ops.rs" 233 39 233 42
  let%span schecked_ops6 = "../checked_ops.rs" 234 14 234 19
  let%span schecked_ops7 = "../checked_ops.rs" 235 23 235 24
  let%span schecked_ops8 = "../checked_ops.rs" 235 32 235 35
  let%span schecked_ops9 = "../checked_ops.rs" 235 48 235 52
  let%span schecked_ops10 = "../checked_ops.rs" 235 4 235 53
  let%span schecked_ops11 = "../checked_ops.rs" 233 4 233 43
  let%span schecked_ops12 = "../checked_ops.rs" 232 4 232 52
  let%span schecked_ops13 = "../checked_ops.rs" 231 4 231 43
  let%span schecked_ops14 = "../checked_ops.rs" 229 11 229 17
  let%span span15 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span16 = "" 0 0 0 0
  let%span span17 = "" 0 0 0 0
  let%span span18 = "" 0 0 0 0
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span28 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span29 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span30 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span31 = "" 0 0 0 0
  let%span span32 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span33 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span34 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span15] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span16] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span17] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span18] (8 : uint32)
  
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span23] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span22] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span21] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span20] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#span19] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span26] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span25] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span24] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span30] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span29] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span28] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#span27] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span31] inv'0 self}
    any [ return' (result:bool)-> {[%#span32] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span34] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[%#span33] (result = Option'0.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_neg (a:int8) (return'  (ret:()))= {[%#schecked_ops14] Int8.to_int a < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub'0 {[%#schecked_ops0] (127 : int8)} {a}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_6 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub'0 {[%#schecked_ops1] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.add {[%#schecked_ops2] (2 : int8)} {a} (fun (_ret':int8) ->  [ &_15 <- _ret' ] s1)
      | s1 = Int8.neg {_15} (fun (_ret:int8) ->  [ &_14 <- _ret ] s2)
      | s2 = Int8.sub {_14} {[%#schecked_ops3] (127 : int8)} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s3)
      | s3 = Int8.eq {_11} {_13} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_sub'0 {[%#schecked_ops4] (127 : int8)} {a} (fun (_ret':int8) ->  [ &_20 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_20} {[%#schecked_ops5] (127 : int8)} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1)
      | s1 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_sub'0 {[%#schecked_ops6] (127 : int8)} {a} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.add {[%#schecked_ops7] (2 : int8)} {a} (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = Int8.neg {_30} (fun (_ret:int8) ->  [ &_29 <- _ret ] s2)
      | s2 = Int8.sub {_29} {[%#schecked_ops8] (127 : int8)} (fun (_ret':int8) ->  [ &_28 <- _ret' ] s3)
      | s3 = Int8.eq {let (r'0, _) = res in r'0} {_28} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s4)
      | s4 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_32 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops9] true) ] s1
      | s1 = any [ br0 -> {_32 = false} (! bb14) | br1 -> {_32} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops10] false} any
    | bb10 = {[%#schecked_ops11] false} any
    | bb7 = {[%#schecked_ops12] false} any
    | bb4 = {[%#schecked_ops13] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & _4 : bool = any_l ()
    | & _6 : Option'0.t_Option int8 = any_l ()
    | & _10 : bool = any_l ()
    | & _11 : int8 = any_l ()
    | & _13 : int8 = any_l ()
    | & _14 : int8 = any_l ()
    | & _15 : int8 = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _26 : bool = any_l ()
    | & _28 : int8 = any_l ()
    | & _29 : int8 = any_l ()
    | & _30 : int8 = any_l ()
    | & _32 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_sub [#"../checked_ops.rs" 241 0 241 47]
  let%span schecked_ops0 = "../checked_ops.rs" 240 10 240 84
  let%span span1 = "" 0 0 0 0
  let%span span2 = "" 0 0 0 0
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span5 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span1] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span2] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span3] (8 : uint32)
  
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span7] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span6] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span5] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#span4] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_sub (a:int8) (b:int8) (return'  (ret:int8))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':int8) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : int8 = any_l () | & a : int8 = a | & b : int8 = b ] 
    [ return' (result:int8)-> {[@expl:postcondition] [%#schecked_ops0] Int8.to_int result
      = Int8.to_int a - Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256}
      (! return' {result}) ]
    
end
module M_checked_ops__test_i8_overflowing_sub [#"../checked_ops.rs" 246 0 246 44]
  let%span schecked_ops0 = "../checked_ops.rs" 248 4 248 65
  let%span schecked_ops1 = "../checked_ops.rs" 247 4 247 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span5] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span6] (-128 : int8)
  
  use prelude.prelude.Int8
  
  let rec checked_sub'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span8] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self - Int8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_sub'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span13] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span12] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span11] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self - Int8.to_int rhs}
      {[%#span10] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec overflowing_sub'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span17] Int8.to_int self - Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span16] Int8.to_int self - Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self - Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span15] Int8.to_int self - Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self - Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self - Int8.to_int rhs}
      {[%#span14] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self - Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_sub (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_sub'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub'0 {a} {b} (fun (_ret':Option'0.t_Option int8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l ()
    | & _6 : (int8, bool) = any_l ()
    | & _9 : int8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (int8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option int8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_example [#"../checked_ops.rs" 252 0 252 28]
  let%span schecked_ops0 = "../checked_ops.rs" 253 12 253 15
  let%span schecked_ops1 = "../checked_ops.rs" 253 28 253 30
  let%span schecked_ops2 = "../checked_ops.rs" 253 44 253 46
  let%span schecked_ops3 = "../checked_ops.rs" 254 12 254 16
  let%span schecked_ops4 = "../checked_ops.rs" 254 29 254 31
  let%span schecked_ops5 = "../checked_ops.rs" 255 12 255 16
  let%span schecked_ops6 = "../checked_ops.rs" 255 29 255 32
  let%span schecked_ops7 = "../checked_ops.rs" 257 12 257 15
  let%span schecked_ops8 = "../checked_ops.rs" 257 29 257 31
  let%span schecked_ops9 = "../checked_ops.rs" 257 36 257 38
  let%span schecked_ops10 = "../checked_ops.rs" 258 12 258 16
  let%span schecked_ops11 = "../checked_ops.rs" 258 30 258 32
  let%span schecked_ops12 = "../checked_ops.rs" 258 37 258 40
  let%span schecked_ops13 = "../checked_ops.rs" 259 12 259 16
  let%span schecked_ops14 = "../checked_ops.rs" 259 30 259 33
  let%span schecked_ops15 = "../checked_ops.rs" 259 38 259 40
  let%span schecked_ops16 = "../checked_ops.rs" 261 12 261 15
  let%span schecked_ops17 = "../checked_ops.rs" 261 31 261 33
  let%span schecked_ops18 = "../checked_ops.rs" 261 38 261 40
  let%span schecked_ops19 = "../checked_ops.rs" 262 12 262 16
  let%span schecked_ops20 = "../checked_ops.rs" 262 32 262 34
  let%span schecked_ops21 = "../checked_ops.rs" 262 39 262 42
  let%span schecked_ops22 = "../checked_ops.rs" 263 12 263 16
  let%span schecked_ops23 = "../checked_ops.rs" 263 32 263 35
  let%span schecked_ops24 = "../checked_ops.rs" 263 40 263 44
  let%span schecked_ops25 = "../checked_ops.rs" 265 14 265 17
  let%span schecked_ops26 = "../checked_ops.rs" 265 34 265 36
  let%span schecked_ops27 = "../checked_ops.rs" 266 21 266 23
  let%span schecked_ops28 = "../checked_ops.rs" 266 36 266 41
  let%span schecked_ops29 = "../checked_ops.rs" 267 14 267 18
  let%span schecked_ops30 = "../checked_ops.rs" 267 35 267 37
  let%span schecked_ops31 = "../checked_ops.rs" 268 21 268 24
  let%span schecked_ops32 = "../checked_ops.rs" 268 37 268 41
  let%span schecked_ops33 = "../checked_ops.rs" 269 14 269 18
  let%span schecked_ops34 = "../checked_ops.rs" 269 35 269 38
  let%span schecked_ops35 = "../checked_ops.rs" 270 21 270 23
  let%span schecked_ops36 = "../checked_ops.rs" 270 36 270 40
  let%span schecked_ops37 = "../checked_ops.rs" 270 4 270 41
  let%span schecked_ops38 = "../checked_ops.rs" 268 4 268 42
  let%span schecked_ops39 = "../checked_ops.rs" 266 4 266 42
  let%span schecked_ops40 = "../checked_ops.rs" 263 4 263 45
  let%span schecked_ops41 = "../checked_ops.rs" 262 4 262 43
  let%span schecked_ops42 = "../checked_ops.rs" 261 4 261 41
  let%span schecked_ops43 = "../checked_ops.rs" 259 4 259 41
  let%span schecked_ops44 = "../checked_ops.rs" 258 4 258 41
  let%span schecked_ops45 = "../checked_ops.rs" 257 4 257 39
  let%span schecked_ops46 = "../checked_ops.rs" 255 4 255 44
  let%span schecked_ops47 = "../checked_ops.rs" 254 4 254 43
  let%span schecked_ops48 = "../checked_ops.rs" 253 4 253 47
  let%span span49 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span50 = "" 0 0 0 0
  let%span span51 = "" 0 0 0 0
  let%span span52 = "" 0 0 0 0
  let%span span53 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span54 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span56 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span57 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span58 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span59 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span60 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span61 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span62 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span63 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span64 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span65 = "" 0 0 0 0
  let%span span66 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span67 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span68 = "" 0 0 0 0
  let%span span69 = "" 0 0 0 0
  let%span span70 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span71 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Option'0.t_Option int8) =
    [%#span49] inv'0 self
  
  predicate inv'2 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Option'0.t_Option int8 [inv'2 x] . inv'2 x = true
  
  predicate inv'1 (_1 : int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int8 [inv'1 x] . inv'1 x = true
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span50] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span51] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span52] (8 : uint32)
  
  use prelude.prelude.Int8
  
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span57] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span56] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span55] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span54] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#span53] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span60] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span59] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span58] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span64] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span63] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span62] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#span61] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span65] inv'2 self}
    any [ return' (result:bool)-> {[%#span66] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span68] inv'0 self}
    {[@expl:precondition] [%#span67] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span69] inv'1 result}
      {[%#span67] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span71] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[%#span70] (result = Option'0.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (5 : int8)} {[%#schecked_ops1] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_4} (fun (_ret':int8) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_3} {[%#schecked_ops2] (50 : int8)} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1)
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops3] (50 : int8)} {[%#schecked_ops4] (10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = is_none'0 {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops5] (50 : int8)} {[%#schecked_ops6] (-10 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = is_none'0 {_14} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops7] (5 : int8)} {[%#schecked_ops8] (10 : int8)}
          (fun (_ret':int8) ->  [ &_18 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_18} {[%#schecked_ops9] (50 : int8)} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1)
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops10] (50 : int8)} {[%#schecked_ops11] (10 : int8)}
          (fun (_ret':int8) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb16 ]
      
    | bb16 = s0
      [ s0 = Int8.eq {_22} {[%#schecked_ops12] (-12 : int8)} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops13] (50 : int8)} {[%#schecked_ops14] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_26 <- _ret' ] s1)
      | s1 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.eq {_26} {[%#schecked_ops15] (12 : int8)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1)
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops16] (5 : int8)} {[%#schecked_ops17] (10 : int8)}
          (fun (_ret':int8) ->  [ &_30 <- _ret' ] s1)
      | s1 = bb22 ]
      
    | bb22 = s0
      [ s0 = Int8.eq {_30} {[%#schecked_ops18] (50 : int8)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1)
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
      
    | bb23 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops19] (50 : int8)} {[%#schecked_ops20] (10 : int8)}
          (fun (_ret':int8) ->  [ &_34 <- _ret' ] s1)
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 = Int8.eq {_34} {[%#schecked_ops21] (127 : int8)} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1)
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops22] (50 : int8)} {[%#schecked_ops23] (-10 : int8)}
          (fun (_ret':int8) ->  [ &_38 <- _ret' ] s1)
      | s1 = bb28 ]
      
    | bb28 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops24] (-128 : int8)} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s1)
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops25] (5 : int8)} {[%#schecked_ops26] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops27] (50 : int8)}
          (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 =  [ &_44 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops28] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops29] (50 : int8)} {[%#schecked_ops30] (10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops31] (-12 : int8)}
          (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 =  [ &_51 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops32] true) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
      
    | bb39 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops33] (50 : int8)} {[%#schecked_ops34] (-10 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops35] (12 : int8)}
          (fun (_ret':bool) ->  [ &_56 <- _ret' ] s1)
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 =  [ &_58 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops36] true) ] s1
      | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
      
    | bb45 = return' {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops37] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops38] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops39] false} any
    | bb30 = {[%#schecked_ops40] false} any
    | bb27 = {[%#schecked_ops41] false} any
    | bb24 = {[%#schecked_ops42] false} any
    | bb21 = {[%#schecked_ops43] false} any
    | bb18 = {[%#schecked_ops44] false} any
    | bb15 = {[%#schecked_ops45] false} any
    | bb12 = {[%#schecked_ops46] false} any
    | bb8 = {[%#schecked_ops47] false} any
    | bb4 = {[%#schecked_ops48] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _3 : int8 = any_l ()
    | & _4 : Option'0.t_Option int8 = any_l ()
    | & _7 : bool = any_l ()
    | & _9 : Option'0.t_Option int8 = any_l ()
    | & _12 : bool = any_l ()
    | & _14 : Option'0.t_Option int8 = any_l ()
    | & _17 : bool = any_l ()
    | & _18 : int8 = any_l ()
    | & _21 : bool = any_l ()
    | & _22 : int8 = any_l ()
    | & _25 : bool = any_l ()
    | & _26 : int8 = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : int8 = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : int8 = any_l ()
    | & _37 : bool = any_l ()
    | & _38 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _42 : bool = any_l ()
    | & _44 : bool = any_l ()
    | & res1 : (int8, bool) = any_l ()
    | & _49 : bool = any_l ()
    | & _51 : bool = any_l ()
    | & res2 : (int8, bool) = any_l ()
    | & _56 : bool = any_l ()
    | & _58 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_zero [#"../checked_ops.rs" 274 0 274 30]
  let%span schecked_ops0 = "../checked_ops.rs" 275 12 275 15
  let%span schecked_ops1 = "../checked_ops.rs" 275 43 275 44
  let%span schecked_ops2 = "../checked_ops.rs" 276 12 276 15
  let%span schecked_ops3 = "../checked_ops.rs" 276 35 276 36
  let%span schecked_ops4 = "../checked_ops.rs" 277 12 277 15
  let%span schecked_ops5 = "../checked_ops.rs" 277 37 277 38
  let%span schecked_ops6 = "../checked_ops.rs" 278 14 278 17
  let%span schecked_ops7 = "../checked_ops.rs" 279 21 279 22
  let%span schecked_ops8 = "../checked_ops.rs" 279 35 279 40
  let%span schecked_ops9 = "../checked_ops.rs" 279 4 279 41
  let%span schecked_ops10 = "../checked_ops.rs" 277 4 277 39
  let%span schecked_ops11 = "../checked_ops.rs" 276 4 276 37
  let%span schecked_ops12 = "../checked_ops.rs" 275 4 275 45
  let%span span13 = "" 0 0 0 0
  let%span span14 = "" 0 0 0 0
  let%span span15 = "" 0 0 0 0
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  let%span span21 = "../../../../creusot-contracts/src/std/num.rs" 168 16 171 18
  let%span span22 = "../../../../creusot-contracts/src/std/num.rs" 173 16 173 85
  let%span span23 = "../../../../creusot-contracts/src/std/num.rs" 174 16 174 85
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span26 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span27 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span28 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span29 = "" 0 0 0 0
  let%span span30 = "" 0 0 0 0
  let%span span31 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span32 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  
  use prelude.prelude.Int8
  
  predicate inv'1 (_1 : int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int8 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span13] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span14] (-128 : int8)
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span15] (8 : uint32)
  
  use prelude.prelude.Int8
  
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span20] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span19] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span18] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span17] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#span16] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec saturating_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span23] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MAX'0 : int8)}
      {[%#span22] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      {[%#span21] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      (! return' {result}) ]
    
  
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span27] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span26] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span25] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#span24] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span29] inv'0 self}
    {[@expl:precondition] [%#span28] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span30] inv'1 result}
      {[%#span28] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span32] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[%#span31] (result = Option'0.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_zero (a:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul'0 {[%#schecked_ops0] (0 : int8)} {a}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = unwrap'0 {_5} (fun (_ret':int8) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {_4} {[%#schecked_ops1] (0 : int8)} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1)
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
      
    | bb3 = s0
      [ s0 = wrapping_mul'0 {[%#schecked_ops2] (0 : int8)} {a} (fun (_ret':int8) ->  [ &_10 <- _ret' ] s1) | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = Int8.eq {_10} {[%#schecked_ops3] (0 : int8)} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1)
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 = saturating_mul'0 {[%#schecked_ops4] (0 : int8)} {a} (fun (_ret':int8) ->  [ &_15 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_15} {[%#schecked_ops5] (0 : int8)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
      
    | bb9 = s0
      [ s0 = overflowing_mul'0 {[%#schecked_ops6] (0 : int8)} {a} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb11 ]
      
    | bb11 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops7] (0 : int8)}
          (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_23 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops8] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
      
    | bb13 = return' {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops9] false} any
    | bb10 = {[%#schecked_ops10] false} any
    | bb7 = {[%#schecked_ops11] false} any
    | bb4 = {[%#schecked_ops12] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & _3 : bool = any_l ()
    | & _4 : int8 = any_l ()
    | & _5 : Option'0.t_Option int8 = any_l ()
    | & _9 : bool = any_l ()
    | & _10 : int8 = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_overflowing_mul [#"../checked_ops.rs" 283 0 283 44]
  let%span schecked_ops0 = "../checked_ops.rs" 285 4 285 65
  let%span schecked_ops1 = "../checked_ops.rs" 284 4 284 56
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "" 0 0 0 0
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 129 20 130 89
  let%span span8 = "../../../../creusot-contracts/src/std/num.rs" 133 16 133 89
  let%span span9 = "" 0 0 0 0
  let%span span10 = "../../../../creusot-contracts/src/std/num.rs" 141 20 141 93
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 144 16 147 18
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 151 16 155 18
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 156 16 160 18
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 183 20 183 95
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 186 16 189 18
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 193 16 197 18
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 198 16 202 18
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 205 20 205 98
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MAX'0 : int8 = [%#span5] (127 : int8)
  
  constant v_MIN'0 : int8 = [%#span6] (-128 : int8)
  
  use prelude.prelude.Int8
  
  let rec checked_mul'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span8] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = Int8.to_int self * Int8.to_int rhs}
      {[%#span7] (result = Option'0.C_None)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      (! return' {result}) ]
    
  
  use int.EuclideanDivision
  
  use int.Power
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.UInt32
  
  constant v_BITS'0 : uint32 = [%#span9] (8 : uint32)
  
  let rec wrapping_mul'0 (self:int8) (rhs:int8) (return'  (ret:int8))= any
    [ return' (result:int8)-> {[%#span13] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span12] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int result
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span11] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int result = Int8.to_int self * Int8.to_int rhs}
      {[%#span10] Int8.to_int result
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec overflowing_mul'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= any
    [ return' (result:(int8, bool))-> {[%#span18] (let (_, a) = result in a)
      = (Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
      \/ Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8))}
      {[%#span17] Int8.to_int self * Int8.to_int rhs > Int8.to_int (v_MAX'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs - k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span16] Int8.to_int self * Int8.to_int rhs < Int8.to_int (v_MIN'0 : int8)
       -> (exists k : int . k > 0
      /\ Int8.to_int (let (a, _) = result in a)
      = Int8.to_int self * Int8.to_int rhs + k * (Int8.to_int (v_MAX'0 : int8) - Int8.to_int (v_MIN'0 : int8) + 1))}
      {[%#span15] Int8.to_int self * Int8.to_int rhs >= Int8.to_int (v_MIN'0 : int8)
      /\ Int8.to_int self * Int8.to_int rhs <= Int8.to_int (v_MAX'0 : int8)
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self * Int8.to_int rhs}
      {[%#span14] Int8.to_int (let (a, _) = result in a)
      = EuclideanDivision.mod (Int8.to_int self * Int8.to_int rhs) (Power.power 2 (UInt32.to_int (v_BITS'0 : uint32)))
      + Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_mul (a:int8) (b:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul'0 {a} {b} (fun (_ret':int8) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = Int8.eq {let (r'0, _) = _6 in r'0} {_9} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1)
      | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ]
      
    | bb3 = s0 [ s0 = overflowing_mul'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &_16 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul'0 {a} {b} (fun (_ret':Option'0.t_Option int8) ->  [ &_21 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none'0 {_21} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- Bool.eq (let (_, r'0) = _16 in r'0) _19 ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
      
    | bb8 = return' {_0}
    | bb9 = {[%#schecked_ops0] false} any
    | bb4 = {[%#schecked_ops1] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & b : int8 = b
    | & _4 : bool = any_l ()
    | & _6 : (int8, bool) = any_l ()
    | & _9 : int8 = any_l ()
    | & _14 : bool = any_l ()
    | & _16 : (int8, bool) = any_l ()
    | & _19 : bool = any_l ()
    | & _21 : Option'0.t_Option int8 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_example [#"../checked_ops.rs" 289 0 289 28]
  let%span schecked_ops0 = "../checked_ops.rs" 290 12 290 15
  let%span schecked_ops1 = "../checked_ops.rs" 290 28 290 29
  let%span schecked_ops2 = "../checked_ops.rs" 291 12 291 15
  let%span schecked_ops3 = "../checked_ops.rs" 291 28 291 29
  let%span schecked_ops4 = "../checked_ops.rs" 291 43 291 44
  let%span schecked_ops5 = "../checked_ops.rs" 292 12 292 15
  let%span schecked_ops6 = "../checked_ops.rs" 292 28 292 30
  let%span schecked_ops7 = "../checked_ops.rs" 292 44 292 46
  let%span schecked_ops8 = "../checked_ops.rs" 293 12 293 20
  let%span schecked_ops9 = "../checked_ops.rs" 293 33 293 35
  let%span schecked_ops10 = "../checked_ops.rs" 295 12 295 15
  let%span schecked_ops11 = "../checked_ops.rs" 295 29 295 30
  let%span schecked_ops12 = "../checked_ops.rs" 295 35 295 36
  let%span schecked_ops13 = "../checked_ops.rs" 296 12 296 15
  let%span schecked_ops14 = "../checked_ops.rs" 296 29 296 31
  let%span schecked_ops15 = "../checked_ops.rs" 296 36 296 38
  let%span schecked_ops16 = "../checked_ops.rs" 297 12 297 20
  let%span schecked_ops17 = "../checked_ops.rs" 297 34 297 36
  let%span schecked_ops18 = "../checked_ops.rs" 297 41 297 45
  let%span schecked_ops19 = "../checked_ops.rs" 299 12 299 15
  let%span schecked_ops20 = "../checked_ops.rs" 299 31 299 32
  let%span schecked_ops21 = "../checked_ops.rs" 299 37 299 38
  let%span schecked_ops22 = "../checked_ops.rs" 300 12 300 15
  let%span schecked_ops23 = "../checked_ops.rs" 300 31 300 33
  let%span schecked_ops24 = "../checked_ops.rs" 300 38 300 40
  let%span schecked_ops25 = "../checked_ops.rs" 301 12 301 20
  let%span schecked_ops26 = "../checked_ops.rs" 301 36 301 38
  let%span schecked_ops27 = "../checked_ops.rs" 301 43 301 47
  let%span schecked_ops28 = "../checked_ops.rs" 303 14 303 17
  let%span schecked_ops29 = "../checked_ops.rs" 303 34 303 35
  let%span schecked_ops30 = "../checked_ops.rs" 304 21 304 22
  let%span schecked_ops31 = "../checked_ops.rs" 304 35 304 40
  let%span schecked_ops32 = "../checked_ops.rs" 305 14 305 17
  let%span schecked_ops33 = "../checked_ops.rs" 305 34 305 36
  let%span schecked_ops34 = "../checked_ops.rs" 306 21 306 23
  let%span schecked_ops35 = "../checked_ops.rs" 306 36 306 41
  let%span schecked_ops36 = "../checked_ops.rs" 307 14 307 22
  let%span schecked_ops37 = "../checked_ops.rs" 307 39 307 41
  let%span schecked_ops38 = "../checked_ops.rs" 308 21 308 25
  let%span schecked_ops39 = "../checked_ops.rs" 308 38 308 42
  let%span schecked_ops40 = "../checked_ops.rs" 308 4 308 43
  let%span schecked_ops41 = "../checked_ops.rs" 306 4 306 42
  let%span schecked_ops42 = "../checked_ops.rs" 304 4 304 41
  let%span schecked_ops43 = "../checked_ops.rs" 301 4 301 48
  let%span schecked_ops44 = "../checked_ops.rs" 300 4 300 41
  let%span schecked_ops45 = "../checked_ops.rs" 299 4 299 39
  let%span schecked_ops46 = "../checked_ops.rs" 297 4 297 46
  let%span schecked_ops47 = "../checked_ops.rs" 296 4 296 39
  let%span schecked_ops48 = "../checked_ops.rs" 295 4 295 37
  let%span schecked_ops49 = "../checked_ops.rs" 293 4 293 47
  let%span schecked_ops50 = "../checked_ops.rs" 292 4 292 47
  let%span schecked_ops51 = "../checked_ops.rs" 291 4 291 45
  let%span schecked_ops52 = "../checked_ops.rs" 290 4 290 41
  let%span span53 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span54 = "" 0 0 0 0
  let%span span55 = "../../../../creusot-contracts/src/std/num.rs" 95 27 95 36
  let%span span56 = "../../../../creusot-contracts/src/std/num.rs" 97 16 97 87
  let%span span57 = "../../../../creusot-contracts/src/std/num.rs" 99 26 99 91
  let%span span58 = "../../../../creusot-contracts/src/std/num.rs" 101 26 101 74
  let%span span59 = "../../../../creusot-contracts/src/std/num.rs" 85 27 85 36
  let%span span60 = "../../../../creusot-contracts/src/std/num.rs" 87 16 87 91
  let%span span61 = "../../../../creusot-contracts/src/std/num.rs" 89 26 89 89
  let%span span62 = "../../../../creusot-contracts/src/std/num.rs" 75 27 75 36
  let%span span63 = "../../../../creusot-contracts/src/std/num.rs" 77 16 77 85
  let%span span64 = "../../../../creusot-contracts/src/std/num.rs" 79 26 79 89
  let%span span65 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span66 = "" 0 0 0 0
  let%span span67 = "" 0 0 0 0
  let%span span68 = "" 0 0 0 0
  let%span span69 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span70 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span71 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.Int8
  
  predicate inv'2 (_1 : int8)
  
  axiom inv_axiom'2 [@rewrite] : forall x : int8 [inv'2 x] . inv'2 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span53] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : int8 = [%#span54] (-128 : int8)
  
  use prelude.prelude.Int8
  
  let rec overflowing_div'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= {[@expl:precondition] [%#span55] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(int8, bool))-> {[%#span58] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1)}
      {[%#span57] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span56] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [%#span59] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[%#span61] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span60] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec wrapping_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [%#span62] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[%#span64] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span63] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span66] inv'1 self}
    {[@expl:precondition] [%#span65] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span67] inv'2 result}
      {[%#span65] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span68] inv'0 self}
    any [ return' (result:bool)-> {[%#span69] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span71] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span70] (result = Option'0.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_example (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {[%#schecked_ops0] (5 : int8)} {[%#schecked_ops1] (0 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_4 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_4} (fun (_ret':bool) ->  [ &_2 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div'0 {[%#schecked_ops2] (5 : int8)} {[%#schecked_ops3] (2 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0 [ s0 = unwrap'0 {_9} (fun (_ret':int8) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = Int8.eq {_8} {[%#schecked_ops4] (2 : int8)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
      
    | bb7 = s0
      [ s0 = checked_div'0 {[%#schecked_ops5] (5 : int8)} {[%#schecked_ops6] (-2 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_14 <- _ret' ] s1)
      | s1 = bb9 ]
      
    | bb9 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':int8) ->  [ &_13 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 = Int8.eq {_13} {[%#schecked_ops7] (-2 : int8)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ]
      
    | bb11 = s0
      [ s0 = checked_div'0 {[%#schecked_ops8] (-128 : int8)} {[%#schecked_ops9] (-1 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_19 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0 [ s0 = is_none'0 {_19} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = any [ br0 -> {_17 = false} (! bb16) | br1 -> {_17} (! bb15) ] 
    | bb15 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops10] (5 : int8)} {[%#schecked_ops11] (2 : int8)}
          (fun (_ret':int8) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb17 ]
      
    | bb17 = s0
      [ s0 = Int8.eq {_23} {[%#schecked_ops12] (2 : int8)} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1)
      | s1 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb18) ]  ]
      
    | bb18 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops13] (5 : int8)} {[%#schecked_ops14] (-2 : int8)}
          (fun (_ret':int8) ->  [ &_27 <- _ret' ] s1)
      | s1 = bb20 ]
      
    | bb20 = s0
      [ s0 = Int8.eq {_27} {[%#schecked_ops15] (-2 : int8)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1)
      | s1 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb21) ]  ]
      
    | bb21 = s0
      [ s0 = wrapping_div'0 {[%#schecked_ops16] (-128 : int8)} {[%#schecked_ops17] (-1 : int8)}
          (fun (_ret':int8) ->  [ &_31 <- _ret' ] s1)
      | s1 = bb23 ]
      
    | bb23 = s0
      [ s0 = Int8.eq {_31} {[%#schecked_ops18] (-128 : int8)} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1)
      | s1 = any [ br0 -> {_30 = false} (! bb25) | br1 -> {_30} (! bb24) ]  ]
      
    | bb24 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops19] (5 : int8)} {[%#schecked_ops20] (2 : int8)}
          (fun (_ret':int8) ->  [ &_35 <- _ret' ] s1)
      | s1 = bb26 ]
      
    | bb26 = s0
      [ s0 = Int8.eq {_35} {[%#schecked_ops21] (2 : int8)} (fun (_ret':bool) ->  [ &_34 <- _ret' ] s1)
      | s1 = any [ br0 -> {_34 = false} (! bb28) | br1 -> {_34} (! bb27) ]  ]
      
    | bb27 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops22] (5 : int8)} {[%#schecked_ops23] (-2 : int8)}
          (fun (_ret':int8) ->  [ &_39 <- _ret' ] s1)
      | s1 = bb29 ]
      
    | bb29 = s0
      [ s0 = Int8.eq {_39} {[%#schecked_ops24] (-2 : int8)} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s1)
      | s1 = any [ br0 -> {_38 = false} (! bb31) | br1 -> {_38} (! bb30) ]  ]
      
    | bb30 = s0
      [ s0 = saturating_div'0 {[%#schecked_ops25] (-128 : int8)} {[%#schecked_ops26] (-1 : int8)}
          (fun (_ret':int8) ->  [ &_43 <- _ret' ] s1)
      | s1 = bb32 ]
      
    | bb32 = s0
      [ s0 = Int8.eq {_43} {[%#schecked_ops27] (-128 : int8)} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s1)
      | s1 = any [ br0 -> {_42 = false} (! bb34) | br1 -> {_42} (! bb33) ]  ]
      
    | bb33 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops28] (5 : int8)} {[%#schecked_ops29] (2 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1)
      | s1 = bb35 ]
      
    | bb35 = s0
      [ s0 = Int8.eq {let (r'0, _) = res in r'0} {[%#schecked_ops30] (2 : int8)}
          (fun (_ret':bool) ->  [ &_47 <- _ret' ] s1)
      | s1 = any [ br0 -> {_47 = false} (! bb39) | br1 -> {_47} (! bb36) ]  ]
      
    | bb36 = s0
      [ s0 =  [ &_49 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops31] false) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb38) | br1 -> {_49} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops32] (5 : int8)} {[%#schecked_ops33] (-2 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res1 <- _ret' ] s1)
      | s1 = bb41 ]
      
    | bb41 = s0
      [ s0 = Int8.eq {let (r'0, _) = res1 in r'0} {[%#schecked_ops34] (-2 : int8)}
          (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = any [ br0 -> {_54 = false} (! bb45) | br1 -> {_54} (! bb42) ]  ]
      
    | bb42 = s0
      [ s0 =  [ &_56 <- Bool.eq (let (_, r'0) = res1 in r'0) ([%#schecked_ops35] false) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb44) | br1 -> {_56} (! bb43) ]  ]
      
    | bb43 = s0
      [ s0 = overflowing_div'0 {[%#schecked_ops36] (-128 : int8)} {[%#schecked_ops37] (-1 : int8)}
          (fun (_ret':(int8, bool)) ->  [ &res2 <- _ret' ] s1)
      | s1 = bb47 ]
      
    | bb47 = s0
      [ s0 = Int8.eq {let (r'0, _) = res2 in r'0} {[%#schecked_ops38] (-128 : int8)}
          (fun (_ret':bool) ->  [ &_61 <- _ret' ] s1)
      | s1 = any [ br0 -> {_61 = false} (! bb51) | br1 -> {_61} (! bb48) ]  ]
      
    | bb48 = s0
      [ s0 =  [ &_63 <- Bool.eq (let (_, r'0) = res2 in r'0) ([%#schecked_ops39] true) ] s1
      | s1 = any [ br0 -> {_63 = false} (! bb50) | br1 -> {_63} (! bb49) ]  ]
      
    | bb49 = return' {_0}
    | bb50 = bb52
    | bb51 = bb52
    | bb52 = {[%#schecked_ops40] false} any
    | bb44 = bb46
    | bb45 = bb46
    | bb46 = {[%#schecked_ops41] false} any
    | bb38 = bb40
    | bb39 = bb40
    | bb40 = {[%#schecked_ops42] false} any
    | bb34 = {[%#schecked_ops43] false} any
    | bb31 = {[%#schecked_ops44] false} any
    | bb28 = {[%#schecked_ops45] false} any
    | bb25 = {[%#schecked_ops46] false} any
    | bb22 = {[%#schecked_ops47] false} any
    | bb19 = {[%#schecked_ops48] false} any
    | bb16 = {[%#schecked_ops49] false} any
    | bb12 = {[%#schecked_ops50] false} any
    | bb8 = {[%#schecked_ops51] false} any
    | bb4 = {[%#schecked_ops52] false} any ]
    )
    [ & _0 : () = any_l ()
    | & _2 : bool = any_l ()
    | & _4 : Option'0.t_Option int8 = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : int8 = any_l ()
    | & _9 : Option'0.t_Option int8 = any_l ()
    | & _12 : bool = any_l ()
    | & _13 : int8 = any_l ()
    | & _14 : Option'0.t_Option int8 = any_l ()
    | & _17 : bool = any_l ()
    | & _19 : Option'0.t_Option int8 = any_l ()
    | & _22 : bool = any_l ()
    | & _23 : int8 = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : int8 = any_l ()
    | & _30 : bool = any_l ()
    | & _31 : int8 = any_l ()
    | & _34 : bool = any_l ()
    | & _35 : int8 = any_l ()
    | & _38 : bool = any_l ()
    | & _39 : int8 = any_l ()
    | & _42 : bool = any_l ()
    | & _43 : int8 = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _47 : bool = any_l ()
    | & _49 : bool = any_l ()
    | & res1 : (int8, bool) = any_l ()
    | & _54 : bool = any_l ()
    | & _56 : bool = any_l ()
    | & res2 : (int8, bool) = any_l ()
    | & _61 : bool = any_l ()
    | & _63 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_no_overflow [#"../checked_ops.rs" 313 0 313 44]
  let%span schecked_ops0 = "../checked_ops.rs" 314 41 314 46
  let%span schecked_ops1 = "../checked_ops.rs" 315 33 315 38
  let%span schecked_ops2 = "../checked_ops.rs" 316 35 316 40
  let%span schecked_ops3 = "../checked_ops.rs" 318 21 318 26
  let%span schecked_ops4 = "../checked_ops.rs" 318 39 318 44
  let%span schecked_ops5 = "../checked_ops.rs" 318 4 318 45
  let%span schecked_ops6 = "../checked_ops.rs" 316 4 316 41
  let%span schecked_ops7 = "../checked_ops.rs" 315 4 315 39
  let%span schecked_ops8 = "../checked_ops.rs" 314 4 314 47
  let%span schecked_ops9 = "../checked_ops.rs" 312 11 312 46
  let%span span10 = "" 0 0 0 0
  let%span span11 = "../../../../creusot-contracts/src/std/num.rs" 95 27 95 36
  let%span span12 = "../../../../creusot-contracts/src/std/num.rs" 97 16 97 87
  let%span span13 = "../../../../creusot-contracts/src/std/num.rs" 99 26 99 91
  let%span span14 = "../../../../creusot-contracts/src/std/num.rs" 101 26 101 74
  let%span span15 = "../../../../creusot-contracts/src/std/num.rs" 85 27 85 36
  let%span span16 = "../../../../creusot-contracts/src/std/num.rs" 87 16 87 91
  let%span span17 = "../../../../creusot-contracts/src/std/num.rs" 89 26 89 89
  let%span span18 = "../../../../creusot-contracts/src/std/num.rs" 75 27 75 36
  let%span span19 = "../../../../creusot-contracts/src/std/num.rs" 77 16 77 85
  let%span span20 = "../../../../creusot-contracts/src/std/num.rs" 79 26 79 89
  let%span span21 = "../../../../creusot-contracts/src/std/option.rs" 30 0 141 1
  let%span span22 = "" 0 0 0 0
  let%span span23 = "" 0 0 0 0
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span25 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.Int8
  
  predicate inv'1 (_1 : int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int8 [inv'1 x] . inv'1 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Int8
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Bool
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : int8 = [%#span10] (-128 : int8)
  
  let rec overflowing_div'0 (self:int8) (rhs:int8) (return'  (ret:(int8, bool)))= {[@expl:precondition] [%#span11] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:(int8, bool))-> {[%#span14] (let (_, a) = result in a)
      = (Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1)}
      {[%#span13] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int (let (a, _) = result in a) = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span12] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int (let (a, _) = result in a) = Int8.to_int self}
      (! return' {result}) ]
    
  
  let rec saturating_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [%#span15] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[%#span17] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span16] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN'0 : int8)}
      (! return' {result}) ]
    
  
  let rec wrapping_div'0 (self:int8) (rhs:int8) (return'  (ret:int8))= {[@expl:precondition] [%#span18] Int8.to_int rhs
    <> 0}
    any
    [ return' (result:int8)-> {[%#span20] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span19] Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self}
      (! return' {result}) ]
    
  
  let rec unwrap'0 (self:Option'0.t_Option int8) (return'  (ret:int8))= {[@expl:precondition] [%#span22] inv'0 self}
    {[@expl:precondition] [%#span21] self <> Option'0.C_None}
    any
    [ return' (result:int8)-> {[%#span23] inv'1 result}
      {[%#span21] Option'0.C_Some result = self}
      (! return' {result}) ]
    
  
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span25] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span24] (result = Option'0.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_no_overflow (a:int8) (b:int8) (return'  (ret:()))= {[%#schecked_ops9] Int8.to_int b <> 0
    /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div'0 {a} {b} (fun (_ret':Option'0.t_Option int8) ->  [ &_7 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap'0 {_7} (fun (_ret':int8) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_11 <- a ] s1
      | s1 =  [ &_12 <- b ] s2
      | s2 = Int8.eq {_12} {[%#schecked_ops0] (0 : int8)} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops0] not _13} s4
      | s4 = bb3 ]
      
    | bb3 = s0
      [ s0 = Int8.eq {_12} {[%#schecked_ops0] (-1 : int8)} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1)
      | s1 = Int8.eq {_11} {[%#schecked_ops0] (-128 : int8)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 =  [ &_16 <- _14 && _15 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops0] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = Int8.div {_11} {_12} (fun (_ret':int8) ->  [ &_10 <- _ret' ] s1)
      | s1 = Int8.eq {_6} {_10} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb6) | br1 -> {_5} (! bb5) ]  ]
      
    | bb5 = s0 [ s0 = wrapping_div'0 {a} {b} (fun (_ret':int8) ->  [ &_20 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_24 <- a ] s1
      | s1 =  [ &_25 <- b ] s2
      | s2 = Int8.eq {_25} {[%#schecked_ops1] (0 : int8)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops1] not _26} s4
      | s4 = bb8 ]
      
    | bb8 = s0
      [ s0 = Int8.eq {_25} {[%#schecked_ops1] (-1 : int8)} (fun (_ret':bool) ->  [ &_27 <- _ret' ] s1)
      | s1 = Int8.eq {_24} {[%#schecked_ops1] (-128 : int8)} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s2)
      | s2 =  [ &_29 <- _27 && _28 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops1] not _29} s4
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = Int8.div {_24} {_25} (fun (_ret':int8) ->  [ &_23 <- _ret' ] s1)
      | s1 = Int8.eq {_20} {_23} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s2)
      | s2 = any [ br0 -> {_19 = false} (! bb11) | br1 -> {_19} (! bb10) ]  ]
      
    | bb10 = s0 [ s0 = saturating_div'0 {a} {b} (fun (_ret':int8) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_37 <- a ] s1
      | s1 =  [ &_38 <- b ] s2
      | s2 = Int8.eq {_38} {[%#schecked_ops2] (0 : int8)} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops2] not _39} s4
      | s4 = bb13 ]
      
    | bb13 = s0
      [ s0 = Int8.eq {_38} {[%#schecked_ops2] (-1 : int8)} (fun (_ret':bool) ->  [ &_40 <- _ret' ] s1)
      | s1 = Int8.eq {_37} {[%#schecked_ops2] (-128 : int8)} (fun (_ret':bool) ->  [ &_41 <- _ret' ] s2)
      | s2 =  [ &_42 <- _40 && _41 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops2] not _42} s4
      | s4 = bb14 ]
      
    | bb14 = s0
      [ s0 = Int8.div {_37} {_38} (fun (_ret':int8) ->  [ &_36 <- _ret' ] s1)
      | s1 = Int8.eq {_33} {_36} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s2)
      | s2 = any [ br0 -> {_32 = false} (! bb16) | br1 -> {_32} (! bb15) ]  ]
      
    | bb15 = s0 [ s0 = overflowing_div'0 {a} {b} (fun (_ret':(int8, bool)) ->  [ &res <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_51 <- a ] s1
      | s1 =  [ &_52 <- b ] s2
      | s2 = Int8.eq {_52} {[%#schecked_ops3] (0 : int8)} (fun (_ret':bool) ->  [ &_53 <- _ret' ] s3)
      | s3 = {[@expl:division by zero] [%#schecked_ops3] not _53} s4
      | s4 = bb18 ]
      
    | bb18 = s0
      [ s0 = Int8.eq {_52} {[%#schecked_ops3] (-1 : int8)} (fun (_ret':bool) ->  [ &_54 <- _ret' ] s1)
      | s1 = Int8.eq {_51} {[%#schecked_ops3] (-128 : int8)} (fun (_ret':bool) ->  [ &_55 <- _ret' ] s2)
      | s2 =  [ &_56 <- _54 && _55 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops3] not _56} s4
      | s4 = bb19 ]
      
    | bb19 = s0
      [ s0 = Int8.div {_51} {_52} (fun (_ret':int8) ->  [ &_50 <- _ret' ] s1)
      | s1 = Int8.eq {let (r'0, _) = res in r'0} {_50} (fun (_ret':bool) ->  [ &_48 <- _ret' ] s2)
      | s2 = any [ br0 -> {_48 = false} (! bb23) | br1 -> {_48} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &_57 <- Bool.eq (let (_, r'0) = res in r'0) ([%#schecked_ops4] false) ] s1
      | s1 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb21) ]  ]
      
    | bb21 = return' {_0}
    | bb22 = bb24
    | bb23 = bb24
    | bb24 = {[%#schecked_ops5] false} any
    | bb16 = {[%#schecked_ops6] false} any
    | bb11 = {[%#schecked_ops7] false} any
    | bb6 = {[%#schecked_ops8] false} any ]
    )
    [ & _0 : () = any_l ()
    | & a : int8 = a
    | & b : int8 = b
    | & _5 : bool = any_l ()
    | & _6 : int8 = any_l ()
    | & _7 : Option'0.t_Option int8 = any_l ()
    | & _10 : int8 = any_l ()
    | & _11 : int8 = any_l ()
    | & _12 : int8 = any_l ()
    | & _13 : bool = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _16 : bool = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : int8 = any_l ()
    | & _23 : int8 = any_l ()
    | & _24 : int8 = any_l ()
    | & _25 : int8 = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : bool = any_l ()
    | & _28 : bool = any_l ()
    | & _29 : bool = any_l ()
    | & _32 : bool = any_l ()
    | & _33 : int8 = any_l ()
    | & _36 : int8 = any_l ()
    | & _37 : int8 = any_l ()
    | & _38 : int8 = any_l ()
    | & _39 : bool = any_l ()
    | & _40 : bool = any_l ()
    | & _41 : bool = any_l ()
    | & _42 : bool = any_l ()
    | & res : (int8, bool) = any_l ()
    | & _48 : bool = any_l ()
    | & _50 : int8 = any_l ()
    | & _51 : int8 = any_l ()
    | & _52 : int8 = any_l ()
    | & _53 : bool = any_l ()
    | & _54 : bool = any_l ()
    | & _55 : bool = any_l ()
    | & _56 : bool = any_l ()
    | & _57 : bool = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_zero [#"../checked_ops.rs" 322 0 322 30]
  let%span schecked_ops0 = "../checked_ops.rs" 323 26 323 27
  let%span schecked_ops1 = "../checked_ops.rs" 323 4 323 39
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span3 = "" 0 0 0 0
  let%span span4 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  let%span span5 = "" 0 0 0 0
  let%span span6 = "../../../../creusot-contracts/src/std/num.rs" 67 26 67 97
  let%span span7 = "../../../../creusot-contracts/src/std/num.rs" 69 16 69 85
  
  use prelude.prelude.Int8
  
  use T_core__option__Option as Option'0
  
  predicate inv'1 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Option'0.t_Option int8 [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : Option'0.t_Option int8) =
    [%#span2] inv'1 self
  
  predicate inv'0 (_1 : Option'0.t_Option int8)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Option'0.t_Option int8 [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  let rec is_none'0 (self:Option'0.t_Option int8) (return'  (ret:bool))= {[@expl:precondition] [%#span3] inv'0 self}
    any [ return' (result:bool)-> {[%#span4] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  use prelude.prelude.Int
  
  constant v_MIN'0 : int8 = [%#span5] (-128 : int8)
  
  use prelude.prelude.Int8
  
  let rec checked_div'0 (self:int8) (rhs:int8) (return'  (ret:Option'0.t_Option int8))= any
    [ return' (result:Option'0.t_Option int8)-> {[%#span7] forall r : int8 . result = Option'0.C_Some r
       -> Int8.to_int r = div (Int8.to_int self) (Int8.to_int rhs)}
      {[%#span6] (result = Option'0.C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self = Int8.to_int (v_MIN'0 : int8) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_zero (a:int8) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div'0 {a} {[%#schecked_ops0] (0 : int8)}
          (fun (_ret':Option'0.t_Option int8) ->  [ &_5 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return' {_0}
    | bb4 = {[%#schecked_ops1] false} any ]
    ) [ & _0 : () = any_l () | & a : int8 = a | & _3 : bool = any_l () | & _5 : Option'0.t_Option int8 = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
