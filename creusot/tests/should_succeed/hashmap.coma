
module Hashmap_List_Type
  type t_list 't =
    | C_Nil
    | C_Cons 't (t_list 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec nil < 't > (input:t_list 't) (ret  )= any
    [ good -> {C_Nil  = input} (! ret) | bad -> {C_Nil  <> input} {false} any ]
    
  
  let rec cons < 't > (input:t_list 't) (ret  (field_0:'t) (field_1:t_list 't))= any
    [ good (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 <> input} {false} any ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Hashmap_Impl2_Hash
  let%span shashmap0 = "../hashmap.rs" 58 14 58 58
  
  let%span span1 = "../hashmap.rs" 65 20 65 21
  
  let%span span2 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span1] x
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  function deep_model'1 (self : usize) : int =
    [%#span2] UIntSize.to_int self
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : usize) : int =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt64
  
  let rec hash (self:usize) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.of_int {UIntSize.to_int self} (fun (_res:uint64) ->  [ &_0 <- _res ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () | & self : usize = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [%#shashmap0] UInt64.to_int result
      = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.prelude.Opaque
  
  type t_nonnull 't =
    | C_NonNull opaque_ptr
  
  function any_l (_ : 'b) : 'a
  
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
  
  function any_l (_ : 'b) : 'a
  
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as PhantomData'0
  
  use Core_Ptr_NonNull_NonNull_Type as NonNull'0
  
  type t_unique 't =
    | C_Unique (NonNull'0.t_nonnull 't) (PhantomData'0.t_phantomdata 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't))= any
    [ good (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_RawVec_Cap_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_cap  =
    | C_Cap usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_cap (input:t_cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Cap'0
  
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_rawvec 't 'a =
    | C_RawVec (Unique'0.t_unique 't) (Cap'0.t_cap) 'a
  
  function any_l (_ : 'b) : 'a
  
  let rec t_rawvec < 't > < 'a > (input:t_rawvec 't 'a) (ret  (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc <> input} {false} any ]
    
end
module Alloc_Vec_Vec_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use Alloc_RawVec_RawVec_Type as RawVec'0
  
  type t_vec 't 'a =
    | C_Vec (RawVec'0.t_rawvec 't 'a) usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_vec < 't > < 'a > (input:t_vec 't 'a) (ret  (buf:RawVec'0.t_rawvec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module Hashmap_MyHashMap_Type
  use Alloc_Alloc_Global_Type as Global'0
  
  use Hashmap_List_Type as List'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  type t_myhashmap 'k 'v =
    | C_MyHashMap (Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_myhashmap < 'k > < 'v > (input:t_myhashmap 'k 'v) (ret  (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global)))= any
    [ good (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))-> {C_MyHashMap buckets = input}
      (! ret {buckets})
    | bad (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))-> {C_MyHashMap buckets <> input}
      {false}
      any ]
    
  
  function myhashmap_buckets (self : t_myhashmap 'k 'v) : Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global) =
    match self with
      | C_MyHashMap a -> a
      end
end
module Hashmap_Impl5_New
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 95 15 95 24
  
  let%span shashmap1 = "../hashmap.rs" 96 14 96 34
  
  let%span shashmap2 = "../hashmap.rs" 97 4 97 64
  
  let%span shashmap3 = "../hashmap.rs" 98 31 98 46
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span7 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span8 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span10 = "../hashmap.rs" 30 12 33 13
  
  let%span span11 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span12 = "../hashmap.rs" 90 20 90 66
  
  let%span span13 = "../hashmap.rs" 85 8 85 53
  
  let%span span14 = "../hashmap.rs" 79 20 79 45
  
  let%span span15 = "../hashmap.rs" 40 12 43 13
  
  let%span span16 = "../hashmap.rs" 200 8 202 9
  
  let%span span17 = "../hashmap.rs" 209 8 212 9
  
  let%span span18 = "" 0 0 0 0
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 174 22 174 41
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 175 12 175 78
  
  let%span span21 = "" 0 0 0 0
  
  predicate invariant'5 (self : v)
  
  predicate inv'5 (_x : v)
  
  axiom inv'5 : forall x : v . inv'5 x = true
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'4 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span4] true
  
  predicate inv'4 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'4 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'4 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span5] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'3 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'1_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span6] inv'3 self)
   -> ([%#span8] inv'4 (shallow_model'1 self))
  && ([%#span7] Seq.length (shallow_model'1 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'3 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span9] inv'4 (shallow_model'1 self)
  
  axiom inv'3 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'3 x = true
  
  predicate invariant'2 (self : List'0.t_list (k, v)) =
    [%#span4] true
  
  predicate inv'2 (_x : List'0.t_list (k, v))
  
  axiom inv'2 : forall x : List'0.t_list (k, v) . inv'2 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'1 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span4] true
  
  predicate inv'1 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'1 : forall x : MyHashMap'0.t_myhashmap k v . inv'1 x = true
  
  type deep_model_ty'0
  
  predicate invariant'0 (self : deep_model_ty'0)
  
  predicate inv'0 (_x : deep_model_ty'0)
  
  axiom inv'0 : forall x : deep_model_ty'0 . inv'0 x = true
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span10] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span11] Seq.get (shallow_model'1 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span12] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span13] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span14] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span15] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span16] forall v : v . forall k : deep_model_ty'0 . inv'5 v
     -> inv'0 k  -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  use prelude.prelude.Borrow
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span17] 0 < Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  use prelude.prelude.Intrinsic
  
  let rec from_elem'0 (elem:List'0.t_list (k, v)) (n:usize) (return'  (ret:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))= {[@expl:precondition] [%#span18] inv'2 elem}
    any
    [ return' (result:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))-> {[%#span21] inv'3 result}
      {[%#span20] forall i : int . 0 <= i /\ i < UIntSize.to_int n  -> index_logic'0 result i = elem}
      {[%#span19] Seq.length (shallow_model'1 result) = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  let rec new (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap k v))= {[%#shashmap0] 0 < UIntSize.to_int size}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- List'0.C_Nil ] s1
      | s1 = from_elem'0 {_7} {size}
          (fun (_ret':Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &res <- MyHashMap'0.C_MyHashMap _6 ] 
        (any [ any_ (_any:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))-> (!  [ &_6 <- _any ] s1) ] )
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &_0 <- res ] (any [ any_ (_any:MyHashMap'0.t_myhashmap k v)-> (!  [ &res <- _any ] s1) ] ) | s1 = bb3 ]
      
    | bb3 = return' {_0} ]
    )
    [ & _0 : MyHashMap'0.t_myhashmap k v = any_l ()
    | & size : usize = size
    | & res : MyHashMap'0.t_myhashmap k v = any_l ()
    | & _6 : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) = any_l ()
    | & _7 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:MyHashMap'0.t_myhashmap k v)-> {[@expl:postcondition] [%#shashmap3] inv'1 result}
      {[@expl:postcondition] [%#shashmap2] forall i : deep_model_ty'0 . inv'0 i
       -> Map.get (shallow_model'0 result) i = Option'0.C_None}
      {[@expl:postcondition] [%#shashmap1] hashmap_inv'0 result}
      (! return' {result}) ]
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_box 't 'a =
    | C_Box (Unique'0.t_unique 't) 'a
  
  function any_l (_ : 'b) : 'a
end
module Hashmap_Impl5_Add
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 108 23 108 41
  
  let%span shashmap1 = "../hashmap.rs" 110 27 110 55
  
  let%span shashmap2 = "../hashmap.rs" 112 20 112 35
  
  let%span shashmap3 = "../hashmap.rs" 114 20 114 52
  
  let%span shashmap4 = "../hashmap.rs" 114 8 114 54
  
  let%span shashmap5 = "../hashmap.rs" 118 20 118 44
  
  let%span shashmap6 = "../hashmap.rs" 133 24 133 44
  
  let%span shashmap7 = "../hashmap.rs" 125 32 125 52
  
  let%span shashmap8 = "../hashmap.rs" 103 15 103 36
  
  let%span shashmap9 = "../hashmap.rs" 106 20 106 24
  
  let%span shashmap10 = "../hashmap.rs" 106 26 106 29
  
  let%span shashmap11 = "../hashmap.rs" 106 34 106 37
  
  let%span shashmap12 = "../hashmap.rs" 104 14 104 35
  
  let%span shashmap13 = "../hashmap.rs" 105 4 105 124
  
  let%span span14 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span15 = "" 0 0 0 0
  
  let%span span16 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span17 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span18 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span20 = "../hashmap.rs" 30 12 33 13
  
  let%span span21 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span22 = "../hashmap.rs" 90 20 90 66
  
  let%span span23 = "../hashmap.rs" 85 8 85 53
  
  let%span span24 = "../hashmap.rs" 79 20 79 45
  
  let%span span25 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span26 = "../hashmap.rs" 40 12 43 13
  
  let%span span27 = "../hashmap.rs" 200 8 202 9
  
  let%span span28 = "../hashmap.rs" 209 8 212 9
  
  let%span span29 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span30 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span31 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span32 = "" 0 0 0 0
  
  let%span span33 = "" 0 0 0 0
  
  let%span span34 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span35 = "../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96
  
  let%span span36 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span37 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span38 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span39 = "" 0 0 0 0
  
  let%span span40 = "" 0 0 0 0
  
  let%span span41 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span42 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span43 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span44 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span45 = "" 0 0 0 0
  
  let%span span46 = "../hashmap.rs" 51 13 51 17
  
  let%span span47 = "../hashmap.rs" 50 14 50 58
  
  let%span span48 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span49 = "" 0 0 0 0
  
  let%span span50 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'17 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'17 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'17 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'17 x = true
  
  use prelude.prelude.UIntSize
  
  predicate invariant'16 (self : usize) =
    [%#span14] true
  
  predicate inv'16 (_x : usize)
  
  axiom inv'16 : forall x : usize . inv'16 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'15 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) =
    [%#span14] true
  
  predicate inv'15 (_x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))
  
  axiom inv'15 : forall x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) . inv'15 x = true
  
  predicate invariant'14 (self : k)
  
  predicate inv'14 (_x : k)
  
  axiom inv'14 : forall x : k . inv'14 x = true
  
  predicate invariant'13 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span14] true
  
  predicate inv'13 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'13 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'13 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'12 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span14] true
  
  predicate inv'12 (_x : borrowed (MyHashMap'0.t_myhashmap k v))
  
  axiom inv'12 : forall x : borrowed (MyHashMap'0.t_myhashmap k v) . inv'12 x = true
  
  predicate invariant'11 (self : borrowed (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'11 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'11 : forall x : borrowed (List'0.t_list (k, v)) . inv'11 x = true
  
  predicate invariant'10 (self : borrowed k)
  
  predicate inv'10 (_x : borrowed k)
  
  axiom inv'10 : forall x : borrowed k . inv'10 x = true
  
  predicate invariant'9 (self : borrowed v)
  
  predicate inv'9 (_x : borrowed v)
  
  axiom inv'9 : forall x : borrowed v . inv'9 x = true
  
  predicate invariant'8 (self : List'0.t_list (k, v)) =
    [%#span14] true
  
  predicate inv'8 (_x : List'0.t_list (k, v))
  
  axiom inv'8 : forall x : List'0.t_list (k, v) . inv'8 x = true
  
  predicate invariant'7 (self : v)
  
  predicate inv'7 (_x : v)
  
  axiom inv'7 : forall x : v . inv'7 x = true
  
  predicate invariant'6 (self : k)
  
  predicate inv'6 (_x : k)
  
  axiom inv'6 : forall x : k . inv'6 x = true
  
  type deep_model_ty'0
  
  predicate invariant'5 (self : deep_model_ty'0)
  
  predicate inv'5 (_x : deep_model_ty'0)
  
  axiom inv'5 : forall x : deep_model_ty'0 . inv'5 x = true
  
  use prelude.prelude.Snapshot
  
  predicate invariant'4 (self : Snapshot.snap_ty (borrowed (List'0.t_list (k, v)))) =
    [%#span14] true
  
  predicate inv'4 (_x : Snapshot.snap_ty (borrowed (List'0.t_list (k, v))))
  
  axiom inv'4 : forall x : Snapshot.snap_ty (borrowed (List'0.t_list (k, v))) . inv'4 x = true
  
  predicate invariant'3 (self : borrowed (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'3 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'3 : forall x : borrowed (List'0.t_list (k, v)) . inv'3 x = true
  
  predicate invariant'2 (self : List'0.t_list (k, v)) =
    [%#span14] true
  
  predicate inv'2 (_x : List'0.t_list (k, v))
  
  axiom inv'2 : forall x : List'0.t_list (k, v) . inv'2 x = true
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span15] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'1 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'4 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'4_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span16] inv'1 self)
   -> ([%#span18] inv'17 (shallow_model'4 self))
  && ([%#span17] Seq.length (shallow_model'4 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span19] inv'17 (shallow_model'4 self)
  
  axiom inv'1 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'1 x = true
  
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) =
    [%#span14] true
  
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)))
  
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) . inv'0 x = true
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  use Core_Option_Option_Type as Option'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span20] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span21] Seq.get (shallow_model'4 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span22] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span23] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span24] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  function shallow_model'1 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span25] shallow_model'0 ( * self)
  
  use map.Map
  
  use prelude.prelude.Intrinsic
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span26] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span27] forall v : v . forall k : deep_model_ty'0 . inv'7 v
     -> inv'5 k  -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span28] 0 < Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  predicate resolve'9 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span29]  ^ self =  * self
  
  predicate resolve'8 (self : List'0.t_list (k, v)) =
    [%#span30] true
  
  predicate resolve'7 (self : v)
  
  predicate resolve'6 (self : k)
  
  predicate resolve'5 (self : borrowed (List'0.t_list (k, v))) =
    [%#span29]  ^ self =  * self
  
  predicate resolve'4 (self : borrowed k) =
    [%#span29]  ^ self =  * self
  
  predicate resolve'3 (self : borrowed v) =
    [%#span29]  ^ self =  * self
  
  function deep_model'1 (self : k) : deep_model_ty'0 =
    [%#span31] deep_model'0 self
  
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] [%#span33] inv'14 other}
    {[@expl:precondition] [%#span32] inv'14 self}
    any [ return' (result:bool)-> {[%#span34] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate resolve'2 (self : Snapshot.snap_ty (borrowed (List'0.t_list (k, v)))) =
    [%#span30] true
  
  use prelude.prelude.Snapshot
  
  predicate resolve'1 (self : borrowed (List'0.t_list (k, v))) =
    [%#span29]  ^ self =  * self
  
  use prelude.prelude.Slice
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (List'0.t_list (k, v))) (fin : Seq.seq (List'0.t_list (k, v)))
    
   =
    [%#span35] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span36] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span37] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span25] shallow_model'4 ( * self)
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) (index:usize) (return'  (ret:borrowed (List'0.t_list (k, v))))= {[@expl:precondition] [%#span40] inv'16 index}
    {[@expl:precondition] [%#span39] inv'15 self}
    {[@expl:precondition] [%#span38] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (List'0.t_list (k, v)))-> {[%#span45] inv'3 result}
      {[%#span44] Seq.length (shallow_model'4 ( ^ self)) = Seq.length (shallow_model'3 self)}
      {[%#span43] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'4 ( ^ self))}
      {[%#span42] has_value'0 index (shallow_model'4 ( ^ self)) ( ^ result)}
      {[%#span41] has_value'0 index (shallow_model'3 self) ( * result)}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [%#span46] inv'14 self}
    any
    [ return' (result:uint64)-> {[%#span47] UInt64.to_int result = hash_log'0 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span48] shallow_model'4 self
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span49] inv'13 self}
    any
    [ return' (result:usize)-> {[%#span50] UIntSize.to_int result = Seq.length (shallow_model'2 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) =
    [%#span30] true
  
  use prelude.prelude.Snapshot
  
  let rec add (self:borrowed (MyHashMap'0.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[%#shashmap11] inv'7 val'}
    {[%#shashmap10] inv'6 key}
    {[%#shashmap9] inv'12 self}
    {[%#shashmap8] hashmap_inv'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#shashmap0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = MyHashMap'0.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &length <- _ret' ] s3))
      | s3 = bb2 ]
      
    | bb2 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_13 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _13}
          (fun (_res:usize) ->  [ &_12 <- _res ] (any [ any_ (_any:uint64)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 =  [ &_15 <- length ] s2
      | s2 = UIntSize.eq {_15} {[%#shashmap1] (0 : usize)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s3)
      | s3 = {[@expl:remainder by zero] [%#shashmap1] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = UIntSize.rem {_12} {_15}
          (fun (_ret':usize) ->
             [ &index <- _ret' ] 
            (any
            [ any_ (_any:usize)-> (!  [ &_12 <- _any ] (any [ any_ (_any:usize)-> (!  [ &_15 <- _any ] s1) ] )) ]
            ))
      | s1 = MyHashMap'0.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            Borrow.borrow_final
              <Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)>
              {rbuckets'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) ->
                 [ &_20 <- _ret' ] 
                MyHashMap'0.t_myhashmap <k> <v> { * self}
                  (fun (l_buckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                     [ &self <- { self with current = MyHashMap'0.C_MyHashMap ( ^ _20) ; } ] 
                    s2)))
      | s2 = -{inv'1 ( ^ _20)}- s3
      | s3 = index_mut'0 {_20} {index} (fun (_ret':borrowed (List'0.t_list (k, v))) ->  [ &_19 <- _ret' ] s4)
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <List'0.t_list (k, v)> { * _19} {Borrow.get_id _19}
          (fun (_ret':borrowed (List'0.t_list (k, v))) ->
             [ &_18 <- _ret' ] 
             [ &_19 <- { _19 with current = ( ^ _18) ; } ] 
            s1)
      | s1 = -{inv'2 ( ^ _18)}- s2
      | s2 = Borrow.borrow_final <List'0.t_list (k, v)> { * _18} {Borrow.get_id _18}
          (fun (_ret':borrowed (List'0.t_list (k, v))) ->
             [ &l <- _ret' ] 
             [ &_18 <- { _18 with current = ( ^ l) ; } ] 
            s3)
      | s3 = -{inv'2 ( ^ l)}- s4
      | s4 = {[@expl:type invariant] inv'3 _18} s5
      | s5 = -{resolve'1 _18}- s6
      | s6 =  [ &old_l <- [%#shashmap2] Snapshot.new l ] s7
      | s7 = bb6 ]
      
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv'4 old_l} s1 | s1 = -{resolve'2 old_l}- s2 | s2 = bb7 ] 
    | bb7 = bb7
      [ bb7 = {[@expl:loop invariant] [%#shashmap4] (forall i : deep_model_ty'0 . inv'5 i
         -> get'0 ( * l) i = get'0 ( ^ l) i \/ i = deep_model'0 key)
        /\ no_double_binding'0 ( ^ l)  -> no_double_binding'0 ( ^ Snapshot.inner old_l)}
        {[@expl:loop invariant] [%#shashmap5] no_double_binding'0 ( * l)}
        {[@expl:loop invariant] [%#shashmap4] forall i : deep_model_ty'0 . inv'5 i
         -> get'0 ( ^ l) i = get'0 ( * l) i  -> get'0 ( ^ Snapshot.inner old_l) i = get'0 ( * Snapshot.inner old_l) i}
        {[@expl:loop invariant] [%#shashmap4] get'0 ( ^ l) (deep_model'0 key) = Option'0.C_Some val'
         -> get'0 ( ^ Snapshot.inner old_l) (deep_model'0 key) = Option'0.C_Some val'}
        {[@expl:loop invariant] [%#shashmap4] good_bucket'0 ( * Snapshot.inner old_self) ( ^ l) (UIntSize.to_int index)
         -> good_bucket'0 ( * Snapshot.inner old_self) ( ^ Snapshot.inner old_l) (UIntSize.to_int index)}
        {[@expl:loop invariant] [%#shashmap3] good_bucket'0 ( * Snapshot.inner old_self) ( * l) (UIntSize.to_int index)}
        (! s0) [ s0 = bb8 ] 
        [ bb8 = any
          [ br0 -> { * l = List'0.C_Nil } (! bb14)
          | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> { * l = List'0.C_Cons a b} (! bb9) ]
          
        | bb9 = bb10
        | bb10 = s0
          [ s0 = List'0.cons <(k, v)> { * l}
              (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->
                Borrow.borrow_final
                  <k>
                  {let (r'0, _) = r0'0 in r'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id l) 1) 1}
                  (fun (_ret':borrowed k) ->
                     [ &k <- _ret' ] 
                    List'0.cons <(k, v)> { * l}
                      (fun (l_0'0:(k, v)) (l_1'0:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons (let (_, l'2) = l_0'0 in ( ^ k, l'2)) l_1'0 ; } ] 
                        s1)))
          | s1 = -{inv'6 ( ^ k)}- s2
          | s2 = List'0.cons <(k, v)> { * l}
              (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->
                Borrow.borrow_final
                  <v>
                  {let (_, r'1) = r0'1 in r'1}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id l) 1) 2}
                  (fun (_ret':borrowed v) ->
                     [ &v <- _ret' ] 
                    List'0.cons <(k, v)> { * l}
                      (fun (l_0'1:(k, v)) (l_1'1:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons (let (l'4, _) = l_0'1 in (l'4,  ^ v)) l_1'1 ; } ] 
                        s3)))
          | s3 = -{inv'7 ( ^ v)}- s4
          | s4 = List'0.cons <(k, v)> { * l}
              (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->
                Borrow.borrow_final <List'0.t_list (k, v)> {r1'2} {Borrow.inherit_id (Borrow.get_id l) 2}
                  (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                     [ &tl <- _ret' ] 
                    List'0.cons <(k, v)> { * l}
                      (fun (l_0'2:(k, v)) (l_1'2:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons l_0'2 ( ^ tl) ; } ] 
                        s5)))
          | s5 = -{inv'8 ( ^ tl)}- s6
          | s6 =  [ &tl1 <- tl ] (any [ any_ (_any:borrowed (List'0.t_list (k, v)))-> (!  [ &tl <- _any ] s7) ] )
          | s7 = eq'0 { * k} {key} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s8)
          | s8 = bb11 ]
          
        | bb11 = any [ br0 -> {_38 = false} (! bb13) | br1 -> {_38} (! bb12) ] 
        | bb13 = s0
          [ s0 = {[@expl:type invariant] inv'9 v} s1
          | s1 = -{resolve'3 v}- s2
          | s2 = {[@expl:type invariant] inv'10 k} s3
          | s3 = -{resolve'4 k}- s4
          | s4 = Borrow.borrow_mut <List'0.t_list (k, v)> { * tl1}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_46 <- _ret' ] 
                 [ &tl1 <- { tl1 with current = ( ^ _46) ; } ] 
                s5)
          | s5 = -{inv'2 ( ^ _46)}- s6
          | s6 = Borrow.borrow_final <List'0.t_list (k, v)> { * _46} {Borrow.get_id _46}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_45 <- _ret' ] 
                 [ &_46 <- { _46 with current = ( ^ _45) ; } ] 
                s7)
          | s7 = -{inv'2 ( ^ _45)}- s8
          | s8 = {[@expl:type invariant] inv'3 l} s9
          | s9 = -{resolve'1 l}- s10
          | s10 =  [ &l <- _45 ] (any [ any_ (_any:borrowed (List'0.t_list (k, v)))-> (!  [ &_45 <- _any ] s11) ] )
          | s11 = {[@expl:type invariant] inv'3 _46} s12
          | s12 = -{resolve'1 _46}- s13
          | s13 = {[@expl:type invariant] inv'11 tl1} s14
          | s14 = -{resolve'5 tl1}- s15
          | s15 = bb7 ]
           ]
         ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'6 key} s1
      | s1 = -{resolve'6 key}- s2
      | s2 = {[@expl:type invariant] inv'7 val'} s3
      | s3 = -{resolve'7 val'}- s4
      | s4 =  [ &_51 <- (key, val') ] s5
      | s5 =  [ &_55 <- List'0.C_Nil ] s6
      | s6 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_50 <- List'0.C_Cons _51 _55 ] 
        (any
        [ any_ (_any:(k, v))-> (!  [ &_51 <- _any ] 
          (any [ any_ (_any:List'0.t_list (k, v))-> (!  [ &_55 <- _any ] s1) ] )) ]
        )
      | s1 = bb16 ]
      
    | bb16 = bb17
    | bb17 = s0
      [ s0 =  [ &l <- { l with current = _50 ; } ] 
        (any [ any_ (_any:List'0.t_list (k, v))-> (!  [ &_50 <- _any ] s1) ] )
      | s1 = {[@expl:type invariant] inv'2 ( * l)} s2
      | s2 = -{resolve'8 ( * l)}- s3
      | s3 = {[@expl:type invariant] inv'3 l} s4
      | s4 = -{resolve'1 l}- s5
      | s5 = bb19 ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'3 _19} s1
      | s1 = -{resolve'1 _19}- s2
      | s2 = {[@expl:type invariant] inv'12 self} s3
      | s3 = -{resolve'9 self}- s4
      | s4 = {[@expl:assertion] [%#shashmap6] hashmap_inv'0 ( * self)} s5
      | s5 = bb20 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'11 tl1} s1
      | s1 = -{resolve'5 tl1}- s2
      | s2 = {[@expl:type invariant] inv'10 k} s3
      | s3 = -{resolve'4 k}- s4
      | s4 = {[@expl:type invariant] inv'6 key} s5
      | s5 = -{resolve'6 key}- s6
      | s6 = {[@expl:type invariant] inv'7 val'} s7
      | s7 = -{resolve'7 val'}- s8
      | s8 =  [ &v <- { v with current = val' ; } ] s9
      | s9 = {[@expl:type invariant] inv'7 ( * v)} s10
      | s10 = -{resolve'7 ( * v)}- s11
      | s11 = {[@expl:type invariant] inv'9 v} s12
      | s12 = -{resolve'3 v}- s13
      | s13 = {[@expl:type invariant] inv'3 _19} s14
      | s14 = -{resolve'1 _19}- s15
      | s15 = {[@expl:type invariant] inv'3 l} s16
      | s16 = -{resolve'1 l}- s17
      | s17 = {[@expl:type invariant] inv'12 self} s18
      | s18 = -{resolve'9 self}- s19
      | s19 = {[@expl:assertion] [%#shashmap7] hashmap_inv'0 ( * self)} s20
      | s20 = bb20 ]
      
    | bb20 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (MyHashMap'0.t_myhashmap k v) = self
    | & key : k = key
    | & val' : v = val'
    | & old_self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l ()
    | & length : usize = any_l ()
    | & index : usize = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : uint64 = any_l ()
    | & _15 : usize = any_l ()
    | & _16 : bool = any_l ()
    | & l : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _18 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _19 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _20 : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) = any_l ()
    | & old_l : Snapshot.snap_ty (borrowed (List'0.t_list (k, v))) = any_l ()
    | & k : borrowed k = any_l ()
    | & v : borrowed v = any_l ()
    | & tl : borrowed (List'0.t_list (k, v)) = any_l ()
    | & tl1 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _38 : bool = any_l ()
    | & _45 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _46 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _50 : List'0.t_list (k, v) = any_l ()
    | & _51 : (k, v) = any_l ()
    | & _55 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#shashmap13] forall i : deep_model_ty'0 . inv'5 i
       -> Map.get (shallow_model'0 ( ^ self)) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'1 self) i)}
      {[@expl:postcondition] [%#shashmap12] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Get
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 142 27 142 67
  
  let%span shashmap1 = "../hashmap.rs" 145 20 145 101
  
  let%span shashmap2 = "../hashmap.rs" 136 15 136 33
  
  let%span shashmap3 = "../hashmap.rs" 141 16 141 20
  
  let%span shashmap4 = "../hashmap.rs" 141 22 141 25
  
  let%span shashmap5 = "../hashmap.rs" 137 14 140 5
  
  let%span shashmap6 = "../hashmap.rs" 141 33 141 43
  
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span8 = "" 0 0 0 0
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span13 = "../hashmap.rs" 30 12 33 13
  
  let%span span14 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span15 = "../hashmap.rs" 90 20 90 66
  
  let%span span16 = "../hashmap.rs" 85 8 85 53
  
  let%span span17 = "../hashmap.rs" 79 20 79 45
  
  let%span span18 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span19 = "../hashmap.rs" 40 12 43 13
  
  let%span span20 = "../hashmap.rs" 200 8 202 9
  
  let%span span21 = "../hashmap.rs" 209 8 212 9
  
  let%span span22 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span23 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span24 = "" 0 0 0 0
  
  let%span span25 = "" 0 0 0 0
  
  let%span span26 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span27 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span28 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span29 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span30 = "" 0 0 0 0
  
  let%span span31 = "" 0 0 0 0
  
  let%span span32 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span33 = "" 0 0 0 0
  
  let%span span34 = "" 0 0 0 0
  
  let%span span35 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span36 = "../hashmap.rs" 51 13 51 17
  
  let%span span37 = "../hashmap.rs" 50 14 50 58
  
  type deep_model_ty'0
  
  predicate invariant'12 (self : deep_model_ty'0)
  
  predicate inv'12 (_x : deep_model_ty'0)
  
  axiom inv'12 : forall x : deep_model_ty'0 . inv'12 x = true
  
  predicate invariant'11 (self : v)
  
  predicate inv'11 (_x : v)
  
  axiom inv'11 : forall x : v . inv'11 x = true
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'10 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span7] true
  
  predicate inv'10 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'10 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'10 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span8] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'9 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'2_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span9] inv'9 self)
   -> ([%#span11] inv'10 (shallow_model'2 self))
  && ([%#span10] Seq.length (shallow_model'2 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'9 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span12] inv'10 (shallow_model'2 self)
  
  axiom inv'9 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'9 x = true
  
  predicate invariant'8 (self : usize) =
    [%#span7] true
  
  predicate inv'8 (_x : usize)
  
  axiom inv'8 : forall x : usize . inv'8 x = true
  
  predicate invariant'7 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span7] true
  
  predicate inv'7 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'7 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'7 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'6 (self : Option'0.t_option v) =
    [%#span7] true
  
  predicate inv'6 (_x : Option'0.t_option v)
  
  axiom inv'6 : forall x : Option'0.t_option v . inv'6 x = true
  
  predicate invariant'5 (self : k)
  
  predicate inv'5 (_x : k)
  
  axiom inv'5 : forall x : k . inv'5 x = true
  
  predicate invariant'4 (self : List'0.t_list (k, v)) =
    [%#span7] true
  
  predicate inv'4 (_x : List'0.t_list (k, v))
  
  axiom inv'4 : forall x : List'0.t_list (k, v) . inv'4 x = true
  
  predicate invariant'3 (self : v)
  
  predicate inv'3 (_x : v)
  
  axiom inv'3 : forall x : v . inv'3 x = true
  
  predicate invariant'2 (self : k)
  
  predicate inv'2 (_x : k)
  
  axiom inv'2 : forall x : k . inv'2 x = true
  
  predicate invariant'1 (self : List'0.t_list (k, v)) =
    [%#span7] true
  
  predicate inv'1 (_x : List'0.t_list (k, v))
  
  axiom inv'1 : forall x : List'0.t_list (k, v) . inv'1 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'0 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span7] true
  
  predicate inv'0 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'0 : forall x : MyHashMap'0.t_myhashmap k v . inv'0 x = true
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span13] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span14] Seq.get (shallow_model'2 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span15] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span16] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'3 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span17] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v) =
    [%#span18] shallow_model'3 self
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span19] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span20] forall v : v . forall k : deep_model_ty'0 . inv'11 v
     -> inv'12 k  -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span21] 0 < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'5 (self : k)
  
  predicate resolve'4 (self : List'0.t_list (k, v)) =
    [%#span22] true
  
  predicate resolve'3 (self : v)
  
  function deep_model'1 (self : k) : deep_model_ty'0 =
    [%#span23] deep_model'0 self
  
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] [%#span25] inv'2 other}
    {[@expl:precondition] [%#span24] inv'2 self}
    any [ return' (result:bool)-> {[%#span26] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ] 
  
  predicate resolve'2 (self : k)
  
  predicate resolve'1 (self : List'0.t_list (k, v)) =
    [%#span22] true
  
  use prelude.prelude.Slice
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span27] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span28] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span18] shallow_model'2 self
  
  let rec index'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (index:usize) (return'  (ret:List'0.t_list (k, v)))= {[@expl:precondition] [%#span31] inv'8 index}
    {[@expl:precondition] [%#span30] inv'7 self}
    {[@expl:precondition] [%#span29] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:List'0.t_list (k, v))-> {[%#span33] inv'1 result}
      {[%#span32] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span22] true
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span34] inv'7 self}
    any
    [ return' (result:usize)-> {[%#span35] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [%#span36] inv'2 self}
    any
    [ return' (result:uint64)-> {[%#span37] UInt64.to_int result = hash_log'0 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  let rec get (self:MyHashMap'0.t_myhashmap k v) (key:k) (return'  (ret:Option'0.t_option v))= {[%#shashmap4] inv'5 key}
    {[%#shashmap3] inv'0 self}
    {[%#shashmap2] hashmap_inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_8 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _8}
          (fun (_res:usize) ->  [ &_7 <- _res ] (any [ any_ (_any:uint64)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = MyHashMap'0.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.eq {_10} {[%#shashmap0] (0 : usize)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = {[@expl:remainder by zero] [%#shashmap0] not _12} s2
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = UIntSize.rem {_7} {_10}
          (fun (_ret':usize) ->
             [ &index <- _ret' ] 
            (any [ any_ (_any:usize)-> (!  [ &_7 <- _any ] (any [ any_ (_any:usize)-> (!  [ &_10 <- _any ] s1) ] )) ] ))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 = MyHashMap'0.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            index'0 {rbuckets'0} {index} (fun (_ret':List'0.t_list (k, v)) ->  [ &_14 <- _ret' ] s4))
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &l <- _14 ] s1 | s1 = {[@expl:type invariant] inv'1 _14} s2 | s2 = -{resolve'1 _14}- s3 | s3 = bb5 ]
      
    | bb5 = bb5
      [ bb5 = {[@expl:loop invariant] [%#shashmap1] get'0 (bucket'0 self (deep_model'0 key)) (deep_model'0 key)
        = get'0 l (deep_model'0 key)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = any
          [ br0 -> {l = List'0.C_Nil } (! bb12)
          | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> {l = List'0.C_Cons a b} (! bb7) ]
          
        | bb7 = bb8
        | bb8 = s0
          [ s0 = List'0.cons <(k, v)> {l}
              (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
          | s1 = List'0.cons <(k, v)> {l}
              (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
          | s2 = List'0.cons <(k, v)> {l} (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->  [ &tl <- r1'2 ] s3)
          | s3 = {[@expl:type invariant] inv'1 l} s4
          | s4 = -{resolve'1 l}- s5
          | s5 = {[@expl:type invariant] inv'2 k} s6
          | s6 = -{resolve'2 k}- s7
          | s7 = eq'0 {k} {key} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s8)
          | s8 = bb9 ]
          
        | bb9 = any [ br0 -> {_25 = false} (! bb11) | br1 -> {_25} (! bb10) ] 
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'3 v} s1
          | s1 = -{resolve'3 v}- s2
          | s2 =  [ &_31 <- tl ] s3
          | s3 = {[@expl:type invariant] inv'4 tl} s4
          | s4 = -{resolve'4 tl}- s5
          | s5 = {[@expl:type invariant] inv'1 _31} s6
          | s6 = -{resolve'1 _31}- s7
          | s7 =  [ &l <- _31 ] s8
          | s8 = bb5 ]
           ]
         ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'1 l} s1
      | s1 = -{resolve'1 l}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'5 key}- s4
      | s4 =  [ &_0 <- Option'0.C_None ] s5
      | s5 = bb13 ]
      
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'4 tl} s1
      | s1 = -{resolve'4 tl}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'5 key}- s4
      | s4 = {[@expl:type invariant] inv'3 v} s5
      | s5 = -{resolve'3 v}- s6
      | s6 =  [ &_0 <- Option'0.C_Some v ] s7
      | s7 = bb13 ]
      
    | bb13 = return' {_0} ]
    )
    [ & _0 : Option'0.t_option v = any_l ()
    | & self : MyHashMap'0.t_myhashmap k v = self
    | & key : k = key
    | & index : usize = any_l ()
    | & _7 : usize = any_l ()
    | & _8 : uint64 = any_l ()
    | & _10 : usize = any_l ()
    | & _12 : bool = any_l ()
    | & l : List'0.t_list (k, v) = any_l ()
    | & _14 : List'0.t_list (k, v) = any_l ()
    | & k : k = any_l ()
    | & v : v = any_l ()
    | & tl : List'0.t_list (k, v) = any_l ()
    | & _25 : bool = any_l ()
    | & _31 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:Option'0.t_option v)-> {[@expl:postcondition] [%#shashmap6] inv'6 result}
      {[@expl:postcondition] [%#shashmap5] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Resize
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 162 23 162 41
  
  let%span shashmap1 = "../hashmap.rs" 163 53 163 54
  
  let%span shashmap2 = "../hashmap.rs" 165 27 165 28
  
  let%span shashmap3 = "../hashmap.rs" 166 8 166 111
  
  let%span shashmap4 = "../hashmap.rs" 172 20 172 37
  
  let%span shashmap5 = "../hashmap.rs" 173 20 173 66
  
  let%span shashmap6 = "../hashmap.rs" 174 20 174 45
  
  let%span shashmap7 = "../hashmap.rs" 178 24 178 41
  
  let%span shashmap8 = "../hashmap.rs" 178 12 178 43
  
  let%span shashmap9 = "../hashmap.rs" 185 24 185 45
  
  let%span shashmap10 = "../hashmap.rs" 186 24 186 51
  
  let%span shashmap11 = "../hashmap.rs" 191 12 191 121
  
  let%span shashmap12 = "../hashmap.rs" 192 17 192 18
  
  let%span shashmap13 = "../hashmap.rs" 156 15 156 41
  
  let%span shashmap14 = "../hashmap.rs" 157 15 157 36
  
  let%span shashmap15 = "../hashmap.rs" 161 19 161 23
  
  let%span shashmap16 = "../hashmap.rs" 158 14 158 35
  
  let%span shashmap17 = "../hashmap.rs" 159 4 159 74
  
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span19 = "" 0 0 0 0
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span21 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span23 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span24 = "../hashmap.rs" 30 12 33 13
  
  let%span span25 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span26 = "../hashmap.rs" 90 20 90 66
  
  let%span span27 = "../hashmap.rs" 85 8 85 53
  
  let%span span28 = "../hashmap.rs" 79 20 79 45
  
  let%span span29 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span30 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span31 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span32 = "../../../../creusot-contracts/src/resolve.rs" 35 8 35 31
  
  let%span span33 = "../hashmap.rs" 40 12 43 13
  
  let%span span34 = "../hashmap.rs" 200 8 202 9
  
  let%span span35 = "../hashmap.rs" 209 8 212 9
  
  let%span span36 = "../hashmap.rs" 103 15 103 36
  
  let%span span37 = "../hashmap.rs" 106 20 106 24
  
  let%span span38 = "../hashmap.rs" 106 26 106 29
  
  let%span span39 = "../hashmap.rs" 106 34 106 37
  
  let%span span40 = "../hashmap.rs" 104 14 104 35
  
  let%span span41 = "../hashmap.rs" 105 4 105 124
  
  let%span span42 = "" 0 0 0 0
  
  let%span span43 = "" 0 0 0 0
  
  let%span span44 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  
  let%span span45 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  let%span span46 = "" 0 0 0 0
  
  let%span span47 = "../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96
  
  let%span span48 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span49 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span50 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span51 = "" 0 0 0 0
  
  let%span span52 = "" 0 0 0 0
  
  let%span span53 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span54 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span55 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span56 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span57 = "" 0 0 0 0
  
  let%span span58 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span59 = "../../../../creusot-contracts/src/snapshot.rs" 28 20 28 48
  
  let%span span60 = "../hashmap.rs" 95 15 95 24
  
  let%span span61 = "../hashmap.rs" 96 14 96 34
  
  let%span span62 = "../hashmap.rs" 97 4 97 64
  
  let%span span63 = "../hashmap.rs" 98 31 98 46
  
  let%span span64 = "" 0 0 0 0
  
  let%span span65 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  use prelude.prelude.UIntSize
  
  predicate invariant'13 (self : usize) =
    [%#span18] true
  
  predicate inv'13 (_x : usize)
  
  axiom inv'13 : forall x : usize . inv'13 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Hashmap_List_Type as List'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'12 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) =
    [%#span18] true
  
  predicate inv'12 (_x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))
  
  axiom inv'12 : forall x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) . inv'12 x = true
  
  use seq.Seq
  
  predicate invariant'11 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span18] true
  
  predicate inv'11 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'11 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'11 x = true
  
  predicate invariant'10 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span18] true
  
  predicate inv'10 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'10 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'10 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'9 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span18] true
  
  predicate inv'9 (_x : borrowed (MyHashMap'0.t_myhashmap k v))
  
  axiom inv'9 : forall x : borrowed (MyHashMap'0.t_myhashmap k v) . inv'9 x = true
  
  predicate invariant'8 (self : List'0.t_list (k, v)) =
    [%#span18] true
  
  predicate inv'8 (_x : List'0.t_list (k, v))
  
  axiom inv'8 : forall x : List'0.t_list (k, v) . inv'8 x = true
  
  predicate invariant'7 (self : v)
  
  predicate inv'7 (_x : v)
  
  axiom inv'7 : forall x : v . inv'7 x = true
  
  predicate invariant'6 (self : k)
  
  predicate inv'6 (_x : k)
  
  axiom inv'6 : forall x : k . inv'6 x = true
  
  predicate invariant'5 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span18] true
  
  predicate inv'5 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'5 : forall x : MyHashMap'0.t_myhashmap k v . inv'5 x = true
  
  predicate invariant'4 (self : borrowed (List'0.t_list (k, v))) =
    [%#span18] true
  
  predicate inv'4 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'4 : forall x : borrowed (List'0.t_list (k, v)) . inv'4 x = true
  
  predicate invariant'3 (self : List'0.t_list (k, v)) =
    [%#span18] true
  
  predicate inv'3 (_x : List'0.t_list (k, v))
  
  axiom inv'3 : forall x : List'0.t_list (k, v) . inv'3 x = true
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span19] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'2 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'2_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span20] inv'2 self)
   -> ([%#span22] inv'11 (shallow_model'2 self))
  && ([%#span21] Seq.length (shallow_model'2 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span23] inv'11 (shallow_model'2 self)
  
  axiom inv'2 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'2 x = true
  
  type deep_model_ty'0
  
  predicate invariant'1 (self : deep_model_ty'0)
  
  predicate inv'1 (_x : deep_model_ty'0)
  
  axiom inv'1 : forall x : deep_model_ty'0 . inv'1 x = true
  
  use prelude.prelude.Snapshot
  
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) =
    [%#span18] true
  
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)))
  
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) . inv'0 x = true
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  use Core_Option_Option_Type as Option'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span24] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span25] Seq.get (shallow_model'2 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span26] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span27] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'1 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span28] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  function shallow_model'3 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span29] shallow_model'1 ( * self)
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'7 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span30]  ^ self =  * self
  
  predicate resolve'6 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span31] true
  
  predicate resolve'2 (self : List'0.t_list (k, v)) =
    [%#span31] true
  
  predicate resolve'5 (self : List'0.t_list (k, v)) =
    [%#span32] resolve'2 self
  
  use map.Map
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span33] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span34] forall v : v . forall k : deep_model_ty'0 . inv'7 v
     -> inv'1 k  -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span35] 0 < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[@expl:precondition] [%#span39] inv'7 val'}
    {[@expl:precondition] [%#span38] inv'6 key}
    {[@expl:precondition] [%#span37] inv'9 self}
    {[@expl:precondition] [%#span36] hashmap_inv'0 ( * self)}
    any
    [ return' (result:())-> {[%#span41] forall i : deep_model_ty'0 . inv'1 i
       -> Map.get (shallow_model'1 ( ^ self)) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'3 self) i)}
      {[%#span40] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
  
  predicate resolve'4 (self : v)
  
  predicate resolve'3 (self : k)
  
  predicate resolve'1 (self : borrowed (List'0.t_list (k, v))) =
    [%#span30]  ^ self =  * self
  
  let rec replace'0 (dest:borrowed (List'0.t_list (k, v))) (src:List'0.t_list (k, v)) (return'  (ret:List'0.t_list (k, v)))= {[@expl:precondition] [%#span43] inv'3 src}
    {[@expl:precondition] [%#span42] inv'4 dest}
    any
    [ return' (result:List'0.t_list (k, v))-> {[%#span46] inv'3 result}
      {[%#span45] result =  * dest}
      {[%#span44]  ^ dest = src}
      (! return' {result}) ]
    
  
  use prelude.prelude.Slice
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (List'0.t_list (k, v))) (fin : Seq.seq (List'0.t_list (k, v)))
    
   =
    [%#span47] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span48] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span49] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'6 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span29] shallow_model'2 ( * self)
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) (index:usize) (return'  (ret:borrowed (List'0.t_list (k, v))))= {[@expl:precondition] [%#span52] inv'13 index}
    {[@expl:precondition] [%#span51] inv'12 self}
    {[@expl:precondition] [%#span50] in_bounds'0 index (shallow_model'6 self)}
    any
    [ return' (result:borrowed (List'0.t_list (k, v)))-> {[%#span57] inv'4 result}
      {[%#span56] Seq.length (shallow_model'2 ( ^ self)) = Seq.length (shallow_model'6 self)}
      {[%#span55] resolve_elswhere'0 index (shallow_model'6 self) (shallow_model'2 ( ^ self))}
      {[%#span54] has_value'0 index (shallow_model'2 ( ^ self)) ( ^ result)}
      {[%#span53] has_value'0 index (shallow_model'6 self) ( * result)}
      (! return' {result}) ]
    
  
  function shallow_model'5 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span58] shallow_model'3 self
  
  use prelude.prelude.Snapshot
  
  function shallow_model'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span59] shallow_model'5 (Snapshot.inner self)
  
  let rec new'0 (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap k v))= {[@expl:precondition] [%#span60] 0
    < UIntSize.to_int size}
    any
    [ return' (result:MyHashMap'0.t_myhashmap k v)-> {[%#span63] inv'5 result}
      {[%#span62] forall i : deep_model_ty'0 . inv'1 i  -> Map.get (shallow_model'1 result) i = Option'0.C_None}
      {[%#span61] hashmap_inv'0 result}
      (! return' {result}) ]
    
  
  function shallow_model'4 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span58] shallow_model'2 self
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span64] inv'10 self}
    any
    [ return' (result:usize)-> {[%#span65] UIntSize.to_int result = Seq.length (shallow_model'4 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) =
    [%#span31] true
  
  use prelude.prelude.Snapshot
  
  let rec resize (self:borrowed (MyHashMap'0.t_myhashmap k v)) (return'  (ret:()))= {[%#shashmap15] inv'9 self}
    {[%#shashmap14] hashmap_inv'0 ( * self)}
    {[%#shashmap13] Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self))) < 1000}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#shashmap0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = MyHashMap'0.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s3))
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.mul {_10} {[%#shashmap1] (2 : usize)}
          (fun (_ret':usize) ->  [ &_9 <- _ret' ] (any [ any_ (_any:usize)-> (!  [ &_10 <- _any ] s1) ] ))
      | s1 = new'0 {_9} (fun (_ret':MyHashMap'0.t_myhashmap k v) ->  [ &new <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 =  [ &i <- [%#shashmap2] (0 : usize) ] s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &old_6_0 <- Snapshot.new self ] s1 | s1 = bb6 ] 
    | bb6 = bb6
      [ bb6 = {[@expl:loop invariant]  ^ Snapshot.inner old_6_0 =  ^ self}
        {[@expl:loop invariant] [%#shashmap6] UIntSize.to_int i
        <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)))}
        {[@expl:loop invariant] [%#shashmap5] Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
        = Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)))}
        {[@expl:loop invariant] [%#shashmap4] hashmap_inv'0 new}
        {[@expl:loop invariant] [%#shashmap3] forall j : int . UIntSize.to_int i <= j
        /\ j < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
         -> index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)) j
        = index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)) j}
        {[@expl:loop invariant] [%#shashmap3] forall k : deep_model_ty'0 . inv'1 k
         -> UIntSize.to_int i <= bucket_ix'0 ( * Snapshot.inner old_self) k
        /\ bucket_ix'0 ( * Snapshot.inner old_self) k
        <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
         -> Map.get (shallow_model'1 new) k = Option'0.C_None}
        {[@expl:loop invariant] [%#shashmap3] forall k : deep_model_ty'0 . inv'1 k
         -> bucket_ix'0 ( * Snapshot.inner old_self) k < UIntSize.to_int i
         -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = MyHashMap'0.t_myhashmap <k> <v> { * self}
              (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_23 <- _ret' ] s1))
          | s1 = bb8 ]
          
        | bb8 = s0
          [ s0 = UIntSize.lt {i} {_23}
              (fun (_ret':bool) ->  [ &_21 <- _ret' ] (any [ any_ (_any:usize)-> (!  [ &_23 <- _any ] s1) ] ))
          | s1 = any [ br0 -> {_21 = false} (! bb29) | br1 -> {_21} (! bb9) ]  ]
          
        | bb9 = s0
          [ s0 = MyHashMap'0.t_myhashmap <k> <v> { * self}
              (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                Borrow.borrow_mut <Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)> {rbuckets'0}
                  (fun (_ret':borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) ->
                     [ &_29 <- _ret' ] 
                    MyHashMap'0.t_myhashmap <k> <v> { * self}
                      (fun (l_buckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                         [ &self <- { self with current = MyHashMap'0.C_MyHashMap ( ^ _29) ; } ] 
                        s1)))
          | s1 = -{inv'2 ( ^ _29)}- s2
          | s2 = index_mut'0 {_29} {i} (fun (_ret':borrowed (List'0.t_list (k, v))) ->  [ &_28 <- _ret' ] s3)
          | s3 = bb10 ]
          
        | bb10 = s0
          [ s0 = Borrow.borrow_final <List'0.t_list (k, v)> { * _28} {Borrow.get_id _28}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_27 <- _ret' ] 
                 [ &_28 <- { _28 with current = ( ^ _27) ; } ] 
                s1)
          | s1 = -{inv'3 ( ^ _27)}- s2
          | s2 = Borrow.borrow_final <List'0.t_list (k, v)> { * _27} {Borrow.get_id _27}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_26 <- _ret' ] 
                 [ &_27 <- { _27 with current = ( ^ _26) ; } ] 
                s3)
          | s3 = -{inv'3 ( ^ _26)}- s4
          | s4 =  [ &_31 <- List'0.C_Nil ] s5
          | s5 = replace'0 {_26} {_31} (fun (_ret':List'0.t_list (k, v)) ->  [ &l <- _ret' ] s6)
          | s6 = bb11 ]
          
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'4 _28} s1
          | s1 = -{resolve'1 _28}- s2
          | s2 = {[@expl:type invariant] inv'4 _27} s3
          | s3 = -{resolve'1 _27}- s4
          | s4 = bb12 ]
          
        | bb12 = bb13
        | bb13 = bb14
        | bb14 = bb15
        | bb15 = bb16
        | bb16 = bb17
        | bb17 = bb17
          [ bb17 = {[@expl:loop invariant] [%#shashmap10] good_bucket'0 ( * Snapshot.inner old_self) l (UIntSize.to_int i)}
            {[@expl:loop invariant] [%#shashmap9] no_double_binding'0 l}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k = UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k
            = match get'0 l k with
              | Option'0.C_None -> Map.get (shallow_model'1 new) k
              | Option'0.C_Some v -> Option'0.C_Some v
              end}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'1 k
             -> UIntSize.to_int i < bucket_ix'0 ( * Snapshot.inner old_self) k
            /\ bucket_ix'0 ( * Snapshot.inner old_self) k
            <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
             -> Map.get (shallow_model'1 new) k = Option'0.C_None}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k < UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
            {[@expl:loop invariant] [%#shashmap7] hashmap_inv'0 new}
            (! s0) [ s0 = bb18 ] 
            [ bb18 = any
              [ br0 -> {l = List'0.C_Nil } (! bb25)
              | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> {l = List'0.C_Cons a b} (! bb19) ]
              
            | bb19 = bb20
            | bb20 = s0
              [ s0 = List'0.cons <(k, v)> {l}
                  (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
              | s1 = List'0.cons <(k, v)> {l}
                  (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
              | s2 = List'0.cons <(k, v)> {l}
                  (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->
                     [ &tl <- r1'2 ] 
                    (any
                    [ any_ (_any:List'0.t_list (k, v))-> (! List'0.cons <(k, v)> {l}
                        (fun (l_0'0:(k, v)) (l_1'0:List'0.t_list (k, v)) ->  [ &l <- List'0.C_Cons l_0'0 _any ] s3)) ]
                    ))
              | s3 = {[@expl:type invariant] inv'3 l} s4
              | s4 = -{resolve'2 l}- s5
              | s5 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap k v> {new}
                  (fun (_ret':borrowed (MyHashMap'0.t_myhashmap k v)) ->  [ &_44 <- _ret' ]  [ &new <-  ^ _44 ] s6)
              | s6 = -{inv'5 ( ^ _44)}- s7
              | s7 = {[@expl:type invariant] inv'6 k} s8
              | s8 = -{resolve'3 k}- s9
              | s9 = {[@expl:type invariant] inv'7 v} s10
              | s10 = -{resolve'4 v}- s11
              | s11 = add'0 {_44} {k} {v} (fun (_ret':()) ->  [ &_43 <- _ret' ] s12)
              | s12 = bb21 ]
              
            | bb21 = s0 [ s0 = {[@expl:type invariant] inv'8 tl} s1 | s1 = -{resolve'5 tl}- s2 | s2 = bb22 ] 
            | bb22 = s0
              [ s0 =  [ &l <- tl ] (any [ any_ (_any:List'0.t_list (k, v))-> (!  [ &tl <- _any ] s1) ] ) | s1 = bb24 ]
              
            | bb24 = bb26
            | bb26 = bb17 ]
             ]
          
        | bb25 = s0
          [ s0 = {[@expl:type invariant] inv'3 l} s1
          | s1 = -{resolve'2 l}- s2
          | s2 = {[@expl:assertion] [%#shashmap11] forall k : deep_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k = UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
            s3
          | s3 = bb27 ]
          
        | bb27 = s0
          [ s0 = UIntSize.add {i} {[%#shashmap12] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s1) | s1 = bb28 ]
          
        | bb28 = bb6 ]
         ]
      
    | bb29 = bb30
    | bb30 = s0
      [ s0 =  [ &self <- { self with current = new ; } ] 
        (any [ any_ (_any:MyHashMap'0.t_myhashmap k v)-> (!  [ &new <- _any ] s1) ] )
      | s1 = {[@expl:type invariant] inv'5 ( * self)} s2
      | s2 = -{resolve'6 ( * self)}- s3
      | s3 = {[@expl:type invariant] inv'9 self} s4
      | s4 = -{resolve'7 self}- s5
      | s5 = bb32 ]
      
    | bb32 = bb33
    | bb33 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (MyHashMap'0.t_myhashmap k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l ()
    | & new : MyHashMap'0.t_myhashmap k v = any_l ()
    | & _9 : usize = any_l ()
    | & _10 : usize = any_l ()
    | & i : usize = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : usize = any_l ()
    | & l : List'0.t_list (k, v) = any_l ()
    | & _26 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _27 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _28 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _29 : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) = any_l ()
    | & _31 : List'0.t_list (k, v) = any_l ()
    | & k : k = any_l ()
    | & v : v = any_l ()
    | & tl : List'0.t_list (k, v) = any_l ()
    | & _43 : () = any_l ()
    | & _44 : borrowed (MyHashMap'0.t_myhashmap k v) = any_l ()
    | & old_6_0 : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#shashmap17] forall k : deep_model_ty'0 . inv'1 k
       -> Map.get (shallow_model'1 ( ^ self)) k = Map.get (shallow_model'3 self) k}
      {[@expl:postcondition] [%#shashmap16] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
end
module Hashmap_Main
  let%span shashmap0 = "../hashmap.rs" 223 57 223 59
  
  let%span shashmap1 = "../hashmap.rs" 224 57 224 59
  
  let%span shashmap2 = "../hashmap.rs" 225 24 225 25
  
  let%span shashmap3 = "../hashmap.rs" 226 24 226 25
  
  let%span shashmap4 = "../hashmap.rs" 227 24 227 25
  
  let%span shashmap5 = "../hashmap.rs" 228 24 228 25
  
  let%span shashmap6 = "../hashmap.rs" 232 11 232 12
  
  let%span shashmap7 = "../hashmap.rs" 232 14 232 16
  
  let%span shashmap8 = "../hashmap.rs" 233 16 233 17
  
  let%span shashmap9 = "../hashmap.rs" 234 16 234 17
  
  let%span shashmap10 = "../hashmap.rs" 235 16 235 17
  
  let%span shashmap11 = "../hashmap.rs" 236 16 236 17
  
  let%span shashmap12 = "../hashmap.rs" 239 11 239 12
  
  let%span shashmap13 = "../hashmap.rs" 239 14 239 16
  
  let%span shashmap14 = "../hashmap.rs" 240 16 240 17
  
  let%span shashmap15 = "../hashmap.rs" 241 16 241 17
  
  let%span shashmap16 = "../hashmap.rs" 242 16 242 17
  
  let%span shashmap17 = "../hashmap.rs" 243 16 243 17
  
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span19 = "" 0 0 0 0
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span21 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span23 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span25 = "../hashmap.rs" 30 12 33 13
  
  let%span span26 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span27 = "../hashmap.rs" 65 20 65 21
  
  let%span span28 = "../hashmap.rs" 90 20 90 66
  
  let%span span29 = "../hashmap.rs" 85 8 85 53
  
  let%span span30 = "../hashmap.rs" 79 20 79 45
  
  let%span span31 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span32 = "../hashmap.rs" 40 12 43 13
  
  let%span span33 = "../hashmap.rs" 200 8 202 9
  
  let%span span34 = "../hashmap.rs" 209 8 212 9
  
  let%span span35 = "../hashmap.rs" 103 15 103 36
  
  let%span span36 = "../hashmap.rs" 106 20 106 24
  
  let%span span37 = "../hashmap.rs" 106 26 106 29
  
  let%span span38 = "../hashmap.rs" 106 34 106 37
  
  let%span span39 = "../hashmap.rs" 104 14 104 35
  
  let%span span40 = "../hashmap.rs" 105 4 105 124
  
  let%span span41 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span42 = "../hashmap.rs" 136 15 136 33
  
  let%span span43 = "../hashmap.rs" 141 16 141 20
  
  let%span span44 = "../hashmap.rs" 141 22 141 25
  
  let%span span45 = "../hashmap.rs" 137 14 140 5
  
  let%span span46 = "../hashmap.rs" 141 33 141 43
  
  let%span span47 = "../hashmap.rs" 95 15 95 24
  
  let%span span48 = "../hashmap.rs" 96 14 96 34
  
  let%span span49 = "../hashmap.rs" 97 4 97 64
  
  let%span span50 = "../hashmap.rs" 98 31 98 46
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.UIntSize
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'8 (self : Seq.seq (List'0.t_list (usize, isize))) =
    [%#span18] true
  
  predicate inv'8 (_x : Seq.seq (List'0.t_list (usize, isize)))
  
  axiom inv'8 : forall x : Seq.seq (List'0.t_list (usize, isize)) . inv'8 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span19] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'7 (_x : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global))
  
  function shallow_model'3 (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) : Seq.seq (List'0.t_list (usize, isize))
    
  
  axiom shallow_model'3_spec : forall self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global) . ([%#span20] inv'7 self)
   -> ([%#span22] inv'8 (shallow_model'3 self))
  && ([%#span21] Seq.length (shallow_model'3 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'7 (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) =
    [%#span23] inv'8 (shallow_model'3 self)
  
  axiom inv'7 : forall x : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global) . inv'7 x = true
  
  predicate invariant'6 (self : isize) =
    [%#span18] true
  
  predicate inv'6 (_x : isize)
  
  axiom inv'6 : forall x : isize . inv'6 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'5 (self : borrowed (MyHashMap'0.t_myhashmap usize isize)) =
    [%#span18] true
  
  predicate inv'5 (_x : borrowed (MyHashMap'0.t_myhashmap usize isize))
  
  axiom inv'5 : forall x : borrowed (MyHashMap'0.t_myhashmap usize isize) . inv'5 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'4 (self : Option'0.t_option isize) =
    [%#span18] true
  
  predicate inv'4 (_x : Option'0.t_option isize)
  
  axiom inv'4 : forall x : Option'0.t_option isize . inv'4 x = true
  
  predicate invariant'3 (self : usize) =
    [%#span18] true
  
  predicate inv'3 (_x : usize)
  
  axiom inv'3 : forall x : usize . inv'3 x = true
  
  predicate invariant'2 (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span18] true
  
  predicate inv'2 (_x : MyHashMap'0.t_myhashmap usize isize)
  
  axiom inv'2 : forall x : MyHashMap'0.t_myhashmap usize isize . inv'2 x = true
  
  predicate invariant'1 (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span18] true
  
  predicate inv'1 (_x : MyHashMap'0.t_myhashmap usize isize)
  
  axiom inv'1 : forall x : MyHashMap'0.t_myhashmap usize isize . inv'1 x = true
  
  use prelude.prelude.Int
  
  predicate invariant'0 (self : int) =
    [%#span18] true
  
  predicate inv'0 (_x : int)
  
  axiom inv'0 : forall x : int . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : usize) : int =
    [%#span24] UIntSize.to_int self
  
  function get'1 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (usize, isize)) (index : int) : Option'0.t_option isize
    
   =
    [%#span25] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'1 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) (ix : int) : List'0.t_list (usize, isize)
    
   =
    [%#span26] Seq.get (shallow_model'3 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span27] x
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap usize isize) (k : int) : int =
    [%#span28] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap usize isize) (k : int) : List'0.t_list (usize, isize)
    
   =
    [%#span29] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap usize isize) : Map.map int (Option'0.t_option isize)
    
   =
    [%#span30] Mapping.from_fn (fun (k : int) -> get'1 (bucket'0 self k) k)
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap usize isize)) : Map.map int (Option'0.t_option isize)
    
   =
    [%#span31] shallow_model'0 ( * self)
  
  use map.Map
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (usize, isize)) =
    [%#span32] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'1 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap usize isize) (l : List'0.t_list (usize, isize)) (h : int)
    
   =
    [%#span33] forall v : isize . forall k : int . inv'6 v
     -> inv'0 k  -> get'1 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span34] 0 < Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap usize isize)) (key:usize) (val':isize) (return'  (ret:()))= {[@expl:precondition] [%#span38] inv'6 val'}
    {[@expl:precondition] [%#span37] inv'3 key}
    {[@expl:precondition] [%#span36] inv'5 self}
    {[@expl:precondition] [%#span35] hashmap_inv'0 ( * self)}
    any
    [ return' (result:())-> {[%#span40] forall i : int . inv'0 i
       -> Map.get (shallow_model'0 ( ^ self)) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      {[%#span39] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
  
  function shallow_model'1 (self : MyHashMap'0.t_myhashmap usize isize) : Map.map int (Option'0.t_option isize) =
    [%#span41] shallow_model'0 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap usize isize) (key:usize) (return'  (ret:Option'0.t_option isize))= {[@expl:precondition] [%#span44] inv'3 key}
    {[@expl:precondition] [%#span43] inv'2 self}
    {[@expl:precondition] [%#span42] hashmap_inv'0 self}
    any
    [ return' (result:Option'0.t_option isize)-> {[%#span46] inv'4 result}
      {[%#span45] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'1 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'1 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  let rec new'0 (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap usize isize))= {[@expl:precondition] [%#span47] 0
    < UIntSize.to_int size}
    any
    [ return' (result:MyHashMap'0.t_myhashmap usize isize)-> {[%#span50] inv'1 result}
      {[%#span49] forall i : int . inv'0 i  -> Map.get (shallow_model'0 result) i = Option'0.C_None}
      {[%#span48] hashmap_inv'0 result}
      (! return' {result}) ]
    
  
  let rec main (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = new'0 {[%#shashmap0] (17 : usize)}
          (fun (_ret':MyHashMap'0.t_myhashmap usize isize) ->  [ &h1 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = new'0 {[%#shashmap1] (42 : usize)}
          (fun (_ret':MyHashMap'0.t_myhashmap usize isize) ->  [ &h2 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = get'0 {h1} {[%#shashmap2] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_x <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = get'0 {h1} {[%#shashmap3] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_y <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = get'0 {h2} {[%#shashmap4] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_z <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = get'0 {h2} {[%#shashmap5] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_t <- _ret' ] s1)
      | s1 = bb6 ]
      
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap usize isize> {h1}
          (fun (_ret':borrowed (MyHashMap'0.t_myhashmap usize isize)) ->  [ &_12 <- _ret' ]  [ &h1 <-  ^ _12 ] s1)
      | s1 = add'0 {_12} {[%#shashmap6] (1 : usize)} {[%#shashmap7] (17 : isize)}
          (fun (_ret':()) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = get'0 {h1} {[%#shashmap8] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_x <- _13 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_13 <- _any ] s1) ] )
      | s1 = get'0 {h1} {[%#shashmap9] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 =  [ &_y <- _15 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_15 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[%#shashmap10] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0
      [ s0 =  [ &_z <- _17 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_17 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[%#shashmap11] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 =  [ &_t <- _19 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap usize isize> {h2}
          (fun (_ret':borrowed (MyHashMap'0.t_myhashmap usize isize)) ->  [ &_22 <- _ret' ]  [ &h2 <-  ^ _22 ] s2)
      | s2 = add'0 {_22} {[%#shashmap12] (1 : usize)} {[%#shashmap13] (42 : isize)}
          (fun (_ret':()) ->  [ &_21 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = get'0 {h1} {[%#shashmap14] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 =  [ &_x <- _23 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_23 <- _any ] s1) ] )
      | s1 = get'0 {h1} {[%#shashmap15] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 =  [ &_y <- _25 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_25 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[%#shashmap16] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_z <- _27 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_27 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[%#shashmap17] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = s0
      [ s0 =  [ &_t <- _29 ] (any [ any_ (_any:Option'0.t_option isize)-> (!  [ &_29 <- _any ] s1) ] ) | s1 = bb17 ]
      
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & h1 : MyHashMap'0.t_myhashmap usize isize = any_l ()
    | & h2 : MyHashMap'0.t_myhashmap usize isize = any_l ()
    | & _x : Option'0.t_option isize = any_l ()
    | & _y : Option'0.t_option isize = any_l ()
    | & _z : Option'0.t_option isize = any_l ()
    | & _t : Option'0.t_option isize = any_l ()
    | & _11 : () = any_l ()
    | & _12 : borrowed (MyHashMap'0.t_myhashmap usize isize) = any_l ()
    | & _13 : Option'0.t_option isize = any_l ()
    | & _15 : Option'0.t_option isize = any_l ()
    | & _17 : Option'0.t_option isize = any_l ()
    | & _19 : Option'0.t_option isize = any_l ()
    | & _21 : () = any_l ()
    | & _22 : borrowed (MyHashMap'0.t_myhashmap usize isize) = any_l ()
    | & _23 : Option'0.t_option isize = any_l ()
    | & _25 : Option'0.t_option isize = any_l ()
    | & _27 : Option'0.t_option isize = any_l ()
    | & _29 : Option'0.t_option isize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Hashmap_Impl0
  type t
  
  let%span shashmap0 = "../hashmap.rs" 16 4 16 27
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  use Hashmap_List_Type as List'0
  
  predicate invariant'1 (self : List'0.t_list t) =
    [%#span1] true
  
  predicate inv'1 (_x : List'0.t_list t)
  
  axiom inv'1 : forall x : List'0.t_list t . inv'1 x = true
  
  predicate invariant'0 (self : List'0.t_list t) =
    [%#span1] true
  
  predicate inv'0 (_x : List'0.t_list t)
  
  axiom inv'0 : forall x : List'0.t_list t . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  goal clone'_refn : [%#shashmap0] forall self : List'0.t_list t . inv'0 self
   -> inv'0 self /\ (forall result : List'0.t_list t . inv'1 result /\ result = self  -> inv'1 result /\ result = self)
end
module Hashmap_Impl2
  let%span shashmap0 = "../hashmap.rs" 59 4 59 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../hashmap.rs" 65 20 65 21
  
  let%span span3 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use prelude.prelude.UIntSize
  
  predicate invariant'0 (self : usize) =
    [%#span1] true
  
  predicate inv'0 (_x : usize)
  
  axiom inv'0 : forall x : usize . inv'0 x = true
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span2] x
  
  use prelude.prelude.UIntSize
  
  function deep_model'1 (self : usize) : int =
    [%#span3] UIntSize.to_int self
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : usize) : int =
    [%#span4] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  goal hash_refn : [%#shashmap0] forall self : usize . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Hashmap_Impl3
  type k
  
  type v
end
