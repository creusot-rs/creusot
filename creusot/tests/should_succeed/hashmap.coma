
module Hashmap_List_Type
  type t_list 't =
    | C_Nil
    | C_Cons 't (t_list 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec nil < 't > (input:t_list 't) (ret  )= any
    [ good -> {C_Nil  = input} (! ret) | bad -> {C_Nil  <> input} {false} any ]
    
  
  let rec cons < 't > (input:t_list 't) (ret  (field_0:'t) (field_1:t_list 't))= any
    [ good (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 <> input} {false} any ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Hashmap_Impl2_Hash
  let%span shashmap0 = "../hashmap.rs" 58 14 58 58
  
  let%span span1 = "../hashmap.rs" 65 20 65 21
  
  let%span span2 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span3 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span1] x
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  function deep_model'1 (self : usize) : int =
    [%#span2] UIntSize.to_int self
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : usize) : int =
    [%#span3] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt64
  
  let rec hash (self:usize) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.of_int {UIntSize.to_int self} (fun (_res:uint64) ->  [ &_0 <- _res ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () | & self : usize = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [%#shashmap0] UInt64.to_int result
      = hash_log'0 (deep_model'0 self)}
      (! return' {result}) ]
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.prelude.Opaque
  
  type t_nonnull 't =
    | C_NonNull opaque_ptr
  
  function any_l (_ : 'b) : 'a
  
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
  
  function any_l (_ : 'b) : 'a
  
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as PhantomData'0
  
  use Core_Ptr_NonNull_NonNull_Type as NonNull'0
  
  type t_unique 't =
    | C_Unique (NonNull'0.t_nonnull 't) (PhantomData'0.t_phantomdata 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't))= any
    [ good (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_RawVec_Cap_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_cap  =
    | C_Cap usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_cap (input:t_cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Cap'0
  
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_rawvec 't 'a =
    | C_RawVec (Unique'0.t_unique 't) (Cap'0.t_cap) 'a
  
  function any_l (_ : 'b) : 'a
  
  let rec t_rawvec < 't > < 'a > (input:t_rawvec 't 'a) (ret  (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Unique'0.t_unique 't) (cap:Cap'0.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc <> input} {false} any ]
    
end
module Alloc_Vec_Vec_Type
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use Alloc_RawVec_RawVec_Type as RawVec'0
  
  type t_vec 't 'a =
    | C_Vec (RawVec'0.t_rawvec 't 'a) usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_vec < 't > < 'a > (input:t_vec 't 'a) (ret  (buf:RawVec'0.t_rawvec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:RawVec'0.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module Hashmap_MyHashMap_Type
  use Alloc_Alloc_Global_Type as Global'0
  
  use Hashmap_List_Type as List'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  type t_myhashmap 'k 'v =
    | C_MyHashMap (Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_myhashmap < 'k > < 'v > (input:t_myhashmap 'k 'v) (ret  (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global)))= any
    [ good (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))-> {C_MyHashMap buckets = input}
      (! ret {buckets})
    | bad (buckets:Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global))-> {C_MyHashMap buckets <> input}
      {false}
      any ]
    
  
  function myhashmap_buckets (self : t_myhashmap 'k 'v) : Vec'0.t_vec (List'0.t_list ('k, 'v)) (Global'0.t_global) =
    match self with
      | C_MyHashMap a -> a
      end
end
module Hashmap_Impl5_New
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 95 15 95 24
  
  let%span shashmap1 = "../hashmap.rs" 96 14 96 34
  
  let%span shashmap2 = "../hashmap.rs" 97 4 97 64
  
  let%span shashmap3 = "../hashmap.rs" 98 31 98 46
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span5 = "" 0 0 0 0
  
  let%span span6 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span7 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span8 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span10 = "../hashmap.rs" 30 12 33 13
  
  let%span span11 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span12 = "../hashmap.rs" 90 20 90 66
  
  let%span span13 = "../hashmap.rs" 85 8 85 53
  
  let%span span14 = "../hashmap.rs" 79 20 79 45
  
  let%span span15 = "../hashmap.rs" 40 12 43 13
  
  let%span span16 = "../hashmap.rs" 200 8 202 9
  
  let%span span17 = "../hashmap.rs" 209 8 212 9
  
  let%span span18 = "" 0 0 0 0
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 174 22 174 41
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 175 12 175 78
  
  let%span span21 = "" 0 0 0 0
  
  predicate invariant'5 (self : v)
  
  predicate inv'5 (_x : v)
  
  axiom inv'5 : forall x : v . inv'5 x = true
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'4 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span4] true
  
  predicate inv'4 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'4 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'4 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span5] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'3 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'1_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span6] inv'3 self)
   -> ([%#span8] inv'4 (shallow_model'1 self))
  && ([%#span7] Seq.length (shallow_model'1 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'3 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span9] inv'4 (shallow_model'1 self)
  
  axiom inv'3 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'3 x = true
  
  predicate invariant'2 (self : List'0.t_list (k, v)) =
    [%#span4] true
  
  predicate inv'2 (_x : List'0.t_list (k, v))
  
  axiom inv'2 : forall x : List'0.t_list (k, v) . inv'2 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'1 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span4] true
  
  predicate inv'1 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'1 : forall x : MyHashMap'0.t_myhashmap k v . inv'1 x = true
  
  type deep_model_ty'0
  
  predicate invariant'0 (self : deep_model_ty'0)
  
  predicate inv'0 (_x : deep_model_ty'0)
  
  axiom inv'0 : forall x : deep_model_ty'0 . inv'0 x = true
  
  use Core_Option_Option_Type as Option'0
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span10] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span11] Seq.get (shallow_model'1 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span12] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span13] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span14] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span15] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span16] forall k : deep_model_ty'0, v : v . inv'0 k /\ inv'5 v
     -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  use prelude.prelude.Borrow
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span17] 0 < Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  use prelude.prelude.Intrinsic
  
  let rec from_elem'0 (elem:List'0.t_list (k, v)) (n:usize) (return'  (ret:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))= {[@expl:precondition] [%#span18] inv'2 elem}
    any
    [ return' (result:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))-> {[%#span21] inv'3 result}
      {[%#span20] forall i : int . 0 <= i /\ i < UIntSize.to_int n  -> index_logic'0 result i = elem}
      {[%#span19] Seq.length (shallow_model'1 result) = UIntSize.to_int n}
      (! return' {result}) ]
    
  
  let rec new (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap k v))= {[%#shashmap0] 0 < UIntSize.to_int size}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- List'0.C_Nil ] s1
      | s1 = from_elem'0 {_7} {size}
          (fun (_ret':Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 =  [ &res <- MyHashMap'0.C_MyHashMap _6 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- res ] s1 | s1 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : MyHashMap'0.t_myhashmap k v = any_l ()
    | & size : usize = size
    | & res : MyHashMap'0.t_myhashmap k v = any_l ()
    | & _6 : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) = any_l ()
    | & _7 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:MyHashMap'0.t_myhashmap k v)-> {[@expl:postcondition] [%#shashmap3] inv'1 result}
      {[@expl:postcondition] [%#shashmap2] forall i : deep_model_ty'0 . inv'0 i
       -> Map.get (shallow_model'0 result) i = Option'0.C_None}
      {[@expl:postcondition] [%#shashmap1] hashmap_inv'0 result}
      (! return' {result}) ]
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_box 't 'a =
    | C_Box (Unique'0.t_unique 't) 'a
  
  function any_l (_ : 'b) : 'a
end
module Hashmap_Impl5_Add
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 108 23 108 41
  
  let%span shashmap1 = "../hashmap.rs" 110 27 110 55
  
  let%span shashmap2 = "../hashmap.rs" 112 20 112 35
  
  let%span shashmap3 = "../hashmap.rs" 114 20 114 52
  
  let%span shashmap4 = "../hashmap.rs" 114 8 114 54
  
  let%span shashmap5 = "../hashmap.rs" 118 20 118 44
  
  let%span shashmap6 = "../hashmap.rs" 133 24 133 44
  
  let%span shashmap7 = "../hashmap.rs" 125 32 125 52
  
  let%span shashmap8 = "../hashmap.rs" 103 15 103 36
  
  let%span shashmap9 = "../hashmap.rs" 106 20 106 24
  
  let%span shashmap10 = "../hashmap.rs" 106 26 106 29
  
  let%span shashmap11 = "../hashmap.rs" 106 34 106 37
  
  let%span shashmap12 = "../hashmap.rs" 104 14 104 35
  
  let%span shashmap13 = "../hashmap.rs" 105 4 105 124
  
  let%span span14 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span15 = "" 0 0 0 0
  
  let%span span16 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span17 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span18 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span20 = "../hashmap.rs" 30 12 33 13
  
  let%span span21 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span22 = "../hashmap.rs" 90 20 90 66
  
  let%span span23 = "../hashmap.rs" 85 8 85 53
  
  let%span span24 = "../hashmap.rs" 79 20 79 45
  
  let%span span25 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span26 = "../hashmap.rs" 40 12 43 13
  
  let%span span27 = "../hashmap.rs" 200 8 202 9
  
  let%span span28 = "../hashmap.rs" 209 8 212 9
  
  let%span span29 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span30 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span31 = "" 0 0 0 0
  
  let%span span32 = "" 0 0 0 0
  
  let%span span33 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span34 = "../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96
  
  let%span span35 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span36 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span37 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span38 = "" 0 0 0 0
  
  let%span span39 = "" 0 0 0 0
  
  let%span span40 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span41 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span42 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span43 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span44 = "" 0 0 0 0
  
  let%span span45 = "../hashmap.rs" 51 13 51 17
  
  let%span span46 = "../hashmap.rs" 50 14 50 58
  
  let%span span47 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span48 = "" 0 0 0 0
  
  let%span span49 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'15 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'15 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'15 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'15 x = true
  
  use prelude.prelude.UIntSize
  
  predicate invariant'14 (self : usize) =
    [%#span14] true
  
  predicate inv'14 (_x : usize)
  
  axiom inv'14 : forall x : usize . inv'14 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'13 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) =
    [%#span14] true
  
  predicate inv'13 (_x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))
  
  axiom inv'13 : forall x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) . inv'13 x = true
  
  predicate invariant'12 (self : k)
  
  predicate inv'12 (_x : k)
  
  axiom inv'12 : forall x : k . inv'12 x = true
  
  predicate invariant'11 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span14] true
  
  predicate inv'11 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'11 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'11 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'10 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span14] true
  
  predicate inv'10 (_x : borrowed (MyHashMap'0.t_myhashmap k v))
  
  axiom inv'10 : forall x : borrowed (MyHashMap'0.t_myhashmap k v) . inv'10 x = true
  
  predicate invariant'9 (self : borrowed (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'9 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'9 : forall x : borrowed (List'0.t_list (k, v)) . inv'9 x = true
  
  predicate invariant'8 (self : borrowed v)
  
  predicate inv'8 (_x : borrowed v)
  
  axiom inv'8 : forall x : borrowed v . inv'8 x = true
  
  predicate invariant'7 (self : borrowed k)
  
  predicate inv'7 (_x : borrowed k)
  
  axiom inv'7 : forall x : borrowed k . inv'7 x = true
  
  predicate invariant'6 (self : List'0.t_list (k, v)) =
    [%#span14] true
  
  predicate inv'6 (_x : List'0.t_list (k, v))
  
  axiom inv'6 : forall x : List'0.t_list (k, v) . inv'6 x = true
  
  predicate invariant'5 (self : v)
  
  predicate inv'5 (_x : v)
  
  axiom inv'5 : forall x : v . inv'5 x = true
  
  predicate invariant'4 (self : k)
  
  predicate inv'4 (_x : k)
  
  axiom inv'4 : forall x : k . inv'4 x = true
  
  type deep_model_ty'0
  
  predicate invariant'3 (self : deep_model_ty'0)
  
  predicate inv'3 (_x : deep_model_ty'0)
  
  axiom inv'3 : forall x : deep_model_ty'0 . inv'3 x = true
  
  predicate invariant'2 (self : borrowed (List'0.t_list (k, v))) =
    [%#span14] true
  
  predicate inv'2 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'2 : forall x : borrowed (List'0.t_list (k, v)) . inv'2 x = true
  
  predicate invariant'1 (self : List'0.t_list (k, v)) =
    [%#span14] true
  
  predicate inv'1 (_x : List'0.t_list (k, v))
  
  axiom inv'1 : forall x : List'0.t_list (k, v) . inv'1 x = true
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span15] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'0 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'4 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'4_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span16] inv'0 self)
   -> ([%#span18] inv'15 (shallow_model'4 self))
  && ([%#span17] Seq.length (shallow_model'4 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'0 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span19] inv'15 (shallow_model'4 self)
  
  axiom inv'0 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'0 x = true
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  use Core_Option_Option_Type as Option'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span20] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span21] Seq.get (shallow_model'4 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span22] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span23] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span24] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  function shallow_model'1 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span25] shallow_model'0 self.current
  
  use map.Map
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span26] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span27] forall k : deep_model_ty'0, v : v . inv'3 k /\ inv'5 v
     -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span28] 0 < Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  predicate resolve'4 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span29] self.final = self.current
  
  predicate resolve'3 (self : borrowed (List'0.t_list (k, v))) =
    [%#span29] self.final = self.current
  
  predicate resolve'2 (self : borrowed v) =
    [%#span29] self.final = self.current
  
  predicate resolve'1 (self : borrowed k) =
    [%#span29] self.final = self.current
  
  function deep_model'1 (self : k) : deep_model_ty'0 =
    [%#span30] deep_model'0 self
  
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] [%#span32] inv'12 other}
    {[@expl:precondition] [%#span31] inv'12 self}
    any [ return' (result:bool)-> {[%#span33] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ] 
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Snapshot
  
  predicate resolve'0 (self : borrowed (List'0.t_list (k, v))) =
    [%#span29] self.final = self.current
  
  use prelude.prelude.Slice
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (List'0.t_list (k, v))) (fin : Seq.seq (List'0.t_list (k, v)))
    
   =
    [%#span34] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span35] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span36] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span25] shallow_model'4 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) (index:usize) (return'  (ret:borrowed (List'0.t_list (k, v))))= {[@expl:precondition] [%#span39] inv'14 index}
    {[@expl:precondition] [%#span38] inv'13 self}
    {[@expl:precondition] [%#span37] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (List'0.t_list (k, v)))-> {[%#span44] inv'2 result}
      {[%#span43] Seq.length (shallow_model'4 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span42] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'4 self.final)}
      {[%#span41] has_value'0 index (shallow_model'4 self.final) result.final}
      {[%#span40] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [%#span45] inv'12 self}
    any
    [ return' (result:uint64)-> {[%#span46] UInt64.to_int result = hash_log'0 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span47] shallow_model'4 self
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span48] inv'11 self}
    any
    [ return' (result:usize)-> {[%#span49] UIntSize.to_int result = Seq.length (shallow_model'2 self)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  let rec add (self:borrowed (MyHashMap'0.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[%#shashmap11] inv'5 val'}
    {[%#shashmap10] inv'4 key}
    {[%#shashmap9] inv'10 self}
    {[%#shashmap8] hashmap_inv'0 self.current}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#shashmap0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MyHashMap'0.t_myhashmap <k> <v> {self.current}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &length <- _ret' ] s1))
      | s1 = bb2 ]
      
    | bb2 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_13 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _13} (fun (_res:usize) ->  [ &_12 <- _res ] s1)
      | s1 =  [ &_15 <- length ] s2
      | s2 = UIntSize.eq {_15} {[%#shashmap1] (0 : usize)} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s3)
      | s3 = {[@expl:remainder by zero] [%#shashmap1] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = UIntSize.rem {_12} {_15} (fun (_ret':usize) ->  [ &index <- _ret' ] s1)
      | s1 = MyHashMap'0.t_myhashmap <k> <v> {self.current}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            Borrow.borrow_final
              <Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)>
              {rbuckets'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) ->
                 [ &_20 <- _ret' ] 
                MyHashMap'0.t_myhashmap <k> <v> {self.current}
                  (fun (l_buckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                     [ &self <- { self with current = MyHashMap'0.C_MyHashMap _20.final ; } ] 
                    s2)))
      | s2 = -{inv'0 _20.final}- s3
      | s3 = index_mut'0 {_20} {index} (fun (_ret':borrowed (List'0.t_list (k, v))) ->  [ &_19 <- _ret' ] s4)
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <List'0.t_list (k, v)> {_19.current} {Borrow.get_id _19}
          (fun (_ret':borrowed (List'0.t_list (k, v))) ->
             [ &_18 <- _ret' ] 
             [ &_19 <- { _19 with current = _18.final ; } ] 
            s1)
      | s1 = -{inv'1 _18.final}- s2
      | s2 = Borrow.borrow_final <List'0.t_list (k, v)> {_18.current} {Borrow.get_id _18}
          (fun (_ret':borrowed (List'0.t_list (k, v))) ->
             [ &l <- _ret' ] 
             [ &_18 <- { _18 with current = l.final ; } ] 
            s3)
      | s3 = -{inv'1 l.final}- s4
      | s4 = {[@expl:type invariant] inv'2 _18} s5
      | s5 = -{resolve'0 _18}- s6
      | s6 =  [ &old_l <- [%#shashmap2] Snapshot.new l ] s7
      | s7 = bb6 ]
      
    | bb6 = bb7
    | bb7 = bb7
      [ bb7 = {[@expl:loop invariant] [%#shashmap4] (forall i : deep_model_ty'0 . inv'3 i
         -> get'0 l.current i = get'0 l.final i \/ i = deep_model'0 key)
        /\ no_double_binding'0 l.final  -> no_double_binding'0 (Snapshot.inner old_l).final}
        {[@expl:loop invariant] [%#shashmap5] no_double_binding'0 l.current}
        {[@expl:loop invariant] [%#shashmap4] forall i : deep_model_ty'0 . inv'3 i
         -> get'0 l.final i = get'0 l.current i
         -> get'0 (Snapshot.inner old_l).final i = get'0 (Snapshot.inner old_l).current i}
        {[@expl:loop invariant] [%#shashmap4] get'0 l.final (deep_model'0 key) = Option'0.C_Some val'
         -> get'0 (Snapshot.inner old_l).final (deep_model'0 key) = Option'0.C_Some val'}
        {[@expl:loop invariant] [%#shashmap4] good_bucket'0 (Snapshot.inner old_self).current l.final (UIntSize.to_int index)
         -> good_bucket'0 (Snapshot.inner old_self).current (Snapshot.inner old_l).final (UIntSize.to_int index)}
        {[@expl:loop invariant] [%#shashmap3] good_bucket'0 (Snapshot.inner old_self).current l.current (UIntSize.to_int index)}
        (! s0) [ s0 = bb8 ] 
        [ bb8 = any
          [ br0 -> {l.current = List'0.C_Nil } (! bb14)
          | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> {l.current = List'0.C_Cons a b} (! bb9) ]
          
        | bb9 = bb10
        | bb10 = s0
          [ s0 = List'0.cons <(k, v)> {l.current}
              (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->
                Borrow.borrow_mut <k> {let (r'0, _) = r0'0 in r'0}
                  (fun (_ret':borrowed k) ->
                     [ &k <- _ret' ] 
                    List'0.cons <(k, v)> {l.current}
                      (fun (l_0'0:(k, v)) (l_1'0:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons (let (_, l'2) = l_0'0 in (k.final, l'2)) l_1'0 ; } ] 
                        s1)))
          | s1 = -{inv'4 k.final}- s2
          | s2 = List'0.cons <(k, v)> {l.current}
              (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->
                Borrow.borrow_mut <v> {let (_, r'1) = r0'1 in r'1}
                  (fun (_ret':borrowed v) ->
                     [ &v <- _ret' ] 
                    List'0.cons <(k, v)> {l.current}
                      (fun (l_0'1:(k, v)) (l_1'1:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons (let (l'4, _) = l_0'1 in (l'4, v.final)) l_1'1 ; } ] 
                        s3)))
          | s3 = -{inv'5 v.final}- s4
          | s4 = List'0.cons <(k, v)> {l.current}
              (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->
                Borrow.borrow_mut <List'0.t_list (k, v)> {r1'2}
                  (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                     [ &tl <- _ret' ] 
                    List'0.cons <(k, v)> {l.current}
                      (fun (l_0'2:(k, v)) (l_1'2:List'0.t_list (k, v)) ->
                         [ &l <- { l with current = List'0.C_Cons l_0'2 tl.final ; } ] 
                        s5)))
          | s5 = -{inv'6 tl.final}- s6
          | s6 =  [ &tl1 <- tl ] s7
          | s7 = eq'0 {k.current} {key} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s8)
          | s8 = bb11 ]
          
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'7 k} s1
          | s1 = -{resolve'1 k}- s2
          | s2 = any [ br0 -> {_38 = false} (! bb13) | br1 -> {_38} (! bb12) ]  ]
          
        | bb13 = s0
          [ s0 = {[@expl:type invariant] inv'8 v} s1
          | s1 = -{resolve'2 v}- s2
          | s2 = Borrow.borrow_final <List'0.t_list (k, v)> {tl1.current} {Borrow.get_id tl1}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_46 <- _ret' ] 
                 [ &tl1 <- { tl1 with current = _46.final ; } ] 
                s3)
          | s3 = -{inv'1 _46.final}- s4
          | s4 = Borrow.borrow_final <List'0.t_list (k, v)> {_46.current} {Borrow.get_id _46}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_45 <- _ret' ] 
                 [ &_46 <- { _46 with current = _45.final ; } ] 
                s5)
          | s5 = -{inv'1 _45.final}- s6
          | s6 = {[@expl:type invariant] inv'2 l} s7
          | s7 = -{resolve'0 l}- s8
          | s8 =  [ &l <- _45 ] s9
          | s9 = {[@expl:type invariant] inv'2 _46} s10
          | s10 = -{resolve'0 _46}- s11
          | s11 = {[@expl:type invariant] inv'9 tl1} s12
          | s12 = -{resolve'3 tl1}- s13
          | s13 = bb7 ]
           ]
         ]
      
    | bb14 = s0 [ s0 =  [ &_51 <- (key, val') ] s1 | s1 =  [ &_55 <- List'0.C_Nil ] s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_50 <- List'0.C_Cons _51 _55 ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'1 l.current} s1
      | s1 =  [ &l <- { l with current = _50 ; } ] s2
      | s2 = {[@expl:type invariant] inv'2 l} s3
      | s3 = -{resolve'0 l}- s4
      | s4 = {[@expl:type invariant] inv'2 _19} s5
      | s5 = -{resolve'0 _19}- s6
      | s6 = {[@expl:type invariant] inv'10 self} s7
      | s7 = -{resolve'4 self}- s8
      | s8 = bb19 ]
      
    | bb19 = s0 [ s0 = {[@expl:assertion] [%#shashmap6] hashmap_inv'0 self.current} s1 | s1 = bb20 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'9 tl1} s1
      | s1 = -{resolve'3 tl1}- s2
      | s2 =  [ &v <- { v with current = val' ; } ] s3
      | s3 = {[@expl:type invariant] inv'8 v} s4
      | s4 = -{resolve'2 v}- s5
      | s5 = {[@expl:type invariant] inv'2 _19} s6
      | s6 = -{resolve'0 _19}- s7
      | s7 = {[@expl:type invariant] inv'2 l} s8
      | s8 = -{resolve'0 l}- s9
      | s9 = {[@expl:type invariant] inv'10 self} s10
      | s10 = -{resolve'4 self}- s11
      | s11 = {[@expl:assertion] [%#shashmap7] hashmap_inv'0 self.current} s12
      | s12 = bb20 ]
      
    | bb20 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (MyHashMap'0.t_myhashmap k v) = self
    | & key : k = key
    | & val' : v = val'
    | & old_self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l ()
    | & length : usize = any_l ()
    | & index : usize = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : uint64 = any_l ()
    | & _15 : usize = any_l ()
    | & _16 : bool = any_l ()
    | & l : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _18 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _19 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _20 : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) = any_l ()
    | & old_l : Snapshot.snap_ty (borrowed (List'0.t_list (k, v))) = any_l ()
    | & k : borrowed k = any_l ()
    | & v : borrowed v = any_l ()
    | & tl : borrowed (List'0.t_list (k, v)) = any_l ()
    | & tl1 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _38 : bool = any_l ()
    | & _45 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _46 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _50 : List'0.t_list (k, v) = any_l ()
    | & _51 : (k, v) = any_l ()
    | & _55 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#shashmap13] forall i : deep_model_ty'0 . inv'3 i
       -> Map.get (shallow_model'0 self.final) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'1 self) i)}
      {[@expl:postcondition] [%#shashmap12] hashmap_inv'0 self.final}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Get
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 142 27 142 67
  
  let%span shashmap1 = "../hashmap.rs" 145 20 145 101
  
  let%span shashmap2 = "../hashmap.rs" 136 15 136 33
  
  let%span shashmap3 = "../hashmap.rs" 141 16 141 20
  
  let%span shashmap4 = "../hashmap.rs" 141 22 141 25
  
  let%span shashmap5 = "../hashmap.rs" 137 14 140 5
  
  let%span shashmap6 = "../hashmap.rs" 141 33 141 43
  
  let%span span7 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span8 = "" 0 0 0 0
  
  let%span span9 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span10 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span11 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span13 = "../hashmap.rs" 30 12 33 13
  
  let%span span14 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span15 = "../hashmap.rs" 90 20 90 66
  
  let%span span16 = "../hashmap.rs" 85 8 85 53
  
  let%span span17 = "../hashmap.rs" 79 20 79 45
  
  let%span span18 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span19 = "../hashmap.rs" 40 12 43 13
  
  let%span span20 = "../hashmap.rs" 200 8 202 9
  
  let%span span21 = "../hashmap.rs" 209 8 212 9
  
  let%span span22 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  let%span span23 = "" 0 0 0 0
  
  let%span span24 = "" 0 0 0 0
  
  let%span span25 = "../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  let%span span26 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span27 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span28 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span29 = "" 0 0 0 0
  
  let%span span30 = "" 0 0 0 0
  
  let%span span31 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span32 = "" 0 0 0 0
  
  let%span span33 = "" 0 0 0 0
  
  let%span span34 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span35 = "../hashmap.rs" 51 13 51 17
  
  let%span span36 = "../hashmap.rs" 50 14 50 58
  
  predicate invariant'10 (self : v)
  
  predicate inv'10 (_x : v)
  
  axiom inv'10 : forall x : v . inv'10 x = true
  
  type deep_model_ty'0
  
  predicate invariant'9 (self : deep_model_ty'0)
  
  predicate inv'9 (_x : deep_model_ty'0)
  
  axiom inv'9 : forall x : deep_model_ty'0 . inv'9 x = true
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'8 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span7] true
  
  predicate inv'8 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'8 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'8 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span8] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'7 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'2_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span9] inv'7 self)
   -> ([%#span11] inv'8 (shallow_model'2 self))
  && ([%#span10] Seq.length (shallow_model'2 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'7 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span12] inv'8 (shallow_model'2 self)
  
  axiom inv'7 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'7 x = true
  
  predicate invariant'6 (self : List'0.t_list (k, v)) =
    [%#span7] true
  
  predicate inv'6 (_x : List'0.t_list (k, v))
  
  axiom inv'6 : forall x : List'0.t_list (k, v) . inv'6 x = true
  
  predicate invariant'5 (self : usize) =
    [%#span7] true
  
  predicate inv'5 (_x : usize)
  
  axiom inv'5 : forall x : usize . inv'5 x = true
  
  predicate invariant'4 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span7] true
  
  predicate inv'4 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'4 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'4 x = true
  
  predicate invariant'3 (self : k)
  
  predicate inv'3 (_x : k)
  
  axiom inv'3 : forall x : k . inv'3 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'2 (self : Option'0.t_option v) =
    [%#span7] true
  
  predicate inv'2 (_x : Option'0.t_option v)
  
  axiom inv'2 : forall x : Option'0.t_option v . inv'2 x = true
  
  predicate invariant'1 (self : k)
  
  predicate inv'1 (_x : k)
  
  axiom inv'1 : forall x : k . inv'1 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'0 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span7] true
  
  predicate inv'0 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'0 : forall x : MyHashMap'0.t_myhashmap k v . inv'0 x = true
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span13] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span14] Seq.get (shallow_model'2 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span15] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span16] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'3 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span17] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  use prelude.prelude.Borrow
  
  function shallow_model'0 (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v) =
    [%#span18] shallow_model'3 self
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span19] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span20] forall k : deep_model_ty'0, v : v . inv'9 k /\ inv'10 v
     -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span21] 0 < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  use prelude.prelude.Intrinsic
  
  function deep_model'1 (self : k) : deep_model_ty'0 =
    [%#span22] deep_model'0 self
  
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] [%#span24] inv'3 other}
    {[@expl:precondition] [%#span23] inv'3 self}
    any [ return' (result:bool)-> {[%#span25] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ] 
  
  use prelude.prelude.Slice
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span26] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span27] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span18] shallow_model'2 self
  
  let rec index'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (index:usize) (return'  (ret:List'0.t_list (k, v)))= {[@expl:precondition] [%#span30] inv'5 index}
    {[@expl:precondition] [%#span29] inv'4 self}
    {[@expl:precondition] [%#span28] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:List'0.t_list (k, v))-> {[%#span32] inv'6 result}
      {[%#span31] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span33] inv'4 self}
    any
    [ return' (result:usize)-> {[%#span34] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [%#span35] inv'3 self}
    any
    [ return' (result:uint64)-> {[%#span36] UInt64.to_int result = hash_log'0 (deep_model'1 self)}
      (! return' {result}) ]
    
  
  let rec get (self:MyHashMap'0.t_myhashmap k v) (key:k) (return'  (ret:Option'0.t_option v))= {[%#shashmap4] inv'1 key}
    {[%#shashmap3] inv'0 self}
    {[%#shashmap2] hashmap_inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_8 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _8} (fun (_res:usize) ->  [ &_7 <- _res ] s1)
      | s1 = MyHashMap'0.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.eq {_10} {[%#shashmap0] (0 : usize)} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = {[@expl:remainder by zero] [%#shashmap0] not _12} s2
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = UIntSize.rem {_7} {_10} (fun (_ret':usize) ->  [ &index <- _ret' ] s1)
      | s1 = MyHashMap'0.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            index'0 {rbuckets'0} {index} (fun (_ret':List'0.t_list (k, v)) ->  [ &_14 <- _ret' ] s2))
      | s2 = bb4 ]
      
    | bb4 = s0 [ s0 =  [ &l <- _14 ] s1 | s1 = bb5 ] 
    | bb5 = bb5
      [ bb5 = {[@expl:loop invariant] [%#shashmap1] get'0 (bucket'0 self (deep_model'0 key)) (deep_model'0 key)
        = get'0 l (deep_model'0 key)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = any
          [ br0 -> {l = List'0.C_Nil } (! bb12)
          | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> {l = List'0.C_Cons a b} (! bb7) ]
          
        | bb7 = bb8
        | bb8 = s0
          [ s0 = List'0.cons <(k, v)> {l}
              (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
          | s1 = List'0.cons <(k, v)> {l}
              (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
          | s2 = List'0.cons <(k, v)> {l} (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->  [ &tl <- r1'2 ] s3)
          | s3 = eq'0 {k} {key} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s4)
          | s4 = bb9 ]
          
        | bb9 = any [ br0 -> {_25 = false} (! bb11) | br1 -> {_25} (! bb10) ] 
        | bb11 = s0 [ s0 =  [ &_31 <- tl ] s1 | s1 =  [ &l <- _31 ] s2 | s2 = bb5 ]  ]
         ]
      
    | bb12 = s0 [ s0 =  [ &_0 <- Option'0.C_None ] s1 | s1 = bb13 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- Option'0.C_Some v ] s1 | s1 = bb13 ] 
    | bb13 = return' {_0} ]
    )
    [ & _0 : Option'0.t_option v = any_l ()
    | & self : MyHashMap'0.t_myhashmap k v = self
    | & key : k = key
    | & index : usize = any_l ()
    | & _7 : usize = any_l ()
    | & _8 : uint64 = any_l ()
    | & _10 : usize = any_l ()
    | & _12 : bool = any_l ()
    | & l : List'0.t_list (k, v) = any_l ()
    | & _14 : List'0.t_list (k, v) = any_l ()
    | & k : k = any_l ()
    | & v : v = any_l ()
    | & tl : List'0.t_list (k, v) = any_l ()
    | & _25 : bool = any_l ()
    | & _31 : List'0.t_list (k, v) = any_l () ]
    
    [ return' (result:Option'0.t_option v)-> {[@expl:postcondition] [%#shashmap6] inv'2 result}
      {[@expl:postcondition] [%#shashmap5] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'0 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Resize
  type k
  
  type v
  
  let%span shashmap0 = "../hashmap.rs" 162 23 162 41
  
  let%span shashmap1 = "../hashmap.rs" 163 53 163 54
  
  let%span shashmap2 = "../hashmap.rs" 165 27 165 28
  
  let%span shashmap3 = "../hashmap.rs" 166 8 166 111
  
  let%span shashmap4 = "../hashmap.rs" 172 20 172 37
  
  let%span shashmap5 = "../hashmap.rs" 173 20 173 66
  
  let%span shashmap6 = "../hashmap.rs" 174 20 174 45
  
  let%span shashmap7 = "../hashmap.rs" 178 24 178 41
  
  let%span shashmap8 = "../hashmap.rs" 178 12 178 43
  
  let%span shashmap9 = "../hashmap.rs" 185 24 185 45
  
  let%span shashmap10 = "../hashmap.rs" 186 24 186 51
  
  let%span shashmap11 = "../hashmap.rs" 191 12 191 121
  
  let%span shashmap12 = "../hashmap.rs" 192 17 192 18
  
  let%span shashmap13 = "../hashmap.rs" 156 15 156 41
  
  let%span shashmap14 = "../hashmap.rs" 157 15 157 36
  
  let%span shashmap15 = "../hashmap.rs" 161 19 161 23
  
  let%span shashmap16 = "../hashmap.rs" 158 14 158 35
  
  let%span shashmap17 = "../hashmap.rs" 159 4 159 74
  
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span19 = "" 0 0 0 0
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span21 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span23 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span24 = "../hashmap.rs" 30 12 33 13
  
  let%span span25 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span26 = "../hashmap.rs" 90 20 90 66
  
  let%span span27 = "../hashmap.rs" 85 8 85 53
  
  let%span span28 = "../hashmap.rs" 79 20 79 45
  
  let%span span29 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span30 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span31 = "../hashmap.rs" 40 12 43 13
  
  let%span span32 = "../hashmap.rs" 200 8 202 9
  
  let%span span33 = "../hashmap.rs" 209 8 212 9
  
  let%span span34 = "../hashmap.rs" 103 15 103 36
  
  let%span span35 = "../hashmap.rs" 106 20 106 24
  
  let%span span36 = "../hashmap.rs" 106 26 106 29
  
  let%span span37 = "../hashmap.rs" 106 34 106 37
  
  let%span span38 = "../hashmap.rs" 104 14 104 35
  
  let%span span39 = "../hashmap.rs" 105 4 105 124
  
  let%span span40 = "" 0 0 0 0
  
  let%span span41 = "" 0 0 0 0
  
  let%span span42 = "../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  
  let%span span43 = "../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  let%span span44 = "" 0 0 0 0
  
  let%span span45 = "../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96
  
  let%span span46 = "../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37
  
  let%span span47 = "../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  
  let%span span48 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span49 = "" 0 0 0 0
  
  let%span span50 = "" 0 0 0 0
  
  let%span span51 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span52 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span53 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span54 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span55 = "" 0 0 0 0
  
  let%span span56 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span57 = "../../../../creusot-contracts/src/snapshot.rs" 27 20 27 48
  
  let%span span58 = "../hashmap.rs" 95 15 95 24
  
  let%span span59 = "../hashmap.rs" 96 14 96 34
  
  let%span span60 = "../hashmap.rs" 97 4 97 64
  
  let%span span61 = "../hashmap.rs" 98 31 98 46
  
  let%span span62 = "" 0 0 0 0
  
  let%span span63 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  predicate invariant'11 (self : k)
  
  predicate inv'11 (_x : k)
  
  axiom inv'11 : forall x : k . inv'11 x = true
  
  predicate invariant'10 (self : v)
  
  predicate inv'10 (_x : v)
  
  axiom inv'10 : forall x : v . inv'10 x = true
  
  use prelude.prelude.UIntSize
  
  predicate invariant'9 (self : usize) =
    [%#span18] true
  
  predicate inv'9 (_x : usize)
  
  axiom inv'9 : forall x : usize . inv'9 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Hashmap_List_Type as List'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'8 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) =
    [%#span18] true
  
  predicate inv'8 (_x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)))
  
  axiom inv'8 : forall x : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) . inv'8 x = true
  
  use seq.Seq
  
  predicate invariant'7 (self : Seq.seq (List'0.t_list (k, v))) =
    [%#span18] true
  
  predicate inv'7 (_x : Seq.seq (List'0.t_list (k, v)))
  
  axiom inv'7 : forall x : Seq.seq (List'0.t_list (k, v)) . inv'7 x = true
  
  predicate invariant'6 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span18] true
  
  predicate inv'6 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  axiom inv'6 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'6 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  predicate invariant'5 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span18] true
  
  predicate inv'5 (_x : borrowed (MyHashMap'0.t_myhashmap k v))
  
  axiom inv'5 : forall x : borrowed (MyHashMap'0.t_myhashmap k v) . inv'5 x = true
  
  predicate invariant'4 (self : MyHashMap'0.t_myhashmap k v) =
    [%#span18] true
  
  predicate inv'4 (_x : MyHashMap'0.t_myhashmap k v)
  
  axiom inv'4 : forall x : MyHashMap'0.t_myhashmap k v . inv'4 x = true
  
  predicate invariant'3 (self : borrowed (List'0.t_list (k, v))) =
    [%#span18] true
  
  predicate inv'3 (_x : borrowed (List'0.t_list (k, v)))
  
  axiom inv'3 : forall x : borrowed (List'0.t_list (k, v)) . inv'3 x = true
  
  predicate invariant'2 (self : List'0.t_list (k, v)) =
    [%#span18] true
  
  predicate inv'2 (_x : List'0.t_list (k, v))
  
  axiom inv'2 : forall x : List'0.t_list (k, v) . inv'2 x = true
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span19] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'1 (_x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))
  
  function shallow_model'2 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
  
  axiom shallow_model'2_spec : forall self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . ([%#span20] inv'1 self)
   -> ([%#span22] inv'7 (shallow_model'2 self))
  && ([%#span21] Seq.length (shallow_model'2 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'1 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) =
    [%#span23] inv'7 (shallow_model'2 self)
  
  axiom inv'1 : forall x : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global) . inv'1 x = true
  
  type deep_model_ty'0
  
  predicate invariant'0 (self : deep_model_ty'0)
  
  predicate inv'0 (_x : deep_model_ty'0)
  
  axiom inv'0 : forall x : deep_model_ty'0 . inv'0 x = true
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : k) : deep_model_ty'0
  
  use Core_Option_Option_Type as Option'0
  
  function get'0 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (k, v)) (index : deep_model_ty'0) : Option'0.t_option v
    
   =
    [%#span24] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'0 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (ix : int) : List'0.t_list (k, v)
    
   =
    [%#span25] Seq.get (shallow_model'2 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 54 4 54 45] (_1 : deep_model_ty'0) : int
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : int =
    [%#span26] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap k v) (k : deep_model_ty'0) : List'0.t_list (k, v)
    
   =
    [%#span27] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  use map.Map
  
  function shallow_model'1 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap k v) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span28] Mapping.from_fn (fun (k : deep_model_ty'0) -> get'0 (bucket'0 self k) k)
  
  function shallow_model'3 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span29] shallow_model'1 self.current
  
  use prelude.prelude.Snapshot
  
  use prelude.prelude.Intrinsic
  
  predicate resolve'1 (self : borrowed (MyHashMap'0.t_myhashmap k v)) =
    [%#span30] self.final = self.current
  
  use map.Map
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (k, v)) =
    [%#span31] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'0 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap k v) (l : List'0.t_list (k, v)) (h : int)
    
   =
    [%#span32] forall k : deep_model_ty'0, v : v . inv'0 k /\ inv'10 v
     -> get'0 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap k v) =
    [%#span33] 0 < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[@expl:precondition] [%#span37] inv'10 val'}
    {[@expl:precondition] [%#span36] inv'11 key}
    {[@expl:precondition] [%#span35] inv'5 self}
    {[@expl:precondition] [%#span34] hashmap_inv'0 self.current}
    any
    [ return' (result:())-> {[%#span39] forall i : deep_model_ty'0 . inv'0 i
       -> Map.get (shallow_model'1 self.final) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'3 self) i)}
      {[%#span38] hashmap_inv'0 self.final}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (List'0.t_list (k, v))) =
    [%#span30] self.final = self.current
  
  let rec replace'0 (dest:borrowed (List'0.t_list (k, v))) (src:List'0.t_list (k, v)) (return'  (ret:List'0.t_list (k, v)))= {[@expl:precondition] [%#span41] inv'2 src}
    {[@expl:precondition] [%#span40] inv'3 dest}
    any
    [ return' (result:List'0.t_list (k, v))-> {[%#span44] inv'2 result}
      {[%#span43] result = dest.current}
      {[%#span42] dest.final = src}
      (! return' {result}) ]
    
  
  use prelude.prelude.Slice
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (List'0.t_list (k, v))) (fin : Seq.seq (List'0.t_list (k, v)))
    
   =
    [%#span45] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) (out : List'0.t_list (k, v))
    
   =
    [%#span46] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (List'0.t_list (k, v))) =
    [%#span47] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'6 (self : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span29] shallow_model'2 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) (index:usize) (return'  (ret:borrowed (List'0.t_list (k, v))))= {[@expl:precondition] [%#span50] inv'9 index}
    {[@expl:precondition] [%#span49] inv'8 self}
    {[@expl:precondition] [%#span48] in_bounds'0 index (shallow_model'6 self)}
    any
    [ return' (result:borrowed (List'0.t_list (k, v)))-> {[%#span55] inv'3 result}
      {[%#span54] Seq.length (shallow_model'2 self.final) = Seq.length (shallow_model'6 self)}
      {[%#span53] resolve_elswhere'0 index (shallow_model'6 self) (shallow_model'2 self.final)}
      {[%#span52] has_value'0 index (shallow_model'2 self.final) result.final}
      {[%#span51] has_value'0 index (shallow_model'6 self) result.current}
      (! return' {result}) ]
    
  
  function shallow_model'5 (self : borrowed (MyHashMap'0.t_myhashmap k v)) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span56] shallow_model'3 self
  
  use prelude.prelude.Snapshot
  
  function shallow_model'0 (self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v))) : Map.map deep_model_ty'0 (Option'0.t_option v)
    
   =
    [%#span57] shallow_model'5 (Snapshot.inner self)
  
  let rec new'0 (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap k v))= {[@expl:precondition] [%#span58] 0
    < UIntSize.to_int size}
    any
    [ return' (result:MyHashMap'0.t_myhashmap k v)-> {[%#span61] inv'4 result}
      {[%#span60] forall i : deep_model_ty'0 . inv'0 i  -> Map.get (shallow_model'1 result) i = Option'0.C_None}
      {[%#span59] hashmap_inv'0 result}
      (! return' {result}) ]
    
  
  function shallow_model'4 (self : Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) : Seq.seq (List'0.t_list (k, v))
    
   =
    [%#span56] shallow_model'2 self
  
  let rec len'0 (self:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) (return'  (ret:usize))= {[@expl:precondition] [%#span62] inv'6 self}
    any
    [ return' (result:usize)-> {[%#span63] UIntSize.to_int result = Seq.length (shallow_model'4 self)}
      (! return' {result}) ]
    
  
  use prelude.prelude.Snapshot
  
  let rec resize (self:borrowed (MyHashMap'0.t_myhashmap k v)) (return'  (ret:()))= {[%#shashmap15] inv'5 self}
    {[%#shashmap14] hashmap_inv'0 self.current}
    {[%#shashmap13] Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self.current)) < 1000}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#shashmap0] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = MyHashMap'0.t_myhashmap <k> <v> {self.current}
          (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s1))
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.mul {_10} {[%#shashmap1] (2 : usize)} (fun (_ret':usize) ->  [ &_9 <- _ret' ] s1)
      | s1 = new'0 {_9} (fun (_ret':MyHashMap'0.t_myhashmap k v) ->  [ &new <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 =  [ &i <- [%#shashmap2] (0 : usize) ] s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &old_6_0 <- Snapshot.new self ] s1 | s1 = bb6 ] 
    | bb6 = bb6
      [ bb6 = {[@expl:loop invariant] (Snapshot.inner old_6_0).final = self.final}
        {[@expl:loop invariant] [%#shashmap6] UIntSize.to_int i
        <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self.current))}
        {[@expl:loop invariant] [%#shashmap5] Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets (Snapshot.inner old_self).current))
        = Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self.current))}
        {[@expl:loop invariant] [%#shashmap4] hashmap_inv'0 new}
        {[@expl:loop invariant] [%#shashmap3] forall j : int . UIntSize.to_int i <= j
        /\ j < Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets (Snapshot.inner old_self).current))
         -> index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self.current) j
        = index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets (Snapshot.inner old_self).current) j}
        {[@expl:loop invariant] [%#shashmap3] forall k : deep_model_ty'0 . inv'0 k
         -> UIntSize.to_int i <= bucket_ix'0 (Snapshot.inner old_self).current k
        /\ bucket_ix'0 (Snapshot.inner old_self).current k
        <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets (Snapshot.inner old_self).current))
         -> Map.get (shallow_model'1 new) k = Option'0.C_None}
        {[@expl:loop invariant] [%#shashmap3] forall k : deep_model_ty'0 . inv'0 k
         -> bucket_ix'0 (Snapshot.inner old_self).current k < UIntSize.to_int i
         -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = MyHashMap'0.t_myhashmap <k> <v> {self.current}
              (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_23 <- _ret' ] s1))
          | s1 = bb8 ]
          
        | bb8 = s0
          [ s0 = UIntSize.lt {i} {_23} (fun (_ret':bool) ->  [ &_21 <- _ret' ] s1)
          | s1 = any [ br0 -> {_21 = false} (! bb29) | br1 -> {_21} (! bb9) ]  ]
          
        | bb9 = s0
          [ s0 = MyHashMap'0.t_myhashmap <k> <v> {self.current}
              (fun (rbuckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                Borrow.borrow_mut <Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)> {rbuckets'0}
                  (fun (_ret':borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global))) ->
                     [ &_29 <- _ret' ] 
                    MyHashMap'0.t_myhashmap <k> <v> {self.current}
                      (fun (l_buckets'0:Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) ->
                         [ &self <- { self with current = MyHashMap'0.C_MyHashMap _29.final ; } ] 
                        s1)))
          | s1 = -{inv'1 _29.final}- s2
          | s2 = index_mut'0 {_29} {i} (fun (_ret':borrowed (List'0.t_list (k, v))) ->  [ &_28 <- _ret' ] s3)
          | s3 = bb10 ]
          
        | bb10 = s0
          [ s0 = Borrow.borrow_final <List'0.t_list (k, v)> {_28.current} {Borrow.get_id _28}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_27 <- _ret' ] 
                 [ &_28 <- { _28 with current = _27.final ; } ] 
                s1)
          | s1 = -{inv'2 _27.final}- s2
          | s2 = Borrow.borrow_final <List'0.t_list (k, v)> {_27.current} {Borrow.get_id _27}
              (fun (_ret':borrowed (List'0.t_list (k, v))) ->
                 [ &_26 <- _ret' ] 
                 [ &_27 <- { _27 with current = _26.final ; } ] 
                s3)
          | s3 = -{inv'2 _26.final}- s4
          | s4 =  [ &_31 <- List'0.C_Nil ] s5
          | s5 = replace'0 {_26} {_31} (fun (_ret':List'0.t_list (k, v)) ->  [ &l <- _ret' ] s6)
          | s6 = bb11 ]
          
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'3 _28} s1
          | s1 = -{resolve'0 _28}- s2
          | s2 = {[@expl:type invariant] inv'3 _27} s3
          | s3 = -{resolve'0 _27}- s4
          | s4 = bb12 ]
          
        | bb12 = bb13
        | bb13 = bb14
        | bb14 = bb15
        | bb15 = bb16
        | bb16 = bb17
        | bb17 = bb17
          [ bb17 = {[@expl:loop invariant] [%#shashmap10] good_bucket'0 (Snapshot.inner old_self).current l (UIntSize.to_int i)}
            {[@expl:loop invariant] [%#shashmap9] no_double_binding'0 l}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'0 k
             -> bucket_ix'0 (Snapshot.inner old_self).current k = UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k
            = match get'0 l k with
              | Option'0.C_None -> Map.get (shallow_model'1 new) k
              | Option'0.C_Some v -> Option'0.C_Some v
              end}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'0 k
             -> UIntSize.to_int i < bucket_ix'0 (Snapshot.inner old_self).current k
            /\ bucket_ix'0 (Snapshot.inner old_self).current k
            <= Seq.length (shallow_model'2 (Hashmap_MyHashMap_Type.myhashmap_buckets (Snapshot.inner old_self).current))
             -> Map.get (shallow_model'1 new) k = Option'0.C_None}
            {[@expl:loop invariant] [%#shashmap8] forall k : deep_model_ty'0 . inv'0 k
             -> bucket_ix'0 (Snapshot.inner old_self).current k < UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
            {[@expl:loop invariant] [%#shashmap7] hashmap_inv'0 new}
            (! s0) [ s0 = bb18 ] 
            [ bb18 = any
              [ br0 -> {l = List'0.C_Nil } (! bb25)
              | br1 (a:(k, v)) (b:List'0.t_list (k, v))-> {l = List'0.C_Cons a b} (! bb19) ]
              
            | bb19 = bb20
            | bb20 = s0
              [ s0 = List'0.cons <(k, v)> {l}
                  (fun (r0'0:(k, v)) (r1'0:List'0.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
              | s1 = List'0.cons <(k, v)> {l}
                  (fun (r0'1:(k, v)) (r1'1:List'0.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
              | s2 = List'0.cons <(k, v)> {l} (fun (r0'2:(k, v)) (r1'2:List'0.t_list (k, v)) ->  [ &tl <- r1'2 ] s3)
              | s3 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap k v> {new}
                  (fun (_ret':borrowed (MyHashMap'0.t_myhashmap k v)) ->  [ &_44 <- _ret' ]  [ &new <- _44.final ] s4)
              | s4 = -{inv'4 _44.final}- s5
              | s5 = add'0 {_44} {k} {v} (fun (_ret':()) ->  [ &_43 <- _ret' ] s6)
              | s6 = bb21 ]
              
            | bb21 = bb22
            | bb22 = s0 [ s0 =  [ &l <- tl ] s1 | s1 = bb24 ] 
            | bb24 = bb26
            | bb26 = bb17 ]
             ]
          
        | bb25 = s0
          [ s0 = {[@expl:type invariant] match l with
              | List'0.C_Cons _ _ -> inv'2 l
              | _ -> true
              end}
            s1
          | s1 = {[@expl:assertion] [%#shashmap11] forall k : deep_model_ty'0 . inv'0 k
             -> bucket_ix'0 (Snapshot.inner old_self).current k = UIntSize.to_int i
             -> Map.get (shallow_model'0 old_self) k = Map.get (shallow_model'1 new) k}
            s2
          | s2 = bb27 ]
          
        | bb27 = s0
          [ s0 = UIntSize.add {i} {[%#shashmap12] (1 : usize)} (fun (_ret':usize) ->  [ &i <- _ret' ] s1) | s1 = bb28 ]
          
        | bb28 = bb6 ]
         ]
      
    | bb29 = bb30
    | bb30 = s0
      [ s0 = {[@expl:type invariant] inv'4 self.current} s1
      | s1 =  [ &self <- { self with current = new ; } ] s2
      | s2 = {[@expl:type invariant] inv'5 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb32 ]
      
    | bb32 = bb33
    | bb33 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & self : borrowed (MyHashMap'0.t_myhashmap k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l ()
    | & new : MyHashMap'0.t_myhashmap k v = any_l ()
    | & _9 : usize = any_l ()
    | & _10 : usize = any_l ()
    | & i : usize = any_l ()
    | & _21 : bool = any_l ()
    | & _23 : usize = any_l ()
    | & l : List'0.t_list (k, v) = any_l ()
    | & _26 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _27 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _28 : borrowed (List'0.t_list (k, v)) = any_l ()
    | & _29 : borrowed (Vec'0.t_vec (List'0.t_list (k, v)) (Global'0.t_global)) = any_l ()
    | & _31 : List'0.t_list (k, v) = any_l ()
    | & k : k = any_l ()
    | & v : v = any_l ()
    | & tl : List'0.t_list (k, v) = any_l ()
    | & _43 : () = any_l ()
    | & _44 : borrowed (MyHashMap'0.t_myhashmap k v) = any_l ()
    | & old_6_0 : Snapshot.snap_ty (borrowed (MyHashMap'0.t_myhashmap k v)) = any_l () ]
    
    [ return' (result:())-> {[@expl:postcondition] [%#shashmap17] forall k : deep_model_ty'0 . inv'0 k
       -> Map.get (shallow_model'1 self.final) k = Map.get (shallow_model'3 self) k}
      {[@expl:postcondition] [%#shashmap16] hashmap_inv'0 self.final}
      (! return' {result}) ]
    
end
module Hashmap_Main
  let%span shashmap0 = "../hashmap.rs" 223 57 223 59
  
  let%span shashmap1 = "../hashmap.rs" 224 57 224 59
  
  let%span shashmap2 = "../hashmap.rs" 225 24 225 25
  
  let%span shashmap3 = "../hashmap.rs" 226 24 226 25
  
  let%span shashmap4 = "../hashmap.rs" 227 24 227 25
  
  let%span shashmap5 = "../hashmap.rs" 228 24 228 25
  
  let%span shashmap6 = "../hashmap.rs" 232 11 232 12
  
  let%span shashmap7 = "../hashmap.rs" 232 14 232 16
  
  let%span shashmap8 = "../hashmap.rs" 233 16 233 17
  
  let%span shashmap9 = "../hashmap.rs" 234 16 234 17
  
  let%span shashmap10 = "../hashmap.rs" 235 16 235 17
  
  let%span shashmap11 = "../hashmap.rs" 236 16 236 17
  
  let%span shashmap12 = "../hashmap.rs" 239 11 239 12
  
  let%span shashmap13 = "../hashmap.rs" 239 14 239 16
  
  let%span shashmap14 = "../hashmap.rs" 240 16 240 17
  
  let%span shashmap15 = "../hashmap.rs" 241 16 241 17
  
  let%span shashmap16 = "../hashmap.rs" 242 16 242 17
  
  let%span shashmap17 = "../hashmap.rs" 243 16 243 17
  
  let%span span18 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span19 = "" 0 0 0 0
  
  let%span span20 = "../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25
  
  let%span span21 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span22 = "../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36
  
  let%span span23 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span24 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span25 = "../hashmap.rs" 30 12 33 13
  
  let%span span26 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span27 = "../hashmap.rs" 65 20 65 21
  
  let%span span28 = "../hashmap.rs" 90 20 90 66
  
  let%span span29 = "../hashmap.rs" 85 8 85 53
  
  let%span span30 = "../hashmap.rs" 79 20 79 45
  
  let%span span31 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span32 = "../hashmap.rs" 40 12 43 13
  
  let%span span33 = "../hashmap.rs" 200 8 202 9
  
  let%span span34 = "../hashmap.rs" 209 8 212 9
  
  let%span span35 = "../hashmap.rs" 103 15 103 36
  
  let%span span36 = "../hashmap.rs" 106 20 106 24
  
  let%span span37 = "../hashmap.rs" 106 26 106 29
  
  let%span span38 = "../hashmap.rs" 106 34 106 37
  
  let%span span39 = "../hashmap.rs" 104 14 104 35
  
  let%span span40 = "../hashmap.rs" 105 4 105 124
  
  let%span span41 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span42 = "../hashmap.rs" 136 15 136 33
  
  let%span span43 = "../hashmap.rs" 141 16 141 20
  
  let%span span44 = "../hashmap.rs" 141 22 141 25
  
  let%span span45 = "../hashmap.rs" 137 14 140 5
  
  let%span span46 = "../hashmap.rs" 141 33 141 43
  
  let%span span47 = "../hashmap.rs" 95 15 95 24
  
  let%span span48 = "../hashmap.rs" 96 14 96 34
  
  let%span span49 = "../hashmap.rs" 97 4 97 64
  
  let%span span50 = "../hashmap.rs" 98 31 98 46
  
  use prelude.prelude.IntSize
  
  use prelude.prelude.UIntSize
  
  use Hashmap_List_Type as List'0
  
  use seq.Seq
  
  predicate invariant'8 (self : Seq.seq (List'0.t_list (usize, isize))) =
    [%#span18] true
  
  predicate inv'8 (_x : Seq.seq (List'0.t_list (usize, isize)))
  
  axiom inv'8 : forall x : Seq.seq (List'0.t_list (usize, isize)) . inv'8 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  use Alloc_Vec_Vec_Type as Vec'0
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  constant max'0 : usize = [%#span19] (18446744073709551615 : usize)
  
  use seq.Seq
  
  predicate inv'7 (_x : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global))
  
  function shallow_model'3 (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) : Seq.seq (List'0.t_list (usize, isize))
    
  
  axiom shallow_model'3_spec : forall self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global) . ([%#span20] inv'7 self)
   -> ([%#span22] inv'8 (shallow_model'3 self))
  && ([%#span21] Seq.length (shallow_model'3 self) <= UIntSize.to_int (max'0 : usize))
  
  predicate invariant'7 (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) =
    [%#span23] inv'8 (shallow_model'3 self)
  
  axiom inv'7 : forall x : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global) . inv'7 x = true
  
  predicate invariant'6 (self : isize) =
    [%#span18] true
  
  predicate inv'6 (_x : isize)
  
  axiom inv'6 : forall x : isize . inv'6 x = true
  
  use Hashmap_MyHashMap_Type as MyHashMap'0
  
  use prelude.prelude.Borrow
  
  predicate invariant'5 (self : borrowed (MyHashMap'0.t_myhashmap usize isize)) =
    [%#span18] true
  
  predicate inv'5 (_x : borrowed (MyHashMap'0.t_myhashmap usize isize))
  
  axiom inv'5 : forall x : borrowed (MyHashMap'0.t_myhashmap usize isize) . inv'5 x = true
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'4 (self : Option'0.t_option isize) =
    [%#span18] true
  
  predicate inv'4 (_x : Option'0.t_option isize)
  
  axiom inv'4 : forall x : Option'0.t_option isize . inv'4 x = true
  
  predicate invariant'3 (self : usize) =
    [%#span18] true
  
  predicate inv'3 (_x : usize)
  
  axiom inv'3 : forall x : usize . inv'3 x = true
  
  predicate invariant'2 (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span18] true
  
  predicate inv'2 (_x : MyHashMap'0.t_myhashmap usize isize)
  
  axiom inv'2 : forall x : MyHashMap'0.t_myhashmap usize isize . inv'2 x = true
  
  predicate invariant'1 (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span18] true
  
  predicate inv'1 (_x : MyHashMap'0.t_myhashmap usize isize)
  
  axiom inv'1 : forall x : MyHashMap'0.t_myhashmap usize isize . inv'1 x = true
  
  use prelude.prelude.Int
  
  predicate invariant'0 (self : int) =
    [%#span18] true
  
  predicate inv'0 (_x : int)
  
  axiom inv'0 : forall x : int . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use map.Map
  
  use prelude.prelude.Mapping
  
  function deep_model'0 (self : usize) : int =
    [%#span24] UIntSize.to_int self
  
  function get'1 [#"../hashmap.rs" 28 4 28 56] (self : List'0.t_list (usize, isize)) (index : int) : Option'0.t_option isize
    
   =
    [%#span25] match self with
      | List'0.C_Nil -> Option'0.C_None
      | List'0.C_Cons (k, v) tl -> if deep_model'0 k = index then Option'0.C_Some v else get'1 tl index
      end
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_vec (List'0.t_list (usize, isize)) (Global'0.t_global)) (ix : int) : List'0.t_list (usize, isize)
    
   =
    [%#span26] Seq.get (shallow_model'3 self) ix
  
  use int.EuclideanDivision
  
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span27] x
  
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 48] (self : MyHashMap'0.t_myhashmap usize isize) (k : int) : int =
    [%#span28] EuclideanDivision.mod (hash_log'0 k) (Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  
  function bucket'0 [#"../hashmap.rs" 84 4 84 54] (self : MyHashMap'0.t_myhashmap usize isize) (k : int) : List'0.t_list (usize, isize)
    
   =
    [%#span29] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  
  function shallow_model'0 [#"../hashmap.rs" 78 4 78 50] (self : MyHashMap'0.t_myhashmap usize isize) : Map.map int (Option'0.t_option isize)
    
   =
    [%#span30] Mapping.from_fn (fun (k : int) -> get'1 (bucket'0 self k) k)
  
  function shallow_model'2 (self : borrowed (MyHashMap'0.t_myhashmap usize isize)) : Map.map int (Option'0.t_option isize)
    
   =
    [%#span31] shallow_model'0 self.current
  
  use map.Map
  
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : List'0.t_list (usize, isize)) =
    [%#span32] match self with
      | List'0.C_Nil -> true
      | List'0.C_Cons (k, _) tl -> get'1 tl (deep_model'0 k) = Option'0.C_None /\ no_double_binding'0 tl
      end
  
  predicate good_bucket'0 [#"../hashmap.rs" 199 4 199 57] (self : MyHashMap'0.t_myhashmap usize isize) (l : List'0.t_list (usize, isize)) (h : int)
    
   =
    [%#span33] forall k : int, v : isize . inv'0 k /\ inv'6 v
     -> get'1 l k = Option'0.C_Some v  -> bucket_ix'0 self k = h
  
  predicate hashmap_inv'0 [#"../hashmap.rs" 208 4 208 33] (self : MyHashMap'0.t_myhashmap usize isize) =
    [%#span34] 0 < Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (shallow_model'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  
  let rec add'0 (self:borrowed (MyHashMap'0.t_myhashmap usize isize)) (key:usize) (val':isize) (return'  (ret:()))= {[@expl:precondition] [%#span38] inv'6 val'}
    {[@expl:precondition] [%#span37] inv'3 key}
    {[@expl:precondition] [%#span36] inv'5 self}
    {[@expl:precondition] [%#span35] hashmap_inv'0 self.current}
    any
    [ return' (result:())-> {[%#span40] forall i : int . inv'0 i
       -> Map.get (shallow_model'0 self.final) i
      = (if i = deep_model'0 key then Option'0.C_Some val' else Map.get (shallow_model'2 self) i)}
      {[%#span39] hashmap_inv'0 self.final}
      (! return' {result}) ]
    
  
  function shallow_model'1 (self : MyHashMap'0.t_myhashmap usize isize) : Map.map int (Option'0.t_option isize) =
    [%#span41] shallow_model'0 self
  
  let rec get'0 (self:MyHashMap'0.t_myhashmap usize isize) (key:usize) (return'  (ret:Option'0.t_option isize))= {[@expl:precondition] [%#span44] inv'3 key}
    {[@expl:precondition] [%#span43] inv'2 self}
    {[@expl:precondition] [%#span42] hashmap_inv'0 self}
    any
    [ return' (result:Option'0.t_option isize)-> {[%#span46] inv'4 result}
      {[%#span45] match result with
        | Option'0.C_Some v -> Map.get (shallow_model'1 self) (deep_model'0 key) = Option'0.C_Some v
        | Option'0.C_None -> Map.get (shallow_model'1 self) (deep_model'0 key) = Option'0.C_None
        end}
      (! return' {result}) ]
    
  
  let rec new'0 (size:usize) (return'  (ret:MyHashMap'0.t_myhashmap usize isize))= {[@expl:precondition] [%#span47] 0
    < UIntSize.to_int size}
    any
    [ return' (result:MyHashMap'0.t_myhashmap usize isize)-> {[%#span50] inv'1 result}
      {[%#span49] forall i : int . inv'0 i  -> Map.get (shallow_model'0 result) i = Option'0.C_None}
      {[%#span48] hashmap_inv'0 result}
      (! return' {result}) ]
    
  
  let rec main (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = new'0 {[%#shashmap0] (17 : usize)}
          (fun (_ret':MyHashMap'0.t_myhashmap usize isize) ->  [ &h1 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = new'0 {[%#shashmap1] (42 : usize)}
          (fun (_ret':MyHashMap'0.t_myhashmap usize isize) ->  [ &h2 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = get'0 {h1} {[%#shashmap2] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_x <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = get'0 {h1} {[%#shashmap3] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_y <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = get'0 {h2} {[%#shashmap4] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_z <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = get'0 {h2} {[%#shashmap5] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_t <- _ret' ] s1)
      | s1 = bb6 ]
      
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap usize isize> {h1}
          (fun (_ret':borrowed (MyHashMap'0.t_myhashmap usize isize)) ->  [ &_12 <- _ret' ]  [ &h1 <- _12.final ] s1)
      | s1 = add'0 {_12} {[%#shashmap6] (1 : usize)} {[%#shashmap7] (17 : isize)}
          (fun (_ret':()) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = get'0 {h1} {[%#shashmap8] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_x <- _13 ] s1
      | s1 = get'0 {h1} {[%#shashmap9] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 =  [ &_y <- _15 ] s1
      | s1 = get'0 {h2} {[%#shashmap10] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0
      [ s0 =  [ &_z <- _17 ] s1
      | s1 = get'0 {h2} {[%#shashmap11] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 =  [ &_t <- _19 ] s1
      | s1 = Borrow.borrow_mut <MyHashMap'0.t_myhashmap usize isize> {h2}
          (fun (_ret':borrowed (MyHashMap'0.t_myhashmap usize isize)) ->  [ &_22 <- _ret' ]  [ &h2 <- _22.final ] s2)
      | s2 = add'0 {_22} {[%#shashmap12] (1 : usize)} {[%#shashmap13] (42 : isize)}
          (fun (_ret':()) ->  [ &_21 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = get'0 {h1} {[%#shashmap14] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 =  [ &_x <- _23 ] s1
      | s1 = get'0 {h1} {[%#shashmap15] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 =  [ &_y <- _25 ] s1
      | s1 = get'0 {h2} {[%#shashmap16] (1 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_z <- _27 ] s1
      | s1 = get'0 {h2} {[%#shashmap17] (2 : usize)} (fun (_ret':Option'0.t_option isize) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = s0 [ s0 =  [ &_t <- _29 ] s1 | s1 = bb17 ] 
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & h1 : MyHashMap'0.t_myhashmap usize isize = any_l ()
    | & h2 : MyHashMap'0.t_myhashmap usize isize = any_l ()
    | & _x : Option'0.t_option isize = any_l ()
    | & _y : Option'0.t_option isize = any_l ()
    | & _z : Option'0.t_option isize = any_l ()
    | & _t : Option'0.t_option isize = any_l ()
    | & _11 : () = any_l ()
    | & _12 : borrowed (MyHashMap'0.t_myhashmap usize isize) = any_l ()
    | & _13 : Option'0.t_option isize = any_l ()
    | & _15 : Option'0.t_option isize = any_l ()
    | & _17 : Option'0.t_option isize = any_l ()
    | & _19 : Option'0.t_option isize = any_l ()
    | & _21 : () = any_l ()
    | & _22 : borrowed (MyHashMap'0.t_myhashmap usize isize) = any_l ()
    | & _23 : Option'0.t_option isize = any_l ()
    | & _25 : Option'0.t_option isize = any_l ()
    | & _27 : Option'0.t_option isize = any_l ()
    | & _29 : Option'0.t_option isize = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Hashmap_Impl0
  type t
  
  let%span shashmap0 = "../hashmap.rs" 16 4 16 27
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  use Hashmap_List_Type as List'0
  
  predicate invariant'1 (self : List'0.t_list t) =
    [%#span1] true
  
  predicate inv'1 (_x : List'0.t_list t)
  
  axiom inv'1 : forall x : List'0.t_list t . inv'1 x = true
  
  predicate invariant'0 (self : List'0.t_list t) =
    [%#span1] true
  
  predicate inv'0 (_x : List'0.t_list t)
  
  axiom inv'0 : forall x : List'0.t_list t . inv'0 x = true
  
  use prelude.prelude.Borrow
  
  goal clone'_refn : [%#shashmap0] forall self : List'0.t_list t . inv'0 self
   -> inv'0 self /\ (forall result : List'0.t_list t . inv'1 result /\ result = self  -> inv'1 result /\ result = self)
end
module Hashmap_Impl2
  let%span shashmap0 = "../hashmap.rs" 59 4 59 25
  
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span2 = "../hashmap.rs" 65 20 65 21
  
  let%span span3 = "../../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  
  let%span span4 = "../../../../creusot-contracts/src/model.rs" 81 8 81 28
  
  use prelude.prelude.UIntSize
  
  predicate invariant'0 (self : usize) =
    [%#span1] true
  
  predicate inv'0 (_x : usize)
  
  axiom inv'0 : forall x : usize . inv'0 x = true
  
  use prelude.prelude.Int
  
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [%#span2] x
  
  use prelude.prelude.UIntSize
  
  function deep_model'1 (self : usize) : int =
    [%#span3] UIntSize.to_int self
  
  use prelude.prelude.Int
  
  use prelude.prelude.Borrow
  
  function deep_model'0 (self : usize) : int =
    [%#span4] deep_model'1 self
  
  use prelude.prelude.UInt64
  
  use prelude.prelude.UInt64
  
  goal hash_refn : [%#shashmap0] forall self : usize . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (deep_model'0 self)
   -> UInt64.to_int result = hash_log'0 (deep_model'0 self))
end
module Hashmap_Impl3
  type k
  
  type v
end
