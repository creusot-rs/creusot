
module Hashmap_List_Type
  type t_list 't =
    | C_Nil
    | C_Cons 't (t_list 't)
    
  function any_l (_ : 'b) : 'a
  let rec nil < 't > (input:t_list 't) (ret  )= any
    [ good -> {C_Nil  = input} (! ret) | bad -> {C_Nil  <> input} {false} any ]
    
  let rec cons < 't > (input:t_list 't) (ret  (field_0:'t) (field_1:t_list 't))= any
    [ good (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:'t) (field_1:t_list 't)-> {C_Cons field_0 field_1 <> input} {false} any ]
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  function any_l (_ : 'b) : 'a
  let rec none < 't > (input:t_option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  let rec some < 't > (input:t_option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module Hashmap_Impl2_Hash
  use prelude.Int
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [#"../hashmap.rs" 65 20 65 21] x
  let rec hash_log'0 (x:int) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  use prelude.UIntSize
  use prelude.UIntSize
  function eq_model'1 (self : usize) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  let rec eq_model'1 (self:usize) (return'  (ret:int))= any
    [ return' (result:int)-> {result = eq_model'1 self} (! return' {result}) ]
    
  use prelude.Int
  use prelude.Borrow
  function eq_model'0 (self : usize) : int =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'1 self
  let rec eq_model'0 (self:usize) (return'  (ret:int))= any
    [ return' (result:int)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.Intrinsic
  use prelude.UInt64
  let rec hash (self:usize) (return'  (ret:uint64))= (! bb0
    [ bb0 = s0
      [ s0 = UInt64.of_int {UIntSize.to_int self} (fun (_res:uint64) ->  [ &_0 <- _res ] s1) | s1 = return' {_0} ]
       ]
    ) [ & _0 : uint64 = any_l () : uint64 | & self : usize = self ] 
    [ return' (result:uint64)-> {[@expl:postcondition] [#"../hashmap.rs" 58 14 58 56] UInt64.to_int result
      = hash_log'0 (eq_model'0 self)}
      (! return' {result}) ]
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
  function any_l (_ : 'b) : 'a
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
  function any_l (_ : 'b) : 'a
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
  function any_l (_ : 'b) : 'a
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't))= any
    [ good (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (_marker:Core_Marker_PhantomData_Type.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_RawVec_Cap_Type
  use prelude.UIntSize
  use prelude.Int
  type t_cap  =
    | C_Cap usize
    
  function any_l (_ : 'b) : 'a
  let rec t_cap (input:t_cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module Alloc_RawVec_RawVec_Type
  use Alloc_RawVec_Cap_Type as Alloc_RawVec_Cap_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) (Alloc_RawVec_Cap_Type.t_cap) 'a
    
  function any_l (_ : 'b) : 'a
  let rec t_rawvec < 't > < 'a > (input:t_rawvec 't 'a) (ret  (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a))= any
    [ good (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc
      = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Core_Ptr_Unique_Unique_Type.t_unique 't) (cap:Alloc_RawVec_Cap_Type.t_cap) (alloc:'a)-> {C_RawVec ptr cap alloc
      <> input}
      {false}
      any ]
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
  function any_l (_ : 'b) : 'a
  let rec t_vec < 't > < 'a > (input:t_vec 't 'a) (ret  (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize))= any
    [ good (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
  function any_l (_ : 'b) : 'a
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module Hashmap_MyHashMap_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Hashmap_List_Type as Hashmap_List_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_myhashmap 'k 'v =
    | C_MyHashMap (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list ('k, 'v)) (Alloc_Alloc_Global_Type.t_global))
    
  function any_l (_ : 'b) : 'a
  let rec t_myhashmap < 'k > < 'v > (input:t_myhashmap 'k 'v) (ret  (buckets:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list ('k, 'v)) (Alloc_Alloc_Global_Type.t_global)))= any
    [ good (buckets:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list ('k, 'v)) (Alloc_Alloc_Global_Type.t_global))-> {C_MyHashMap buckets
      = input}
      (! ret {buckets})
    | bad (buckets:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list ('k, 'v)) (Alloc_Alloc_Global_Type.t_global))-> {C_MyHashMap buckets
      <> input}
      {false}
      any ]
    
  function myhashmap_buckets (self : t_myhashmap 'k 'v) : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list ('k, 'v)) (Alloc_Alloc_Global_Type.t_global)
    
   =
    match self with
      | C_MyHashMap a -> a
      end
end
module Hashmap_Impl5_New
  type k
  type v
  predicate invariant'5 (self : v)
  let rec invariant'5 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : v)
  let rec inv'5 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ] 
  axiom inv'5 : forall x : v . inv'5 x = true
  use Hashmap_List_Type as Hashmap_List_Type
  use seq.Seq
  predicate invariant'4 (self : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'4 (self:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec inv'4 (_x:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Seq.seq (Hashmap_List_Type.t_list (k, v)) . inv'4 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'3 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'3 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  function view'1 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
  let rec view'1 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'3 self}
    any [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'1 self} (! return' {result}) ] 
  axiom view'1_spec : forall self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'3 self)
   -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] inv'4 (view'1 self))
  && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (view'1 self)
  <= UIntSize.to_int (max'0 : usize))
  predicate invariant'3 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv'4 (view'1 self)
  let rec invariant'3 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  axiom inv'3 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'3 x
  = true
  predicate invariant'2 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'2 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'2 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Hashmap_List_Type.t_list (k, v) . inv'2 x = true
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  predicate invariant'1 (self : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec invariant'1 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec inv'1 (_x:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Hashmap_MyHashMap_Type.t_myhashmap k v . inv'1 x = true
  type eq_model_ty'0
  predicate invariant'0 (self : eq_model_ty'0)
  let rec invariant'0 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : eq_model_ty'0)
  let rec inv'0 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : eq_model_ty'0 . inv'0 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use prelude.Mapping
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function get'0 [#"../hashmap.rs" 28 4 28 54] (self : Hashmap_List_Type.t_list (k, v)) (index : eq_model_ty'0) : Core_Option_Option_Type.t_option v
    
   =
    [#"../hashmap.rs" 30 12 33 13] match self with
      | Hashmap_List_Type.C_Nil -> Core_Option_Option_Type.C_None
      | Hashmap_List_Type.C_Cons (k, v) tl -> if eq_model'0 k = index then
        Core_Option_Option_Type.C_Some v
      else
        get'0 tl index
      
      end
  let rec get'0 (self:Hashmap_List_Type.t_list (k, v)) (index:eq_model_ty'0) (return'  (ret:Core_Option_Option_Type.t_option v))= any
    [ return' (result:Core_Option_Option_Type.t_option v)-> {result = get'0 self index} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix : int) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (view'1 self) ix
  let rec index_logic'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix:int) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use int.EuclideanDivision
  function hash_log'0 [#"../hashmap.rs" 54 4 54 43] (_1 : eq_model_ty'0) : int
  let rec hash_log'0 (_1:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 _1} (! return' {result}) ]
    
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 46] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : int
    
   =
    [#"../hashmap.rs" 90 20 90 66] EuclideanDivision.mod (hash_log'0 k) (Seq.length (view'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  let rec bucket_ix'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = bucket_ix'0 self k} (! return' {result}) ]
    
  function bucket'0 [#"../hashmap.rs" 84 4 84 52] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../hashmap.rs" 85 8 85 53] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  let rec bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = bucket'0 self k} (! return' {result}) ]
    
  use map.Map
  function view'0 [#"../hashmap.rs" 78 4 78 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../hashmap.rs" 79 20 79 45] Mapping.from_fn (fun (k : eq_model_ty'0) -> get'0 (bucket'0 self k) k)
  let rec view'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : Hashmap_List_Type.t_list (k, v)) =
    [#"../hashmap.rs" 40 12 43 13] match self with
      | Hashmap_List_Type.C_Nil -> true
      | Hashmap_List_Type.C_Cons (k, _) tl -> get'0 tl (eq_model'0 k) = Core_Option_Option_Type.C_None
      /\ no_double_binding'0 tl
      end
  let rec no_double_binding'0 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = no_double_binding'0 self} (! return' {result}) ]
    
  predicate good_bucket'0 [#"../hashmap.rs" 200 4 200 57] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (l : Hashmap_List_Type.t_list (k, v)) (h : int)
    
   =
    [#"../hashmap.rs" 201 8 203 9] forall v : v . forall k : eq_model_ty'0 . inv'5 v
     -> inv'0 k  -> get'0 l k = Core_Option_Option_Type.C_Some v  -> bucket_ix'0 self k = h
  let rec good_bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (l:Hashmap_List_Type.t_list (k, v)) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = good_bucket'0 self l h} (! return' {result}) ]
    
  use prelude.Borrow
  predicate hashmap_inv'0 [#"../hashmap.rs" 209 4 209 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) =
    [#"../hashmap.rs" 210 8 213 9] 0 < Seq.length (view'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (view'1 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  let rec hashmap_inv'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = hashmap_inv'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  let rec from_elem'0 (elem:Hashmap_List_Type.t_list (k, v)) (n:usize) (return'  (ret:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)))= {[@expl:precondition] inv'2 elem}
    any
    [ return' (result:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))-> {inv'3 result}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 175 12 175 78] forall i : int . 0 <= i /\ i < UIntSize.to_int n
       -> index_logic'0 result i = elem}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 174 22 174 41] Seq.length (view'1 result) = UIntSize.to_int n}
      (! return' {result}) ]
    
  let rec new (size:usize) (return'  (ret:Hashmap_MyHashMap_Type.t_myhashmap k v))= {[#"../hashmap.rs" 95 15 95 24] 0
    < UIntSize.to_int size}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- Hashmap_List_Type.C_Nil : Hashmap_List_Type.t_list (k, v) ] s1
      | s1 = from_elem'0 {_7} {size}
          (fun (_ret':Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
             [ &_6 <- _ret' ] 
            s2)
      | s2 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &res <- Hashmap_MyHashMap_Type.C_MyHashMap _6 : Hashmap_MyHashMap_Type.t_myhashmap k v ] 
        (any
        [ any_ (_any:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))-> (! 
          [ &_6 <- _any ]
          
          s1) ]
        )
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 =  [ &_0 <- res ] (any [ any_ (_any:Hashmap_MyHashMap_Type.t_myhashmap k v)-> (!  [ &res <- _any ] s1) ] )
      | s1 = bb3 ]
      
    | bb3 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Hashmap_MyHashMap_Type.t_myhashmap k v = any_l () : Hashmap_MyHashMap_Type.t_myhashmap k v
    | & size : usize = size
    | & res : Hashmap_MyHashMap_Type.t_myhashmap k v = any_l () : Hashmap_MyHashMap_Type.t_myhashmap k v
    | & _6 : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) = any_l () : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)
    | & _7 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v) ]
    
    [ return' (result:Hashmap_MyHashMap_Type.t_myhashmap k v)-> {[@expl:postcondition] [#"../hashmap.rs" 98 31 98 46] inv'1 result}
      {[@expl:postcondition] [#"../hashmap.rs" 97 4 97 62] forall i : eq_model_ty'0 . inv'0 i
       -> Map.get (view'0 result) i = Core_Option_Option_Type.C_None}
      {[@expl:postcondition] [#"../hashmap.rs" 96 14 96 34] hashmap_inv'0 result}
      (! return' {result}) ]
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
  function any_l (_ : 'b) : 'a
end
module Hashmap_Impl5_Add
  type k
  type v
  use Hashmap_List_Type as Hashmap_List_Type
  use seq.Seq
  predicate invariant'17 (self : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'17 (self:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'17 self} (! return' {result}) ]
    
  predicate inv'17 (_x : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec inv'17 (_x:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'17 _x} (! return' {result}) ]
    
  axiom inv'17 : forall x : Seq.seq (Hashmap_List_Type.t_list (k, v)) . inv'17 x = true
  use prelude.UIntSize
  predicate invariant'16 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'16 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'16 self} (! return' {result}) ]
    
  predicate inv'16 (_x : usize)
  let rec inv'16 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'16 _x} (! return' {result}) ]
    
  axiom inv'16 : forall x : usize . inv'16 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Borrow
  predicate invariant'15 (self : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)))
    
  let rec invariant'15 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'15 self} (! return' {result}) ]
    
  predicate inv'15 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)))
    
  let rec inv'15 (_x:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'15 _x} (! return' {result}) ]
    
  axiom inv'15 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) . inv'15 x
  = true
  predicate invariant'14 (self : k)
  let rec invariant'14 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'14 self} (! return' {result}) ]
    
  predicate inv'14 (_x : k)
  let rec inv'14 (_x:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'14 _x} (! return' {result}) ]
    
  axiom inv'14 : forall x : k . inv'14 x = true
  predicate invariant'13 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
  let rec invariant'13 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'13 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'13 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'13 x
  = true
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  predicate invariant'12 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
  let rec invariant'12 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
  let rec inv'12 (_x:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) . inv'12 x = true
  predicate invariant'11 (self : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'11 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec inv'11 (_x:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : borrowed (Hashmap_List_Type.t_list (k, v)) . inv'11 x = true
  predicate invariant'10 (self : borrowed k)
  let rec invariant'10 (self:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : borrowed k)
  let rec inv'10 (_x:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : borrowed k . inv'10 x = true
  predicate invariant'9 (self : borrowed v)
  let rec invariant'9 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : borrowed v)
  let rec inv'9 (_x:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : borrowed v . inv'9 x = true
  predicate invariant'8 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'8 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'8 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Hashmap_List_Type.t_list (k, v) . inv'8 x = true
  predicate invariant'7 (self : v)
  let rec invariant'7 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : v)
  let rec inv'7 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ] 
  axiom inv'7 : forall x : v . inv'7 x = true
  predicate invariant'6 (self : k)
  let rec invariant'6 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : k)
  let rec inv'6 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ] 
  axiom inv'6 : forall x : k . inv'6 x = true
  type eq_model_ty'0
  predicate invariant'5 (self : eq_model_ty'0)
  let rec invariant'5 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : eq_model_ty'0)
  let rec inv'5 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : eq_model_ty'0 . inv'5 x = true
  use prelude.Snapshot
  predicate invariant'4 (self : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v))))
  let rec invariant'4 (self:Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v)))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v))))
  let rec inv'4 (_x:Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v)))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v))) . inv'4 x = true
  predicate invariant'3 (self : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'3 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec inv'3 (_x:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : borrowed (Hashmap_List_Type.t_list (k, v)) . inv'3 x = true
  predicate invariant'2 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'2 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'2 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Hashmap_List_Type.t_list (k, v) . inv'2 x = true
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'1 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'1 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  function view'4 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
  let rec view'4 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'1 self}
    any [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'4 self} (! return' {result}) ] 
  axiom view'4_spec : forall self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'1 self)
   -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] inv'17 (view'4 self))
  && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (view'4 self)
  <= UIntSize.to_int (max'0 : usize))
  predicate invariant'1 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv'17 (view'4 self)
  let rec invariant'1 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  axiom inv'1 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'1 x
  = true
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec invariant'0 (self:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) . inv'0 x = true
  use prelude.Mapping
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get'0 [#"../hashmap.rs" 28 4 28 54] (self : Hashmap_List_Type.t_list (k, v)) (index : eq_model_ty'0) : Core_Option_Option_Type.t_option v
    
   =
    [#"../hashmap.rs" 30 12 33 13] match self with
      | Hashmap_List_Type.C_Nil -> Core_Option_Option_Type.C_None
      | Hashmap_List_Type.C_Cons (k, v) tl -> if eq_model'0 k = index then
        Core_Option_Option_Type.C_Some v
      else
        get'0 tl index
      
      end
  let rec get'0 (self:Hashmap_List_Type.t_list (k, v)) (index:eq_model_ty'0) (return'  (ret:Core_Option_Option_Type.t_option v))= any
    [ return' (result:Core_Option_Option_Type.t_option v)-> {result = get'0 self index} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix : int) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (view'4 self) ix
  let rec index_logic'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix:int) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use int.EuclideanDivision
  function hash_log'0 [#"../hashmap.rs" 54 4 54 43] (_1 : eq_model_ty'0) : int
  let rec hash_log'0 (_1:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 _1} (! return' {result}) ]
    
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 46] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : int
    
   =
    [#"../hashmap.rs" 90 20 90 66] EuclideanDivision.mod (hash_log'0 k) (Seq.length (view'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  let rec bucket_ix'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = bucket_ix'0 self k} (! return' {result}) ]
    
  function bucket'0 [#"../hashmap.rs" 84 4 84 52] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../hashmap.rs" 85 8 85 53] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  let rec bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = bucket'0 self k} (! return' {result}) ]
    
  use map.Map
  function view'0 [#"../hashmap.rs" 78 4 78 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../hashmap.rs" 79 20 79 45] Mapping.from_fn (fun (k : eq_model_ty'0) -> get'0 (bucket'0 self k) k)
  let rec view'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  function view'1 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'0 ( * self)
  let rec view'1 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  use map.Map
  use prelude.Intrinsic
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : Hashmap_List_Type.t_list (k, v)) =
    [#"../hashmap.rs" 40 12 43 13] match self with
      | Hashmap_List_Type.C_Nil -> true
      | Hashmap_List_Type.C_Cons (k, _) tl -> get'0 tl (eq_model'0 k) = Core_Option_Option_Type.C_None
      /\ no_double_binding'0 tl
      end
  let rec no_double_binding'0 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = no_double_binding'0 self} (! return' {result}) ]
    
  predicate good_bucket'0 [#"../hashmap.rs" 200 4 200 57] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (l : Hashmap_List_Type.t_list (k, v)) (h : int)
    
   =
    [#"../hashmap.rs" 201 8 203 9] forall v : v . forall k : eq_model_ty'0 . inv'7 v
     -> inv'5 k  -> get'0 l k = Core_Option_Option_Type.C_Some v  -> bucket_ix'0 self k = h
  let rec good_bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (l:Hashmap_List_Type.t_list (k, v)) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = good_bucket'0 self l h} (! return' {result}) ]
    
  predicate hashmap_inv'0 [#"../hashmap.rs" 209 4 209 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) =
    [#"../hashmap.rs" 210 8 213 9] 0 < Seq.length (view'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (view'4 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  let rec hashmap_inv'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = hashmap_inv'0 self} (! return' {result}) ]
    
  predicate resolve'9 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'9 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'9 self} (! return' {result}) ]
    
  predicate resolve'8 (self : Hashmap_List_Type.t_list (k, v))
  let rec resolve'8 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'8 self} (! return' {result}) ]
    
  predicate resolve'7 (self : v)
  let rec resolve'7 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'7 self} (! return' {result}) ]
    
  predicate resolve'6 (self : k)
  let rec resolve'6 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'5 (self : borrowed (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'5 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  predicate resolve'4 (self : borrowed k) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'4 (self:borrowed k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'3 (self : borrowed v) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'3 (self:borrowed v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  function eq_model'1 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'0 self
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] inv'14 other}
    {[@expl:precondition] inv'14 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 71] result
      = (eq_model'1 self = eq_model'1 other)}
      (! return' {result}) ]
    
  use prelude.Snapshot
  use prelude.Snapshot
  use prelude.Snapshot
  predicate resolve'2 (self : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v))))
  let rec resolve'2 (self:Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v)))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  use prelude.Snapshot
  predicate resolve'1 (self : borrowed (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Slice
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (Hashmap_List_Type.t_list (k, v))) (fin : Seq.seq (Hashmap_List_Type.t_list (k, v)))
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96] forall i : int . 0 <= i
    /\ i <> UIntSize.to_int self /\ i < Seq.length old'  -> Seq.get old' i = Seq.get fin i
  let rec resolve_elswhere'0 (self:usize) (old':Seq.seq (Hashmap_List_Type.t_list (k, v))) (fin:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve_elswhere'0 self old' fin} (! return' {result}) ]
    
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) (out : Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  let rec has_value'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (out:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_value'0 self seq out} (! return' {result}) ]
    
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  let rec in_bounds'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = in_bounds'0 self seq} (! return' {result}) ]
    
  function view'3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'4 ( * self)
  let rec view'3 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'3 self} (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (index:usize) (return'  (ret:borrowed (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] inv'16 index}
    {[@expl:precondition] inv'15 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46] in_bounds'0 index (view'3 self)}
    any
    [ return' (result:borrowed (Hashmap_List_Type.t_list (k, v)))-> {inv'3 result}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55] Seq.length (view'4 ( ^ self))
      = Seq.length (view'3 self)}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62] resolve_elswhere'0 index (view'3 self) (view'4 ( ^ self))}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57] has_value'0 index (view'4 ( ^ self)) ( ^ result)}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54] has_value'0 index (view'3 self) ( * result)}
      (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.UInt64
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [#"../hashmap.rs" 51 13 51 17] inv'14 self}
    any
    [ return' (result:uint64)-> {[#"../hashmap.rs" 50 14 50 56] UInt64.to_int result = hash_log'0 (eq_model'1 self)}
      (! return' {result}) ]
    
  function view'2 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'4 self
  let rec view'2 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'2 self} (! return' {result}) ]
    
  let rec len'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:usize))= {[@expl:precondition] inv'13 self}
    any
    [ return' (result:usize)-> {[#"../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48] UIntSize.to_int result
      = Seq.length (view'2 self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec resolve'0 (self:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  let rec add (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[#"../hashmap.rs" 106 34 106 37] inv'7 val'}
    {[#"../hashmap.rs" 106 26 106 29] inv'6 key}
    {[#"../hashmap.rs" 106 20 106 24] inv'12 self}
    {[#"../hashmap.rs" 103 15 103 36] hashmap_inv'0 ( * self)}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [#"../hashmap.rs" 108 23 108 41] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &length <- _ret' ] s3))
      | s3 = bb2 ]
      
    | bb2 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_13 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _13}
          (fun (_res:usize) ->  [ &_12 <- _res ] (any [ any_ (_any:uint64)-> (!  [ &_13 <- _any ] s1) ] ))
      | s1 =  [ &_15 <- length ] s2
      | s2 = UIntSize.eq {_15} {[#"../hashmap.rs" 110 27 110 55] (0 : usize)}
          (fun (_ret':bool) ->  [ &_16 <- _ret' ] s3)
      | s3 = {[@expl:remainder by zero] [#"../hashmap.rs" 110 27 110 55] not _16} s4
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 = UIntSize.rem {_12} {_15}
          (fun (_ret':usize) ->
             [ &index <- _ret' ] 
            (any
            [ any_ (_any:usize)-> (!  [ &_12 <- _any ] (any [ any_ (_any:usize)-> (!  [ &_15 <- _any ] s1) ] )) ]
            ))
      | s1 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
            Borrow.borrow_final
              <Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)>
              {rbuckets'0}
              {Borrow.inherit_id (Borrow.get_id self) 1}
              (fun (_ret':borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) ->
                 [ &_20 <- _ret' ] 
                Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
                  (fun (l_buckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
                    
                    [ &self <- { self with current = (Hashmap_MyHashMap_Type.C_MyHashMap ( ^ _20) : Hashmap_MyHashMap_Type.t_myhashmap k v) ; } ]
                    
                    s2)))
      | s2 = -{inv'1 ( ^ _20)}- s3
      | s3 = index_mut'0 {_20} {index} (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->  [ &_19 <- _ret' ] s4)
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> { * _19} {Borrow.get_id _19}
          (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
             [ &_18 <- _ret' ] 
             [ &_19 <- { _19 with current = ( ^ _18) ; } ] 
            s1)
      | s1 = -{inv'2 ( ^ _18)}- s2
      | s2 = Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> { * _18} {Borrow.get_id _18}
          (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
             [ &l <- _ret' ] 
             [ &_18 <- { _18 with current = ( ^ l) ; } ] 
            s3)
      | s3 = -{inv'2 ( ^ l)}- s4
      | s4 = {[@expl:type invariant] inv'3 _18} s5
      | s5 = -{resolve'1 _18}- s6
      | s6 =  [ &old_l <- [#"../hashmap.rs" 112 20 112 35] Snapshot.new l ] s7
      | s7 = bb6 ]
      
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv'4 old_l} s1 | s1 = -{resolve'2 old_l}- s2 | s2 = bb7 ] 
    | bb7 = bb7
      [ bb7 = {[@expl:loop invariant] [#"../hashmap.rs" 114 8 114 54] (forall i : eq_model_ty'0 . inv'5 i
         -> get'0 ( * l) i = get'0 ( ^ l) i \/ i = eq_model'0 key)
        /\ no_double_binding'0 ( ^ l)  -> no_double_binding'0 ( ^ Snapshot.inner old_l)}
        {[@expl:loop invariant] [#"../hashmap.rs" 118 20 118 44] no_double_binding'0 ( * l)}
        {[@expl:loop invariant] [#"../hashmap.rs" 114 8 114 54] forall i : eq_model_ty'0 . inv'5 i
         -> get'0 ( ^ l) i = get'0 ( * l) i  -> get'0 ( ^ Snapshot.inner old_l) i = get'0 ( * Snapshot.inner old_l) i}
        {[@expl:loop invariant] [#"../hashmap.rs" 114 8 114 54] get'0 ( ^ l) (eq_model'0 key)
        = Core_Option_Option_Type.C_Some val'
         -> get'0 ( ^ Snapshot.inner old_l) (eq_model'0 key) = Core_Option_Option_Type.C_Some val'}
        {[@expl:loop invariant] [#"../hashmap.rs" 114 8 114 54] good_bucket'0 ( * Snapshot.inner old_self) ( ^ l) (UIntSize.to_int index)
         -> good_bucket'0 ( * Snapshot.inner old_self) ( ^ Snapshot.inner old_l) (UIntSize.to_int index)}
        {[@expl:loop invariant] [#"../hashmap.rs" 114 20 114 52] good_bucket'0 ( * Snapshot.inner old_self) ( * l) (UIntSize.to_int index)}
        (! s0) [ s0 = bb8 ] 
        [ bb8 = s0
          [ s0 = any
            [ br0 -> { * l = Hashmap_List_Type.C_Nil } (! bb14)
            | br1 (a:(k, v)) (b:Hashmap_List_Type.t_list (k, v))-> { * l = Hashmap_List_Type.C_Cons a b} (! bb9) ]
             ]
          
        | bb9 = s0 [ s0 = bb10 ] 
        | bb10 = s0
          [ s0 = Hashmap_List_Type.cons <(k, v)> { * l}
              (fun (r0'0:(k, v)) (r1'0:Hashmap_List_Type.t_list (k, v)) ->
                Borrow.borrow_final
                  <k>
                  {let (r'0, _) = r0'0 in r'0}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id l) 1) 1}
                  (fun (_ret':borrowed k) ->
                     [ &k <- _ret' ] 
                    Hashmap_List_Type.cons <(k, v)> { * l}
                      (fun (l_0'0:(k, v)) (l_1'0:Hashmap_List_Type.t_list (k, v)) ->
                        
                        [ &l <- { l with current = (Hashmap_List_Type.C_Cons (let (_, l'2) = l_0'0 in ( ^ k, l'2)) l_1'0 : Hashmap_List_Type.t_list (k, v)) ; } ]
                        
                        s1)))
          | s1 = -{inv'6 ( ^ k)}- s2
          | s2 = Hashmap_List_Type.cons <(k, v)> { * l}
              (fun (r0'1:(k, v)) (r1'1:Hashmap_List_Type.t_list (k, v)) ->
                Borrow.borrow_final
                  <v>
                  {let (_, r'1) = r0'1 in r'1}
                  {Borrow.inherit_id (Borrow.inherit_id (Borrow.get_id l) 1) 2}
                  (fun (_ret':borrowed v) ->
                     [ &v <- _ret' ] 
                    Hashmap_List_Type.cons <(k, v)> { * l}
                      (fun (l_0'1:(k, v)) (l_1'1:Hashmap_List_Type.t_list (k, v)) ->
                        
                        [ &l <- { l with current = (Hashmap_List_Type.C_Cons (let (l'4, _) = l_0'1 in (l'4,  ^ v)) l_1'1 : Hashmap_List_Type.t_list (k, v)) ; } ]
                        
                        s3)))
          | s3 = -{inv'7 ( ^ v)}- s4
          | s4 = Hashmap_List_Type.cons <(k, v)> { * l}
              (fun (r0'2:(k, v)) (r1'2:Hashmap_List_Type.t_list (k, v)) ->
                Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> {r1'2} {Borrow.inherit_id (Borrow.get_id l) 2}
                  (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
                     [ &tl <- _ret' ] 
                    Hashmap_List_Type.cons <(k, v)> { * l}
                      (fun (l_0'2:(k, v)) (l_1'2:Hashmap_List_Type.t_list (k, v)) ->
                        
                        [ &l <- { l with current = (Hashmap_List_Type.C_Cons l_0'2 ( ^ tl) : Hashmap_List_Type.t_list (k, v)) ; } ]
                        
                        s5)))
          | s5 = -{inv'8 ( ^ tl)}- s6
          | s6 =  [ &tl1 <- tl ] 
            (any [ any_ (_any:borrowed (Hashmap_List_Type.t_list (k, v)))-> (!  [ &tl <- _any ] s7) ] )
          | s7 = eq'0 { * k} {key} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s8)
          | s8 = bb11 ]
          
        | bb11 = s0 [ s0 = any [ br0 -> {_38 = false} (! bb13) | br1 -> {_38} (! bb12) ]  ] 
        | bb13 = s0
          [ s0 = {[@expl:type invariant] inv'9 v} s1
          | s1 = -{resolve'3 v}- s2
          | s2 = {[@expl:type invariant] inv'10 k} s3
          | s3 = -{resolve'4 k}- s4
          | s4 = Borrow.borrow_mut <Hashmap_List_Type.t_list (k, v)> { * tl1}
              (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
                 [ &_46 <- _ret' ] 
                 [ &tl1 <- { tl1 with current = ( ^ _46) ; } ] 
                s5)
          | s5 = -{inv'2 ( ^ _46)}- s6
          | s6 = Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> { * _46} {Borrow.get_id _46}
              (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
                 [ &_45 <- _ret' ] 
                 [ &_46 <- { _46 with current = ( ^ _45) ; } ] 
                s7)
          | s7 = -{inv'2 ( ^ _45)}- s8
          | s8 = {[@expl:type invariant] inv'3 l} s9
          | s9 = -{resolve'1 l}- s10
          | s10 =  [ &l <- _45 ] 
            (any [ any_ (_any:borrowed (Hashmap_List_Type.t_list (k, v)))-> (!  [ &_45 <- _any ] s11) ] )
          | s11 = {[@expl:type invariant] inv'3 _46} s12
          | s12 = -{resolve'1 _46}- s13
          | s13 = {[@expl:type invariant] inv'11 tl1} s14
          | s14 = -{resolve'5 tl1}- s15
          | s15 = bb7 ]
           ]
         ]
      
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'6 key} s1
      | s1 = -{resolve'6 key}- s2
      | s2 = {[@expl:type invariant] inv'7 val'} s3
      | s3 = -{resolve'7 val'}- s4
      | s4 =  [ &_51 <- (key, val') ] s5
      | s5 =  [ &_55 <- Hashmap_List_Type.C_Nil : Hashmap_List_Type.t_list (k, v) ] s6
      | s6 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_50 <- Hashmap_List_Type.C_Cons _51 _55 : Hashmap_List_Type.t_list (k, v) ] 
        (any
        [ any_ (_any:(k, v))-> (!  [ &_51 <- _any ] 
          (any [ any_ (_any:Hashmap_List_Type.t_list (k, v))-> (!  [ &_55 <- _any ] s1) ] )) ]
        )
      | s1 = bb16 ]
      
    | bb16 = s0 [ s0 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &l <- { l with current = _50 ; } ] 
        (any [ any_ (_any:Hashmap_List_Type.t_list (k, v))-> (!  [ &_50 <- _any ] s1) ] )
      | s1 = {[@expl:type invariant] inv'2 ( * l)} s2
      | s2 = -{resolve'8 ( * l)}- s3
      | s3 = {[@expl:type invariant] inv'3 l} s4
      | s4 = -{resolve'1 l}- s5
      | s5 = bb19 ]
      
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'3 _19} s1
      | s1 = -{resolve'1 _19}- s2
      | s2 = {[@expl:type invariant] inv'12 self} s3
      | s3 = -{resolve'9 self}- s4
      | s4 = {[@expl:assertion] [#"../hashmap.rs" 133 24 133 44] hashmap_inv'0 ( * self)} s5
      | s5 =  [ &_0 <- [#"../hashmap.rs" 106 42 134 5] () ] s6
      | s6 = bb20 ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'11 tl1} s1
      | s1 = -{resolve'5 tl1}- s2
      | s2 = {[@expl:type invariant] inv'10 k} s3
      | s3 = -{resolve'4 k}- s4
      | s4 = {[@expl:type invariant] inv'6 key} s5
      | s5 = -{resolve'6 key}- s6
      | s6 = {[@expl:type invariant] inv'7 val'} s7
      | s7 = -{resolve'7 val'}- s8
      | s8 =  [ &v <- { v with current = val' ; } ] s9
      | s9 = {[@expl:type invariant] inv'7 ( * v)} s10
      | s10 = -{resolve'7 ( * v)}- s11
      | s11 = {[@expl:type invariant] inv'9 v} s12
      | s12 = -{resolve'3 v}- s13
      | s13 = {[@expl:type invariant] inv'3 _19} s14
      | s14 = -{resolve'1 _19}- s15
      | s15 = {[@expl:type invariant] inv'3 l} s16
      | s16 = -{resolve'1 l}- s17
      | s17 = {[@expl:type invariant] inv'12 self} s18
      | s18 = -{resolve'9 self}- s19
      | s19 = {[@expl:assertion] [#"../hashmap.rs" 125 32 125 52] hashmap_inv'0 ( * self)} s20
      | s20 =  [ &_0 <- [#"../hashmap.rs" 126 16 126 22] () ] s21
      | s21 = bb20 ]
      
    | bb20 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) = self
    | & key : k = key
    | & val' : v = val'
    | & old_self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) = any_l () : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
    | & length : usize = any_l () : usize
    | & index : usize = any_l () : usize
    | & _12 : usize = any_l () : usize
    | & _13 : uint64 = any_l () : uint64
    | & _15 : usize = any_l () : usize
    | & _16 : bool = any_l () : bool
    | & l : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _18 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _19 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _20 : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) = any_l () : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    | & old_l : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v))) = any_l () : Snapshot.snap_ty (borrowed (Hashmap_List_Type.t_list (k, v)))
    | & k : borrowed k = any_l () : borrowed k
    | & v : borrowed v = any_l () : borrowed v
    | & tl : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & tl1 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _38 : bool = any_l () : bool
    | & _45 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _46 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _50 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & _51 : (k, v) = any_l () : (k, v)
    | & _55 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../hashmap.rs" 105 4 105 120] forall i : eq_model_ty'0 . inv'5 i
       -> Map.get (view'0 ( ^ self)) i
      = (if i = eq_model'0 key then Core_Option_Option_Type.C_Some val' else Map.get (view'1 self) i)}
      {[@expl:postcondition] [#"../hashmap.rs" 104 14 104 35] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Get
  type k
  type v
  type eq_model_ty'0
  predicate invariant'12 (self : eq_model_ty'0)
  let rec invariant'12 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : eq_model_ty'0)
  let rec inv'12 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : eq_model_ty'0 . inv'12 x = true
  predicate invariant'11 (self : v)
  let rec invariant'11 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : v)
  let rec inv'11 (_x:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : v . inv'11 x = true
  use Hashmap_List_Type as Hashmap_List_Type
  use seq.Seq
  predicate invariant'10 (self : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'10 (self:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec inv'10 (_x:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : Seq.seq (Hashmap_List_Type.t_list (k, v)) . inv'10 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'9 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'9 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  function view'2 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
  let rec view'2 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'9 self}
    any [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'2 self} (! return' {result}) ] 
  axiom view'2_spec : forall self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'9 self)
   -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] inv'10 (view'2 self))
  && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (view'2 self)
  <= UIntSize.to_int (max'0 : usize))
  predicate invariant'9 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv'10 (view'2 self)
  let rec invariant'9 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  axiom inv'9 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'9 x
  = true
  predicate invariant'8 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'8 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : usize)
  let rec inv'8 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : usize . inv'8 x = true
  predicate invariant'7 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
  let rec invariant'7 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'7 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  axiom inv'7 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'7 x
  = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'6 (self : Core_Option_Option_Type.t_option v)
  let rec invariant'6 (self:Core_Option_Option_Type.t_option v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : Core_Option_Option_Type.t_option v)
  let rec inv'6 (_x:Core_Option_Option_Type.t_option v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : Core_Option_Option_Type.t_option v . inv'6 x = true
  predicate invariant'5 (self : k)
  let rec invariant'5 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : k)
  let rec inv'5 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ] 
  axiom inv'5 : forall x : k . inv'5 x = true
  predicate invariant'4 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'4 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'4 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Hashmap_List_Type.t_list (k, v) . inv'4 x = true
  predicate invariant'3 (self : v)
  let rec invariant'3 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : v)
  let rec inv'3 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ] 
  axiom inv'3 : forall x : v . inv'3 x = true
  predicate invariant'2 (self : k)
  let rec invariant'2 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : k)
  let rec inv'2 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ] 
  axiom inv'2 : forall x : k . inv'2 x = true
  predicate invariant'1 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'1 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'1 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Hashmap_List_Type.t_list (k, v) . inv'1 x = true
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  predicate invariant'0 (self : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec invariant'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec inv'0 (_x:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Hashmap_MyHashMap_Type.t_myhashmap k v . inv'0 x = true
  use map.Map
  use prelude.Mapping
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function get'0 [#"../hashmap.rs" 28 4 28 54] (self : Hashmap_List_Type.t_list (k, v)) (index : eq_model_ty'0) : Core_Option_Option_Type.t_option v
    
   =
    [#"../hashmap.rs" 30 12 33 13] match self with
      | Hashmap_List_Type.C_Nil -> Core_Option_Option_Type.C_None
      | Hashmap_List_Type.C_Cons (k, v) tl -> if eq_model'0 k = index then
        Core_Option_Option_Type.C_Some v
      else
        get'0 tl index
      
      end
  let rec get'0 (self:Hashmap_List_Type.t_list (k, v)) (index:eq_model_ty'0) (return'  (ret:Core_Option_Option_Type.t_option v))= any
    [ return' (result:Core_Option_Option_Type.t_option v)-> {result = get'0 self index} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix : int) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (view'2 self) ix
  let rec index_logic'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix:int) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use int.EuclideanDivision
  function hash_log'0 [#"../hashmap.rs" 54 4 54 43] (_1 : eq_model_ty'0) : int
  let rec hash_log'0 (_1:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 _1} (! return' {result}) ]
    
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 46] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : int
    
   =
    [#"../hashmap.rs" 90 20 90 66] EuclideanDivision.mod (hash_log'0 k) (Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  let rec bucket_ix'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = bucket_ix'0 self k} (! return' {result}) ]
    
  function bucket'0 [#"../hashmap.rs" 84 4 84 52] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../hashmap.rs" 85 8 85 53] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  let rec bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = bucket'0 self k} (! return' {result}) ]
    
  use map.Map
  function view'3 [#"../hashmap.rs" 78 4 78 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../hashmap.rs" 79 20 79 45] Mapping.from_fn (fun (k : eq_model_ty'0) -> get'0 (bucket'0 self k) k)
  let rec view'3 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'3 self}
      (! return' {result}) ]
    
  use prelude.Borrow
  function view'0 (self : Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'3 self
  let rec view'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : Hashmap_List_Type.t_list (k, v)) =
    [#"../hashmap.rs" 40 12 43 13] match self with
      | Hashmap_List_Type.C_Nil -> true
      | Hashmap_List_Type.C_Cons (k, _) tl -> get'0 tl (eq_model'0 k) = Core_Option_Option_Type.C_None
      /\ no_double_binding'0 tl
      end
  let rec no_double_binding'0 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = no_double_binding'0 self} (! return' {result}) ]
    
  predicate good_bucket'0 [#"../hashmap.rs" 200 4 200 57] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (l : Hashmap_List_Type.t_list (k, v)) (h : int)
    
   =
    [#"../hashmap.rs" 201 8 203 9] forall v : v . forall k : eq_model_ty'0 . inv'11 v
     -> inv'12 k  -> get'0 l k = Core_Option_Option_Type.C_Some v  -> bucket_ix'0 self k = h
  let rec good_bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (l:Hashmap_List_Type.t_list (k, v)) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = good_bucket'0 self l h} (! return' {result}) ]
    
  predicate hashmap_inv'0 [#"../hashmap.rs" 209 4 209 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) =
    [#"../hashmap.rs" 210 8 213 9] 0 < Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  let rec hashmap_inv'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = hashmap_inv'0 self} (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'5 (self : k)
  let rec resolve'5 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  predicate resolve'4 (self : Hashmap_List_Type.t_list (k, v))
  let rec resolve'4 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'3 (self : v)
  let rec resolve'3 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  function eq_model'1 (self : k) : eq_model_ty'0 =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'0 self
  let rec eq_model'1 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'1 self} (! return' {result}) ]
    
  let rec eq'0 (self:k) (other:k) (return'  (ret:bool))= {[@expl:precondition] inv'2 other}
    {[@expl:precondition] inv'2 self}
    any
    [ return' (result:bool)-> {[#"../../../../creusot-contracts/src/std/cmp.rs" 11 26 11 71] result
      = (eq_model'1 self = eq_model'1 other)}
      (! return' {result}) ]
    
  predicate resolve'2 (self : k)
  let rec resolve'2 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'1 (self : Hashmap_List_Type.t_list (k, v))
  let rec resolve'1 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  use prelude.Slice
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) (out : Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  let rec has_value'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (out:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_value'0 self seq out} (! return' {result}) ]
    
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  let rec in_bounds'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = in_bounds'0 self seq} (! return' {result}) ]
    
  function view'1 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'2 self
  let rec view'1 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'1 self} (! return' {result}) ]
    
  let rec index'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (index:usize) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= {[@expl:precondition] inv'8 index}
    {[@expl:precondition] inv'7 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46] in_bounds'0 index (view'1 self)}
    any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {inv'1 result}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54] has_value'0 index (view'1 self) result}
      (! return' {result}) ]
    
  predicate resolve'0 (self : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec resolve'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  let rec len'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:usize))= {[@expl:precondition] inv'7 self}
    any
    [ return' (result:usize)-> {[#"../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48] UIntSize.to_int result
      = Seq.length (view'1 self)}
      (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.UInt64
  let rec hash'0 (self:k) (return'  (ret:uint64))= {[@expl:precondition] [#"../hashmap.rs" 51 13 51 17] inv'2 self}
    any
    [ return' (result:uint64)-> {[#"../hashmap.rs" 50 14 50 56] UInt64.to_int result = hash_log'0 (eq_model'1 self)}
      (! return' {result}) ]
    
  let rec get (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (key:k) (return'  (ret:Core_Option_Option_Type.t_option v))= {[#"../hashmap.rs" 141 22 141 25] inv'5 key}
    {[#"../hashmap.rs" 141 16 141 20] inv'0 self}
    {[#"../hashmap.rs" 136 15 136 33] hashmap_inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash'0 {key} (fun (_ret':uint64) ->  [ &_8 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = UIntSize.of_int {UInt64.to_int _8}
          (fun (_res:usize) ->  [ &_7 <- _res ] (any [ any_ (_any:uint64)-> (!  [ &_8 <- _any ] s1) ] ))
      | s1 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s2))
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.eq {_10} {[#"../hashmap.rs" 142 27 142 67] (0 : usize)}
          (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1)
      | s1 = {[@expl:remainder by zero] [#"../hashmap.rs" 142 27 142 67] not _12} s2
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = UIntSize.rem {_7} {_10}
          (fun (_ret':usize) ->
             [ &index <- _ret' ] 
            (any [ any_ (_any:usize)-> (!  [ &_7 <- _any ] (any [ any_ (_any:usize)-> (!  [ &_10 <- _any ] s1) ] )) ] ))
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> {self}
          (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
            index'0 {rbuckets'0} {index} (fun (_ret':Hashmap_List_Type.t_list (k, v)) ->  [ &_14 <- _ret' ] s4))
      | s4 = bb4 ]
      
    | bb4 = s0
      [ s0 =  [ &l <- _14 ] s1 | s1 = {[@expl:type invariant] inv'1 _14} s2 | s2 = -{resolve'1 _14}- s3 | s3 = bb5 ]
      
    | bb5 = bb5
      [ bb5 = {[@expl:loop invariant] [#"../hashmap.rs" 145 20 145 95] get'0 (bucket'0 self (eq_model'0 key)) (eq_model'0 key)
        = get'0 l (eq_model'0 key)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = any
            [ br0 -> {l = Hashmap_List_Type.C_Nil } (! bb12)
            | br1 (a:(k, v)) (b:Hashmap_List_Type.t_list (k, v))-> {l = Hashmap_List_Type.C_Cons a b} (! bb7) ]
             ]
          
        | bb7 = s0 [ s0 = bb8 ] 
        | bb8 = s0
          [ s0 = Hashmap_List_Type.cons <(k, v)> {l}
              (fun (r0'0:(k, v)) (r1'0:Hashmap_List_Type.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
          | s1 = Hashmap_List_Type.cons <(k, v)> {l}
              (fun (r0'1:(k, v)) (r1'1:Hashmap_List_Type.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
          | s2 = Hashmap_List_Type.cons <(k, v)> {l}
              (fun (r0'2:(k, v)) (r1'2:Hashmap_List_Type.t_list (k, v)) ->  [ &tl <- r1'2 ] s3)
          | s3 = {[@expl:type invariant] inv'1 l} s4
          | s4 = -{resolve'1 l}- s5
          | s5 = {[@expl:type invariant] inv'2 k} s6
          | s6 = -{resolve'2 k}- s7
          | s7 = eq'0 {k} {key} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s8)
          | s8 = bb9 ]
          
        | bb9 = s0 [ s0 = any [ br0 -> {_25 = false} (! bb11) | br1 -> {_25} (! bb10) ]  ] 
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'3 v} s1
          | s1 = -{resolve'3 v}- s2
          | s2 =  [ &_31 <- tl ] s3
          | s3 = {[@expl:type invariant] inv'4 tl} s4
          | s4 = -{resolve'4 tl}- s5
          | s5 = {[@expl:type invariant] inv'1 _31} s6
          | s6 = -{resolve'1 _31}- s7
          | s7 =  [ &l <- _31 ] s8
          | s8 = bb5 ]
           ]
         ]
      
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'1 l} s1
      | s1 = -{resolve'1 l}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'5 key}- s4
      | s4 =  [ &_0 <- Core_Option_Option_Type.C_None : Core_Option_Option_Type.t_option v ] s5
      | s5 = bb13 ]
      
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'4 tl} s1
      | s1 = -{resolve'4 tl}- s2
      | s2 = {[@expl:type invariant] inv'5 key} s3
      | s3 = -{resolve'5 key}- s4
      | s4 = {[@expl:type invariant] inv'3 v} s5
      | s5 = -{resolve'3 v}- s6
      | s6 =  [ &_0 <- Core_Option_Option_Type.C_Some v : Core_Option_Option_Type.t_option v ] s7
      | s7 = bb13 ]
      
    | bb13 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : Core_Option_Option_Type.t_option v = any_l () : Core_Option_Option_Type.t_option v
    | & self : Hashmap_MyHashMap_Type.t_myhashmap k v = self
    | & key : k = key
    | & index : usize = any_l () : usize
    | & _7 : usize = any_l () : usize
    | & _8 : uint64 = any_l () : uint64
    | & _10 : usize = any_l () : usize
    | & _12 : bool = any_l () : bool
    | & l : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & _14 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & k : k = any_l () : k
    | & v : v = any_l () : v
    | & tl : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & _25 : bool = any_l () : bool
    | & _31 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v) ]
    
    [ return' (result:Core_Option_Option_Type.t_option v)-> {[@expl:postcondition] [#"../hashmap.rs" 141 33 141 43] inv'6 result}
      {[@expl:postcondition] [#"../hashmap.rs" 137 14 140 5] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (view'0 self) (eq_model'0 key) = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (view'0 self) (eq_model'0 key) = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
end
module Hashmap_Impl5_Resize
  type k
  type v
  use prelude.UIntSize
  predicate invariant'13 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'13 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'13 self} (! return' {result}) ]
    
  predicate inv'13 (_x : usize)
  let rec inv'13 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'13 _x} (! return' {result}) ]
    
  axiom inv'13 : forall x : usize . inv'13 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Hashmap_List_Type as Hashmap_List_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Borrow
  predicate invariant'12 (self : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)))
    
  let rec invariant'12 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'12 self} (! return' {result}) ]
    
  predicate inv'12 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)))
    
  let rec inv'12 (_x:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'12 _x} (! return' {result}) ]
    
  axiom inv'12 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) . inv'12 x
  = true
  use seq.Seq
  predicate invariant'11 (self : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'11 (self:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'11 self} (! return' {result}) ]
    
  predicate inv'11 (_x : Seq.seq (Hashmap_List_Type.t_list (k, v)))
  let rec inv'11 (_x:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'11 _x} (! return' {result}) ]
    
  axiom inv'11 : forall x : Seq.seq (Hashmap_List_Type.t_list (k, v)) . inv'11 x = true
  predicate invariant'10 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
  let rec invariant'10 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'10 self} (! return' {result}) ]
    
  predicate inv'10 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'10 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'10 _x} (! return' {result}) ]
    
  axiom inv'10 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'10 x
  = true
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  predicate invariant'9 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
  let rec invariant'9 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'9 self} (! return' {result}) ]
    
  predicate inv'9 (_x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
  let rec inv'9 (_x:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'9 _x} (! return' {result}) ]
    
  axiom inv'9 : forall x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) . inv'9 x = true
  predicate invariant'8 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'8 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'8 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Hashmap_List_Type.t_list (k, v) . inv'8 x = true
  predicate invariant'7 (self : v)
  let rec invariant'7 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  predicate inv'7 (_x : v)
  let rec inv'7 (_x:v) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ] 
  axiom inv'7 : forall x : v . inv'7 x = true
  predicate invariant'6 (self : k)
  let rec invariant'6 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : k)
  let rec inv'6 (_x:k) (return'  (ret:bool))= any [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ] 
  axiom inv'6 : forall x : k . inv'6 x = true
  predicate invariant'5 (self : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec invariant'5 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec inv'5 (_x:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : Hashmap_MyHashMap_Type.t_myhashmap k v . inv'5 x = true
  predicate invariant'4 (self : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec invariant'4 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : borrowed (Hashmap_List_Type.t_list (k, v)))
  let rec inv'4 (_x:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : borrowed (Hashmap_List_Type.t_list (k, v)) . inv'4 x = true
  predicate invariant'3 (self : Hashmap_List_Type.t_list (k, v))
  let rec invariant'3 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : Hashmap_List_Type.t_list (k, v))
  let rec inv'3 (_x:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : Hashmap_List_Type.t_list (k, v) . inv'3 x = true
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'2 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
  let rec inv'2 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  function view'2 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
  let rec view'2 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'2 self}
    any [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'2 self} (! return' {result}) ] 
  axiom view'2_spec : forall self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'2 self)
   -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] inv'11 (view'2 self))
  && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (view'2 self)
  <= UIntSize.to_int (max'0 : usize))
  predicate invariant'2 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv'11 (view'2 self)
  let rec invariant'2 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  axiom inv'2 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global) . inv'2 x
  = true
  type eq_model_ty'0
  predicate invariant'1 (self : eq_model_ty'0)
  let rec invariant'1 (self:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : eq_model_ty'0)
  let rec inv'1 (_x:eq_model_ty'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : eq_model_ty'0 . inv'1 x = true
  use prelude.Snapshot
  predicate invariant'0 (self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec invariant'0 (self:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec inv'0 (_x:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) . inv'0 x = true
  use prelude.Mapping
  function eq_model'0 (self : k) : eq_model_ty'0
  let rec eq_model'0 (self:k) (return'  (ret:eq_model_ty'0))= any
    [ return' (result:eq_model_ty'0)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get'0 [#"../hashmap.rs" 28 4 28 54] (self : Hashmap_List_Type.t_list (k, v)) (index : eq_model_ty'0) : Core_Option_Option_Type.t_option v
    
   =
    [#"../hashmap.rs" 30 12 33 13] match self with
      | Hashmap_List_Type.C_Nil -> Core_Option_Option_Type.C_None
      | Hashmap_List_Type.C_Cons (k, v) tl -> if eq_model'0 k = index then
        Core_Option_Option_Type.C_Some v
      else
        get'0 tl index
      
      end
  let rec get'0 (self:Hashmap_List_Type.t_list (k, v)) (index:eq_model_ty'0) (return'  (ret:Core_Option_Option_Type.t_option v))= any
    [ return' (result:Core_Option_Option_Type.t_option v)-> {result = get'0 self index} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix : int) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (view'2 self) ix
  let rec index_logic'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (ix:int) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use int.EuclideanDivision
  function hash_log'0 [#"../hashmap.rs" 54 4 54 43] (_1 : eq_model_ty'0) : int
  let rec hash_log'0 (_1:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 _1} (! return' {result}) ]
    
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 46] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : int
    
   =
    [#"../hashmap.rs" 90 20 90 66] EuclideanDivision.mod (hash_log'0 k) (Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  let rec bucket_ix'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:int))= any
    [ return' (result:int)-> {result = bucket_ix'0 self k} (! return' {result}) ]
    
  function bucket'0 [#"../hashmap.rs" 84 4 84 52] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (k : eq_model_ty'0) : Hashmap_List_Type.t_list (k, v)
    
   =
    [#"../hashmap.rs" 85 8 85 53] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  let rec bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (k:eq_model_ty'0) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {result = bucket'0 self k} (! return' {result}) ]
    
  use map.Map
  function view'1 [#"../hashmap.rs" 78 4 78 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../hashmap.rs" 79 20 79 45] Mapping.from_fn (fun (k : eq_model_ty'0) -> get'0 (bucket'0 self k) k)
  let rec view'1 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'1 self}
      (! return' {result}) ]
    
  function view'3 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'1 ( * self)
  let rec view'3 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'3 self}
      (! return' {result}) ]
    
  use prelude.Intrinsic
  predicate resolve'7 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'7 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'7 self} (! return' {result}) ]
    
  predicate resolve'6 (self : Hashmap_MyHashMap_Type.t_myhashmap k v)
  let rec resolve'6 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'6 self} (! return' {result}) ]
    
  predicate resolve'2 (self : Hashmap_List_Type.t_list (k, v))
  let rec resolve'2 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'2 self} (! return' {result}) ]
    
  predicate resolve'5 (self : Hashmap_List_Type.t_list (k, v)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 35 8 35 31] resolve'2 self
  let rec resolve'5 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'5 self} (! return' {result}) ]
    
  use map.Map
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : Hashmap_List_Type.t_list (k, v)) =
    [#"../hashmap.rs" 40 12 43 13] match self with
      | Hashmap_List_Type.C_Nil -> true
      | Hashmap_List_Type.C_Cons (k, _) tl -> get'0 tl (eq_model'0 k) = Core_Option_Option_Type.C_None
      /\ no_double_binding'0 tl
      end
  let rec no_double_binding'0 (self:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = no_double_binding'0 self} (! return' {result}) ]
    
  predicate good_bucket'0 [#"../hashmap.rs" 200 4 200 57] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) (l : Hashmap_List_Type.t_list (k, v)) (h : int)
    
   =
    [#"../hashmap.rs" 201 8 203 9] forall v : v . forall k : eq_model_ty'0 . inv'7 v
     -> inv'1 k  -> get'0 l k = Core_Option_Option_Type.C_Some v  -> bucket_ix'0 self k = h
  let rec good_bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (l:Hashmap_List_Type.t_list (k, v)) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = good_bucket'0 self l h} (! return' {result}) ]
    
  predicate hashmap_inv'0 [#"../hashmap.rs" 209 4 209 33] (self : Hashmap_MyHashMap_Type.t_myhashmap k v) =
    [#"../hashmap.rs" 210 8 213 9] 0 < Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  let rec hashmap_inv'0 (self:Hashmap_MyHashMap_Type.t_myhashmap k v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = hashmap_inv'0 self} (! return' {result}) ]
    
  let rec add'0 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (key:k) (val':v) (return'  (ret:()))= {[@expl:precondition] [#"../hashmap.rs" 106 34 106 37] inv'7 val'}
    {[@expl:precondition] [#"../hashmap.rs" 106 26 106 29] inv'6 key}
    {[@expl:precondition] [#"../hashmap.rs" 106 20 106 24] inv'9 self}
    {[@expl:precondition] [#"../hashmap.rs" 103 15 103 36] hashmap_inv'0 ( * self)}
    any
    [ return' (result:())-> {[#"../hashmap.rs" 105 4 105 120] forall i : eq_model_ty'0 . inv'1 i
       -> Map.get (view'1 ( ^ self)) i
      = (if i = eq_model'0 key then Core_Option_Option_Type.C_Some val' else Map.get (view'3 self) i)}
      {[#"../hashmap.rs" 104 14 104 35] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
  predicate resolve'4 (self : v)
  let rec resolve'4 (self:v) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'4 self} (! return' {result}) ]
    
  predicate resolve'3 (self : k)
  let rec resolve'3 (self:k) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'3 self} (! return' {result}) ]
    
  predicate resolve'1 (self : borrowed (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/resolve.rs" 26 20 26 34]  ^ self =  * self
  let rec resolve'1 (self:borrowed (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'1 self} (! return' {result}) ]
    
  let rec replace'0 (dest:borrowed (Hashmap_List_Type.t_list (k, v))) (src:Hashmap_List_Type.t_list (k, v)) (return'  (ret:Hashmap_List_Type.t_list (k, v)))= {[@expl:precondition] inv'3 src}
    {[@expl:precondition] inv'4 dest}
    any
    [ return' (result:Hashmap_List_Type.t_list (k, v))-> {inv'3 result}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 9 22 9 37] result =  * dest}
      {[#"../../../../creusot-contracts/src/std/mem.rs" 8 22 8 34]  ^ dest = src}
      (! return' {result}) ]
    
  use prelude.Slice
  predicate resolve_elswhere'0 [@inline:trivial] (self : usize) (old' : Seq.seq (Hashmap_List_Type.t_list (k, v))) (fin : Seq.seq (Hashmap_List_Type.t_list (k, v)))
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96] forall i : int . 0 <= i
    /\ i <> UIntSize.to_int self /\ i < Seq.length old'  -> Seq.get old' i = Seq.get fin i
  let rec resolve_elswhere'0 (self:usize) (old':Seq.seq (Hashmap_List_Type.t_list (k, v))) (fin:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve_elswhere'0 self old' fin} (! return' {result}) ]
    
  predicate has_value'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) (out : Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  let rec has_value'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (out:Hashmap_List_Type.t_list (k, v)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = has_value'0 self seq out} (! return' {result}) ]
    
  predicate in_bounds'0 [@inline:trivial] (self : usize) (seq : Seq.seq (Hashmap_List_Type.t_list (k, v))) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  let rec in_bounds'0 (self:usize) (seq:Seq.seq (Hashmap_List_Type.t_list (k, v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = in_bounds'0 self seq} (! return' {result}) ]
    
  function view'6 (self : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'2 ( * self)
  let rec view'6 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'6 self} (! return' {result}) ]
    
  let rec index_mut'0 (self:borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) (index:usize) (return'  (ret:borrowed (Hashmap_List_Type.t_list (k, v))))= {[@expl:precondition] inv'13 index}
    {[@expl:precondition] inv'12 self}
    {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46] in_bounds'0 index (view'6 self)}
    any
    [ return' (result:borrowed (Hashmap_List_Type.t_list (k, v)))-> {inv'4 result}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55] Seq.length (view'2 ( ^ self))
      = Seq.length (view'6 self)}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62] resolve_elswhere'0 index (view'6 self) (view'2 ( ^ self))}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57] has_value'0 index (view'2 ( ^ self)) ( ^ result)}
      {[#"../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54] has_value'0 index (view'6 self) ( * result)}
      (! return' {result}) ]
    
  use prelude.Snapshot
  function view'5 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'3 self
  let rec view'5 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'5 self}
      (! return' {result}) ]
    
  use prelude.Snapshot
  function view'0 (self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) : Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)
    
   =
    [#"../../../../creusot-contracts/src/snapshot.rs" 27 20 27 39] view'5 (Snapshot.inner self)
  let rec view'0 (self:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v)))= any
    [ return' (result:Map.map eq_model_ty'0 (Core_Option_Option_Type.t_option v))-> {result = view'0 self}
      (! return' {result}) ]
    
  let rec new'0 (size:usize) (return'  (ret:Hashmap_MyHashMap_Type.t_myhashmap k v))= {[@expl:precondition] [#"../hashmap.rs" 95 15 95 24] 0
    < UIntSize.to_int size}
    any
    [ return' (result:Hashmap_MyHashMap_Type.t_myhashmap k v)-> {[#"../hashmap.rs" 98 31 98 46] inv'5 result}
      {[#"../hashmap.rs" 97 4 97 62] forall i : eq_model_ty'0 . inv'1 i
       -> Map.get (view'1 result) i = Core_Option_Option_Type.C_None}
      {[#"../hashmap.rs" 96 14 96 34] hashmap_inv'0 result}
      (! return' {result}) ]
    
  function view'4 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (k, v))
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'2 self
  let rec view'4 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (k, v))))= any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (k, v)))-> {result = view'4 self} (! return' {result}) ]
    
  let rec len'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:usize))= {[@expl:precondition] inv'10 self}
    any
    [ return' (result:usize)-> {[#"../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48] UIntSize.to_int result
      = Seq.length (view'4 self)}
      (! return' {result}) ]
    
  predicate resolve'0 (self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)))
  let rec resolve'0 (self:Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = resolve'0 self} (! return' {result}) ]
    
  use prelude.Snapshot
  let rec resize (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) (return'  (ret:()))= {[#"../hashmap.rs" 161 19 161 23] inv'9 self}
    {[#"../hashmap.rs" 157 15 157 36] hashmap_inv'0 ( * self)}
    {[#"../hashmap.rs" 156 15 156 41] Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self))) < 1000}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [#"../hashmap.rs" 162 23 162 41] Snapshot.new self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 old_self} s1
      | s1 = -{resolve'0 old_self}- s2
      | s2 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
          (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
            len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_10 <- _ret' ] s3))
      | s3 = bb2 ]
      
    | bb2 = s0
      [ s0 = UIntSize.mul {_10} {[#"../hashmap.rs" 163 53 163 54] (2 : usize)}
          (fun (_ret':usize) ->  [ &_9 <- _ret' ] (any [ any_ (_any:usize)-> (!  [ &_10 <- _any ] s1) ] ))
      | s1 = new'0 {_9} (fun (_ret':Hashmap_MyHashMap_Type.t_myhashmap k v) ->  [ &new <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 =  [ &i <- [#"../hashmap.rs" 165 27 165 28] (0 : usize) ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = bb5 ] 
    | bb5 = s0 [ s0 = bb6 ] 
    | bb6 = bb6
      [ bb6 = {[@expl:loop invariant] [#"../hashmap.rs" 175 20 175 45] UIntSize.to_int i
        <= Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)))}
        {[@expl:loop invariant] [#"../hashmap.rs" 174 20 174 66] Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
        = Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)))}
        {[@expl:loop invariant] [#"../hashmap.rs" 173 20 173 46]  ^ Snapshot.inner old_self =  ^ self}
        {[@expl:loop invariant] [#"../hashmap.rs" 172 20 172 37] hashmap_inv'0 new}
        {[@expl:loop invariant] [#"../hashmap.rs" 166 8 166 109] forall j : int . UIntSize.to_int i <= j
        /\ j < Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
         -> index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * self)) j
        = index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)) j}
        {[@expl:loop invariant] [#"../hashmap.rs" 166 8 166 109] forall k : eq_model_ty'0 . inv'1 k
         -> UIntSize.to_int i <= bucket_ix'0 ( * Snapshot.inner old_self) k
        /\ bucket_ix'0 ( * Snapshot.inner old_self) k
        <= Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
         -> Map.get (view'1 new) k = Core_Option_Option_Type.C_None}
        {[@expl:loop invariant] [#"../hashmap.rs" 166 8 166 109] forall k : eq_model_ty'0 . inv'1 k
         -> bucket_ix'0 ( * Snapshot.inner old_self) k < UIntSize.to_int i
         -> Map.get (view'0 old_self) k = Map.get (view'1 new) k}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
              (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
                len'0 {rbuckets'0} (fun (_ret':usize) ->  [ &_24 <- _ret' ] s1))
          | s1 = bb8 ]
          
        | bb8 = s0
          [ s0 = UIntSize.lt {i} {_24}
              (fun (_ret':bool) ->  [ &_22 <- _ret' ] (any [ any_ (_any:usize)-> (!  [ &_24 <- _any ] s1) ] ))
          | s1 = any [ br0 -> {_22 = false} (! bb29) | br1 -> {_22} (! bb9) ]  ]
          
        | bb9 = s0
          [ s0 = Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
              (fun (rbuckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
                Borrow.borrow_mut
                  <Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)>
                  {rbuckets'0}
                  (fun (_ret':borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))) ->
                     [ &_30 <- _ret' ] 
                    Hashmap_MyHashMap_Type.t_myhashmap <k> <v> { * self}
                      (fun (l_buckets'0:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) ->
                        
                        [ &self <- { self with current = (Hashmap_MyHashMap_Type.C_MyHashMap ( ^ _30) : Hashmap_MyHashMap_Type.t_myhashmap k v) ; } ]
                        
                        s1)))
          | s1 = -{inv'2 ( ^ _30)}- s2
          | s2 = index_mut'0 {_30} {i} (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->  [ &_29 <- _ret' ] s3)
          | s3 = bb10 ]
          
        | bb10 = s0
          [ s0 = Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> { * _29} {Borrow.get_id _29}
              (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
                 [ &_28 <- _ret' ] 
                 [ &_29 <- { _29 with current = ( ^ _28) ; } ] 
                s1)
          | s1 = -{inv'3 ( ^ _28)}- s2
          | s2 = Borrow.borrow_final <Hashmap_List_Type.t_list (k, v)> { * _28} {Borrow.get_id _28}
              (fun (_ret':borrowed (Hashmap_List_Type.t_list (k, v))) ->
                 [ &_27 <- _ret' ] 
                 [ &_28 <- { _28 with current = ( ^ _27) ; } ] 
                s3)
          | s3 = -{inv'3 ( ^ _27)}- s4
          | s4 =  [ &_32 <- Hashmap_List_Type.C_Nil : Hashmap_List_Type.t_list (k, v) ] s5
          | s5 = replace'0 {_27} {_32} (fun (_ret':Hashmap_List_Type.t_list (k, v)) ->  [ &l <- _ret' ] s6)
          | s6 = bb11 ]
          
        | bb11 = s0
          [ s0 = {[@expl:type invariant] inv'4 _29} s1
          | s1 = -{resolve'1 _29}- s2
          | s2 = {[@expl:type invariant] inv'4 _28} s3
          | s3 = -{resolve'1 _28}- s4
          | s4 = bb12 ]
          
        | bb12 = s0 [ s0 = bb13 ] 
        | bb13 = s0 [ s0 = bb14 ] 
        | bb14 = s0 [ s0 = bb15 ] 
        | bb15 = s0 [ s0 = bb16 ] 
        | bb16 = s0 [ s0 = bb17 ] 
        | bb17 = bb17
          [ bb17 = {[@expl:loop invariant] [#"../hashmap.rs" 187 24 187 51] good_bucket'0 ( * Snapshot.inner old_self) l (UIntSize.to_int i)}
            {[@expl:loop invariant] [#"../hashmap.rs" 186 24 186 45] no_double_binding'0 l}
            {[@expl:loop invariant] [#"../hashmap.rs" 179 12 179 43] forall k : eq_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k = UIntSize.to_int i
             -> Map.get (view'0 old_self) k
            = match get'0 l k with
              | Core_Option_Option_Type.C_None -> Map.get (view'1 new) k
              | Core_Option_Option_Type.C_Some v -> Core_Option_Option_Type.C_Some v
              end}
            {[@expl:loop invariant] [#"../hashmap.rs" 179 12 179 43] forall k : eq_model_ty'0 . inv'1 k
             -> UIntSize.to_int i < bucket_ix'0 ( * Snapshot.inner old_self) k
            /\ bucket_ix'0 ( * Snapshot.inner old_self) k
            <= Seq.length (view'2 (Hashmap_MyHashMap_Type.myhashmap_buckets ( * Snapshot.inner old_self)))
             -> Map.get (view'1 new) k = Core_Option_Option_Type.C_None}
            {[@expl:loop invariant] [#"../hashmap.rs" 179 12 179 43] forall k : eq_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k < UIntSize.to_int i
             -> Map.get (view'0 old_self) k = Map.get (view'1 new) k}
            {[@expl:loop invariant] [#"../hashmap.rs" 179 24 179 41] hashmap_inv'0 new}
            (! s0) [ s0 = bb18 ] 
            [ bb18 = s0
              [ s0 = any
                [ br0 -> {l = Hashmap_List_Type.C_Nil } (! bb25)
                | br1 (a:(k, v)) (b:Hashmap_List_Type.t_list (k, v))-> {l = Hashmap_List_Type.C_Cons a b} (! bb19) ]
                 ]
              
            | bb19 = s0 [ s0 = bb20 ] 
            | bb20 = s0
              [ s0 = Hashmap_List_Type.cons <(k, v)> {l}
                  (fun (r0'0:(k, v)) (r1'0:Hashmap_List_Type.t_list (k, v)) ->  [ &k <- let (r'0, _) = r0'0 in r'0 ] s1)
              | s1 = Hashmap_List_Type.cons <(k, v)> {l}
                  (fun (r0'1:(k, v)) (r1'1:Hashmap_List_Type.t_list (k, v)) ->  [ &v <- let (_, r'1) = r0'1 in r'1 ] s2)
              | s2 = Hashmap_List_Type.cons <(k, v)> {l}
                  (fun (r0'2:(k, v)) (r1'2:Hashmap_List_Type.t_list (k, v)) ->
                     [ &tl <- r1'2 ] 
                    (any
                    [ any_ (_any:Hashmap_List_Type.t_list (k, v))-> (! Hashmap_List_Type.cons <(k, v)> {l}
                        (fun (l_0'0:(k, v)) (l_1'0:Hashmap_List_Type.t_list (k, v)) ->
                           [ &l <- Hashmap_List_Type.C_Cons l_0'0 _any : Hashmap_List_Type.t_list (k, v) ] 
                          s3)) ]
                    ))
              | s3 = {[@expl:type invariant] inv'3 l} s4
              | s4 = -{resolve'2 l}- s5
              | s5 = Borrow.borrow_mut <Hashmap_MyHashMap_Type.t_myhashmap k v> {new}
                  (fun (_ret':borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) ->
                     [ &_45 <- _ret' ] 
                     [ &new <-  ^ _45 ] 
                    s6)
              | s6 = -{inv'5 ( ^ _45)}- s7
              | s7 = {[@expl:type invariant] inv'6 k} s8
              | s8 = -{resolve'3 k}- s9
              | s9 = {[@expl:type invariant] inv'7 v} s10
              | s10 = -{resolve'4 v}- s11
              | s11 = add'0 {_45} {k} {v} (fun (_ret':()) ->  [ &_44 <- _ret' ] s12)
              | s12 = bb21 ]
              
            | bb21 = s0 [ s0 = {[@expl:type invariant] inv'8 tl} s1 | s1 = -{resolve'5 tl}- s2 | s2 = bb22 ] 
            | bb22 = s0
              [ s0 =  [ &l <- tl ] (any [ any_ (_any:Hashmap_List_Type.t_list (k, v))-> (!  [ &tl <- _any ] s1) ] )
              | s1 = bb24 ]
              
            | bb24 = s0 [ s0 =  [ &_21 <- [#"../hashmap.rs" 188 49 191 13] () ] s1 | s1 = bb26 ] 
            | bb26 = s0 [ s0 = bb17 ]  ]
             ]
          
        | bb25 = s0
          [ s0 = {[@expl:type invariant] inv'3 l} s1
          | s1 = -{resolve'2 l}- s2
          | s2 = {[@expl:assertion] [#"../hashmap.rs" 192 12 192 119] forall k : eq_model_ty'0 . inv'1 k
             -> bucket_ix'0 ( * Snapshot.inner old_self) k = UIntSize.to_int i
             -> Map.get (view'0 old_self) k = Map.get (view'1 new) k}
            s3
          | s3 = bb27 ]
          
        | bb27 = s0
          [ s0 = UIntSize.add {i} {[#"../hashmap.rs" 193 17 193 18] (1 : usize)}
              (fun (_ret':usize) ->  [ &i <- _ret' ] s1)
          | s1 =  [ &_21 <- [#"../hashmap.rs" 176 37 194 9] () ] s2
          | s2 = bb28 ]
          
        | bb28 = s0 [ s0 = bb6 ]  ]
         ]
      
    | bb29 = s0 [ s0 = bb30 ] 
    | bb30 = s0
      [ s0 =  [ &self <- { self with current = new ; } ] 
        (any [ any_ (_any:Hashmap_MyHashMap_Type.t_myhashmap k v)-> (!  [ &new <- _any ] s1) ] )
      | s1 = {[@expl:type invariant] inv'5 ( * self)} s2
      | s2 = -{resolve'6 ( * self)}- s3
      | s3 = {[@expl:type invariant] inv'9 self} s4
      | s4 = -{resolve'7 self}- s5
      | s5 = bb32 ]
      
    | bb32 = s0 [ s0 =  [ &_0 <- [#"../hashmap.rs" 161 25 197 5] () ] s1 | s1 = bb33 ] 
    | bb33 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) = self
    | & old_self : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v)) = any_l () : Snapshot.snap_ty (borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v))
    | & new : Hashmap_MyHashMap_Type.t_myhashmap k v = any_l () : Hashmap_MyHashMap_Type.t_myhashmap k v
    | & _9 : usize = any_l () : usize
    | & _10 : usize = any_l () : usize
    | & i : usize = any_l () : usize
    | & _21 : () = any_l () : ()
    | & _22 : bool = any_l () : bool
    | & _24 : usize = any_l () : usize
    | & l : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & _27 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _28 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _29 : borrowed (Hashmap_List_Type.t_list (k, v)) = any_l () : borrowed (Hashmap_List_Type.t_list (k, v))
    | & _30 : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global)) = any_l () : borrowed (Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (k, v)) (Alloc_Alloc_Global_Type.t_global))
    | & _32 : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & k : k = any_l () : k
    | & v : v = any_l () : v
    | & tl : Hashmap_List_Type.t_list (k, v) = any_l () : Hashmap_List_Type.t_list (k, v)
    | & _44 : () = any_l () : ()
    | & _45 : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) = any_l () : borrowed (Hashmap_MyHashMap_Type.t_myhashmap k v) ]
    
    [ return' (result:())-> {[@expl:postcondition] [#"../hashmap.rs" 159 4 159 72] forall k : eq_model_ty'0 . inv'1 k
       -> Map.get (view'1 ( ^ self)) k = Map.get (view'3 self) k}
      {[@expl:postcondition] [#"../hashmap.rs" 158 14 158 35] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
end
module Hashmap_Main
  use prelude.IntSize
  use prelude.UIntSize
  use Hashmap_List_Type as Hashmap_List_Type
  use seq.Seq
  predicate invariant'8 (self : Seq.seq (Hashmap_List_Type.t_list (usize, isize))) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'8 (self:Seq.seq (Hashmap_List_Type.t_list (usize, isize))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'8 self} (! return' {result}) ]
    
  predicate inv'8 (_x : Seq.seq (Hashmap_List_Type.t_list (usize, isize)))
  let rec inv'8 (_x:Seq.seq (Hashmap_List_Type.t_list (usize, isize))) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'8 _x} (! return' {result}) ]
    
  axiom inv'8 : forall x : Seq.seq (Hashmap_List_Type.t_list (usize, isize)) . inv'8 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  constant max'0 : usize = (18446744073709551615 : usize)
  use seq.Seq
  predicate inv'7 (_x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global))
    
  let rec inv'7 (_x:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'7 _x} (! return' {result}) ]
    
  function view'3 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) : Seq.seq (Hashmap_List_Type.t_list (usize, isize))
    
  let rec view'3 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:Seq.seq (Hashmap_List_Type.t_list (usize, isize))))= {[@expl:precondition] [#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'7 self}
    any
    [ return' (result:Seq.seq (Hashmap_List_Type.t_list (usize, isize)))-> {result = view'3 self} (! return' {result}) ]
    
  axiom view'3_spec : forall self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 12 19 16] inv'7 self)
   -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 27] inv'8 (view'3 self))
  && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (view'3 self)
  <= UIntSize.to_int (max'0 : usize))
  predicate invariant'7 (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv'8 (view'3 self)
  let rec invariant'7 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'7 self} (! return' {result}) ]
    
  axiom inv'7 : forall x : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global) . inv'7 x
  = true
  predicate invariant'6 (self : isize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'6 (self:isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'6 self} (! return' {result}) ]
    
  predicate inv'6 (_x : isize)
  let rec inv'6 (_x:isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'6 _x} (! return' {result}) ]
    
  axiom inv'6 : forall x : isize . inv'6 x = true
  use Hashmap_MyHashMap_Type as Hashmap_MyHashMap_Type
  use prelude.Borrow
  predicate invariant'5 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'5 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'5 self} (! return' {result}) ]
    
  predicate inv'5 (_x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize))
  let rec inv'5 (_x:borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'5 _x} (! return' {result}) ]
    
  axiom inv'5 : forall x : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize) . inv'5 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant'4 (self : Core_Option_Option_Type.t_option isize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'4 (self:Core_Option_Option_Type.t_option isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'4 self} (! return' {result}) ]
    
  predicate inv'4 (_x : Core_Option_Option_Type.t_option isize)
  let rec inv'4 (_x:Core_Option_Option_Type.t_option isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'4 _x} (! return' {result}) ]
    
  axiom inv'4 : forall x : Core_Option_Option_Type.t_option isize . inv'4 x = true
  predicate invariant'3 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'3 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'3 self} (! return' {result}) ]
    
  predicate inv'3 (_x : usize)
  let rec inv'3 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'3 _x} (! return' {result}) ]
    
  axiom inv'3 : forall x : usize . inv'3 x = true
  predicate invariant'2 (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'2 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'2 self} (! return' {result}) ]
    
  predicate inv'2 (_x : Hashmap_MyHashMap_Type.t_myhashmap usize isize)
  let rec inv'2 (_x:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'2 _x} (! return' {result}) ]
    
  axiom inv'2 : forall x : Hashmap_MyHashMap_Type.t_myhashmap usize isize . inv'2 x = true
  predicate invariant'1 (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'1 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Hashmap_MyHashMap_Type.t_myhashmap usize isize)
  let rec inv'1 (_x:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Hashmap_MyHashMap_Type.t_myhashmap usize isize . inv'1 x = true
  use prelude.Int
  predicate invariant'0 (self : int) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : int)
  let rec inv'0 (_x:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : int . inv'0 x = true
  use prelude.Intrinsic
  use map.Map
  use prelude.Mapping
  function eq_model'0 (self : usize) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  let rec eq_model'0 (self:usize) (return'  (ret:int))= any
    [ return' (result:int)-> {result = eq_model'0 self} (! return' {result}) ]
    
  function get'1 [#"../hashmap.rs" 28 4 28 54] (self : Hashmap_List_Type.t_list (usize, isize)) (index : int) : Core_Option_Option_Type.t_option isize
    
   =
    [#"../hashmap.rs" 30 12 33 13] match self with
      | Hashmap_List_Type.C_Nil -> Core_Option_Option_Type.C_None
      | Hashmap_List_Type.C_Cons (k, v) tl -> if eq_model'0 k = index then
        Core_Option_Option_Type.C_Some v
      else
        get'1 tl index
      
      end
  let rec get'1 (self:Hashmap_List_Type.t_list (usize, isize)) (index:int) (return'  (ret:Core_Option_Option_Type.t_option isize))= any
    [ return' (result:Core_Option_Option_Type.t_option isize)-> {result = get'1 self index} (! return' {result}) ]
    
  use seq.Seq
  function index_logic'0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) (ix : int) : Hashmap_List_Type.t_list (usize, isize)
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (view'3 self) ix
  let rec index_logic'0 (self:Alloc_Vec_Vec_Type.t_vec (Hashmap_List_Type.t_list (usize, isize)) (Alloc_Alloc_Global_Type.t_global)) (ix:int) (return'  (ret:Hashmap_List_Type.t_list (usize, isize)))= any
    [ return' (result:Hashmap_List_Type.t_list (usize, isize))-> {result = index_logic'0 self ix} (! return' {result}) ]
    
  use int.EuclideanDivision
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [#"../hashmap.rs" 65 20 65 21] x
  let rec hash_log'0 (x:int) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  function bucket_ix'0 [#"../hashmap.rs" 89 4 89 46] (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) (k : int) : int
    
   =
    [#"../hashmap.rs" 90 20 90 66] EuclideanDivision.mod (hash_log'0 k) (Seq.length (view'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self)))
  let rec bucket_ix'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (k:int) (return'  (ret:int))= any
    [ return' (result:int)-> {result = bucket_ix'0 self k} (! return' {result}) ]
    
  function bucket'0 [#"../hashmap.rs" 84 4 84 52] (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) (k : int) : Hashmap_List_Type.t_list (usize, isize)
    
   =
    [#"../hashmap.rs" 85 8 85 53] index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) (bucket_ix'0 self k)
  let rec bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (k:int) (return'  (ret:Hashmap_List_Type.t_list (usize, isize)))= any
    [ return' (result:Hashmap_List_Type.t_list (usize, isize))-> {result = bucket'0 self k} (! return' {result}) ]
    
  function view'0 [#"../hashmap.rs" 78 4 78 33] (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) : Map.map int (Core_Option_Option_Type.t_option isize)
    
   =
    [#"../hashmap.rs" 79 20 79 45] Mapping.from_fn (fun (k : int) -> get'1 (bucket'0 self k) k)
  let rec view'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:Map.map int (Core_Option_Option_Type.t_option isize)))= any
    [ return' (result:Map.map int (Core_Option_Option_Type.t_option isize))-> {result = view'0 self}
      (! return' {result}) ]
    
  function view'2 (self : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) : Map.map int (Core_Option_Option_Type.t_option isize)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 108 8 108 22] view'0 ( * self)
  let rec view'2 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) (return'  (ret:Map.map int (Core_Option_Option_Type.t_option isize)))= any
    [ return' (result:Map.map int (Core_Option_Option_Type.t_option isize))-> {result = view'2 self}
      (! return' {result}) ]
    
  use map.Map
  predicate no_double_binding'0 [#"../hashmap.rs" 38 4 38 38] (self : Hashmap_List_Type.t_list (usize, isize)) =
    [#"../hashmap.rs" 40 12 43 13] match self with
      | Hashmap_List_Type.C_Nil -> true
      | Hashmap_List_Type.C_Cons (k, _) tl -> get'1 tl (eq_model'0 k) = Core_Option_Option_Type.C_None
      /\ no_double_binding'0 tl
      end
  let rec no_double_binding'0 (self:Hashmap_List_Type.t_list (usize, isize)) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = no_double_binding'0 self} (! return' {result}) ]
    
  predicate good_bucket'0 [#"../hashmap.rs" 200 4 200 57] (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) (l : Hashmap_List_Type.t_list (usize, isize)) (h : int)
    
   =
    [#"../hashmap.rs" 201 8 203 9] forall v : isize . forall k : int . inv'6 v
     -> inv'0 k  -> get'1 l k = Core_Option_Option_Type.C_Some v  -> bucket_ix'0 self k = h
  let rec good_bucket'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (l:Hashmap_List_Type.t_list (usize, isize)) (h:int) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = good_bucket'0 self l h} (! return' {result}) ]
    
  predicate hashmap_inv'0 [#"../hashmap.rs" 209 4 209 33] (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) =
    [#"../hashmap.rs" 210 8 213 9] 0 < Seq.length (view'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
    /\ (forall i : int . 0 <= i /\ i < Seq.length (view'3 (Hashmap_MyHashMap_Type.myhashmap_buckets self))
     -> good_bucket'0 self (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i) i
    /\ no_double_binding'0 (index_logic'0 (Hashmap_MyHashMap_Type.myhashmap_buckets self) i))
  let rec hashmap_inv'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = hashmap_inv'0 self} (! return' {result}) ]
    
  let rec add'0 (self:borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) (key:usize) (val':isize) (return'  (ret:()))= {[@expl:precondition] [#"../hashmap.rs" 106 34 106 37] inv'6 val'}
    {[@expl:precondition] [#"../hashmap.rs" 106 26 106 29] inv'3 key}
    {[@expl:precondition] [#"../hashmap.rs" 106 20 106 24] inv'5 self}
    {[@expl:precondition] [#"../hashmap.rs" 103 15 103 36] hashmap_inv'0 ( * self)}
    any
    [ return' (result:())-> {[#"../hashmap.rs" 105 4 105 120] forall i : int . inv'0 i
       -> Map.get (view'0 ( ^ self)) i
      = (if i = eq_model'0 key then Core_Option_Option_Type.C_Some val' else Map.get (view'2 self) i)}
      {[#"../hashmap.rs" 104 14 104 35] hashmap_inv'0 ( ^ self)}
      (! return' {result}) ]
    
  function view'1 (self : Hashmap_MyHashMap_Type.t_myhashmap usize isize) : Map.map int (Core_Option_Option_Type.t_option isize)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 90 8 90 22] view'0 self
  let rec view'1 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (return'  (ret:Map.map int (Core_Option_Option_Type.t_option isize)))= any
    [ return' (result:Map.map int (Core_Option_Option_Type.t_option isize))-> {result = view'1 self}
      (! return' {result}) ]
    
  let rec get'0 (self:Hashmap_MyHashMap_Type.t_myhashmap usize isize) (key:usize) (return'  (ret:Core_Option_Option_Type.t_option isize))= {[@expl:precondition] [#"../hashmap.rs" 141 22 141 25] inv'3 key}
    {[@expl:precondition] [#"../hashmap.rs" 141 16 141 20] inv'2 self}
    {[@expl:precondition] [#"../hashmap.rs" 136 15 136 33] hashmap_inv'0 self}
    any
    [ return' (result:Core_Option_Option_Type.t_option isize)-> {[#"../hashmap.rs" 141 33 141 43] inv'4 result}
      {[#"../hashmap.rs" 137 14 140 5] match result with
        | Core_Option_Option_Type.C_Some v -> Map.get (view'1 self) (eq_model'0 key) = Core_Option_Option_Type.C_Some v
        | Core_Option_Option_Type.C_None -> Map.get (view'1 self) (eq_model'0 key) = Core_Option_Option_Type.C_None
        end}
      (! return' {result}) ]
    
  let rec new'0 (size:usize) (return'  (ret:Hashmap_MyHashMap_Type.t_myhashmap usize isize))= {[@expl:precondition] [#"../hashmap.rs" 95 15 95 24] 0
    < UIntSize.to_int size}
    any
    [ return' (result:Hashmap_MyHashMap_Type.t_myhashmap usize isize)-> {[#"../hashmap.rs" 98 31 98 46] inv'1 result}
      {[#"../hashmap.rs" 97 4 97 62] forall i : int . inv'0 i
       -> Map.get (view'0 result) i = Core_Option_Option_Type.C_None}
      {[#"../hashmap.rs" 96 14 96 34] hashmap_inv'0 result}
      (! return' {result}) ]
    
  let rec main (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = new'0 {[#"../hashmap.rs" 224 57 224 59] (17 : usize)}
          (fun (_ret':Hashmap_MyHashMap_Type.t_myhashmap usize isize) ->  [ &h1 <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = new'0 {[#"../hashmap.rs" 225 57 225 59] (42 : usize)}
          (fun (_ret':Hashmap_MyHashMap_Type.t_myhashmap usize isize) ->  [ &h2 <- _ret' ] s1)
      | s1 = bb2 ]
      
    | bb2 = s0
      [ s0 = get'0 {h1} {[#"../hashmap.rs" 226 24 226 25] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_x <- _ret' ] s1)
      | s1 = bb3 ]
      
    | bb3 = s0
      [ s0 = get'0 {h1} {[#"../hashmap.rs" 227 24 227 25] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_y <- _ret' ] s1)
      | s1 = bb4 ]
      
    | bb4 = s0
      [ s0 = get'0 {h2} {[#"../hashmap.rs" 228 24 228 25] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_z <- _ret' ] s1)
      | s1 = bb5 ]
      
    | bb5 = s0
      [ s0 = get'0 {h2} {[#"../hashmap.rs" 229 24 229 25] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_t <- _ret' ] s1)
      | s1 = bb6 ]
      
    | bb6 = s0
      [ s0 = Borrow.borrow_mut <Hashmap_MyHashMap_Type.t_myhashmap usize isize> {h1}
          (fun (_ret':borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) ->
             [ &_12 <- _ret' ] 
             [ &h1 <-  ^ _12 ] 
            s1)
      | s1 = add'0 {_12} {[#"../hashmap.rs" 233 11 233 12] (1 : usize)} {[#"../hashmap.rs" 233 14 233 16] (17 : isize)}
          (fun (_ret':()) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb7 ]
      
    | bb7 = s0
      [ s0 = get'0 {h1} {[#"../hashmap.rs" 234 16 234 17] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_13 <- _ret' ] s1)
      | s1 = bb8 ]
      
    | bb8 = s0
      [ s0 =  [ &_x <- _13 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_13 <- _any ] s1) ] )
      | s1 = get'0 {h1} {[#"../hashmap.rs" 235 16 235 17] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb9 ]
      
    | bb9 = s0
      [ s0 =  [ &_y <- _15 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_15 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[#"../hashmap.rs" 236 16 236 17] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb10 ]
      
    | bb10 = s0
      [ s0 =  [ &_z <- _17 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_17 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[#"../hashmap.rs" 237 16 237 17] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb11 ]
      
    | bb11 = s0
      [ s0 =  [ &_t <- _19 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_19 <- _any ] s1) ] )
      | s1 = Borrow.borrow_mut <Hashmap_MyHashMap_Type.t_myhashmap usize isize> {h2}
          (fun (_ret':borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)) ->
             [ &_22 <- _ret' ] 
             [ &h2 <-  ^ _22 ] 
            s2)
      | s2 = add'0 {_22} {[#"../hashmap.rs" 240 11 240 12] (1 : usize)} {[#"../hashmap.rs" 240 14 240 16] (42 : isize)}
          (fun (_ret':()) ->  [ &_21 <- _ret' ] s3)
      | s3 = bb12 ]
      
    | bb12 = s0
      [ s0 = get'0 {h1} {[#"../hashmap.rs" 241 16 241 17] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_23 <- _ret' ] s1)
      | s1 = bb13 ]
      
    | bb13 = s0
      [ s0 =  [ &_x <- _23 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_23 <- _any ] s1) ] )
      | s1 = get'0 {h1} {[#"../hashmap.rs" 242 16 242 17] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 =  [ &_y <- _25 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_25 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[#"../hashmap.rs" 243 16 243 17] (1 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb15 ]
      
    | bb15 = s0
      [ s0 =  [ &_z <- _27 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_27 <- _any ] s1) ] )
      | s1 = get'0 {h2} {[#"../hashmap.rs" 244 16 244 17] (2 : usize)}
          (fun (_ret':Core_Option_Option_Type.t_option isize) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
      
    | bb16 = s0
      [ s0 =  [ &_t <- _29 ] (any [ any_ (_any:Core_Option_Option_Type.t_option isize)-> (!  [ &_29 <- _any ] s1) ] )
      | s1 =  [ &_0 <- [#"../hashmap.rs" 217 14 247 1] () ] s2
      | s2 = bb17 ]
      
    | bb17 = s0 [ s0 = bb18 ] 
    | bb18 = s0 [ s0 = return' {_0} ]  ]
    )
    [ & _0 : () = any_l () : ()
    | & h1 : Hashmap_MyHashMap_Type.t_myhashmap usize isize = any_l () : Hashmap_MyHashMap_Type.t_myhashmap usize isize
    | & h2 : Hashmap_MyHashMap_Type.t_myhashmap usize isize = any_l () : Hashmap_MyHashMap_Type.t_myhashmap usize isize
    | & _x : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _y : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _z : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _t : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _11 : () = any_l () : ()
    | & _12 : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize) = any_l () : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)
    | & _13 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _15 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _17 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _19 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _21 : () = any_l () : ()
    | & _22 : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize) = any_l () : borrowed (Hashmap_MyHashMap_Type.t_myhashmap usize isize)
    | & _23 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _25 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _27 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize
    | & _29 : Core_Option_Option_Type.t_option isize = any_l () : Core_Option_Option_Type.t_option isize ]
     [ return' (result:())-> (! return' {result}) ] 
end
module Hashmap_Impl0
  type t
  use Hashmap_List_Type as Hashmap_List_Type
  predicate invariant'1 (self : Hashmap_List_Type.t_list t)
  let rec invariant'1 (self:Hashmap_List_Type.t_list t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'1 self} (! return' {result}) ]
    
  predicate inv'1 (_x : Hashmap_List_Type.t_list t)
  let rec inv'1 (_x:Hashmap_List_Type.t_list t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'1 _x} (! return' {result}) ]
    
  axiom inv'1 : forall x : Hashmap_List_Type.t_list t . inv'1 x = true
  predicate invariant'0 (self : Hashmap_List_Type.t_list t)
  let rec invariant'0 (self:Hashmap_List_Type.t_list t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : Hashmap_List_Type.t_list t)
  let rec inv'0 (_x:Hashmap_List_Type.t_list t) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : Hashmap_List_Type.t_list t . inv'0 x = true
  use prelude.Borrow
  goal clone'_refn : [#"../hashmap.rs" 16 4 16 27] forall self : Hashmap_List_Type.t_list t . inv'0 self
   -> inv'0 self
  /\ (forall result : Hashmap_List_Type.t_list t . inv'1 result /\ result = self  -> inv'1 result /\ result = self)
end
module Hashmap_Impl2
  use prelude.UIntSize
  predicate invariant'0 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  let rec invariant'0 (self:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = invariant'0 self} (! return' {result}) ]
    
  predicate inv'0 (_x : usize)
  let rec inv'0 (_x:usize) (return'  (ret:bool))= any
    [ return' (result:bool)-> {result = inv'0 _x} (! return' {result}) ]
    
  axiom inv'0 : forall x : usize . inv'0 x = true
  use prelude.Int
  function hash_log'0 [#"../hashmap.rs" 64 4 64 30] (x : int) : int =
    [#"../hashmap.rs" 65 20 65 21] x
  let rec hash_log'0 (x:int) (return'  (ret:int))= any
    [ return' (result:int)-> {result = hash_log'0 x} (! return' {result}) ]
    
  use prelude.UIntSize
  function eq_model'1 (self : usize) : int =
    [#"../../../../creusot-contracts/src/std/num.rs" 22 16 22 35] UIntSize.to_int self
  let rec eq_model'1 (self:usize) (return'  (ret:int))= any
    [ return' (result:int)-> {result = eq_model'1 self} (! return' {result}) ]
    
  use prelude.Int
  use prelude.Borrow
  function eq_model'0 (self : usize) : int =
    [#"../../../../creusot-contracts/src/model.rs" 81 8 81 26] eq_model'1 self
  let rec eq_model'0 (self:usize) (return'  (ret:int))= any
    [ return' (result:int)-> {result = eq_model'0 self} (! return' {result}) ]
    
  use prelude.UInt64
  use prelude.UInt64
  goal hash_refn : [#"../hashmap.rs" 59 4 59 25] forall self : usize . inv'0 self
   -> (forall result : uint64 . UInt64.to_int result = hash_log'0 (eq_model'0 self)
   -> UInt64.to_int result = hash_log'0 (eq_model'0 self))
end
module Hashmap_Impl3
  type k
  type v
end
