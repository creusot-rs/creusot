
module FloatOps_Eq
  use prelude.Intrinsic
  use prelude.Float64
  let rec eq (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.eq
          {[#"../float_ops.rs" 6 4 6 7] (1.0 : Float64.t)}
          {[#"../float_ops.rs" 6 11 6 14] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 4 10 4 24] result = true}
      (! return' {result}) ]
    
end
module FloatOps_Lt
  use prelude.Intrinsic
  use prelude.Float64
  let rec lt (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.lt
          {[#"../float_ops.rs" 11 4 11 7] (1.0 : Float64.t)}
          {[#"../float_ops.rs" 11 10 11 13] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 9 10 9 24] result = true}
      (! return' {result}) ]
    
end
module FloatOps_Le
  use prelude.Intrinsic
  use prelude.Float64
  let rec le (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.le
          {[#"../float_ops.rs" 16 4 16 7] (1.0 : Float64.t)}
          {[#"../float_ops.rs" 16 11 16 14] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 14 10 14 24] result = true}
      (! return' {result}) ]
    
end
module FloatOps_Gt
  use prelude.Intrinsic
  use prelude.Float64
  let rec gt (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.gt
          {[#"../float_ops.rs" 21 4 21 7] (2.0 : Float64.t)}
          {[#"../float_ops.rs" 21 10 21 13] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 19 10 19 24] result = true}
      (! return' {result}) ]
    
end
module FloatOps_Ge
  use prelude.Intrinsic
  use prelude.Float64
  let rec ge (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.ge
          {[#"../float_ops.rs" 26 4 26 7] (2.0 : Float64.t)}
          {[#"../float_ops.rs" 26 11 26 14] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 24 10 24 24] result = true}
      (! return' {result}) ]
    
end
module FloatOps_Neg
  use prelude.Intrinsic
  use prelude.Float64
  let rec neg (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.le
          {[#"../float_ops.rs" 31 4 31 8] (-2.0 : Float64.t)}
          {[#"../float_ops.rs" 31 12 31 15] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () : bool ] 
    [ return' (result:bool)-> {[@expl:postcondition] [#"../float_ops.rs" 29 10 29 24] result = true}
      (! return' {result}) ]
    
end
