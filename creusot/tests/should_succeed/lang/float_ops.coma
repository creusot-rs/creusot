module M_float_ops__eq [#"float_ops.rs" 8 0 8 19]
  let%span sfloat_ops0 = "float_ops.rs" 9 4 9 7
  let%span sfloat_ops1 = "float_ops.rs" 9 11 9 14
  let%span sfloat_ops2 = "float_ops.rs" 7 10 7 25
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec eq (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.eq {[%#sfloat_ops0] (1.0 : Float64.t)} {[%#sfloat_ops1] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = false} (! return' {result}) ]
    
end
module M_float_ops__lt [#"float_ops.rs" 13 0 13 19]
  let%span sfloat_ops0 = "float_ops.rs" 14 4 14 7
  let%span sfloat_ops1 = "float_ops.rs" 14 10 14 13
  let%span sfloat_ops2 = "float_ops.rs" 12 10 12 24
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec lt (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.lt {[%#sfloat_ops0] (1.0 : Float64.t)} {[%#sfloat_ops1] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = true} (! return' {result}) ]
    
end
module M_float_ops__le [#"float_ops.rs" 18 0 18 19]
  let%span sfloat_ops0 = "float_ops.rs" 19 4 19 7
  let%span sfloat_ops1 = "float_ops.rs" 19 11 19 14
  let%span sfloat_ops2 = "float_ops.rs" 17 10 17 24
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec le (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.le {[%#sfloat_ops0] (1.0 : Float64.t)} {[%#sfloat_ops1] (2.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = true} (! return' {result}) ]
    
end
module M_float_ops__gt [#"float_ops.rs" 23 0 23 19]
  let%span sfloat_ops0 = "float_ops.rs" 24 4 24 7
  let%span sfloat_ops1 = "float_ops.rs" 24 10 24 13
  let%span sfloat_ops2 = "float_ops.rs" 22 10 22 24
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec gt (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.gt {[%#sfloat_ops0] (2.0 : Float64.t)} {[%#sfloat_ops1] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = true} (! return' {result}) ]
    
end
module M_float_ops__ge [#"float_ops.rs" 28 0 28 19]
  let%span sfloat_ops0 = "float_ops.rs" 29 4 29 7
  let%span sfloat_ops1 = "float_ops.rs" 29 11 29 14
  let%span sfloat_ops2 = "float_ops.rs" 27 10 27 24
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec ge (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.ge {[%#sfloat_ops0] (2.0 : Float64.t)} {[%#sfloat_ops1] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = true} (! return' {result}) ]
    
end
module M_float_ops__neg [#"float_ops.rs" 33 0 33 20]
  let%span sfloat_ops0 = "float_ops.rs" 34 4 34 8
  let%span sfloat_ops1 = "float_ops.rs" 34 12 34 15
  let%span sfloat_ops2 = "float_ops.rs" 32 10 32 24
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Float64
  
  meta "compute_max_steps" 1000000
  
  let rec neg (_1:()) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = Float64.le {[%#sfloat_ops0] (-2.0 : Float64.t)} {[%#sfloat_ops1] (1.0 : Float64.t)}
          (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
       ]
    ) [ & _0 : bool = any_l () ] 
    [ return' (result:bool)-> {[@expl:postcondition] [%#sfloat_ops2] result = true} (! return' {result}) ]
    
end
