
module T_core__ptr__non_null__NonNull
  use prelude.prelude.Opaque
  
  type t_NonNull 't =
    | C_NonNull opaque_ptr
  
  function any_l (_ : 'b) : 'a
  
  let rec t_NonNull < 't > (input:t_NonNull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module T_core__marker__PhantomData
  type t_PhantomData 't =
    | C_PhantomData
  
  function any_l (_ : 'b) : 'a
  
  let rec t_PhantomData < 't > (input:t_PhantomData 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module T_core__ptr__unique__Unique
  use T_core__marker__PhantomData as PhantomData'0
  
  use T_core__ptr__non_null__NonNull as NonNull'0
  
  type t_Unique 't =
    | C_Unique (NonNull'0.t_NonNull 't) (PhantomData'0.t_PhantomData 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Unique < 't > (input:t_Unique 't) (ret  (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't))= any
    [ good (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:NonNull'0.t_NonNull 't) (_marker:PhantomData'0.t_PhantomData 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module T_alloc__raw_vec__Cap
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  type t_Cap  =
    | C_Cap usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Cap (input:t_Cap) (ret  (field_0:usize))= any
    [ good (field_0:usize)-> {C_Cap field_0 = input} (! ret {field_0})
    | bad (field_0:usize)-> {C_Cap field_0 <> input} {false} any ]
    
end
module T_alloc__raw_vec__RawVec
  use T_alloc__raw_vec__Cap as Cap'0
  
  use T_core__ptr__unique__Unique as Unique'0
  
  type t_RawVec 't 'a =
    | C_RawVec (Unique'0.t_Unique 't) (Cap'0.t_Cap) 'a
  
  function any_l (_ : 'b) : 'a
  
  let rec t_RawVec < 't > < 'a > (input:t_RawVec 't 'a) (ret  (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a))= any
    [ good (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a)-> {C_RawVec ptr cap alloc = input}
      (! ret {ptr} {cap} {alloc})
    | bad (ptr:Unique'0.t_Unique 't) (cap:Cap'0.t_Cap) (alloc:'a)-> {C_RawVec ptr cap alloc <> input} {false} any ]
    
end
module T_alloc__vec__Vec
  use prelude.prelude.UIntSize
  
  use prelude.prelude.Int
  
  use T_alloc__raw_vec__RawVec as RawVec'0
  
  type t_Vec 't 'a =
    | C_Vec (RawVec'0.t_RawVec 't 'a) usize
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Vec < 't > < 'a > (input:t_Vec 't 'a) (ret  (buf:RawVec'0.t_RawVec 't 'a) (len:usize))= any
    [ good (buf:RawVec'0.t_RawVec 't 'a) (len:usize)-> {C_Vec buf len = input} (! ret {buf} {len})
    | bad (buf:RawVec'0.t_RawVec 't 'a) (len:usize)-> {C_Vec buf len <> input} {false} any ]
    
end
module T_alloc__alloc__Global
  type t_Global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Global (input:t_Global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module T_alloc__boxed__Box
  use T_core__ptr__unique__Unique as Unique'0
  
  type t_Box 't 'a =
    | C_Box (Unique'0.t_Unique 't) 'a
  
  function any_l (_ : 'b) : 'a
end
module M_index_range__create_arr
  let%span sindex_range0 = "../index_range.rs" 15 18 15 28
  
  let%span sindex_range1 = "../index_range.rs" 17 13 17 14
  
  let%span sindex_range2 = "../index_range.rs" 18 13 18 14
  
  let%span sindex_range3 = "../index_range.rs" 19 13 19 14
  
  let%span sindex_range4 = "../index_range.rs" 20 13 20 14
  
  let%span sindex_range5 = "../index_range.rs" 21 13 21 14
  
  let%span sindex_range6 = "../index_range.rs" 7 4 12 22
  
  let%span span7 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span8 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span9 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span10 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span11 = "" 0 0 0 0
  
  let%span span12 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span13 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span14 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span15 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span16 = "" 0 0 0 0
  
  let%span span17 = "" 0 0 0 0
  
  let%span span18 = "../../../../creusot-contracts/src/std/vec.rs" 82 26 82 51
  
  let%span span19 = "../../../../creusot-contracts/src/std/vec.rs" 69 26 69 44
  
  let%span span20 = "" 0 0 0 0
  
  use prelude.prelude.Int32
  
  predicate inv'2 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'4 (self : int32) =
    [%#span7] inv'2 self
  
  predicate inv'4 (_1 : int32)
  
  axiom inv'4 : forall x : int32 . inv'4 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'3 (self : Seq.seq int32) =
    [%#span8] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq int32)
  
  axiom inv'3 : forall x : Seq.seq int32 . inv'3 x = true
  
  predicate invariant'2 (self : int32) =
    [%#span9] true
  
  axiom inv'2 : forall x : int32 . inv'2 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span10] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'1 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'1 x = true
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span11] (18446744073709551615 : usize)
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span12] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span13] inv'3 (shallow_model'0 self)
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Int32
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span14] Seq.get (shallow_model'0 self) ix
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  function shallow_model'1 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span15] shallow_model'0 self.current
  
  let rec push'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (value:int32) (return'  (ret:()))= {[@expl:precondition] [%#span17] inv'2 value}
    {[@expl:precondition] [%#span16] inv'1 self}
    any
    [ return' (result:())-> {[%#span18] shallow_model'0 self.final = Seq.snoc (shallow_model'1 self) value}
      (! return' {result}) ]
    
  
  let rec new'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span20] inv'0 result}
      {[%#span19] Seq.length (shallow_model'0 result) = 0}
      (! return' {result}) ]
    
  
  let rec create_arr (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= (! bb0
    [ bb0 = s0
      [ s0 = new'0 {[%#sindex_range0] ()} (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_4 <- _ret' ]  [ &arr <- _4.final ] s1)
      | s1 = push'0 {_4} {[%#sindex_range1] (0 : int32)} (fun (_ret':()) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_6 <- _ret' ]  [ &arr <- _6.final ] s1)
      | s1 = push'0 {_6} {[%#sindex_range2] (1 : int32)} (fun (_ret':()) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb3 ]
      
    | bb3 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_8 <- _ret' ]  [ &arr <- _8.final ] s1)
      | s1 = push'0 {_8} {[%#sindex_range3] (2 : int32)} (fun (_ret':()) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb4 ]
      
    | bb4 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_10 <- _ret' ]  [ &arr <- _10.final ] s1)
      | s1 = push'0 {_10} {[%#sindex_range4] (3 : int32)} (fun (_ret':()) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_12 <- _ret' ]  [ &arr <- _12.final ] s1)
      | s1 = push'0 {_12} {[%#sindex_range5] (4 : int32)} (fun (_ret':()) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb6 ]
      
    | bb6 = s0 [ s0 =  [ &_0 <- arr ] s1 | s1 = bb7 ] 
    | bb7 = return' {_0} ]
    )
    [ & _0 : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & _3 : () = any_l ()
    | & _4 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _5 : () = any_l ()
    | & _6 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _7 : () = any_l ()
    | & _8 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _9 : () = any_l ()
    | & _10 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _11 : () = any_l ()
    | & _12 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l () ]
    
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[@expl:postcondition] [%#sindex_range6] Seq.length (shallow_model'0 result)
      = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  function any_l (_ : 'b) : 'a
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} {false} any ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad (field_0:'t)-> {C_Some field_0 <> input} {false} any ]
    
end
module T_core__ops__range__Range
  type t_Range 'idx =
    | C_Range 'idx 'idx
  
  function any_l (_ : 'b) : 'a
  
  let rec t_Range < 'idx > (input:t_Range 'idx) (ret  (start:'idx) (end':'idx))= any
    [ good (start:'idx) (end':'idx)-> {C_Range start end' = input} (! ret {start} {end'})
    | bad (start:'idx) (end':'idx)-> {C_Range start end' <> input} {false} any ]
    
  
  function t_Range__start (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range a _ -> a
      end
  
  function t_Range__end (self : t_Range 'idx) : 'idx =
    match self with
      | C_Range _ a -> a
      end
end
module M_index_range__test_range
  let%span sindex_range0 = "../index_range.rs" 29 18 29 30
  
  let%span sindex_range1 = "../index_range.rs" 34 17 34 18
  
  let%span sindex_range2 = "../index_range.rs" 34 20 34 21
  
  let%span sindex_range3 = "../index_range.rs" 35 23 35 24
  
  let%span sindex_range4 = "../index_range.rs" 35 30 35 31
  
  let%span sindex_range5 = "../index_range.rs" 35 28 35 32
  
  let%span sindex_range6 = "../index_range.rs" 35 36 35 37
  
  let%span sindex_range7 = "../index_range.rs" 35 43 35 44
  
  let%span sindex_range8 = "../index_range.rs" 35 41 35 45
  
  let%span sindex_range9 = "../index_range.rs" 35 49 35 50
  
  let%span sindex_range10 = "../index_range.rs" 37 17 37 18
  
  let%span sindex_range11 = "../index_range.rs" 37 20 37 21
  
  let%span sindex_range12 = "../index_range.rs" 38 23 38 24
  
  let%span sindex_range13 = "../index_range.rs" 38 30 38 31
  
  let%span sindex_range14 = "../index_range.rs" 38 28 38 32
  
  let%span sindex_range15 = "../index_range.rs" 38 36 38 37
  
  let%span sindex_range16 = "../index_range.rs" 38 43 38 44
  
  let%span sindex_range17 = "../index_range.rs" 38 41 38 45
  
  let%span sindex_range18 = "../index_range.rs" 38 49 38 50
  
  let%span sindex_range19 = "../index_range.rs" 43 16 43 17
  
  let%span sindex_range20 = "../index_range.rs" 43 19 43 20
  
  let%span sindex_range21 = "../index_range.rs" 43 31 43 32
  
  let%span sindex_range22 = "../index_range.rs" 45 16 45 17
  
  let%span sindex_range23 = "../index_range.rs" 45 19 45 20
  
  let%span sindex_range24 = "../index_range.rs" 45 31 45 32
  
  let%span sindex_range25 = "../index_range.rs" 50 20 50 21
  
  let%span sindex_range26 = "../index_range.rs" 50 23 50 24
  
  let%span sindex_range27 = "../index_range.rs" 52 20 52 21
  
  let%span sindex_range28 = "../index_range.rs" 52 23 52 24
  
  let%span sindex_range29 = "../index_range.rs" 54 20 54 21
  
  let%span sindex_range30 = "../index_range.rs" 54 23 54 24
  
  let%span sindex_range31 = "../index_range.rs" 56 20 56 22
  
  let%span sindex_range32 = "../index_range.rs" 56 24 56 26
  
  let%span sindex_range33 = "../index_range.rs" 59 21 59 22
  
  let%span sindex_range34 = "../index_range.rs" 59 24 59 25
  
  let%span sindex_range35 = "../index_range.rs" 60 23 60 24
  
  let%span sindex_range36 = "../index_range.rs" 61 6 61 7
  
  let%span sindex_range37 = "../index_range.rs" 61 4 61 8
  
  let%span sindex_range38 = "../index_range.rs" 61 11 61 13
  
  let%span sindex_range39 = "../index_range.rs" 62 6 62 7
  
  let%span sindex_range40 = "../index_range.rs" 62 4 62 8
  
  let%span sindex_range41 = "../index_range.rs" 62 11 62 13
  
  let%span sindex_range42 = "../index_range.rs" 67 14 67 15
  
  let%span sindex_range43 = "../index_range.rs" 67 12 67 16
  
  let%span sindex_range44 = "../index_range.rs" 67 20 67 21
  
  let%span sindex_range45 = "../index_range.rs" 69 25 69 26
  
  let%span sindex_range46 = "../index_range.rs" 70 16 70 17
  
  let%span sindex_range47 = "../index_range.rs" 70 22 70 23
  
  let%span sindex_range48 = "../index_range.rs" 71 16 71 17
  
  let%span sindex_range49 = "../index_range.rs" 71 22 71 24
  
  let%span sindex_range50 = "../index_range.rs" 72 16 72 17
  
  let%span sindex_range51 = "../index_range.rs" 72 22 72 24
  
  let%span sindex_range52 = "../index_range.rs" 73 16 73 17
  
  let%span sindex_range53 = "../index_range.rs" 73 22 73 23
  
  let%span sindex_range54 = "../index_range.rs" 74 16 74 17
  
  let%span sindex_range55 = "../index_range.rs" 74 22 74 23
  
  let%span sindex_range56 = "../index_range.rs" 74 4 74 24
  
  let%span sindex_range57 = "../index_range.rs" 73 4 73 24
  
  let%span sindex_range58 = "../index_range.rs" 72 4 72 25
  
  let%span sindex_range59 = "../index_range.rs" 71 4 71 25
  
  let%span sindex_range60 = "../index_range.rs" 70 4 70 24
  
  let%span sindex_range61 = "../index_range.rs" 69 4 69 27
  
  let%span sindex_range62 = "../index_range.rs" 67 4 67 22
  
  let%span sindex_range63 = "../index_range.rs" 60 4 60 25
  
  let%span sindex_range64 = "../index_range.rs" 56 4 56 38
  
  let%span sindex_range65 = "../index_range.rs" 54 4 54 36
  
  let%span sindex_range66 = "../index_range.rs" 52 4 52 36
  
  let%span sindex_range67 = "../index_range.rs" 50 4 50 36
  
  let%span sindex_range68 = "../index_range.rs" 45 4 45 33
  
  let%span sindex_range69 = "../index_range.rs" 43 4 43 33
  
  let%span sindex_range70 = "../index_range.rs" 38 4 38 51
  
  let%span sindex_range71 = "../index_range.rs" 35 4 35 51
  
  let%span span72 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span73 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span74 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span75 = "" 0 0 0 0
  
  let%span span76 = "../../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  
  let%span span77 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  let%span span78 = "../../../../creusot-contracts/src/std/slice.rs" 16 20 16 30
  
  let%span span79 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span80 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span81 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span82 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span83 = "../../../../creusot-contracts/src/std/slice.rs" 131 20 131 37
  
  let%span span84 = "../../../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  
  let%span span85 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span86 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span87 = "" 0 0 0 0
  
  let%span span88 = "" 0 0 0 0
  
  let%span span89 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span90 = "" 0 0 0 0
  
  let%span span91 = "" 0 0 0 0
  
  let%span span92 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span93 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span94 = "../../../../creusot-contracts/src/std/slice.rs" 158 8 161 9
  
  let%span span95 = "../../../../creusot-contracts/src/std/slice.rs" 152 20 152 67
  
  let%span span96 = "../../../../creusot-contracts/src/std/slice.rs" 146 20 146 70
  
  let%span span97 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span98 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span99 = "" 0 0 0 0
  
  let%span span100 = "" 0 0 0 0
  
  let%span span101 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span102 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span103 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span104 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span105 = "" 0 0 0 0
  
  let%span span106 = "" 0 0 0 0
  
  let%span span107 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  
  let%span span108 = "" 0 0 0 0
  
  let%span span109 = "" 0 0 0 0
  
  let%span span110 = "../../../../creusot-contracts/src/std/slice.rs" 264 8 264 102
  
  let%span span111 = "../../../../creusot-contracts/src/std/slice.rs" 265 18 265 55
  
  let%span span112 = "" 0 0 0 0
  
  let%span span113 = "" 0 0 0 0
  
  let%span span114 = "../../../../creusot-contracts/src/std/vec.rs" 163 26 163 42
  
  let%span span115 = "" 0 0 0 0
  
  let%span span116 = "" 0 0 0 0
  
  let%span span117 = "../../../../creusot-contracts/src/std/slice.rs" 247 0 356 1
  
  let%span span118 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span119 = "../index_range.rs" 7 4 12 22
  
  use prelude.prelude.Int32
  
  predicate inv'11 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'13 (self : int32) =
    [%#span72] inv'11 self
  
  predicate inv'13 (_1 : int32)
  
  axiom inv'13 : forall x : int32 . inv'13 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'12 (self : Seq.seq int32) =
    [%#span73] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'12 (_1 : Seq.seq int32)
  
  axiom inv'12 : forall x : Seq.seq int32 . inv'12 x = true
  
  predicate invariant'11 (self : int32) =
    [%#span74] true
  
  axiom inv'11 : forall x : int32 . inv'11 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span75] (18446744073709551615 : usize)
  
  function shallow_model'4 (self : slice int32) : Seq.seq int32
  
  axiom shallow_model'4_spec : forall self : slice int32 . ([%#span77] shallow_model'4 self = Slice.id self)
  && ([%#span76] Seq.length (shallow_model'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'10 (self : slice int32) =
    [%#span78] inv'12 (shallow_model'4 self)
  
  predicate inv'10 (_1 : slice int32)
  
  axiom inv'10 : forall x : slice int32 . inv'10 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span79] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'9 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span80] inv'12 (shallow_model'0 self)
  
  predicate inv'9 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'9 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'9 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'8 (self : int32) =
    [%#span81] inv'11 self
  
  predicate inv'8 (_1 : int32)
  
  axiom inv'8 : forall x : int32 . inv'8 x = true
  
  predicate invariant'7 (self : usize) =
    [%#span74] true
  
  predicate inv'7 (_1 : usize)
  
  axiom inv'7 : forall x : usize . inv'7 x = true
  
  predicate invariant'6 (self : borrowed (slice int32)) =
    [%#span82] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'6 (_1 : borrowed (slice int32))
  
  axiom inv'6 : forall x : borrowed (slice int32) . inv'6 x = true
  
  predicate invariant'5 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span82] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'5 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'5 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (slice int32))
  
  predicate invariant'4 (self : Option'0.t_Option (slice int32)) =
    [%#span81] inv'3 self
  
  predicate inv'4 (_1 : Option'0.t_Option (slice int32))
  
  axiom inv'4 : forall x : Option'0.t_Option (slice int32) . inv'4 x = true
  
  predicate invariant'3 (self : Option'0.t_Option (slice int32)) =
    [%#span74] true
  
  axiom inv'3 : forall x : Option'0.t_Option (slice int32) . inv'3 x = true
  
  predicate invariant'2 (self : slice int32) =
    [%#span81] inv'10 self
  
  predicate inv'2 (_1 : slice int32)
  
  axiom inv'2 : forall x : slice int32 . inv'2 x = true
  
  use T_core__ops__range__Range as Range'0
  
  predicate invariant'1 (self : Range'0.t_Range usize) =
    [%#span74] true
  
  predicate inv'1 (_1 : Range'0.t_Range usize)
  
  axiom inv'1 : forall x : Range'0.t_Range usize . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span81] inv'9 self
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate has_value'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) (out : int32) =
    [%#span83] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) =
    [%#span84] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32 =
    [%#span85] shallow_model'0 self
  
  let rec index'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:usize) (return'  (ret:int32))= {[@expl:precondition] [%#span88] inv'7 index}
    {[@expl:precondition] [%#span87] inv'0 self}
    {[@expl:precondition] [%#span86] in_bounds'1 index (shallow_model'1 self)}
    any
    [ return' (result:int32)-> {[%#span90] inv'8 result}
      {[%#span89] has_value'1 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:usize))= {[@expl:precondition] [%#span91] inv'0 self}
    any
    [ return' (result:usize)-> {[%#span92] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (slice int32)) =
    [%#span93] self.final = self.current
  
  use T_core__ops__range__Range as T_core__ops__range__Range
  
  predicate resolve_elswhere'0 (self : Range'0.t_Range usize) (old' : Seq.seq int32) (fin : Seq.seq int32) =
    [%#span94] forall i : int . 0 <= i
    /\ (i < UIntSize.to_int (T_core__ops__range__Range.t_Range__start self)
    \/ UIntSize.to_int (T_core__ops__range__Range.t_Range__end self) <= i)
    /\ i < Seq.length old'  -> Seq.get old' i = Seq.get fin i
  
  use prelude.seq_ext.SeqExt
  
  predicate has_value'0 (self : Range'0.t_Range usize) (seq : Seq.seq int32) (out : slice int32) =
    [%#span95] SeqExt.subsequence seq (UIntSize.to_int (T_core__ops__range__Range.t_Range__start self)) (UIntSize.to_int (T_core__ops__range__Range.t_Range__end self))
    = shallow_model'4 out
  
  predicate in_bounds'0 (self : Range'0.t_Range usize) (seq : Seq.seq int32) =
    [%#span96] UIntSize.to_int (T_core__ops__range__Range.t_Range__start self)
    <= UIntSize.to_int (T_core__ops__range__Range.t_Range__end self)
    /\ UIntSize.to_int (T_core__ops__range__Range.t_Range__end self) <= Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span97] shallow_model'0 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (index:Range'0.t_Range usize) (return'  (ret:borrowed (slice int32)))= {[@expl:precondition] [%#span100] inv'1 index}
    {[@expl:precondition] [%#span99] inv'5 self}
    {[@expl:precondition] [%#span98] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (slice int32))-> {[%#span105] inv'6 result}
      {[%#span104] Seq.length (shallow_model'0 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span103] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'0 self.final)}
      {[%#span102] has_value'0 index (shallow_model'0 self.final) result.final}
      {[%#span101] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option (slice int32)) (return'  (ret:bool))= {[@expl:precondition] [%#span106] inv'4 self}
    any [ return' (result:bool)-> {[%#span107] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  function shallow_model'2 (self : slice int32) : Seq.seq int32 =
    [%#span85] shallow_model'4 self
  
  let rec get'0 (self:slice int32) (index:Range'0.t_Range usize) (return'  (ret:Option'0.t_Option (slice int32)))= {[@expl:precondition] [%#span109] inv'1 index}
    {[@expl:precondition] [%#span108] inv'2 self}
    any
    [ return' (result:Option'0.t_Option (slice int32))-> {[%#span112] inv'3 result}
      {[%#span111] in_bounds'0 index (shallow_model'2 self) \/ result = Option'0.C_None}
      {[%#span110] in_bounds'0 index (shallow_model'2 self)
       -> (exists r : slice int32 . result = Option'0.C_Some r /\ has_value'0 index (shallow_model'2 self) r)}
      (! return' {result}) ]
    
  
  let rec deref'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:slice int32))= {[@expl:precondition] [%#span113] inv'0 self}
    any
    [ return' (result:slice int32)-> {[%#span115] inv'2 result}
      {[%#span114] shallow_model'2 result = shallow_model'1 self}
      (! return' {result}) ]
    
  
  let rec len'0 (self:slice int32) (return'  (ret:usize))= {[@expl:precondition] [%#span116] inv'2 self}
    any
    [ return' (result:usize)-> {[%#span117] Seq.length (shallow_model'2 self) = UIntSize.to_int result}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:Range'0.t_Range usize) (return'  (ret:slice int32))= {[@expl:precondition] [%#span88] inv'1 index}
    {[@expl:precondition] [%#span87] inv'0 self}
    {[@expl:precondition] [%#span86] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:slice int32)-> {[%#span90] inv'2 result}
      {[%#span89] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span118] Seq.get (shallow_model'0 self) ix
  
  let rec create_arr'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span119] Seq.length (shallow_model'0 result) = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
  
  let rec test_range (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = create_arr'0 {[%#sindex_range0] ()}
          (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &_5 <- Range'0.C_Range ([%#sindex_range1] (0 : usize)) ([%#sindex_range2] (2 : usize)) ] s1
      | s1 = index'0 {arr} {_5} (fun (_ret':slice int32) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &s <- _3 ] s1 | s1 = len'0 {s} (fun (_ret':usize) ->  [ &_8 <- _ret' ] s2) | s2 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.eq {_8} {[%#sindex_range3] (2 : usize)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb11) | br1 -> {_7} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &_12 <- [%#sindex_range4] (0 : usize) ] s1
      | s1 =  [ &_13 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_12} {_13} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range5] _14} s4
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Slice.get <int32> {s} {_12}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range6] (0 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1))
      | s1 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 =  [ &_17 <- [%#sindex_range7] (1 : usize) ] s1
      | s1 =  [ &_18 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_17} {_18} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range8] _19} s4
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = Slice.get <int32> {s} {_17}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range9] (1 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &_24 <- Range'0.C_Range ([%#sindex_range10] (3 : usize)) ([%#sindex_range11] (5 : usize)) ] s1
      | s1 = index'0 {arr} {_24} (fun (_ret':slice int32) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb13 ]
      
    | bb13 = s0 [ s0 =  [ &s1 <- _22 ] s1 | s1 = len'0 {s1} (fun (_ret':usize) ->  [ &_27 <- _ret' ] s2) | s2 = bb14 ] 
    | bb14 = s0
      [ s0 = UIntSize.eq {_27} {[%#sindex_range12] (2 : usize)} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1)
      | s1 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb15) ]  ]
      
    | bb15 = s0
      [ s0 =  [ &_31 <- [%#sindex_range13] (0 : usize) ] s1
      | s1 =  [ &_32 <- Slice.length s1 ] s2
      | s2 = UIntSize.lt {_31} {_32} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range14] _33} s4
      | s4 = bb16 ]
      
    | bb16 = s0
      [ s0 = Slice.get <int32> {s1} {_31}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range15] (3 : int32)} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s1))
      | s1 = any [ br0 -> {_29 = false} (! bb21) | br1 -> {_29} (! bb17) ]  ]
      
    | bb17 = s0
      [ s0 =  [ &_36 <- [%#sindex_range16] (1 : usize) ] s1
      | s1 =  [ &_37 <- Slice.length s1 ] s2
      | s2 = UIntSize.lt {_36} {_37} (fun (_ret':bool) ->  [ &_38 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range17] _38} s4
      | s4 = bb18 ]
      
    | bb18 = s0
      [ s0 = Slice.get <int32> {s1} {_36}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range18] (4 : int32)} (fun (_ret':bool) ->  [ &_34 <- _ret' ] s1))
      | s1 = any [ br0 -> {_34 = false} (! bb20) | br1 -> {_34} (! bb19) ]  ]
      
    | bb19 = s0
      [ s0 =  [ &_46 <- Range'0.C_Range ([%#sindex_range19] (2 : usize)) ([%#sindex_range20] (2 : usize)) ] s1
      | s1 = index'0 {arr} {_46} (fun (_ret':slice int32) ->  [ &_44 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0 [ s0 = len'0 {_44} (fun (_ret':usize) ->  [ &_42 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 = UIntSize.eq {_42} {[%#sindex_range21] (0 : usize)} (fun (_ret':bool) ->  [ &_41 <- _ret' ] s1)
      | s1 = any [ br0 -> {_41 = false} (! bb27) | br1 -> {_41} (! bb26) ]  ]
      
    | bb26 = s0
      [ s0 =  [ &_54 <- Range'0.C_Range ([%#sindex_range22] (5 : usize)) ([%#sindex_range23] (5 : usize)) ] s1
      | s1 = index'0 {arr} {_54} (fun (_ret':slice int32) ->  [ &_52 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0 [ s0 = len'0 {_52} (fun (_ret':usize) ->  [ &_50 <- _ret' ] s1) | s1 = bb29 ] 
    | bb29 = s0
      [ s0 = UIntSize.eq {_50} {[%#sindex_range24] (0 : usize)} (fun (_ret':bool) ->  [ &_49 <- _ret' ] s1)
      | s1 = any [ br0 -> {_49 = false} (! bb31) | br1 -> {_49} (! bb30) ]  ]
      
    | bb30 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_61 <- _ret' ] s1) | s1 = bb32 ] 
    | bb32 = s0
      [ s0 =  [ &_63 <- Range'0.C_Range ([%#sindex_range25] (2 : usize)) ([%#sindex_range26] (6 : usize)) ] s1
      | s1 = get'0 {_61} {_63} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_59 <- _ret' ] s2)
      | s2 = bb33 ]
      
    | bb33 = s0 [ s0 = is_none'0 {_59} (fun (_ret':bool) ->  [ &_57 <- _ret' ] s1) | s1 = bb34 ] 
    | bb34 = any [ br0 -> {_57 = false} (! bb36) | br1 -> {_57} (! bb35) ] 
    | bb35 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_70 <- _ret' ] s1) | s1 = bb37 ] 
    | bb37 = s0
      [ s0 =  [ &_72 <- Range'0.C_Range ([%#sindex_range27] (2 : usize)) ([%#sindex_range28] (1 : usize)) ] s1
      | s1 = get'0 {_70} {_72} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_68 <- _ret' ] s2)
      | s2 = bb38 ]
      
    | bb38 = s0 [ s0 = is_none'0 {_68} (fun (_ret':bool) ->  [ &_66 <- _ret' ] s1) | s1 = bb39 ] 
    | bb39 = any [ br0 -> {_66 = false} (! bb41) | br1 -> {_66} (! bb40) ] 
    | bb40 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_79 <- _ret' ] s1) | s1 = bb42 ] 
    | bb42 = s0
      [ s0 =  [ &_81 <- Range'0.C_Range ([%#sindex_range29] (6 : usize)) ([%#sindex_range30] (6 : usize)) ] s1
      | s1 = get'0 {_79} {_81} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_77 <- _ret' ] s2)
      | s2 = bb43 ]
      
    | bb43 = s0 [ s0 = is_none'0 {_77} (fun (_ret':bool) ->  [ &_75 <- _ret' ] s1) | s1 = bb44 ] 
    | bb44 = any [ br0 -> {_75 = false} (! bb46) | br1 -> {_75} (! bb45) ] 
    | bb45 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_88 <- _ret' ] s1) | s1 = bb47 ] 
    | bb47 = s0
      [ s0 =  [ &_90 <- Range'0.C_Range ([%#sindex_range31] (10 : usize)) ([%#sindex_range32] (10 : usize)) ] s1
      | s1 = get'0 {_88} {_90} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_86 <- _ret' ] s2)
      | s2 = bb48 ]
      
    | bb48 = s0 [ s0 = is_none'0 {_86} (fun (_ret':bool) ->  [ &_84 <- _ret' ] s1) | s1 = bb49 ] 
    | bb49 = any [ br0 -> {_84 = false} (! bb51) | br1 -> {_84} (! bb50) ] 
    | bb50 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_94 <- _ret' ]  [ &arr <- _94.final ] s1)
      | s1 =  [ &_95 <- Range'0.C_Range ([%#sindex_range33] (1 : usize)) ([%#sindex_range34] (4 : usize)) ] s2
      | s2 = index_mut'0 {_94} {_95} (fun (_ret':borrowed (slice int32)) ->  [ &_93 <- _ret' ] s3)
      | s3 = bb52 ]
      
    | bb52 = s0
      [ s0 = Borrow.borrow_final <slice int32> {_93.current} {Borrow.get_id _93}
          (fun (_ret':borrowed (slice int32)) ->  [ &s2 <- _ret' ]  [ &_93 <- { _93 with current = s2.final ; } ] s1)
      | s1 = len'0 {s2.current} (fun (_ret':usize) ->  [ &_98 <- _ret' ] s2)
      | s2 = bb53 ]
      
    | bb53 = s0
      [ s0 = UIntSize.eq {_98} {[%#sindex_range35] (3 : usize)} (fun (_ret':bool) ->  [ &_97 <- _ret' ] s1)
      | s1 = any [ br0 -> {_97 = false} (! bb55) | br1 -> {_97} (! bb54) ]  ]
      
    | bb54 = s0
      [ s0 =  [ &_101 <- [%#sindex_range36] (0 : usize) ] s1
      | s1 =  [ &_102 <- Slice.length s2.current ] s2
      | s2 = UIntSize.lt {_101} {_102} (fun (_ret':bool) ->  [ &_103 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range37] _103} s4
      | s4 = bb56 ]
      
    | bb56 = s0
      [ s0 = Slice.get <int32> {s2.current} {_101}
          (fun (l'0:int32) ->
            Slice.set <int32> {s2.current} {_101} {[%#sindex_range38] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s2 <- { s2 with current = l'1 ; } ] s1))
      | s1 =  [ &_104 <- [%#sindex_range39] (1 : usize) ] s2
      | s2 =  [ &_105 <- Slice.length s2.current ] s3
      | s3 = UIntSize.lt {_104} {_105} (fun (_ret':bool) ->  [ &_106 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range40] _106} s5
      | s5 = bb57 ]
      
    | bb57 = s0
      [ s0 = Slice.get <int32> {s2.current} {_104}
          (fun (l'0:int32) ->
            Slice.set <int32> {s2.current} {_104} {[%#sindex_range41] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s2 <- { s2 with current = l'1 ; } ] s1))
      | s1 =  [ &_110 <- [%#sindex_range42] (2 : usize) ] s2
      | s2 =  [ &_111 <- Slice.length s2.current ] s3
      | s3 = UIntSize.lt {_110} {_111} (fun (_ret':bool) ->  [ &_112 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range43] _112} s5
      | s5 = bb58 ]
      
    | bb58 = s0
      [ s0 = -{resolve'0 s2}- s1
      | s1 = -{resolve'0 _93}- s2
      | s2 = Slice.get <int32> {s2.current} {_110}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range44] (3 : int32)} (fun (_ret':bool) ->  [ &_108 <- _ret' ] s3))
      | s3 = any [ br0 -> {_108 = false} (! bb60) | br1 -> {_108} (! bb59) ]  ]
      
    | bb59 = s0 [ s0 = len'1 {arr} (fun (_ret':usize) ->  [ &_116 <- _ret' ] s1) | s1 = bb61 ] 
    | bb61 = s0
      [ s0 = UIntSize.eq {_116} {[%#sindex_range45] (5 : usize)} (fun (_ret':bool) ->  [ &_115 <- _ret' ] s1)
      | s1 = any [ br0 -> {_115 = false} (! bb63) | br1 -> {_115} (! bb62) ]  ]
      
    | bb62 = s0
      [ s0 = index'1 {arr} {[%#sindex_range46] (0 : usize)} (fun (_ret':int32) ->  [ &_122 <- _ret' ] s1) | s1 = bb64 ]
      
    | bb64 = s0
      [ s0 = Int32.eq {_122} {[%#sindex_range47] (0 : int32)} (fun (_ret':bool) ->  [ &_120 <- _ret' ] s1)
      | s1 = any [ br0 -> {_120 = false} (! bb66) | br1 -> {_120} (! bb65) ]  ]
      
    | bb65 = s0
      [ s0 = index'1 {arr} {[%#sindex_range48] (1 : usize)} (fun (_ret':int32) ->  [ &_128 <- _ret' ] s1) | s1 = bb67 ]
      
    | bb67 = s0
      [ s0 = Int32.eq {_128} {[%#sindex_range49] (-1 : int32)} (fun (_ret':bool) ->  [ &_126 <- _ret' ] s1)
      | s1 = any [ br0 -> {_126 = false} (! bb69) | br1 -> {_126} (! bb68) ]  ]
      
    | bb68 = s0
      [ s0 = index'1 {arr} {[%#sindex_range50] (2 : usize)} (fun (_ret':int32) ->  [ &_134 <- _ret' ] s1) | s1 = bb70 ]
      
    | bb70 = s0
      [ s0 = Int32.eq {_134} {[%#sindex_range51] (-1 : int32)} (fun (_ret':bool) ->  [ &_132 <- _ret' ] s1)
      | s1 = any [ br0 -> {_132 = false} (! bb72) | br1 -> {_132} (! bb71) ]  ]
      
    | bb71 = s0
      [ s0 = index'1 {arr} {[%#sindex_range52] (3 : usize)} (fun (_ret':int32) ->  [ &_140 <- _ret' ] s1) | s1 = bb73 ]
      
    | bb73 = s0
      [ s0 = Int32.eq {_140} {[%#sindex_range53] (3 : int32)} (fun (_ret':bool) ->  [ &_138 <- _ret' ] s1)
      | s1 = any [ br0 -> {_138 = false} (! bb75) | br1 -> {_138} (! bb74) ]  ]
      
    | bb74 = s0
      [ s0 = index'1 {arr} {[%#sindex_range54] (4 : usize)} (fun (_ret':int32) ->  [ &_146 <- _ret' ] s1) | s1 = bb76 ]
      
    | bb76 = s0
      [ s0 = Int32.eq {_146} {[%#sindex_range55] (4 : int32)} (fun (_ret':bool) ->  [ &_144 <- _ret' ] s1)
      | s1 = any [ br0 -> {_144 = false} (! bb78) | br1 -> {_144} (! bb77) ]  ]
      
    | bb77 = bb79
    | bb79 = return' {_0}
    | bb78 = {[%#sindex_range56] false} any
    | bb75 = {[%#sindex_range57] false} any
    | bb72 = {[%#sindex_range58] false} any
    | bb69 = {[%#sindex_range59] false} any
    | bb66 = {[%#sindex_range60] false} any
    | bb63 = {[%#sindex_range61] false} any
    | bb60 = {[%#sindex_range62] false} any
    | bb55 = s0 [ s0 = -{resolve'0 s2}- s1 | s1 = -{resolve'0 _93}- s2 | s2 = {[%#sindex_range63] false} any ] 
    | bb51 = {[%#sindex_range64] false} any
    | bb46 = {[%#sindex_range65] false} any
    | bb41 = {[%#sindex_range66] false} any
    | bb36 = {[%#sindex_range67] false} any
    | bb31 = {[%#sindex_range68] false} any
    | bb27 = {[%#sindex_range69] false} any
    | bb20 = bb23
    | bb21 = bb23
    | bb22 = bb23
    | bb23 = {[%#sindex_range70] false} any
    | bb9 = bb12
    | bb10 = bb12
    | bb11 = bb12
    | bb12 = {[%#sindex_range71] false} any ]
    )
    [ & _0 : () = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & s : slice int32 = any_l ()
    | & _3 : slice int32 = any_l ()
    | & _5 : Range'0.t_Range usize = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : usize = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : usize = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : usize = any_l ()
    | & _19 : bool = any_l ()
    | & s1 : slice int32 = any_l ()
    | & _22 : slice int32 = any_l ()
    | & _24 : Range'0.t_Range usize = any_l ()
    | & _26 : bool = any_l ()
    | & _27 : usize = any_l ()
    | & _29 : bool = any_l ()
    | & _31 : usize = any_l ()
    | & _32 : usize = any_l ()
    | & _33 : bool = any_l ()
    | & _34 : bool = any_l ()
    | & _36 : usize = any_l ()
    | & _37 : usize = any_l ()
    | & _38 : bool = any_l ()
    | & _41 : bool = any_l ()
    | & _42 : usize = any_l ()
    | & _44 : slice int32 = any_l ()
    | & _46 : Range'0.t_Range usize = any_l ()
    | & _49 : bool = any_l ()
    | & _50 : usize = any_l ()
    | & _52 : slice int32 = any_l ()
    | & _54 : Range'0.t_Range usize = any_l ()
    | & _57 : bool = any_l ()
    | & _59 : Option'0.t_Option (slice int32) = any_l ()
    | & _61 : slice int32 = any_l ()
    | & _63 : Range'0.t_Range usize = any_l ()
    | & _66 : bool = any_l ()
    | & _68 : Option'0.t_Option (slice int32) = any_l ()
    | & _70 : slice int32 = any_l ()
    | & _72 : Range'0.t_Range usize = any_l ()
    | & _75 : bool = any_l ()
    | & _77 : Option'0.t_Option (slice int32) = any_l ()
    | & _79 : slice int32 = any_l ()
    | & _81 : Range'0.t_Range usize = any_l ()
    | & _84 : bool = any_l ()
    | & _86 : Option'0.t_Option (slice int32) = any_l ()
    | & _88 : slice int32 = any_l ()
    | & _90 : Range'0.t_Range usize = any_l ()
    | & s2 : borrowed (slice int32) = any_l ()
    | & _93 : borrowed (slice int32) = any_l ()
    | & _94 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _95 : Range'0.t_Range usize = any_l ()
    | & _97 : bool = any_l ()
    | & _98 : usize = any_l ()
    | & _101 : usize = any_l ()
    | & _102 : usize = any_l ()
    | & _103 : bool = any_l ()
    | & _104 : usize = any_l ()
    | & _105 : usize = any_l ()
    | & _106 : bool = any_l ()
    | & _108 : bool = any_l ()
    | & _110 : usize = any_l ()
    | & _111 : usize = any_l ()
    | & _112 : bool = any_l ()
    | & _115 : bool = any_l ()
    | & _116 : usize = any_l ()
    | & _120 : bool = any_l ()
    | & _122 : int32 = any_l ()
    | & _126 : bool = any_l ()
    | & _128 : int32 = any_l ()
    | & _132 : bool = any_l ()
    | & _134 : int32 = any_l ()
    | & _138 : bool = any_l ()
    | & _140 : int32 = any_l ()
    | & _144 : bool = any_l ()
    | & _146 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__ops__range__RangeTo
  type t_RangeTo 'idx =
    | C_RangeTo 'idx
  
  function any_l (_ : 'b) : 'a
  
  let rec t_RangeTo < 'idx > (input:t_RangeTo 'idx) (ret  (end':'idx))= any
    [ good (end':'idx)-> {C_RangeTo end' = input} (! ret {end'})
    | bad (end':'idx)-> {C_RangeTo end' <> input} {false} any ]
    
  
  function t_RangeTo__end (self : t_RangeTo 'idx) : 'idx =
    match self with
      | C_RangeTo a -> a
      end
end
module M_index_range__test_range_to
  let%span sindex_range0 = "../index_range.rs" 80 18 80 30
  
  let%span sindex_range1 = "../index_range.rs" 85 19 85 20
  
  let%span sindex_range2 = "../index_range.rs" 86 23 86 24
  
  let%span sindex_range3 = "../index_range.rs" 86 30 86 31
  
  let%span sindex_range4 = "../index_range.rs" 86 28 86 32
  
  let%span sindex_range5 = "../index_range.rs" 86 36 86 37
  
  let%span sindex_range6 = "../index_range.rs" 86 43 86 44
  
  let%span sindex_range7 = "../index_range.rs" 86 41 86 45
  
  let%span sindex_range8 = "../index_range.rs" 86 49 86 50
  
  let%span sindex_range9 = "../index_range.rs" 91 18 91 19
  
  let%span sindex_range10 = "../index_range.rs" 91 30 91 31
  
  let%span sindex_range11 = "../index_range.rs" 96 22 96 23
  
  let%span sindex_range12 = "../index_range.rs" 99 23 99 24
  
  let%span sindex_range13 = "../index_range.rs" 100 23 100 24
  
  let%span sindex_range14 = "../index_range.rs" 101 6 101 7
  
  let%span sindex_range15 = "../index_range.rs" 101 4 101 8
  
  let%span sindex_range16 = "../index_range.rs" 101 11 101 13
  
  let%span sindex_range17 = "../index_range.rs" 102 6 102 7
  
  let%span sindex_range18 = "../index_range.rs" 102 4 102 8
  
  let%span sindex_range19 = "../index_range.rs" 102 11 102 13
  
  let%span sindex_range20 = "../index_range.rs" 104 14 104 15
  
  let%span sindex_range21 = "../index_range.rs" 104 12 104 16
  
  let%span sindex_range22 = "../index_range.rs" 104 20 104 21
  
  let%span sindex_range23 = "../index_range.rs" 106 25 106 26
  
  let%span sindex_range24 = "../index_range.rs" 107 16 107 17
  
  let%span sindex_range25 = "../index_range.rs" 107 22 107 24
  
  let%span sindex_range26 = "../index_range.rs" 108 16 108 17
  
  let%span sindex_range27 = "../index_range.rs" 108 22 108 23
  
  let%span sindex_range28 = "../index_range.rs" 109 16 109 17
  
  let%span sindex_range29 = "../index_range.rs" 109 22 109 24
  
  let%span sindex_range30 = "../index_range.rs" 110 16 110 17
  
  let%span sindex_range31 = "../index_range.rs" 110 22 110 23
  
  let%span sindex_range32 = "../index_range.rs" 111 16 111 17
  
  let%span sindex_range33 = "../index_range.rs" 111 22 111 23
  
  let%span sindex_range34 = "../index_range.rs" 111 4 111 24
  
  let%span sindex_range35 = "../index_range.rs" 110 4 110 24
  
  let%span sindex_range36 = "../index_range.rs" 109 4 109 25
  
  let%span sindex_range37 = "../index_range.rs" 108 4 108 24
  
  let%span sindex_range38 = "../index_range.rs" 107 4 107 25
  
  let%span sindex_range39 = "../index_range.rs" 106 4 106 27
  
  let%span sindex_range40 = "../index_range.rs" 104 4 104 22
  
  let%span sindex_range41 = "../index_range.rs" 100 4 100 25
  
  let%span sindex_range42 = "../index_range.rs" 96 4 96 35
  
  let%span sindex_range43 = "../index_range.rs" 91 4 91 32
  
  let%span sindex_range44 = "../index_range.rs" 86 4 86 51
  
  let%span span45 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span46 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span47 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span48 = "" 0 0 0 0
  
  let%span span49 = "../../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  
  let%span span50 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  let%span span51 = "../../../../creusot-contracts/src/std/slice.rs" 16 20 16 30
  
  let%span span52 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span53 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span54 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span55 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span56 = "../../../../creusot-contracts/src/std/slice.rs" 131 20 131 37
  
  let%span span57 = "../../../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  
  let%span span58 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span59 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span60 = "" 0 0 0 0
  
  let%span span61 = "" 0 0 0 0
  
  let%span span62 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span63 = "" 0 0 0 0
  
  let%span span64 = "" 0 0 0 0
  
  let%span span65 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span66 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span67 = "../../../../creusot-contracts/src/std/slice.rs" 181 8 181 90
  
  let%span span68 = "../../../../creusot-contracts/src/std/slice.rs" 175 20 175 57
  
  let%span span69 = "../../../../creusot-contracts/src/std/slice.rs" 169 20 169 42
  
  let%span span70 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span71 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span72 = "" 0 0 0 0
  
  let%span span73 = "" 0 0 0 0
  
  let%span span74 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span75 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span76 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span77 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span78 = "" 0 0 0 0
  
  let%span span79 = "" 0 0 0 0
  
  let%span span80 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  
  let%span span81 = "" 0 0 0 0
  
  let%span span82 = "" 0 0 0 0
  
  let%span span83 = "../../../../creusot-contracts/src/std/slice.rs" 264 8 264 102
  
  let%span span84 = "../../../../creusot-contracts/src/std/slice.rs" 265 18 265 55
  
  let%span span85 = "" 0 0 0 0
  
  let%span span86 = "" 0 0 0 0
  
  let%span span87 = "../../../../creusot-contracts/src/std/vec.rs" 163 26 163 42
  
  let%span span88 = "" 0 0 0 0
  
  let%span span89 = "" 0 0 0 0
  
  let%span span90 = "../../../../creusot-contracts/src/std/slice.rs" 247 0 356 1
  
  let%span span91 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span92 = "../index_range.rs" 7 4 12 22
  
  use prelude.prelude.Int32
  
  predicate inv'11 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'13 (self : int32) =
    [%#span45] inv'11 self
  
  predicate inv'13 (_1 : int32)
  
  axiom inv'13 : forall x : int32 . inv'13 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'12 (self : Seq.seq int32) =
    [%#span46] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'12 (_1 : Seq.seq int32)
  
  axiom inv'12 : forall x : Seq.seq int32 . inv'12 x = true
  
  predicate invariant'11 (self : int32) =
    [%#span47] true
  
  axiom inv'11 : forall x : int32 . inv'11 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span48] (18446744073709551615 : usize)
  
  function shallow_model'4 (self : slice int32) : Seq.seq int32
  
  axiom shallow_model'4_spec : forall self : slice int32 . ([%#span50] shallow_model'4 self = Slice.id self)
  && ([%#span49] Seq.length (shallow_model'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'10 (self : slice int32) =
    [%#span51] inv'12 (shallow_model'4 self)
  
  predicate inv'10 (_1 : slice int32)
  
  axiom inv'10 : forall x : slice int32 . inv'10 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span52] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'9 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span53] inv'12 (shallow_model'0 self)
  
  predicate inv'9 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'9 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'9 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'8 (self : int32) =
    [%#span54] inv'11 self
  
  predicate inv'8 (_1 : int32)
  
  axiom inv'8 : forall x : int32 . inv'8 x = true
  
  predicate invariant'7 (self : usize) =
    [%#span47] true
  
  predicate inv'7 (_1 : usize)
  
  axiom inv'7 : forall x : usize . inv'7 x = true
  
  predicate invariant'6 (self : borrowed (slice int32)) =
    [%#span55] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'6 (_1 : borrowed (slice int32))
  
  axiom inv'6 : forall x : borrowed (slice int32) . inv'6 x = true
  
  predicate invariant'5 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span55] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'5 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'5 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (slice int32))
  
  predicate invariant'4 (self : Option'0.t_Option (slice int32)) =
    [%#span54] inv'3 self
  
  predicate inv'4 (_1 : Option'0.t_Option (slice int32))
  
  axiom inv'4 : forall x : Option'0.t_Option (slice int32) . inv'4 x = true
  
  predicate invariant'3 (self : Option'0.t_Option (slice int32)) =
    [%#span47] true
  
  axiom inv'3 : forall x : Option'0.t_Option (slice int32) . inv'3 x = true
  
  predicate invariant'2 (self : slice int32) =
    [%#span54] inv'10 self
  
  predicate inv'2 (_1 : slice int32)
  
  axiom inv'2 : forall x : slice int32 . inv'2 x = true
  
  use T_core__ops__range__RangeTo as RangeTo'0
  
  predicate invariant'1 (self : RangeTo'0.t_RangeTo usize) =
    [%#span47] true
  
  predicate inv'1 (_1 : RangeTo'0.t_RangeTo usize)
  
  axiom inv'1 : forall x : RangeTo'0.t_RangeTo usize . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span54] inv'9 self
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate has_value'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) (out : int32) =
    [%#span56] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) =
    [%#span57] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32 =
    [%#span58] shallow_model'0 self
  
  let rec index'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:usize) (return'  (ret:int32))= {[@expl:precondition] [%#span61] inv'7 index}
    {[@expl:precondition] [%#span60] inv'0 self}
    {[@expl:precondition] [%#span59] in_bounds'1 index (shallow_model'1 self)}
    any
    [ return' (result:int32)-> {[%#span63] inv'8 result}
      {[%#span62] has_value'1 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:usize))= {[@expl:precondition] [%#span64] inv'0 self}
    any
    [ return' (result:usize)-> {[%#span65] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (slice int32)) =
    [%#span66] self.final = self.current
  
  use T_core__ops__range__RangeTo as T_core__ops__range__RangeTo
  
  predicate resolve_elswhere'0 (self : RangeTo'0.t_RangeTo usize) (old' : Seq.seq int32) (fin : Seq.seq int32) =
    [%#span67] forall i : int . UIntSize.to_int (T_core__ops__range__RangeTo.t_RangeTo__end self) <= i
    /\ i < Seq.length old'  -> Seq.get old' i = Seq.get fin i
  
  use prelude.seq_ext.SeqExt
  
  predicate has_value'0 (self : RangeTo'0.t_RangeTo usize) (seq : Seq.seq int32) (out : slice int32) =
    [%#span68] SeqExt.subsequence seq 0 (UIntSize.to_int (T_core__ops__range__RangeTo.t_RangeTo__end self))
    = shallow_model'4 out
  
  predicate in_bounds'0 (self : RangeTo'0.t_RangeTo usize) (seq : Seq.seq int32) =
    [%#span69] UIntSize.to_int (T_core__ops__range__RangeTo.t_RangeTo__end self) <= Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span70] shallow_model'0 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (index:RangeTo'0.t_RangeTo usize) (return'  (ret:borrowed (slice int32)))= {[@expl:precondition] [%#span73] inv'1 index}
    {[@expl:precondition] [%#span72] inv'5 self}
    {[@expl:precondition] [%#span71] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (slice int32))-> {[%#span78] inv'6 result}
      {[%#span77] Seq.length (shallow_model'0 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span76] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'0 self.final)}
      {[%#span75] has_value'0 index (shallow_model'0 self.final) result.final}
      {[%#span74] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option (slice int32)) (return'  (ret:bool))= {[@expl:precondition] [%#span79] inv'4 self}
    any [ return' (result:bool)-> {[%#span80] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  function shallow_model'2 (self : slice int32) : Seq.seq int32 =
    [%#span58] shallow_model'4 self
  
  let rec get'0 (self:slice int32) (index:RangeTo'0.t_RangeTo usize) (return'  (ret:Option'0.t_Option (slice int32)))= {[@expl:precondition] [%#span82] inv'1 index}
    {[@expl:precondition] [%#span81] inv'2 self}
    any
    [ return' (result:Option'0.t_Option (slice int32))-> {[%#span85] inv'3 result}
      {[%#span84] in_bounds'0 index (shallow_model'2 self) \/ result = Option'0.C_None}
      {[%#span83] in_bounds'0 index (shallow_model'2 self)
       -> (exists r : slice int32 . result = Option'0.C_Some r /\ has_value'0 index (shallow_model'2 self) r)}
      (! return' {result}) ]
    
  
  let rec deref'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:slice int32))= {[@expl:precondition] [%#span86] inv'0 self}
    any
    [ return' (result:slice int32)-> {[%#span88] inv'2 result}
      {[%#span87] shallow_model'2 result = shallow_model'1 self}
      (! return' {result}) ]
    
  
  let rec len'0 (self:slice int32) (return'  (ret:usize))= {[@expl:precondition] [%#span89] inv'2 self}
    any
    [ return' (result:usize)-> {[%#span90] Seq.length (shallow_model'2 self) = UIntSize.to_int result}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:RangeTo'0.t_RangeTo usize) (return'  (ret:slice int32))= {[@expl:precondition] [%#span61] inv'1 index}
    {[@expl:precondition] [%#span60] inv'0 self}
    {[@expl:precondition] [%#span59] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:slice int32)-> {[%#span63] inv'2 result}
      {[%#span62] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span91] Seq.get (shallow_model'0 self) ix
  
  let rec create_arr'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span92] Seq.length (shallow_model'0 result) = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
  
  let rec test_range_to (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = create_arr'0 {[%#sindex_range0] ()}
          (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &_5 <- RangeTo'0.C_RangeTo ([%#sindex_range1] (2 : usize)) ] s1
      | s1 = index'0 {arr} {_5} (fun (_ret':slice int32) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &s <- _3 ] s1 | s1 = len'0 {s} (fun (_ret':usize) ->  [ &_8 <- _ret' ] s2) | s2 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.eq {_8} {[%#sindex_range2] (2 : usize)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb11) | br1 -> {_7} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &_12 <- [%#sindex_range3] (0 : usize) ] s1
      | s1 =  [ &_13 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_12} {_13} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range4] _14} s4
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Slice.get <int32> {s} {_12}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range5] (0 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1))
      | s1 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 =  [ &_17 <- [%#sindex_range6] (1 : usize) ] s1
      | s1 =  [ &_18 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_17} {_18} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range7] _19} s4
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = Slice.get <int32> {s} {_17}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range8] (1 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &_27 <- RangeTo'0.C_RangeTo ([%#sindex_range9] (0 : usize)) ] s1
      | s1 = index'0 {arr} {_27} (fun (_ret':slice int32) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb13 ]
      
    | bb13 = s0 [ s0 = len'0 {_25} (fun (_ret':usize) ->  [ &_23 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 = UIntSize.eq {_23} {[%#sindex_range10] (0 : usize)} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1)
      | s1 = any [ br0 -> {_22 = false} (! bb16) | br1 -> {_22} (! bb15) ]  ]
      
    | bb15 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_34 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_36 <- RangeTo'0.C_RangeTo ([%#sindex_range11] (6 : usize)) ] s1
      | s1 = get'0 {_34} {_36} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_32 <- _ret' ] s2)
      | s2 = bb18 ]
      
    | bb18 = s0 [ s0 = is_none'0 {_32} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1) | s1 = bb19 ] 
    | bb19 = any [ br0 -> {_30 = false} (! bb21) | br1 -> {_30} (! bb20) ] 
    | bb20 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_40 <- _ret' ]  [ &arr <- _40.final ] s1)
      | s1 =  [ &_41 <- RangeTo'0.C_RangeTo ([%#sindex_range12] (3 : usize)) ] s2
      | s2 = index_mut'0 {_40} {_41} (fun (_ret':borrowed (slice int32)) ->  [ &_39 <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = Borrow.borrow_final <slice int32> {_39.current} {Borrow.get_id _39}
          (fun (_ret':borrowed (slice int32)) ->  [ &s1 <- _ret' ]  [ &_39 <- { _39 with current = s1.final ; } ] s1)
      | s1 = len'0 {s1.current} (fun (_ret':usize) ->  [ &_44 <- _ret' ] s2)
      | s2 = bb23 ]
      
    | bb23 = s0
      [ s0 = UIntSize.eq {_44} {[%#sindex_range13] (3 : usize)} (fun (_ret':bool) ->  [ &_43 <- _ret' ] s1)
      | s1 = any [ br0 -> {_43 = false} (! bb25) | br1 -> {_43} (! bb24) ]  ]
      
    | bb24 = s0
      [ s0 =  [ &_47 <- [%#sindex_range14] (0 : usize) ] s1
      | s1 =  [ &_48 <- Slice.length s1.current ] s2
      | s2 = UIntSize.lt {_47} {_48} (fun (_ret':bool) ->  [ &_49 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range15] _49} s4
      | s4 = bb26 ]
      
    | bb26 = s0
      [ s0 = Slice.get <int32> {s1.current} {_47}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_47} {[%#sindex_range16] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_50 <- [%#sindex_range17] (2 : usize) ] s2
      | s2 =  [ &_51 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_50} {_51} (fun (_ret':bool) ->  [ &_52 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range18] _52} s5
      | s5 = bb27 ]
      
    | bb27 = s0
      [ s0 = Slice.get <int32> {s1.current} {_50}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_50} {[%#sindex_range19] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_56 <- [%#sindex_range20] (1 : usize) ] s2
      | s2 =  [ &_57 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_56} {_57} (fun (_ret':bool) ->  [ &_58 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range21] _58} s5
      | s5 = bb28 ]
      
    | bb28 = s0
      [ s0 = -{resolve'0 s1}- s1
      | s1 = -{resolve'0 _39}- s2
      | s2 = Slice.get <int32> {s1.current} {_56}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range22] (1 : int32)} (fun (_ret':bool) ->  [ &_54 <- _ret' ] s3))
      | s3 = any [ br0 -> {_54 = false} (! bb30) | br1 -> {_54} (! bb29) ]  ]
      
    | bb29 = s0 [ s0 = len'1 {arr} (fun (_ret':usize) ->  [ &_62 <- _ret' ] s1) | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = UIntSize.eq {_62} {[%#sindex_range23] (5 : usize)} (fun (_ret':bool) ->  [ &_61 <- _ret' ] s1)
      | s1 = any [ br0 -> {_61 = false} (! bb33) | br1 -> {_61} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 = index'1 {arr} {[%#sindex_range24] (0 : usize)} (fun (_ret':int32) ->  [ &_68 <- _ret' ] s1) | s1 = bb34 ]
      
    | bb34 = s0
      [ s0 = Int32.eq {_68} {[%#sindex_range25] (-1 : int32)} (fun (_ret':bool) ->  [ &_66 <- _ret' ] s1)
      | s1 = any [ br0 -> {_66 = false} (! bb36) | br1 -> {_66} (! bb35) ]  ]
      
    | bb35 = s0
      [ s0 = index'1 {arr} {[%#sindex_range26] (1 : usize)} (fun (_ret':int32) ->  [ &_74 <- _ret' ] s1) | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int32.eq {_74} {[%#sindex_range27] (1 : int32)} (fun (_ret':bool) ->  [ &_72 <- _ret' ] s1)
      | s1 = any [ br0 -> {_72 = false} (! bb39) | br1 -> {_72} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 = index'1 {arr} {[%#sindex_range28] (2 : usize)} (fun (_ret':int32) ->  [ &_80 <- _ret' ] s1) | s1 = bb40 ]
      
    | bb40 = s0
      [ s0 = Int32.eq {_80} {[%#sindex_range29] (-1 : int32)} (fun (_ret':bool) ->  [ &_78 <- _ret' ] s1)
      | s1 = any [ br0 -> {_78 = false} (! bb42) | br1 -> {_78} (! bb41) ]  ]
      
    | bb41 = s0
      [ s0 = index'1 {arr} {[%#sindex_range30] (3 : usize)} (fun (_ret':int32) ->  [ &_86 <- _ret' ] s1) | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int32.eq {_86} {[%#sindex_range31] (3 : int32)} (fun (_ret':bool) ->  [ &_84 <- _ret' ] s1)
      | s1 = any [ br0 -> {_84 = false} (! bb45) | br1 -> {_84} (! bb44) ]  ]
      
    | bb44 = s0
      [ s0 = index'1 {arr} {[%#sindex_range32] (4 : usize)} (fun (_ret':int32) ->  [ &_92 <- _ret' ] s1) | s1 = bb46 ]
      
    | bb46 = s0
      [ s0 = Int32.eq {_92} {[%#sindex_range33] (4 : int32)} (fun (_ret':bool) ->  [ &_90 <- _ret' ] s1)
      | s1 = any [ br0 -> {_90 = false} (! bb48) | br1 -> {_90} (! bb47) ]  ]
      
    | bb47 = bb49
    | bb49 = return' {_0}
    | bb48 = {[%#sindex_range34] false} any
    | bb45 = {[%#sindex_range35] false} any
    | bb42 = {[%#sindex_range36] false} any
    | bb39 = {[%#sindex_range37] false} any
    | bb36 = {[%#sindex_range38] false} any
    | bb33 = {[%#sindex_range39] false} any
    | bb30 = {[%#sindex_range40] false} any
    | bb25 = s0 [ s0 = -{resolve'0 s1}- s1 | s1 = -{resolve'0 _39}- s2 | s2 = {[%#sindex_range41] false} any ] 
    | bb21 = {[%#sindex_range42] false} any
    | bb16 = {[%#sindex_range43] false} any
    | bb9 = bb12
    | bb10 = bb12
    | bb11 = bb12
    | bb12 = {[%#sindex_range44] false} any ]
    )
    [ & _0 : () = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & s : slice int32 = any_l ()
    | & _3 : slice int32 = any_l ()
    | & _5 : RangeTo'0.t_RangeTo usize = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : usize = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : usize = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : usize = any_l ()
    | & _19 : bool = any_l ()
    | & _22 : bool = any_l ()
    | & _23 : usize = any_l ()
    | & _25 : slice int32 = any_l ()
    | & _27 : RangeTo'0.t_RangeTo usize = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : Option'0.t_Option (slice int32) = any_l ()
    | & _34 : slice int32 = any_l ()
    | & _36 : RangeTo'0.t_RangeTo usize = any_l ()
    | & s1 : borrowed (slice int32) = any_l ()
    | & _39 : borrowed (slice int32) = any_l ()
    | & _40 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _41 : RangeTo'0.t_RangeTo usize = any_l ()
    | & _43 : bool = any_l ()
    | & _44 : usize = any_l ()
    | & _47 : usize = any_l ()
    | & _48 : usize = any_l ()
    | & _49 : bool = any_l ()
    | & _50 : usize = any_l ()
    | & _51 : usize = any_l ()
    | & _52 : bool = any_l ()
    | & _54 : bool = any_l ()
    | & _56 : usize = any_l ()
    | & _57 : usize = any_l ()
    | & _58 : bool = any_l ()
    | & _61 : bool = any_l ()
    | & _62 : usize = any_l ()
    | & _66 : bool = any_l ()
    | & _68 : int32 = any_l ()
    | & _72 : bool = any_l ()
    | & _74 : int32 = any_l ()
    | & _78 : bool = any_l ()
    | & _80 : int32 = any_l ()
    | & _84 : bool = any_l ()
    | & _86 : int32 = any_l ()
    | & _90 : bool = any_l ()
    | & _92 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__ops__range__RangeFrom
  type t_RangeFrom 'idx =
    | C_RangeFrom 'idx
  
  function any_l (_ : 'b) : 'a
  
  let rec t_RangeFrom < 'idx > (input:t_RangeFrom 'idx) (ret  (start:'idx))= any
    [ good (start:'idx)-> {C_RangeFrom start = input} (! ret {start})
    | bad (start:'idx)-> {C_RangeFrom start <> input} {false} any ]
    
  
  function t_RangeFrom__start (self : t_RangeFrom 'idx) : 'idx =
    match self with
      | C_RangeFrom a -> a
      end
end
module M_index_range__test_range_from
  let%span sindex_range0 = "../index_range.rs" 117 18 117 30
  
  let%span sindex_range1 = "../index_range.rs" 122 17 122 18
  
  let%span sindex_range2 = "../index_range.rs" 123 23 123 24
  
  let%span sindex_range3 = "../index_range.rs" 123 30 123 31
  
  let%span sindex_range4 = "../index_range.rs" 123 28 123 32
  
  let%span sindex_range5 = "../index_range.rs" 123 36 123 37
  
  let%span sindex_range6 = "../index_range.rs" 123 43 123 44
  
  let%span sindex_range7 = "../index_range.rs" 123 41 123 45
  
  let%span sindex_range8 = "../index_range.rs" 123 49 123 50
  
  let%span sindex_range9 = "../index_range.rs" 128 16 128 17
  
  let%span sindex_range10 = "../index_range.rs" 128 30 128 31
  
  let%span sindex_range11 = "../index_range.rs" 133 20 133 21
  
  let%span sindex_range12 = "../index_range.rs" 135 20 135 22
  
  let%span sindex_range13 = "../index_range.rs" 138 21 138 22
  
  let%span sindex_range14 = "../index_range.rs" 139 23 139 24
  
  let%span sindex_range15 = "../index_range.rs" 140 6 140 7
  
  let%span sindex_range16 = "../index_range.rs" 140 4 140 8
  
  let%span sindex_range17 = "../index_range.rs" 140 11 140 13
  
  let%span sindex_range18 = "../index_range.rs" 141 6 141 7
  
  let%span sindex_range19 = "../index_range.rs" 141 4 141 8
  
  let%span sindex_range20 = "../index_range.rs" 141 11 141 13
  
  let%span sindex_range21 = "../index_range.rs" 143 14 143 15
  
  let%span sindex_range22 = "../index_range.rs" 143 12 143 16
  
  let%span sindex_range23 = "../index_range.rs" 143 20 143 21
  
  let%span sindex_range24 = "../index_range.rs" 145 25 145 26
  
  let%span sindex_range25 = "../index_range.rs" 146 16 146 17
  
  let%span sindex_range26 = "../index_range.rs" 146 22 146 23
  
  let%span sindex_range27 = "../index_range.rs" 147 16 147 17
  
  let%span sindex_range28 = "../index_range.rs" 147 22 147 23
  
  let%span sindex_range29 = "../index_range.rs" 148 16 148 17
  
  let%span sindex_range30 = "../index_range.rs" 148 22 148 24
  
  let%span sindex_range31 = "../index_range.rs" 149 16 149 17
  
  let%span sindex_range32 = "../index_range.rs" 149 22 149 24
  
  let%span sindex_range33 = "../index_range.rs" 150 16 150 17
  
  let%span sindex_range34 = "../index_range.rs" 150 22 150 23
  
  let%span sindex_range35 = "../index_range.rs" 150 4 150 24
  
  let%span sindex_range36 = "../index_range.rs" 149 4 149 25
  
  let%span sindex_range37 = "../index_range.rs" 148 4 148 25
  
  let%span sindex_range38 = "../index_range.rs" 147 4 147 24
  
  let%span sindex_range39 = "../index_range.rs" 146 4 146 24
  
  let%span sindex_range40 = "../index_range.rs" 145 4 145 27
  
  let%span sindex_range41 = "../index_range.rs" 143 4 143 22
  
  let%span sindex_range42 = "../index_range.rs" 139 4 139 25
  
  let%span sindex_range43 = "../index_range.rs" 135 4 135 36
  
  let%span sindex_range44 = "../index_range.rs" 133 4 133 35
  
  let%span sindex_range45 = "../index_range.rs" 128 4 128 32
  
  let%span sindex_range46 = "../index_range.rs" 123 4 123 51
  
  let%span span47 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span48 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span49 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span50 = "" 0 0 0 0
  
  let%span span51 = "../../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  
  let%span span52 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  let%span span53 = "../../../../creusot-contracts/src/std/slice.rs" 16 20 16 30
  
  let%span span54 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span55 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span56 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span57 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span58 = "../../../../creusot-contracts/src/std/slice.rs" 131 20 131 37
  
  let%span span59 = "../../../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  
  let%span span60 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span61 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span62 = "" 0 0 0 0
  
  let%span span63 = "" 0 0 0 0
  
  let%span span64 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span65 = "" 0 0 0 0
  
  let%span span66 = "" 0 0 0 0
  
  let%span span67 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span68 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span69 = "../../../../creusot-contracts/src/std/slice.rs" 201 8 203 9
  
  let%span span70 = "../../../../creusot-contracts/src/std/slice.rs" 195 20 195 67
  
  let%span span71 = "../../../../creusot-contracts/src/std/slice.rs" 189 20 189 44
  
  let%span span72 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span73 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span74 = "" 0 0 0 0
  
  let%span span75 = "" 0 0 0 0
  
  let%span span76 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span77 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span78 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span79 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span80 = "" 0 0 0 0
  
  let%span span81 = "" 0 0 0 0
  
  let%span span82 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  
  let%span span83 = "" 0 0 0 0
  
  let%span span84 = "" 0 0 0 0
  
  let%span span85 = "../../../../creusot-contracts/src/std/slice.rs" 264 8 264 102
  
  let%span span86 = "../../../../creusot-contracts/src/std/slice.rs" 265 18 265 55
  
  let%span span87 = "" 0 0 0 0
  
  let%span span88 = "" 0 0 0 0
  
  let%span span89 = "../../../../creusot-contracts/src/std/vec.rs" 163 26 163 42
  
  let%span span90 = "" 0 0 0 0
  
  let%span span91 = "" 0 0 0 0
  
  let%span span92 = "../../../../creusot-contracts/src/std/slice.rs" 247 0 356 1
  
  let%span span93 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span94 = "../index_range.rs" 7 4 12 22
  
  use prelude.prelude.Int32
  
  predicate inv'11 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'13 (self : int32) =
    [%#span47] inv'11 self
  
  predicate inv'13 (_1 : int32)
  
  axiom inv'13 : forall x : int32 . inv'13 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'12 (self : Seq.seq int32) =
    [%#span48] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'12 (_1 : Seq.seq int32)
  
  axiom inv'12 : forall x : Seq.seq int32 . inv'12 x = true
  
  predicate invariant'11 (self : int32) =
    [%#span49] true
  
  axiom inv'11 : forall x : int32 . inv'11 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span50] (18446744073709551615 : usize)
  
  function shallow_model'4 (self : slice int32) : Seq.seq int32
  
  axiom shallow_model'4_spec : forall self : slice int32 . ([%#span52] shallow_model'4 self = Slice.id self)
  && ([%#span51] Seq.length (shallow_model'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'10 (self : slice int32) =
    [%#span53] inv'12 (shallow_model'4 self)
  
  predicate inv'10 (_1 : slice int32)
  
  axiom inv'10 : forall x : slice int32 . inv'10 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span54] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'9 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span55] inv'12 (shallow_model'0 self)
  
  predicate inv'9 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'9 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'9 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'8 (self : int32) =
    [%#span56] inv'11 self
  
  predicate inv'8 (_1 : int32)
  
  axiom inv'8 : forall x : int32 . inv'8 x = true
  
  predicate invariant'7 (self : usize) =
    [%#span49] true
  
  predicate inv'7 (_1 : usize)
  
  axiom inv'7 : forall x : usize . inv'7 x = true
  
  predicate invariant'6 (self : borrowed (slice int32)) =
    [%#span57] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'6 (_1 : borrowed (slice int32))
  
  axiom inv'6 : forall x : borrowed (slice int32) . inv'6 x = true
  
  predicate invariant'5 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span57] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'5 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'5 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (slice int32))
  
  predicate invariant'4 (self : Option'0.t_Option (slice int32)) =
    [%#span56] inv'3 self
  
  predicate inv'4 (_1 : Option'0.t_Option (slice int32))
  
  axiom inv'4 : forall x : Option'0.t_Option (slice int32) . inv'4 x = true
  
  predicate invariant'3 (self : Option'0.t_Option (slice int32)) =
    [%#span49] true
  
  axiom inv'3 : forall x : Option'0.t_Option (slice int32) . inv'3 x = true
  
  predicate invariant'2 (self : slice int32) =
    [%#span56] inv'10 self
  
  predicate inv'2 (_1 : slice int32)
  
  axiom inv'2 : forall x : slice int32 . inv'2 x = true
  
  use T_core__ops__range__RangeFrom as RangeFrom'0
  
  predicate invariant'1 (self : RangeFrom'0.t_RangeFrom usize) =
    [%#span49] true
  
  predicate inv'1 (_1 : RangeFrom'0.t_RangeFrom usize)
  
  axiom inv'1 : forall x : RangeFrom'0.t_RangeFrom usize . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span56] inv'9 self
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate has_value'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) (out : int32) =
    [%#span58] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) =
    [%#span59] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32 =
    [%#span60] shallow_model'0 self
  
  let rec index'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:usize) (return'  (ret:int32))= {[@expl:precondition] [%#span63] inv'7 index}
    {[@expl:precondition] [%#span62] inv'0 self}
    {[@expl:precondition] [%#span61] in_bounds'1 index (shallow_model'1 self)}
    any
    [ return' (result:int32)-> {[%#span65] inv'8 result}
      {[%#span64] has_value'1 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:usize))= {[@expl:precondition] [%#span66] inv'0 self}
    any
    [ return' (result:usize)-> {[%#span67] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (slice int32)) =
    [%#span68] self.final = self.current
  
  use T_core__ops__range__RangeFrom as T_core__ops__range__RangeFrom
  
  predicate resolve_elswhere'0 (self : RangeFrom'0.t_RangeFrom usize) (old' : Seq.seq int32) (fin : Seq.seq int32) =
    [%#span69] forall i : int . 0 <= i
    /\ i < UIntSize.to_int (T_core__ops__range__RangeFrom.t_RangeFrom__start self) /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  use prelude.seq_ext.SeqExt
  
  predicate has_value'0 (self : RangeFrom'0.t_RangeFrom usize) (seq : Seq.seq int32) (out : slice int32) =
    [%#span70] SeqExt.subsequence seq (UIntSize.to_int (T_core__ops__range__RangeFrom.t_RangeFrom__start self)) (Seq.length seq)
    = shallow_model'4 out
  
  predicate in_bounds'0 (self : RangeFrom'0.t_RangeFrom usize) (seq : Seq.seq int32) =
    [%#span71] UIntSize.to_int (T_core__ops__range__RangeFrom.t_RangeFrom__start self) <= Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span72] shallow_model'0 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (index:RangeFrom'0.t_RangeFrom usize) (return'  (ret:borrowed (slice int32)))= {[@expl:precondition] [%#span75] inv'1 index}
    {[@expl:precondition] [%#span74] inv'5 self}
    {[@expl:precondition] [%#span73] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (slice int32))-> {[%#span80] inv'6 result}
      {[%#span79] Seq.length (shallow_model'0 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span78] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'0 self.final)}
      {[%#span77] has_value'0 index (shallow_model'0 self.final) result.final}
      {[%#span76] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option (slice int32)) (return'  (ret:bool))= {[@expl:precondition] [%#span81] inv'4 self}
    any [ return' (result:bool)-> {[%#span82] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  function shallow_model'2 (self : slice int32) : Seq.seq int32 =
    [%#span60] shallow_model'4 self
  
  let rec get'0 (self:slice int32) (index:RangeFrom'0.t_RangeFrom usize) (return'  (ret:Option'0.t_Option (slice int32)))= {[@expl:precondition] [%#span84] inv'1 index}
    {[@expl:precondition] [%#span83] inv'2 self}
    any
    [ return' (result:Option'0.t_Option (slice int32))-> {[%#span87] inv'3 result}
      {[%#span86] in_bounds'0 index (shallow_model'2 self) \/ result = Option'0.C_None}
      {[%#span85] in_bounds'0 index (shallow_model'2 self)
       -> (exists r : slice int32 . result = Option'0.C_Some r /\ has_value'0 index (shallow_model'2 self) r)}
      (! return' {result}) ]
    
  
  let rec deref'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:slice int32))= {[@expl:precondition] [%#span88] inv'0 self}
    any
    [ return' (result:slice int32)-> {[%#span90] inv'2 result}
      {[%#span89] shallow_model'2 result = shallow_model'1 self}
      (! return' {result}) ]
    
  
  let rec len'0 (self:slice int32) (return'  (ret:usize))= {[@expl:precondition] [%#span91] inv'2 self}
    any
    [ return' (result:usize)-> {[%#span92] Seq.length (shallow_model'2 self) = UIntSize.to_int result}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:RangeFrom'0.t_RangeFrom usize) (return'  (ret:slice int32))= {[@expl:precondition] [%#span63] inv'1 index}
    {[@expl:precondition] [%#span62] inv'0 self}
    {[@expl:precondition] [%#span61] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:slice int32)-> {[%#span65] inv'2 result}
      {[%#span64] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span93] Seq.get (shallow_model'0 self) ix
  
  let rec create_arr'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span94] Seq.length (shallow_model'0 result) = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
  
  let rec test_range_from (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = create_arr'0 {[%#sindex_range0] ()}
          (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &_5 <- RangeFrom'0.C_RangeFrom ([%#sindex_range1] (3 : usize)) ] s1
      | s1 = index'0 {arr} {_5} (fun (_ret':slice int32) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &s <- _3 ] s1 | s1 = len'0 {s} (fun (_ret':usize) ->  [ &_8 <- _ret' ] s2) | s2 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.eq {_8} {[%#sindex_range2] (2 : usize)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb11) | br1 -> {_7} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &_12 <- [%#sindex_range3] (0 : usize) ] s1
      | s1 =  [ &_13 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_12} {_13} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range4] _14} s4
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Slice.get <int32> {s} {_12}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range5] (3 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1))
      | s1 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 =  [ &_17 <- [%#sindex_range6] (1 : usize) ] s1
      | s1 =  [ &_18 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_17} {_18} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range7] _19} s4
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = Slice.get <int32> {s} {_17}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range8] (4 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &_27 <- RangeFrom'0.C_RangeFrom ([%#sindex_range9] (5 : usize)) ] s1
      | s1 = index'0 {arr} {_27} (fun (_ret':slice int32) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb13 ]
      
    | bb13 = s0 [ s0 = len'0 {_25} (fun (_ret':usize) ->  [ &_23 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 = UIntSize.eq {_23} {[%#sindex_range10] (0 : usize)} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1)
      | s1 = any [ br0 -> {_22 = false} (! bb16) | br1 -> {_22} (! bb15) ]  ]
      
    | bb15 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_34 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_36 <- RangeFrom'0.C_RangeFrom ([%#sindex_range11] (6 : usize)) ] s1
      | s1 = get'0 {_34} {_36} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_32 <- _ret' ] s2)
      | s2 = bb18 ]
      
    | bb18 = s0 [ s0 = is_none'0 {_32} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1) | s1 = bb19 ] 
    | bb19 = any [ br0 -> {_30 = false} (! bb21) | br1 -> {_30} (! bb20) ] 
    | bb20 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_43 <- _ret' ] s1) | s1 = bb22 ] 
    | bb22 = s0
      [ s0 =  [ &_45 <- RangeFrom'0.C_RangeFrom ([%#sindex_range12] (10 : usize)) ] s1
      | s1 = get'0 {_43} {_45} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_41 <- _ret' ] s2)
      | s2 = bb23 ]
      
    | bb23 = s0 [ s0 = is_none'0 {_41} (fun (_ret':bool) ->  [ &_39 <- _ret' ] s1) | s1 = bb24 ] 
    | bb24 = any [ br0 -> {_39 = false} (! bb26) | br1 -> {_39} (! bb25) ] 
    | bb25 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_49 <- _ret' ]  [ &arr <- _49.final ] s1)
      | s1 =  [ &_50 <- RangeFrom'0.C_RangeFrom ([%#sindex_range13] (2 : usize)) ] s2
      | s2 = index_mut'0 {_49} {_50} (fun (_ret':borrowed (slice int32)) ->  [ &_48 <- _ret' ] s3)
      | s3 = bb27 ]
      
    | bb27 = s0
      [ s0 = Borrow.borrow_final <slice int32> {_48.current} {Borrow.get_id _48}
          (fun (_ret':borrowed (slice int32)) ->  [ &s1 <- _ret' ]  [ &_48 <- { _48 with current = s1.final ; } ] s1)
      | s1 = len'0 {s1.current} (fun (_ret':usize) ->  [ &_53 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = UIntSize.eq {_53} {[%#sindex_range14] (3 : usize)} (fun (_ret':bool) ->  [ &_52 <- _ret' ] s1)
      | s1 = any [ br0 -> {_52 = false} (! bb30) | br1 -> {_52} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 =  [ &_56 <- [%#sindex_range15] (0 : usize) ] s1
      | s1 =  [ &_57 <- Slice.length s1.current ] s2
      | s2 = UIntSize.lt {_56} {_57} (fun (_ret':bool) ->  [ &_58 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range16] _58} s4
      | s4 = bb31 ]
      
    | bb31 = s0
      [ s0 = Slice.get <int32> {s1.current} {_56}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_56} {[%#sindex_range17] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_59 <- [%#sindex_range18] (1 : usize) ] s2
      | s2 =  [ &_60 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_59} {_60} (fun (_ret':bool) ->  [ &_61 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range19] _61} s5
      | s5 = bb32 ]
      
    | bb32 = s0
      [ s0 = Slice.get <int32> {s1.current} {_59}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_59} {[%#sindex_range20] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_65 <- [%#sindex_range21] (2 : usize) ] s2
      | s2 =  [ &_66 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_65} {_66} (fun (_ret':bool) ->  [ &_67 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range22] _67} s5
      | s5 = bb33 ]
      
    | bb33 = s0
      [ s0 = -{resolve'0 s1}- s1
      | s1 = -{resolve'0 _48}- s2
      | s2 = Slice.get <int32> {s1.current} {_65}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range23] (4 : int32)} (fun (_ret':bool) ->  [ &_63 <- _ret' ] s3))
      | s3 = any [ br0 -> {_63 = false} (! bb35) | br1 -> {_63} (! bb34) ]  ]
      
    | bb34 = s0 [ s0 = len'1 {arr} (fun (_ret':usize) ->  [ &_71 <- _ret' ] s1) | s1 = bb36 ] 
    | bb36 = s0
      [ s0 = UIntSize.eq {_71} {[%#sindex_range24] (5 : usize)} (fun (_ret':bool) ->  [ &_70 <- _ret' ] s1)
      | s1 = any [ br0 -> {_70 = false} (! bb38) | br1 -> {_70} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 = index'1 {arr} {[%#sindex_range25] (0 : usize)} (fun (_ret':int32) ->  [ &_77 <- _ret' ] s1) | s1 = bb39 ]
      
    | bb39 = s0
      [ s0 = Int32.eq {_77} {[%#sindex_range26] (0 : int32)} (fun (_ret':bool) ->  [ &_75 <- _ret' ] s1)
      | s1 = any [ br0 -> {_75 = false} (! bb41) | br1 -> {_75} (! bb40) ]  ]
      
    | bb40 = s0
      [ s0 = index'1 {arr} {[%#sindex_range27] (1 : usize)} (fun (_ret':int32) ->  [ &_83 <- _ret' ] s1) | s1 = bb42 ]
      
    | bb42 = s0
      [ s0 = Int32.eq {_83} {[%#sindex_range28] (1 : int32)} (fun (_ret':bool) ->  [ &_81 <- _ret' ] s1)
      | s1 = any [ br0 -> {_81 = false} (! bb44) | br1 -> {_81} (! bb43) ]  ]
      
    | bb43 = s0
      [ s0 = index'1 {arr} {[%#sindex_range29] (2 : usize)} (fun (_ret':int32) ->  [ &_89 <- _ret' ] s1) | s1 = bb45 ]
      
    | bb45 = s0
      [ s0 = Int32.eq {_89} {[%#sindex_range30] (-1 : int32)} (fun (_ret':bool) ->  [ &_87 <- _ret' ] s1)
      | s1 = any [ br0 -> {_87 = false} (! bb47) | br1 -> {_87} (! bb46) ]  ]
      
    | bb46 = s0
      [ s0 = index'1 {arr} {[%#sindex_range31] (3 : usize)} (fun (_ret':int32) ->  [ &_95 <- _ret' ] s1) | s1 = bb48 ]
      
    | bb48 = s0
      [ s0 = Int32.eq {_95} {[%#sindex_range32] (-1 : int32)} (fun (_ret':bool) ->  [ &_93 <- _ret' ] s1)
      | s1 = any [ br0 -> {_93 = false} (! bb50) | br1 -> {_93} (! bb49) ]  ]
      
    | bb49 = s0
      [ s0 = index'1 {arr} {[%#sindex_range33] (4 : usize)} (fun (_ret':int32) ->  [ &_101 <- _ret' ] s1) | s1 = bb51 ]
      
    | bb51 = s0
      [ s0 = Int32.eq {_101} {[%#sindex_range34] (4 : int32)} (fun (_ret':bool) ->  [ &_99 <- _ret' ] s1)
      | s1 = any [ br0 -> {_99 = false} (! bb53) | br1 -> {_99} (! bb52) ]  ]
      
    | bb52 = bb54
    | bb54 = return' {_0}
    | bb53 = {[%#sindex_range35] false} any
    | bb50 = {[%#sindex_range36] false} any
    | bb47 = {[%#sindex_range37] false} any
    | bb44 = {[%#sindex_range38] false} any
    | bb41 = {[%#sindex_range39] false} any
    | bb38 = {[%#sindex_range40] false} any
    | bb35 = {[%#sindex_range41] false} any
    | bb30 = s0 [ s0 = -{resolve'0 s1}- s1 | s1 = -{resolve'0 _48}- s2 | s2 = {[%#sindex_range42] false} any ] 
    | bb26 = {[%#sindex_range43] false} any
    | bb21 = {[%#sindex_range44] false} any
    | bb16 = {[%#sindex_range45] false} any
    | bb9 = bb12
    | bb10 = bb12
    | bb11 = bb12
    | bb12 = {[%#sindex_range46] false} any ]
    )
    [ & _0 : () = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & s : slice int32 = any_l ()
    | & _3 : slice int32 = any_l ()
    | & _5 : RangeFrom'0.t_RangeFrom usize = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : usize = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : usize = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : usize = any_l ()
    | & _19 : bool = any_l ()
    | & _22 : bool = any_l ()
    | & _23 : usize = any_l ()
    | & _25 : slice int32 = any_l ()
    | & _27 : RangeFrom'0.t_RangeFrom usize = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : Option'0.t_Option (slice int32) = any_l ()
    | & _34 : slice int32 = any_l ()
    | & _36 : RangeFrom'0.t_RangeFrom usize = any_l ()
    | & _39 : bool = any_l ()
    | & _41 : Option'0.t_Option (slice int32) = any_l ()
    | & _43 : slice int32 = any_l ()
    | & _45 : RangeFrom'0.t_RangeFrom usize = any_l ()
    | & s1 : borrowed (slice int32) = any_l ()
    | & _48 : borrowed (slice int32) = any_l ()
    | & _49 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _50 : RangeFrom'0.t_RangeFrom usize = any_l ()
    | & _52 : bool = any_l ()
    | & _53 : usize = any_l ()
    | & _56 : usize = any_l ()
    | & _57 : usize = any_l ()
    | & _58 : bool = any_l ()
    | & _59 : usize = any_l ()
    | & _60 : usize = any_l ()
    | & _61 : bool = any_l ()
    | & _63 : bool = any_l ()
    | & _65 : usize = any_l ()
    | & _66 : usize = any_l ()
    | & _67 : bool = any_l ()
    | & _70 : bool = any_l ()
    | & _71 : usize = any_l ()
    | & _75 : bool = any_l ()
    | & _77 : int32 = any_l ()
    | & _81 : bool = any_l ()
    | & _83 : int32 = any_l ()
    | & _87 : bool = any_l ()
    | & _89 : int32 = any_l ()
    | & _93 : bool = any_l ()
    | & _95 : int32 = any_l ()
    | & _99 : bool = any_l ()
    | & _101 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__ops__range__RangeFull
  type t_RangeFull  =
    | C_RangeFull
  
  function any_l (_ : 'b) : 'a
  
  let rec t_RangeFull (input:t_RangeFull) (ret  )= any
    [ good -> {C_RangeFull  = input} (! ret) | bad -> {C_RangeFull  <> input} {false} any ]
    
end
module M_index_range__test_range_full
  let%span sindex_range0 = "../index_range.rs" 156 18 156 30
  
  let%span sindex_range1 = "../index_range.rs" 162 23 162 24
  
  let%span sindex_range2 = "../index_range.rs" 162 30 162 31
  
  let%span sindex_range3 = "../index_range.rs" 162 28 162 32
  
  let%span sindex_range4 = "../index_range.rs" 162 36 162 37
  
  let%span sindex_range5 = "../index_range.rs" 162 43 162 44
  
  let%span sindex_range6 = "../index_range.rs" 162 41 162 45
  
  let%span sindex_range7 = "../index_range.rs" 162 49 162 50
  
  let%span sindex_range8 = "../index_range.rs" 162 56 162 57
  
  let%span sindex_range9 = "../index_range.rs" 162 54 162 58
  
  let%span sindex_range10 = "../index_range.rs" 162 62 162 63
  
  let%span sindex_range11 = "../index_range.rs" 162 69 162 70
  
  let%span sindex_range12 = "../index_range.rs" 162 67 162 71
  
  let%span sindex_range13 = "../index_range.rs" 162 75 162 76
  
  let%span sindex_range14 = "../index_range.rs" 162 82 162 83
  
  let%span sindex_range15 = "../index_range.rs" 162 80 162 84
  
  let%span sindex_range16 = "../index_range.rs" 162 88 162 89
  
  let%span sindex_range17 = "../index_range.rs" 166 23 166 24
  
  let%span sindex_range18 = "../index_range.rs" 167 6 167 7
  
  let%span sindex_range19 = "../index_range.rs" 167 4 167 8
  
  let%span sindex_range20 = "../index_range.rs" 167 11 167 13
  
  let%span sindex_range21 = "../index_range.rs" 168 6 168 7
  
  let%span sindex_range22 = "../index_range.rs" 168 4 168 8
  
  let%span sindex_range23 = "../index_range.rs" 168 11 168 13
  
  let%span sindex_range24 = "../index_range.rs" 170 25 170 26
  
  let%span sindex_range25 = "../index_range.rs" 171 16 171 17
  
  let%span sindex_range26 = "../index_range.rs" 171 22 171 23
  
  let%span sindex_range27 = "../index_range.rs" 172 16 172 17
  
  let%span sindex_range28 = "../index_range.rs" 172 22 172 24
  
  let%span sindex_range29 = "../index_range.rs" 173 16 173 17
  
  let%span sindex_range30 = "../index_range.rs" 173 22 173 23
  
  let%span sindex_range31 = "../index_range.rs" 174 16 174 17
  
  let%span sindex_range32 = "../index_range.rs" 174 22 174 24
  
  let%span sindex_range33 = "../index_range.rs" 175 16 175 17
  
  let%span sindex_range34 = "../index_range.rs" 175 22 175 23
  
  let%span sindex_range35 = "../index_range.rs" 175 4 175 24
  
  let%span sindex_range36 = "../index_range.rs" 174 4 174 25
  
  let%span sindex_range37 = "../index_range.rs" 173 4 173 24
  
  let%span sindex_range38 = "../index_range.rs" 172 4 172 25
  
  let%span sindex_range39 = "../index_range.rs" 171 4 171 24
  
  let%span sindex_range40 = "../index_range.rs" 170 4 170 27
  
  let%span sindex_range41 = "../index_range.rs" 166 4 166 25
  
  let%span sindex_range42 = "../index_range.rs" 162 4 162 90
  
  let%span span43 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span44 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span45 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span46 = "" 0 0 0 0
  
  let%span span47 = "../../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  
  let%span span48 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  let%span span49 = "../../../../creusot-contracts/src/std/slice.rs" 16 20 16 30
  
  let%span span50 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span51 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span52 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span53 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span54 = "../../../../creusot-contracts/src/std/slice.rs" 131 20 131 37
  
  let%span span55 = "../../../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  
  let%span span56 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span57 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span58 = "" 0 0 0 0
  
  let%span span59 = "" 0 0 0 0
  
  let%span span60 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span61 = "" 0 0 0 0
  
  let%span span62 = "" 0 0 0 0
  
  let%span span63 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span64 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span65 = "../../../../creusot-contracts/src/std/slice.rs" 223 20 223 24
  
  let%span span66 = "../../../../creusot-contracts/src/std/slice.rs" 217 20 217 31
  
  let%span span67 = "../../../../creusot-contracts/src/std/slice.rs" 211 20 211 24
  
  let%span span68 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span69 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span70 = "" 0 0 0 0
  
  let%span span71 = "" 0 0 0 0
  
  let%span span72 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span73 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span74 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span75 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span76 = "" 0 0 0 0
  
  let%span span77 = "" 0 0 0 0
  
  let%span span78 = "../../../../creusot-contracts/src/std/slice.rs" 247 0 356 1
  
  let%span span79 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span80 = "../index_range.rs" 7 4 12 22
  
  use prelude.prelude.Int32
  
  predicate inv'9 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'11 (self : int32) =
    [%#span43] inv'9 self
  
  predicate inv'11 (_1 : int32)
  
  axiom inv'11 : forall x : int32 . inv'11 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'10 (self : Seq.seq int32) =
    [%#span44] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'11 (Seq.get self i)
  
  predicate inv'10 (_1 : Seq.seq int32)
  
  axiom inv'10 : forall x : Seq.seq int32 . inv'10 x = true
  
  predicate invariant'9 (self : int32) =
    [%#span45] true
  
  axiom inv'9 : forall x : int32 . inv'9 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span46] (18446744073709551615 : usize)
  
  function shallow_model'4 (self : slice int32) : Seq.seq int32
  
  axiom shallow_model'4_spec : forall self : slice int32 . ([%#span48] shallow_model'4 self = Slice.id self)
  && ([%#span47] Seq.length (shallow_model'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'8 (self : slice int32) =
    [%#span49] inv'10 (shallow_model'4 self)
  
  predicate inv'8 (_1 : slice int32)
  
  axiom inv'8 : forall x : slice int32 . inv'8 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span50] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'7 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span51] inv'10 (shallow_model'0 self)
  
  predicate inv'7 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'7 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'7 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'6 (self : int32) =
    [%#span52] inv'9 self
  
  predicate inv'6 (_1 : int32)
  
  axiom inv'6 : forall x : int32 . inv'6 x = true
  
  predicate invariant'5 (self : usize) =
    [%#span45] true
  
  predicate inv'5 (_1 : usize)
  
  axiom inv'5 : forall x : usize . inv'5 x = true
  
  predicate invariant'4 (self : borrowed (slice int32)) =
    [%#span53] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'4 (_1 : borrowed (slice int32))
  
  axiom inv'4 : forall x : borrowed (slice int32) . inv'4 x = true
  
  predicate invariant'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span53] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'3 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'3 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'3 x = true
  
  predicate invariant'2 (self : slice int32) =
    [%#span52] inv'8 self
  
  predicate inv'2 (_1 : slice int32)
  
  axiom inv'2 : forall x : slice int32 . inv'2 x = true
  
  use T_core__ops__range__RangeFull as RangeFull'0
  
  predicate invariant'1 (self : RangeFull'0.t_RangeFull) =
    [%#span45] true
  
  predicate inv'1 (_1 : RangeFull'0.t_RangeFull)
  
  axiom inv'1 : forall x : RangeFull'0.t_RangeFull . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span52] inv'7 self
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate has_value'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) (out : int32) =
    [%#span54] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) =
    [%#span55] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32 =
    [%#span56] shallow_model'0 self
  
  let rec index'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:usize) (return'  (ret:int32))= {[@expl:precondition] [%#span59] inv'5 index}
    {[@expl:precondition] [%#span58] inv'0 self}
    {[@expl:precondition] [%#span57] in_bounds'1 index (shallow_model'1 self)}
    any
    [ return' (result:int32)-> {[%#span61] inv'6 result}
      {[%#span60] has_value'1 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:usize))= {[@expl:precondition] [%#span62] inv'0 self}
    any
    [ return' (result:usize)-> {[%#span63] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (slice int32)) =
    [%#span64] self.final = self.current
  
  predicate resolve_elswhere'0 (self : RangeFull'0.t_RangeFull) (_old : Seq.seq int32) (_fin : Seq.seq int32) =
    [%#span65] true
  
  predicate has_value'0 (self : RangeFull'0.t_RangeFull) (seq : Seq.seq int32) (out : slice int32) =
    [%#span66] seq = shallow_model'4 out
  
  predicate in_bounds'0 (self : RangeFull'0.t_RangeFull) (_seq : Seq.seq int32) =
    [%#span67] true
  
  function shallow_model'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span68] shallow_model'0 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (index:RangeFull'0.t_RangeFull) (return'  (ret:borrowed (slice int32)))= {[@expl:precondition] [%#span71] inv'1 index}
    {[@expl:precondition] [%#span70] inv'3 self}
    {[@expl:precondition] [%#span69] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (slice int32))-> {[%#span76] inv'4 result}
      {[%#span75] Seq.length (shallow_model'0 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span74] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'0 self.final)}
      {[%#span73] has_value'0 index (shallow_model'0 self.final) result.final}
      {[%#span72] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  function shallow_model'2 (self : slice int32) : Seq.seq int32 =
    [%#span56] shallow_model'4 self
  
  let rec len'0 (self:slice int32) (return'  (ret:usize))= {[@expl:precondition] [%#span77] inv'2 self}
    any
    [ return' (result:usize)-> {[%#span78] Seq.length (shallow_model'2 self) = UIntSize.to_int result}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:RangeFull'0.t_RangeFull) (return'  (ret:slice int32))= {[@expl:precondition] [%#span59] inv'1 index}
    {[@expl:precondition] [%#span58] inv'0 self}
    {[@expl:precondition] [%#span57] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:slice int32)-> {[%#span61] inv'2 result}
      {[%#span60] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span79] Seq.get (shallow_model'0 self) ix
  
  let rec create_arr'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span80] Seq.length (shallow_model'0 result) = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
  
  let rec test_range_full (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = create_arr'0 {[%#sindex_range0] ()}
          (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &_5 <- RangeFull'0.C_RangeFull ] s1
      | s1 = index'0 {arr} {_5} (fun (_ret':slice int32) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &s <- _3 ] s1 | s1 = len'0 {s} (fun (_ret':usize) ->  [ &_8 <- _ret' ] s2) | s2 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.eq {_8} {[%#sindex_range1] (5 : usize)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb20) | br1 -> {_7} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &_12 <- [%#sindex_range2] (0 : usize) ] s1
      | s1 =  [ &_13 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_12} {_13} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range3] _14} s4
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Slice.get <int32> {s} {_12}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range4] (0 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1))
      | s1 = any [ br0 -> {_10 = false} (! bb19) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 =  [ &_17 <- [%#sindex_range5] (1 : usize) ] s1
      | s1 =  [ &_18 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_17} {_18} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range6] _19} s4
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = Slice.get <int32> {s} {_17}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range7] (1 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = any [ br0 -> {_15 = false} (! bb18) | br1 -> {_15} (! bb8) ]  ]
      
    | bb8 = s0
      [ s0 =  [ &_22 <- [%#sindex_range8] (2 : usize) ] s1
      | s1 =  [ &_23 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_22} {_23} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range9] _24} s4
      | s4 = bb9 ]
      
    | bb9 = s0
      [ s0 = Slice.get <int32> {s} {_22}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range10] (2 : int32)} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1))
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb10) ]  ]
      
    | bb10 = s0
      [ s0 =  [ &_27 <- [%#sindex_range11] (3 : usize) ] s1
      | s1 =  [ &_28 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_27} {_28} (fun (_ret':bool) ->  [ &_29 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range12] _29} s4
      | s4 = bb11 ]
      
    | bb11 = s0
      [ s0 = Slice.get <int32> {s} {_27}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range13] (3 : int32)} (fun (_ret':bool) ->  [ &_25 <- _ret' ] s1))
      | s1 = any [ br0 -> {_25 = false} (! bb16) | br1 -> {_25} (! bb12) ]  ]
      
    | bb12 = s0
      [ s0 =  [ &_32 <- [%#sindex_range14] (4 : usize) ] s1
      | s1 =  [ &_33 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_32} {_33} (fun (_ret':bool) ->  [ &_34 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range15] _34} s4
      | s4 = bb13 ]
      
    | bb13 = s0
      [ s0 = Slice.get <int32> {s} {_32}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range16] (4 : int32)} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1))
      | s1 = any [ br0 -> {_30 = false} (! bb15) | br1 -> {_30} (! bb14) ]  ]
      
    | bb14 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_38 <- _ret' ]  [ &arr <- _38.final ] s1)
      | s1 =  [ &_39 <- RangeFull'0.C_RangeFull ] s2
      | s2 = index_mut'0 {_38} {_39} (fun (_ret':borrowed (slice int32)) ->  [ &_37 <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = Borrow.borrow_final <slice int32> {_37.current} {Borrow.get_id _37}
          (fun (_ret':borrowed (slice int32)) ->  [ &s1 <- _ret' ]  [ &_37 <- { _37 with current = s1.final ; } ] s1)
      | s1 = len'0 {s1.current} (fun (_ret':usize) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb23 ]
      
    | bb23 = s0
      [ s0 = UIntSize.eq {_42} {[%#sindex_range17] (5 : usize)} (fun (_ret':bool) ->  [ &_41 <- _ret' ] s1)
      | s1 = any [ br0 -> {_41 = false} (! bb25) | br1 -> {_41} (! bb24) ]  ]
      
    | bb24 = s0
      [ s0 =  [ &_45 <- [%#sindex_range18] (1 : usize) ] s1
      | s1 =  [ &_46 <- Slice.length s1.current ] s2
      | s2 = UIntSize.lt {_45} {_46} (fun (_ret':bool) ->  [ &_47 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range19] _47} s4
      | s4 = bb26 ]
      
    | bb26 = s0
      [ s0 = Slice.get <int32> {s1.current} {_45}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_45} {[%#sindex_range20] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_48 <- [%#sindex_range21] (3 : usize) ] s2
      | s2 =  [ &_49 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_48} {_49} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range22] _50} s5
      | s5 = bb27 ]
      
    | bb27 = s0
      [ s0 = Slice.get <int32> {s1.current} {_48}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_48} {[%#sindex_range23] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 = -{resolve'0 s1}- s2
      | s2 = -{resolve'0 _37}- s3
      | s3 = len'1 {arr} (fun (_ret':usize) ->  [ &_53 <- _ret' ] s4)
      | s4 = bb28 ]
      
    | bb28 = s0
      [ s0 = UIntSize.eq {_53} {[%#sindex_range24] (5 : usize)} (fun (_ret':bool) ->  [ &_52 <- _ret' ] s1)
      | s1 = any [ br0 -> {_52 = false} (! bb30) | br1 -> {_52} (! bb29) ]  ]
      
    | bb29 = s0
      [ s0 = index'1 {arr} {[%#sindex_range25] (0 : usize)} (fun (_ret':int32) ->  [ &_59 <- _ret' ] s1) | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 = Int32.eq {_59} {[%#sindex_range26] (0 : int32)} (fun (_ret':bool) ->  [ &_57 <- _ret' ] s1)
      | s1 = any [ br0 -> {_57 = false} (! bb33) | br1 -> {_57} (! bb32) ]  ]
      
    | bb32 = s0
      [ s0 = index'1 {arr} {[%#sindex_range27] (1 : usize)} (fun (_ret':int32) ->  [ &_65 <- _ret' ] s1) | s1 = bb34 ]
      
    | bb34 = s0
      [ s0 = Int32.eq {_65} {[%#sindex_range28] (-1 : int32)} (fun (_ret':bool) ->  [ &_63 <- _ret' ] s1)
      | s1 = any [ br0 -> {_63 = false} (! bb36) | br1 -> {_63} (! bb35) ]  ]
      
    | bb35 = s0
      [ s0 = index'1 {arr} {[%#sindex_range29] (2 : usize)} (fun (_ret':int32) ->  [ &_71 <- _ret' ] s1) | s1 = bb37 ]
      
    | bb37 = s0
      [ s0 = Int32.eq {_71} {[%#sindex_range30] (2 : int32)} (fun (_ret':bool) ->  [ &_69 <- _ret' ] s1)
      | s1 = any [ br0 -> {_69 = false} (! bb39) | br1 -> {_69} (! bb38) ]  ]
      
    | bb38 = s0
      [ s0 = index'1 {arr} {[%#sindex_range31] (3 : usize)} (fun (_ret':int32) ->  [ &_77 <- _ret' ] s1) | s1 = bb40 ]
      
    | bb40 = s0
      [ s0 = Int32.eq {_77} {[%#sindex_range32] (-1 : int32)} (fun (_ret':bool) ->  [ &_75 <- _ret' ] s1)
      | s1 = any [ br0 -> {_75 = false} (! bb42) | br1 -> {_75} (! bb41) ]  ]
      
    | bb41 = s0
      [ s0 = index'1 {arr} {[%#sindex_range33] (4 : usize)} (fun (_ret':int32) ->  [ &_83 <- _ret' ] s1) | s1 = bb43 ]
      
    | bb43 = s0
      [ s0 = Int32.eq {_83} {[%#sindex_range34] (4 : int32)} (fun (_ret':bool) ->  [ &_81 <- _ret' ] s1)
      | s1 = any [ br0 -> {_81 = false} (! bb45) | br1 -> {_81} (! bb44) ]  ]
      
    | bb44 = bb46
    | bb46 = return' {_0}
    | bb45 = {[%#sindex_range35] false} any
    | bb42 = {[%#sindex_range36] false} any
    | bb39 = {[%#sindex_range37] false} any
    | bb36 = {[%#sindex_range38] false} any
    | bb33 = {[%#sindex_range39] false} any
    | bb30 = {[%#sindex_range40] false} any
    | bb25 = s0 [ s0 = -{resolve'0 s1}- s1 | s1 = -{resolve'0 _37}- s2 | s2 = {[%#sindex_range41] false} any ] 
    | bb15 = bb21
    | bb16 = bb21
    | bb17 = bb21
    | bb18 = bb21
    | bb19 = bb21
    | bb20 = bb21
    | bb21 = {[%#sindex_range42] false} any ]
    )
    [ & _0 : () = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & s : slice int32 = any_l ()
    | & _3 : slice int32 = any_l ()
    | & _5 : RangeFull'0.t_RangeFull = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : usize = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : usize = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : usize = any_l ()
    | & _19 : bool = any_l ()
    | & _20 : bool = any_l ()
    | & _22 : usize = any_l ()
    | & _23 : usize = any_l ()
    | & _24 : bool = any_l ()
    | & _25 : bool = any_l ()
    | & _27 : usize = any_l ()
    | & _28 : usize = any_l ()
    | & _29 : bool = any_l ()
    | & _30 : bool = any_l ()
    | & _32 : usize = any_l ()
    | & _33 : usize = any_l ()
    | & _34 : bool = any_l ()
    | & s1 : borrowed (slice int32) = any_l ()
    | & _37 : borrowed (slice int32) = any_l ()
    | & _38 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _39 : RangeFull'0.t_RangeFull = any_l ()
    | & _41 : bool = any_l ()
    | & _42 : usize = any_l ()
    | & _45 : usize = any_l ()
    | & _46 : usize = any_l ()
    | & _47 : bool = any_l ()
    | & _48 : usize = any_l ()
    | & _49 : usize = any_l ()
    | & _50 : bool = any_l ()
    | & _52 : bool = any_l ()
    | & _53 : usize = any_l ()
    | & _57 : bool = any_l ()
    | & _59 : int32 = any_l ()
    | & _63 : bool = any_l ()
    | & _65 : int32 = any_l ()
    | & _69 : bool = any_l ()
    | & _71 : int32 = any_l ()
    | & _75 : bool = any_l ()
    | & _77 : int32 = any_l ()
    | & _81 : bool = any_l ()
    | & _83 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module T_core__ops__range__RangeToInclusive
  type t_RangeToInclusive 'idx =
    | C_RangeToInclusive 'idx
  
  function any_l (_ : 'b) : 'a
  
  let rec t_RangeToInclusive < 'idx > (input:t_RangeToInclusive 'idx) (ret  (end':'idx))= any
    [ good (end':'idx)-> {C_RangeToInclusive end' = input} (! ret {end'})
    | bad (end':'idx)-> {C_RangeToInclusive end' <> input} {false} any ]
    
  
  function t_RangeToInclusive__end (self : t_RangeToInclusive 'idx) : 'idx =
    match self with
      | C_RangeToInclusive a -> a
      end
end
module M_index_range__test_range_to_inclusive
  let%span sindex_range0 = "../index_range.rs" 181 18 181 30
  
  let%span sindex_range1 = "../index_range.rs" 186 20 186 21
  
  let%span sindex_range2 = "../index_range.rs" 187 23 187 24
  
  let%span sindex_range3 = "../index_range.rs" 187 30 187 31
  
  let%span sindex_range4 = "../index_range.rs" 187 28 187 32
  
  let%span sindex_range5 = "../index_range.rs" 187 36 187 37
  
  let%span sindex_range6 = "../index_range.rs" 187 43 187 44
  
  let%span sindex_range7 = "../index_range.rs" 187 41 187 45
  
  let%span sindex_range8 = "../index_range.rs" 187 49 187 50
  
  let%span sindex_range9 = "../index_range.rs" 192 23 192 24
  
  let%span sindex_range10 = "../index_range.rs" 195 24 195 25
  
  let%span sindex_range11 = "../index_range.rs" 196 23 196 24
  
  let%span sindex_range12 = "../index_range.rs" 197 6 197 7
  
  let%span sindex_range13 = "../index_range.rs" 197 4 197 8
  
  let%span sindex_range14 = "../index_range.rs" 197 11 197 13
  
  let%span sindex_range15 = "../index_range.rs" 198 6 198 7
  
  let%span sindex_range16 = "../index_range.rs" 198 4 198 8
  
  let%span sindex_range17 = "../index_range.rs" 198 11 198 13
  
  let%span sindex_range18 = "../index_range.rs" 200 14 200 15
  
  let%span sindex_range19 = "../index_range.rs" 200 12 200 16
  
  let%span sindex_range20 = "../index_range.rs" 200 20 200 21
  
  let%span sindex_range21 = "../index_range.rs" 202 25 202 26
  
  let%span sindex_range22 = "../index_range.rs" 203 16 203 17
  
  let%span sindex_range23 = "../index_range.rs" 203 22 203 24
  
  let%span sindex_range24 = "../index_range.rs" 204 16 204 17
  
  let%span sindex_range25 = "../index_range.rs" 204 22 204 23
  
  let%span sindex_range26 = "../index_range.rs" 205 16 205 17
  
  let%span sindex_range27 = "../index_range.rs" 205 22 205 24
  
  let%span sindex_range28 = "../index_range.rs" 206 16 206 17
  
  let%span sindex_range29 = "../index_range.rs" 206 22 206 23
  
  let%span sindex_range30 = "../index_range.rs" 207 16 207 17
  
  let%span sindex_range31 = "../index_range.rs" 207 22 207 23
  
  let%span sindex_range32 = "../index_range.rs" 207 4 207 24
  
  let%span sindex_range33 = "../index_range.rs" 206 4 206 24
  
  let%span sindex_range34 = "../index_range.rs" 205 4 205 25
  
  let%span sindex_range35 = "../index_range.rs" 204 4 204 24
  
  let%span sindex_range36 = "../index_range.rs" 203 4 203 25
  
  let%span sindex_range37 = "../index_range.rs" 202 4 202 27
  
  let%span sindex_range38 = "../index_range.rs" 200 4 200 22
  
  let%span sindex_range39 = "../index_range.rs" 196 4 196 25
  
  let%span sindex_range40 = "../index_range.rs" 192 4 192 36
  
  let%span sindex_range41 = "../index_range.rs" 187 4 187 51
  
  let%span span42 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span43 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span44 = "../../../../creusot-contracts/src/invariant.rs" 8 8 8 12
  
  let%span span45 = "" 0 0 0 0
  
  let%span span46 = "../../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  
  let%span span47 = "../../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  let%span span48 = "../../../../creusot-contracts/src/std/slice.rs" 16 20 16 30
  
  let%span span49 = "../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  
  let%span span50 = "../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41
  
  let%span span51 = "../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span52 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span53 = "../../../../creusot-contracts/src/std/slice.rs" 131 20 131 37
  
  let%span span54 = "../../../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  
  let%span span55 = "../../../../creusot-contracts/src/model.rs" 90 8 90 31
  
  let%span span56 = "../../../../creusot-contracts/src/std/vec.rs" 156 27 156 46
  
  let%span span57 = "" 0 0 0 0
  
  let%span span58 = "" 0 0 0 0
  
  let%span span59 = "../../../../creusot-contracts/src/std/vec.rs" 157 26 157 54
  
  let%span span60 = "" 0 0 0 0
  
  let%span span61 = "" 0 0 0 0
  
  let%span span62 = "../../../../creusot-contracts/src/std/vec.rs" 78 26 78 48
  
  let%span span63 = "../../../../creusot-contracts/src/resolve.rs" 26 20 26 34
  
  let%span span64 = "../../../../creusot-contracts/src/std/slice.rs" 243 8 243 89
  
  let%span span65 = "../../../../creusot-contracts/src/std/slice.rs" 237 20 237 61
  
  let%span span66 = "../../../../creusot-contracts/src/std/slice.rs" 231 20 231 41
  
  let%span span67 = "../../../../creusot-contracts/src/model.rs" 108 8 108 31
  
  let%span span68 = "../../../../creusot-contracts/src/std/vec.rs" 146 27 146 46
  
  let%span span69 = "" 0 0 0 0
  
  let%span span70 = "" 0 0 0 0
  
  let%span span71 = "../../../../creusot-contracts/src/std/vec.rs" 147 26 147 54
  
  let%span span72 = "../../../../creusot-contracts/src/std/vec.rs" 148 26 148 57
  
  let%span span73 = "../../../../creusot-contracts/src/std/vec.rs" 149 26 149 62
  
  let%span span74 = "../../../../creusot-contracts/src/std/vec.rs" 150 26 150 55
  
  let%span span75 = "" 0 0 0 0
  
  let%span span76 = "" 0 0 0 0
  
  let%span span77 = "../../../../creusot-contracts/src/std/option.rs" 39 26 39 51
  
  let%span span78 = "" 0 0 0 0
  
  let%span span79 = "" 0 0 0 0
  
  let%span span80 = "../../../../creusot-contracts/src/std/slice.rs" 264 8 264 102
  
  let%span span81 = "../../../../creusot-contracts/src/std/slice.rs" 265 18 265 55
  
  let%span span82 = "" 0 0 0 0
  
  let%span span83 = "" 0 0 0 0
  
  let%span span84 = "../../../../creusot-contracts/src/std/vec.rs" 163 26 163 42
  
  let%span span85 = "" 0 0 0 0
  
  let%span span86 = "" 0 0 0 0
  
  let%span span87 = "../../../../creusot-contracts/src/std/slice.rs" 247 0 356 1
  
  let%span span88 = "../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31
  
  let%span span89 = "../index_range.rs" 7 4 12 22
  
  use prelude.prelude.Int32
  
  predicate inv'11 (_1 : int32)
  
  use T_alloc__alloc__Global as Global'0
  
  predicate invariant'13 (self : int32) =
    [%#span42] inv'11 self
  
  predicate inv'13 (_1 : int32)
  
  axiom inv'13 : forall x : int32 . inv'13 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'12 (self : Seq.seq int32) =
    [%#span43] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'13 (Seq.get self i)
  
  predicate inv'12 (_1 : Seq.seq int32)
  
  axiom inv'12 : forall x : Seq.seq int32 . inv'12 x = true
  
  predicate invariant'11 (self : int32) =
    [%#span44] true
  
  axiom inv'11 : forall x : int32 . inv'11 x = true
  
  use prelude.prelude.Slice
  
  use prelude.prelude.Slice
  
  use prelude.prelude.UIntSize
  
  use prelude.prelude.UIntSize
  
  constant v_MAX'0 : usize = [%#span45] (18446744073709551615 : usize)
  
  function shallow_model'4 (self : slice int32) : Seq.seq int32
  
  axiom shallow_model'4_spec : forall self : slice int32 . ([%#span47] shallow_model'4 self = Slice.id self)
  && ([%#span46] Seq.length (shallow_model'4 self) <= UIntSize.to_int (v_MAX'0 : usize))
  
  predicate invariant'10 (self : slice int32) =
    [%#span48] inv'12 (shallow_model'4 self)
  
  predicate inv'10 (_1 : slice int32)
  
  axiom inv'10 : forall x : slice int32 . inv'10 x = true
  
  use T_alloc__vec__Vec as Vec'0
  
  function shallow_model'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32
  
  axiom shallow_model'0_spec : forall self : Vec'0.t_Vec int32 (Global'0.t_Global) . [%#span49] Seq.length (shallow_model'0 self)
  <= UIntSize.to_int (v_MAX'0 : usize)
  
  predicate invariant'9 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span50] inv'12 (shallow_model'0 self)
  
  predicate inv'9 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'9 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'9 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'8 (self : int32) =
    [%#span51] inv'11 self
  
  predicate inv'8 (_1 : int32)
  
  axiom inv'8 : forall x : int32 . inv'8 x = true
  
  predicate invariant'7 (self : usize) =
    [%#span44] true
  
  predicate inv'7 (_1 : usize)
  
  axiom inv'7 : forall x : usize . inv'7 x = true
  
  predicate invariant'6 (self : borrowed (slice int32)) =
    [%#span52] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'6 (_1 : borrowed (slice int32))
  
  axiom inv'6 : forall x : borrowed (slice int32) . inv'6 x = true
  
  predicate invariant'5 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) =
    [%#span52] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'5 (_1 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)))
  
  axiom inv'5 : forall x : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) . inv'5 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'3 (_1 : Option'0.t_Option (slice int32))
  
  predicate invariant'4 (self : Option'0.t_Option (slice int32)) =
    [%#span51] inv'3 self
  
  predicate inv'4 (_1 : Option'0.t_Option (slice int32))
  
  axiom inv'4 : forall x : Option'0.t_Option (slice int32) . inv'4 x = true
  
  predicate invariant'3 (self : Option'0.t_Option (slice int32)) =
    [%#span44] true
  
  axiom inv'3 : forall x : Option'0.t_Option (slice int32) . inv'3 x = true
  
  predicate invariant'2 (self : slice int32) =
    [%#span51] inv'10 self
  
  predicate inv'2 (_1 : slice int32)
  
  axiom inv'2 : forall x : slice int32 . inv'2 x = true
  
  use T_core__ops__range__RangeToInclusive as RangeToInclusive'0
  
  predicate invariant'1 (self : RangeToInclusive'0.t_RangeToInclusive usize) =
    [%#span44] true
  
  predicate inv'1 (_1 : RangeToInclusive'0.t_RangeToInclusive usize)
  
  axiom inv'1 : forall x : RangeToInclusive'0.t_RangeToInclusive usize . inv'1 x = true
  
  predicate invariant'0 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) =
    [%#span51] inv'9 self
  
  predicate inv'0 (_1 : Vec'0.t_Vec int32 (Global'0.t_Global))
  
  axiom inv'0 : forall x : Vec'0.t_Vec int32 (Global'0.t_Global) . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use seq.Seq
  
  predicate has_value'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) (out : int32) =
    [%#span53] Seq.get seq (UIntSize.to_int self) = out
  
  predicate in_bounds'1 [@inline:trivial] (self : usize) (seq : Seq.seq int32) =
    [%#span54] UIntSize.to_int self < Seq.length seq
  
  function shallow_model'1 (self : Vec'0.t_Vec int32 (Global'0.t_Global)) : Seq.seq int32 =
    [%#span55] shallow_model'0 self
  
  let rec index'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:usize) (return'  (ret:int32))= {[@expl:precondition] [%#span58] inv'7 index}
    {[@expl:precondition] [%#span57] inv'0 self}
    {[@expl:precondition] [%#span56] in_bounds'1 index (shallow_model'1 self)}
    any
    [ return' (result:int32)-> {[%#span60] inv'8 result}
      {[%#span59] has_value'1 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  let rec len'1 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:usize))= {[@expl:precondition] [%#span61] inv'0 self}
    any
    [ return' (result:usize)-> {[%#span62] UIntSize.to_int result = Seq.length (shallow_model'1 self)}
      (! return' {result}) ]
    
  
  predicate resolve'0 (self : borrowed (slice int32)) =
    [%#span63] self.final = self.current
  
  use T_core__ops__range__RangeToInclusive as T_core__ops__range__RangeToInclusive
  
  predicate resolve_elswhere'0 (self : RangeToInclusive'0.t_RangeToInclusive usize) (old' : Seq.seq int32) (fin : Seq.seq int32)
    
   =
    [%#span64] forall i : int . UIntSize.to_int (T_core__ops__range__RangeToInclusive.t_RangeToInclusive__end self) < i
    /\ i < Seq.length old'  -> Seq.get old' i = Seq.get fin i
  
  use prelude.seq_ext.SeqExt
  
  predicate has_value'0 (self : RangeToInclusive'0.t_RangeToInclusive usize) (seq : Seq.seq int32) (out : slice int32) =
    [%#span65] SeqExt.subsequence seq 0 (UIntSize.to_int (T_core__ops__range__RangeToInclusive.t_RangeToInclusive__end self)
    + 1)
    = shallow_model'4 out
  
  predicate in_bounds'0 (self : RangeToInclusive'0.t_RangeToInclusive usize) (seq : Seq.seq int32) =
    [%#span66] UIntSize.to_int (T_core__ops__range__RangeToInclusive.t_RangeToInclusive__end self) < Seq.length seq
  
  function shallow_model'3 (self : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) : Seq.seq int32 =
    [%#span67] shallow_model'0 self.current
  
  let rec index_mut'0 (self:borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) (index:RangeToInclusive'0.t_RangeToInclusive usize) (return'  (ret:borrowed (slice int32)))= {[@expl:precondition] [%#span70] inv'1 index}
    {[@expl:precondition] [%#span69] inv'5 self}
    {[@expl:precondition] [%#span68] in_bounds'0 index (shallow_model'3 self)}
    any
    [ return' (result:borrowed (slice int32))-> {[%#span75] inv'6 result}
      {[%#span74] Seq.length (shallow_model'0 self.final) = Seq.length (shallow_model'3 self)}
      {[%#span73] resolve_elswhere'0 index (shallow_model'3 self) (shallow_model'0 self.final)}
      {[%#span72] has_value'0 index (shallow_model'0 self.final) result.final}
      {[%#span71] has_value'0 index (shallow_model'3 self) result.current}
      (! return' {result}) ]
    
  
  let rec is_none'0 (self:Option'0.t_Option (slice int32)) (return'  (ret:bool))= {[@expl:precondition] [%#span76] inv'4 self}
    any [ return' (result:bool)-> {[%#span77] result = (self = Option'0.C_None)} (! return' {result}) ] 
  
  function shallow_model'2 (self : slice int32) : Seq.seq int32 =
    [%#span55] shallow_model'4 self
  
  let rec get'0 (self:slice int32) (index:RangeToInclusive'0.t_RangeToInclusive usize) (return'  (ret:Option'0.t_Option (slice int32)))= {[@expl:precondition] [%#span79] inv'1 index}
    {[@expl:precondition] [%#span78] inv'2 self}
    any
    [ return' (result:Option'0.t_Option (slice int32))-> {[%#span82] inv'3 result}
      {[%#span81] in_bounds'0 index (shallow_model'2 self) \/ result = Option'0.C_None}
      {[%#span80] in_bounds'0 index (shallow_model'2 self)
       -> (exists r : slice int32 . result = Option'0.C_Some r /\ has_value'0 index (shallow_model'2 self) r)}
      (! return' {result}) ]
    
  
  let rec deref'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (return'  (ret:slice int32))= {[@expl:precondition] [%#span83] inv'0 self}
    any
    [ return' (result:slice int32)-> {[%#span85] inv'2 result}
      {[%#span84] shallow_model'2 result = shallow_model'1 self}
      (! return' {result}) ]
    
  
  let rec len'0 (self:slice int32) (return'  (ret:usize))= {[@expl:precondition] [%#span86] inv'2 self}
    any
    [ return' (result:usize)-> {[%#span87] Seq.length (shallow_model'2 self) = UIntSize.to_int result}
      (! return' {result}) ]
    
  
  let rec index'0 (self:Vec'0.t_Vec int32 (Global'0.t_Global)) (index:RangeToInclusive'0.t_RangeToInclusive usize) (return'  (ret:slice int32))= {[@expl:precondition] [%#span58] inv'1 index}
    {[@expl:precondition] [%#span57] inv'0 self}
    {[@expl:precondition] [%#span56] in_bounds'0 index (shallow_model'1 self)}
    any
    [ return' (result:slice int32)-> {[%#span60] inv'2 result}
      {[%#span59] has_value'0 index (shallow_model'1 self) result}
      (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  function index_logic'0 [@inline:trivial] (self : Vec'0.t_Vec int32 (Global'0.t_Global)) (ix : int) : int32 =
    [%#span88] Seq.get (shallow_model'0 self) ix
  
  let rec create_arr'0 (_1:()) (return'  (ret:Vec'0.t_Vec int32 (Global'0.t_Global)))= any
    [ return' (result:Vec'0.t_Vec int32 (Global'0.t_Global))-> {[%#span89] Seq.length (shallow_model'0 result) = 5
      /\ Int32.to_int (index_logic'0 result 0) = 0
      /\ Int32.to_int (index_logic'0 result 1) = 1
      /\ Int32.to_int (index_logic'0 result 2) = 2
      /\ Int32.to_int (index_logic'0 result 3) = 3 /\ Int32.to_int (index_logic'0 result 4) = 4}
      (! return' {result}) ]
    
  
  let rec test_range_to_inclusive (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = create_arr'0 {[%#sindex_range0] ()}
          (fun (_ret':Vec'0.t_Vec int32 (Global'0.t_Global)) ->  [ &arr <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 =  [ &_5 <- RangeToInclusive'0.C_RangeToInclusive ([%#sindex_range1] (1 : usize)) ] s1
      | s1 = index'0 {arr} {_5} (fun (_ret':slice int32) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0 [ s0 =  [ &s <- _3 ] s1 | s1 = len'0 {s} (fun (_ret':usize) ->  [ &_8 <- _ret' ] s2) | s2 = bb3 ] 
    | bb3 = s0
      [ s0 = UIntSize.eq {_8} {[%#sindex_range2] (2 : usize)} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s1)
      | s1 = any [ br0 -> {_7 = false} (! bb11) | br1 -> {_7} (! bb4) ]  ]
      
    | bb4 = s0
      [ s0 =  [ &_12 <- [%#sindex_range3] (0 : usize) ] s1
      | s1 =  [ &_13 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_12} {_13} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range4] _14} s4
      | s4 = bb5 ]
      
    | bb5 = s0
      [ s0 = Slice.get <int32> {s} {_12}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range5] (0 : int32)} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1))
      | s1 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb6) ]  ]
      
    | bb6 = s0
      [ s0 =  [ &_17 <- [%#sindex_range6] (1 : usize) ] s1
      | s1 =  [ &_18 <- Slice.length s ] s2
      | s2 = UIntSize.lt {_17} {_18} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range7] _19} s4
      | s4 = bb7 ]
      
    | bb7 = s0
      [ s0 = Slice.get <int32> {s} {_17}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range8] (1 : int32)} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1))
      | s1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ]  ]
      
    | bb8 = s0 [ s0 = deref'0 {arr} (fun (_ret':slice int32) ->  [ &_26 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_28 <- RangeToInclusive'0.C_RangeToInclusive ([%#sindex_range9] (5 : usize)) ] s1
      | s1 = get'0 {_26} {_28} (fun (_ret':Option'0.t_Option (slice int32)) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0 [ s0 = is_none'0 {_24} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_22 = false} (! bb17) | br1 -> {_22} (! bb16) ] 
    | bb16 = s0
      [ s0 = Borrow.borrow_mut <Vec'0.t_Vec int32 (Global'0.t_Global)> {arr}
          (fun (_ret':borrowed (Vec'0.t_Vec int32 (Global'0.t_Global))) ->  [ &_32 <- _ret' ]  [ &arr <- _32.final ] s1)
      | s1 =  [ &_33 <- RangeToInclusive'0.C_RangeToInclusive ([%#sindex_range10] (2 : usize)) ] s2
      | s2 = index_mut'0 {_32} {_33} (fun (_ret':borrowed (slice int32)) ->  [ &_31 <- _ret' ] s3)
      | s3 = bb18 ]
      
    | bb18 = s0
      [ s0 = Borrow.borrow_final <slice int32> {_31.current} {Borrow.get_id _31}
          (fun (_ret':borrowed (slice int32)) ->  [ &s1 <- _ret' ]  [ &_31 <- { _31 with current = s1.final ; } ] s1)
      | s1 = len'0 {s1.current} (fun (_ret':usize) ->  [ &_36 <- _ret' ] s2)
      | s2 = bb19 ]
      
    | bb19 = s0
      [ s0 = UIntSize.eq {_36} {[%#sindex_range11] (3 : usize)} (fun (_ret':bool) ->  [ &_35 <- _ret' ] s1)
      | s1 = any [ br0 -> {_35 = false} (! bb21) | br1 -> {_35} (! bb20) ]  ]
      
    | bb20 = s0
      [ s0 =  [ &_39 <- [%#sindex_range12] (0 : usize) ] s1
      | s1 =  [ &_40 <- Slice.length s1.current ] s2
      | s2 = UIntSize.lt {_39} {_40} (fun (_ret':bool) ->  [ &_41 <- _ret' ] s3)
      | s3 = {[@expl:index in bounds] [%#sindex_range13] _41} s4
      | s4 = bb22 ]
      
    | bb22 = s0
      [ s0 = Slice.get <int32> {s1.current} {_39}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_39} {[%#sindex_range14] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_42 <- [%#sindex_range15] (2 : usize) ] s2
      | s2 =  [ &_43 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_42} {_43} (fun (_ret':bool) ->  [ &_44 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range16] _44} s5
      | s5 = bb23 ]
      
    | bb23 = s0
      [ s0 = Slice.get <int32> {s1.current} {_42}
          (fun (l'0:int32) ->
            Slice.set <int32> {s1.current} {_42} {[%#sindex_range17] (-1 : int32)}
              (fun (l'1:slice int32) ->  [ &s1 <- { s1 with current = l'1 ; } ] s1))
      | s1 =  [ &_48 <- [%#sindex_range18] (1 : usize) ] s2
      | s2 =  [ &_49 <- Slice.length s1.current ] s3
      | s3 = UIntSize.lt {_48} {_49} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s4)
      | s4 = {[@expl:index in bounds] [%#sindex_range19] _50} s5
      | s5 = bb24 ]
      
    | bb24 = s0
      [ s0 = -{resolve'0 s1}- s1
      | s1 = -{resolve'0 _31}- s2
      | s2 = Slice.get <int32> {s1.current} {_48}
          (fun (r'0:int32) ->
            Int32.eq {r'0} {[%#sindex_range20] (1 : int32)} (fun (_ret':bool) ->  [ &_46 <- _ret' ] s3))
      | s3 = any [ br0 -> {_46 = false} (! bb26) | br1 -> {_46} (! bb25) ]  ]
      
    | bb25 = s0 [ s0 = len'1 {arr} (fun (_ret':usize) ->  [ &_54 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0
      [ s0 = UIntSize.eq {_54} {[%#sindex_range21] (5 : usize)} (fun (_ret':bool) ->  [ &_53 <- _ret' ] s1)
      | s1 = any [ br0 -> {_53 = false} (! bb29) | br1 -> {_53} (! bb28) ]  ]
      
    | bb28 = s0
      [ s0 = index'1 {arr} {[%#sindex_range22] (0 : usize)} (fun (_ret':int32) ->  [ &_60 <- _ret' ] s1) | s1 = bb30 ]
      
    | bb30 = s0
      [ s0 = Int32.eq {_60} {[%#sindex_range23] (-1 : int32)} (fun (_ret':bool) ->  [ &_58 <- _ret' ] s1)
      | s1 = any [ br0 -> {_58 = false} (! bb32) | br1 -> {_58} (! bb31) ]  ]
      
    | bb31 = s0
      [ s0 = index'1 {arr} {[%#sindex_range24] (1 : usize)} (fun (_ret':int32) ->  [ &_66 <- _ret' ] s1) | s1 = bb33 ]
      
    | bb33 = s0
      [ s0 = Int32.eq {_66} {[%#sindex_range25] (1 : int32)} (fun (_ret':bool) ->  [ &_64 <- _ret' ] s1)
      | s1 = any [ br0 -> {_64 = false} (! bb35) | br1 -> {_64} (! bb34) ]  ]
      
    | bb34 = s0
      [ s0 = index'1 {arr} {[%#sindex_range26] (2 : usize)} (fun (_ret':int32) ->  [ &_72 <- _ret' ] s1) | s1 = bb36 ]
      
    | bb36 = s0
      [ s0 = Int32.eq {_72} {[%#sindex_range27] (-1 : int32)} (fun (_ret':bool) ->  [ &_70 <- _ret' ] s1)
      | s1 = any [ br0 -> {_70 = false} (! bb38) | br1 -> {_70} (! bb37) ]  ]
      
    | bb37 = s0
      [ s0 = index'1 {arr} {[%#sindex_range28] (3 : usize)} (fun (_ret':int32) ->  [ &_78 <- _ret' ] s1) | s1 = bb39 ]
      
    | bb39 = s0
      [ s0 = Int32.eq {_78} {[%#sindex_range29] (3 : int32)} (fun (_ret':bool) ->  [ &_76 <- _ret' ] s1)
      | s1 = any [ br0 -> {_76 = false} (! bb41) | br1 -> {_76} (! bb40) ]  ]
      
    | bb40 = s0
      [ s0 = index'1 {arr} {[%#sindex_range30] (4 : usize)} (fun (_ret':int32) ->  [ &_84 <- _ret' ] s1) | s1 = bb42 ]
      
    | bb42 = s0
      [ s0 = Int32.eq {_84} {[%#sindex_range31] (4 : int32)} (fun (_ret':bool) ->  [ &_82 <- _ret' ] s1)
      | s1 = any [ br0 -> {_82 = false} (! bb44) | br1 -> {_82} (! bb43) ]  ]
      
    | bb43 = bb45
    | bb45 = return' {_0}
    | bb44 = {[%#sindex_range32] false} any
    | bb41 = {[%#sindex_range33] false} any
    | bb38 = {[%#sindex_range34] false} any
    | bb35 = {[%#sindex_range35] false} any
    | bb32 = {[%#sindex_range36] false} any
    | bb29 = {[%#sindex_range37] false} any
    | bb26 = {[%#sindex_range38] false} any
    | bb21 = s0 [ s0 = -{resolve'0 s1}- s1 | s1 = -{resolve'0 _31}- s2 | s2 = {[%#sindex_range39] false} any ] 
    | bb17 = {[%#sindex_range40] false} any
    | bb9 = bb12
    | bb10 = bb12
    | bb11 = bb12
    | bb12 = {[%#sindex_range41] false} any ]
    )
    [ & _0 : () = any_l ()
    | & arr : Vec'0.t_Vec int32 (Global'0.t_Global) = any_l ()
    | & s : slice int32 = any_l ()
    | & _3 : slice int32 = any_l ()
    | & _5 : RangeToInclusive'0.t_RangeToInclusive usize = any_l ()
    | & _7 : bool = any_l ()
    | & _8 : usize = any_l ()
    | & _10 : bool = any_l ()
    | & _12 : usize = any_l ()
    | & _13 : usize = any_l ()
    | & _14 : bool = any_l ()
    | & _15 : bool = any_l ()
    | & _17 : usize = any_l ()
    | & _18 : usize = any_l ()
    | & _19 : bool = any_l ()
    | & _22 : bool = any_l ()
    | & _24 : Option'0.t_Option (slice int32) = any_l ()
    | & _26 : slice int32 = any_l ()
    | & _28 : RangeToInclusive'0.t_RangeToInclusive usize = any_l ()
    | & s1 : borrowed (slice int32) = any_l ()
    | & _31 : borrowed (slice int32) = any_l ()
    | & _32 : borrowed (Vec'0.t_Vec int32 (Global'0.t_Global)) = any_l ()
    | & _33 : RangeToInclusive'0.t_RangeToInclusive usize = any_l ()
    | & _35 : bool = any_l ()
    | & _36 : usize = any_l ()
    | & _39 : usize = any_l ()
    | & _40 : usize = any_l ()
    | & _41 : bool = any_l ()
    | & _42 : usize = any_l ()
    | & _43 : usize = any_l ()
    | & _44 : bool = any_l ()
    | & _46 : bool = any_l ()
    | & _48 : usize = any_l ()
    | & _49 : usize = any_l ()
    | & _50 : bool = any_l ()
    | & _53 : bool = any_l ()
    | & _54 : usize = any_l ()
    | & _58 : bool = any_l ()
    | & _60 : int32 = any_l ()
    | & _64 : bool = any_l ()
    | & _66 : int32 = any_l ()
    | & _70 : bool = any_l ()
    | & _72 : int32 = any_l ()
    | & _76 : bool = any_l ()
    | & _78 : int32 = any_l ()
    | & _82 : bool = any_l ()
    | & _84 : int32 = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
