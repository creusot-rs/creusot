
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.UIntSize
  use prelude.Int
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.UIntSize
  use prelude.Int
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module SparseArray_Sparse_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  type t_sparse 't =
    | C_Sparse usize usize (Alloc_Vec_Vec_Type.t_vec 't (Alloc_Alloc_Global_Type.t_global)) (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
    
  let function sparse_size (self : t_sparse 't) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Sparse a _ _ _ _ -> a
      end
  let function sparse_idx (self : t_sparse 't) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Sparse _ _ _ a _ -> a
      end
  let function sparse_n (self : t_sparse 't) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Sparse _ a _ _ _ -> a
      end
  let function sparse_back (self : t_sparse 't) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Sparse _ _ _ _ a -> a
      end
  let function sparse_values (self : t_sparse 't) : Alloc_Vec_Vec_Type.t_vec 't (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match self with
      | C_Sparse _ _ a _ _ -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module SparseArray_Impl2_Get
  type t
  use seq.Seq
  predicate invariant11 (self : Seq.seq t)
  val invariant11 (self : Seq.seq t) : bool
    ensures { result = invariant11 self }
    
  predicate inv11 (_x : Seq.seq t)
  val inv11 (_x : Seq.seq t) : bool
    ensures { result = inv11 _x }
    
  axiom inv11 : forall x : Seq.seq t . inv11 x = true
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv10 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv10 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv10 _x }
    
  function shallow_model6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv10 self}
    ensures { result = shallow_model6 self }
    
  axiom shallow_model6_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv10 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv11 (shallow_model6 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model6 self) <= UIntSize.to_int max0)
  predicate invariant10 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv11 (shallow_model6 self)
  val invariant10 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant10 self }
    
  axiom inv10 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv10 x = true
  predicate invariant9 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant9 (self : Seq.seq usize) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : Seq.seq usize)
  val inv9 (_x : Seq.seq usize) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : forall x : Seq.seq usize . inv9 x = true
  use seq.Seq
  predicate inv8 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv8 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv8 _x }
    
  function shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv8 self}
    ensures { result = shallow_model5 self }
    
  axiom shallow_model5_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv8 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv9 (shallow_model5 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model5 self) <= UIntSize.to_int max0)
  predicate invariant8 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv9 (shallow_model5 self)
  val invariant8 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant8 self }
    
  axiom inv8 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv8 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  function index_logic4 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model5 self) ix
  val index_logic4 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    ensures { result = index_logic4 self ix }
    
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  use prelude.Mapping
  use seq.Seq
  function index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model6 self) ix
  val index_logic3 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic3 self ix }
    
  use SparseArray_Sparse_Type as SparseArray_Sparse_Type
  function is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool =
    [#"../sparse_array.rs" 73 20 74 52] UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) i) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) /\ UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_back self) (UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) i))) = i
  val is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool
    ensures { result = is_elt0 self i }
    
  function shallow_model4 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    
   =
    [#"../sparse_array.rs" 40 12 41 82] Seq.create (UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) (Mapping.from_fn (fun (i : int) -> if is_elt0 self i then
      Core_Option_Option_Type.C_Some (index_logic3 (SparseArray_Sparse_Type.sparse_values self) i)
    else
      Core_Option_Option_Type.C_None
    ))
  val shallow_model4 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model4 self }
    
  predicate invariant7 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) =
    [#"../sparse_array.rs" 50 8 61 9] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) <= UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model4 self) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model6 (SparseArray_Sparse_Type.sparse_values self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model5 (SparseArray_Sparse_Type.sparse_idx self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model5 (SparseArray_Sparse_Type.sparse_back self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ (forall i : int . 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) -> match index_logic4 (SparseArray_Sparse_Type.sparse_back self) i with
      | j -> 0 <= UIntSize.to_int j /\ UIntSize.to_int j < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) (UIntSize.to_int j)) = i
      end)
  val invariant7 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : SparseArray_Sparse_Type.t_sparse t)
  val inv7 (_x : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : SparseArray_Sparse_Type.t_sparse t . inv7 x = (invariant7 x /\ match x with
    | SparseArray_Sparse_Type.C_Sparse size n values idx back -> true
    end)
  predicate invariant6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val invariant6 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv6 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv6 x = true
  predicate invariant5 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : usize) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : usize)
  val inv5 (_x : usize) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : usize . inv5 x = true
  predicate invariant4 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : usize) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : usize)
  val inv4 (_x : usize) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : usize . inv4 x = true
  predicate invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv3 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv3 x = true
  predicate invariant2 (self : Core_Option_Option_Type.t_option t)
  val invariant2 (self : Core_Option_Option_Type.t_option t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : Core_Option_Option_Type.t_option t)
  val inv2 (_x : Core_Option_Option_Type.t_option t) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : Core_Option_Option_Type.t_option t . inv2 x = true
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : t . inv1 x = true
  predicate invariant0 (self : SparseArray_Sparse_Type.t_sparse t)
  val invariant0 (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : SparseArray_Sparse_Type.t_sparse t)
  val inv0 (_x : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : SparseArray_Sparse_Type.t_sparse t . inv0 x = inv7 x
  use seq.Seq
  function shallow_model1 (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t) =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] shallow_model4 self
  val shallow_model1 (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model1 self }
    
  predicate resolve1 (self : t)
  val resolve1 (self : t) : bool
    ensures { result = resolve1 self }
    
  use prelude.Slice
  predicate has_value1 [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value1 [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value1 self seq out }
    
  predicate in_bounds1 [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds1 [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds1 self seq }
    
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] shallow_model6 self
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    ensures { result = shallow_model3 self }
    
  val index1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (index : usize) : t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 141 27 141 46] in_bounds1 index (shallow_model3 self)}
    requires {inv6 self}
    requires {inv4 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 142 26 142 54] has_value1 index (shallow_model3 self) result }
    ensures { inv1 result }
    
  predicate resolve0 (self : SparseArray_Sparse_Type.t_sparse t)
  val resolve0 (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = resolve0 self }
    
  predicate has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) : bool
    ensures { result = has_value0 self seq out }
    
  predicate in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq usize) : bool
    ensures { result = in_bounds0 self seq }
    
  function shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] shallow_model5 self
  val shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    ensures { result = shallow_model2 self }
    
  val index0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (index : usize) : usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 141 27 141 46] in_bounds0 index (shallow_model2 self)}
    requires {inv3 self}
    requires {inv4 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 142 26 142 54] has_value0 index (shallow_model2 self) result }
    ensures { inv5 result }
    
  let rec cfg get [#"../sparse_array.rs" 89 4 89 45] [@cfg:stackify] [@cfg:subregion_analysis] (self : SparseArray_Sparse_Type.t_sparse t) (i : usize) : Core_Option_Option_Type.t_option t
    requires {[#"../sparse_array.rs" 80 15 80 31] UIntSize.to_int i < Seq.length (shallow_model1 self)}
    requires {[#"../sparse_array.rs" 89 16 89 20] inv0 self}
    ensures { [#"../sparse_array.rs" 81 14 84 5] match result with
      | Core_Option_Option_Type.C_None -> Seq.get (shallow_model1 self) (UIntSize.to_int i) = Core_Option_Option_Type.C_None
      | Core_Option_Option_Type.C_Some x -> Seq.get (shallow_model1 self) (UIntSize.to_int i) = Core_Option_Option_Type.C_Some x
      end }
    ensures { [#"../sparse_array.rs" 85 14 88 5] match Seq.get (shallow_model1 self) (UIntSize.to_int i) with
      | Core_Option_Option_Type.C_None -> result = Core_Option_Option_Type.C_None
      | Core_Option_Option_Type.C_Some _ -> true
      end }
    ensures { [#"../sparse_array.rs" 89 35 89 45] inv2 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self : SparseArray_Sparse_Type.t_sparse t = self;
  var i : usize = i;
  var index : usize;
  var _7 : usize;
  var _10 : bool;
  var _16 : usize;
  var _21 : t;
  var _22 : t;
  {
    goto BB0
  }
  BB0 {
    [#"../sparse_array.rs" 90 20 90 31] _7 <- ([#"../sparse_array.rs" 90 20 90 31] index0 ([#"../sparse_array.rs" 90 20 90 28] SparseArray_Sparse_Type.sparse_idx self) ([#"../sparse_array.rs" 90 29 90 30] i));
    goto BB1
  }
  BB1 {
    [#"../sparse_array.rs" 90 20 90 31] index <- ([#"../sparse_array.rs" 90 20 90 31] _7);
    switch ([#"../sparse_array.rs" 91 11 91 25] ([#"../sparse_array.rs" 91 11 91 16] index) < ([#"../sparse_array.rs" 91 19 91 25] SparseArray_Sparse_Type.sparse_n self))
      | False -> goto BB2
      | True -> goto BB3
      end
  }
  BB2 {
    [#"../sparse_array.rs" 91 11 91 50] _10 <- ([#"../sparse_array.rs" 91 11 91 50] [#"../sparse_array.rs" 91 11 91 50] false);
    goto BB4
  }
  BB3 {
    [#"../sparse_array.rs" 91 29 91 45] _16 <- ([#"../sparse_array.rs" 91 29 91 45] index0 ([#"../sparse_array.rs" 91 29 91 38] SparseArray_Sparse_Type.sparse_back self) ([#"../sparse_array.rs" 91 39 91 44] index));
    goto BB5
  }
  BB4 {
    switch (_10)
      | False -> goto BB8
      | True -> goto BB6
      end
  }
  BB5 {
    [#"../sparse_array.rs" 91 11 91 50] _10 <- ([#"../sparse_array.rs" 91 29 91 50] ([#"../sparse_array.rs" 91 29 91 45] _16) = ([#"../sparse_array.rs" 91 49 91 50] i));
    goto BB4
  }
  BB6 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    [#"../sparse_array.rs" 92 18 92 32] _22 <- ([#"../sparse_array.rs" 92 18 92 32] index1 ([#"../sparse_array.rs" 92 18 92 29] SparseArray_Sparse_Type.sparse_values self) ([#"../sparse_array.rs" 92 30 92 31] i));
    goto BB7
  }
  BB7 {
    [#"../sparse_array.rs" 92 17 92 32] _21 <- ([#"../sparse_array.rs" 92 17 92 32] _22);
    assert { [@expl:type invariant] inv1 _22 };
    assume { resolve1 _22 };
    assert { [@expl:type invariant] inv1 _21 };
    assume { resolve1 _21 };
    [#"../sparse_array.rs" 92 12 92 33] _0 <- ([#"../sparse_array.rs" 92 12 92 33] Core_Option_Option_Type.C_Some ([#"../sparse_array.rs" 92 17 92 32] _21));
    goto BB9
  }
  BB8 {
    assert { [@expl:type invariant] inv0 self };
    assume { resolve0 self };
    [#"../sparse_array.rs" 94 12 94 16] _0 <- ([#"../sparse_array.rs" 94 12 94 16] Core_Option_Option_Type.C_None);
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module SparseArray_Impl2_LemmaPermutation_Impl
  type t
  use seq.Seq
  predicate invariant4 (self : Seq.seq t)
  val invariant4 (self : Seq.seq t) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : Seq.seq t)
  val inv4 (_x : Seq.seq t) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : Seq.seq t . inv4 x = true
  use prelude.UIntSize
  predicate invariant3 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Seq.seq usize) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Seq.seq usize)
  val inv3 (_x : Seq.seq usize) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Seq.seq usize . inv3 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model1 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model1 self }
    
  axiom shallow_model1_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv3 (shallow_model1 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model1 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv3 (shallow_model1 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  use seq.Seq
  predicate inv1 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv1 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv1 _x }
    
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv1 self}
    ensures { result = shallow_model3 self }
    
  axiom shallow_model3_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv1 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv4 (shallow_model3 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model3 self) <= UIntSize.to_int max0)
  predicate invariant1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv4 (shallow_model3 self)
  val invariant1 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant1 self }
    
  axiom inv1 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv1 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  function index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model1 self) ix
  val index_logic0 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    ensures { result = index_logic0 self ix }
    
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  use prelude.Mapping
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model3 self) ix
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic2 self ix }
    
  use SparseArray_Sparse_Type as SparseArray_Sparse_Type
  function is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool =
    [#"../sparse_array.rs" 73 20 74 52] UIntSize.to_int (index_logic0 (SparseArray_Sparse_Type.sparse_idx self) i) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) /\ UIntSize.to_int (index_logic0 (SparseArray_Sparse_Type.sparse_back self) (UIntSize.to_int (index_logic0 (SparseArray_Sparse_Type.sparse_idx self) i))) = i
  val is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool
    ensures { result = is_elt0 self i }
    
  function shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    
   =
    [#"../sparse_array.rs" 40 12 41 82] Seq.create (UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) (Mapping.from_fn (fun (i : int) -> if is_elt0 self i then
      Core_Option_Option_Type.C_Some (index_logic2 (SparseArray_Sparse_Type.sparse_values self) i)
    else
      Core_Option_Option_Type.C_None
    ))
  val shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model2 self }
    
  predicate invariant0 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) =
    [#"../sparse_array.rs" 50 8 61 9] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) <= UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model2 self) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model3 (SparseArray_Sparse_Type.sparse_values self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model1 (SparseArray_Sparse_Type.sparse_idx self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model1 (SparseArray_Sparse_Type.sparse_back self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ (forall i : int . 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) -> match index_logic0 (SparseArray_Sparse_Type.sparse_back self) i with
      | j -> 0 <= UIntSize.to_int j /\ UIntSize.to_int j < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ UIntSize.to_int (index_logic0 (SparseArray_Sparse_Type.sparse_idx self) (UIntSize.to_int j)) = i
      end)
  val invariant0 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : SparseArray_Sparse_Type.t_sparse t)
  val inv0 (_x : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : SparseArray_Sparse_Type.t_sparse t . inv0 x = (invariant0 x /\ match x with
    | SparseArray_Sparse_Type.C_Sparse size n values idx back -> true
    end)
  let rec ghost function lemma_permutation [#"../sparse_array.rs" 104 4 104 38] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : ()
    requires {[#"../sparse_array.rs" 101 15 101 34] SparseArray_Sparse_Type.sparse_n self = SparseArray_Sparse_Type.sparse_size self}
    requires {[#"../sparse_array.rs" 102 15 102 39] 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)}
    requires {[#"../sparse_array.rs" 104 25 104 29] inv0 self}
    ensures { [#"../sparse_array.rs" 103 14 103 28] is_elt0 self i }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../sparse_array.rs" 100 4 100 12] ()
end
module SparseArray_Impl2_Set
  type t
  use prelude.UIntSize
  use seq.Seq
  predicate invariant13 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant13 (self : Seq.seq usize) : bool
    ensures { result = invariant13 self }
    
  predicate inv13 (_x : Seq.seq usize)
  val inv13 (_x : Seq.seq usize) : bool
    ensures { result = inv13 _x }
    
  axiom inv13 : forall x : Seq.seq usize . inv13 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv12 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv12 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv12 _x }
    
  function shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv12 self}
    ensures { result = shallow_model7 self }
    
  axiom shallow_model7_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv12 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv13 (shallow_model7 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model7 self) <= UIntSize.to_int max0)
  predicate invariant12 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv13 (shallow_model7 self)
  val invariant12 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant12 self }
    
  axiom inv12 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv12 x = true
  predicate invariant11 (self : Seq.seq t)
  val invariant11 (self : Seq.seq t) : bool
    ensures { result = invariant11 self }
    
  predicate inv11 (_x : Seq.seq t)
  val inv11 (_x : Seq.seq t) : bool
    ensures { result = inv11 _x }
    
  axiom inv11 : forall x : Seq.seq t . inv11 x = true
  use prelude.Borrow
  predicate invariant10 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant10 (self : borrowed usize) : bool
    ensures { result = invariant10 self }
    
  predicate inv10 (_x : borrowed usize)
  val inv10 (_x : borrowed usize) : bool
    ensures { result = inv10 _x }
    
  axiom inv10 : forall x : borrowed usize . inv10 x = true
  predicate invariant9 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant9 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant9 self }
    
  predicate inv9 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)))
  val inv9 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv9 _x }
    
  axiom inv9 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) . inv9 x = true
  predicate inv0 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv0 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv0 _x }
    
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  function index_logic4 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model7 self) ix
  val index_logic4 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    ensures { result = index_logic4 self ix }
    
  use seq.Seq
  function shallow_model4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model4 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self}
    ensures { result = shallow_model4 self }
    
  axiom shallow_model4_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv0 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv11 (shallow_model4 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model4 self) <= UIntSize.to_int max0)
  use seq.Seq
  use seq.Seq
  use prelude.Mapping
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model4 self) ix
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic1 self ix }
    
  use SparseArray_Sparse_Type as SparseArray_Sparse_Type
  function is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool =
    [#"../sparse_array.rs" 73 20 74 52] UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) i) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) /\ UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_back self) (UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) i))) = i
  val is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool
    ensures { result = is_elt0 self i }
    
  function shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    
   =
    [#"../sparse_array.rs" 40 12 41 82] Seq.create (UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) (Mapping.from_fn (fun (i : int) -> if is_elt0 self i then
      Core_Option_Option_Type.C_Some (index_logic1 (SparseArray_Sparse_Type.sparse_values self) i)
    else
      Core_Option_Option_Type.C_None
    ))
  val shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model2 self }
    
  predicate invariant8 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) =
    [#"../sparse_array.rs" 50 8 61 9] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) <= UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model2 self) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model4 (SparseArray_Sparse_Type.sparse_values self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model7 (SparseArray_Sparse_Type.sparse_idx self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model7 (SparseArray_Sparse_Type.sparse_back self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ (forall i : int . 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) -> match index_logic4 (SparseArray_Sparse_Type.sparse_back self) i with
      | j -> 0 <= UIntSize.to_int j /\ UIntSize.to_int j < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ UIntSize.to_int (index_logic4 (SparseArray_Sparse_Type.sparse_idx self) (UIntSize.to_int j)) = i
      end)
  val invariant8 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : SparseArray_Sparse_Type.t_sparse t)
  val inv8 (_x : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : forall x : SparseArray_Sparse_Type.t_sparse t . inv8 x = (invariant8 x /\ match x with
    | SparseArray_Sparse_Type.C_Sparse size n values idx back -> true
    end)
  predicate invariant7 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant7 (self : usize) : bool
    ensures { result = invariant7 self }
    
  predicate inv7 (_x : usize)
  val inv7 (_x : usize) : bool
    ensures { result = inv7 _x }
    
  axiom inv7 : forall x : usize . inv7 x = true
  predicate invariant6 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv6 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv6 x = true
  predicate invariant5 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant5 (self : usize) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : usize)
  val inv5 (_x : usize) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : usize . inv5 x = true
  predicate invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val invariant4 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = invariant4 self }
    
  predicate inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)))
  val inv4 (_x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) . inv4 x = true
  predicate invariant3 (self : borrowed (SparseArray_Sparse_Type.t_sparse t))
  val invariant3 (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : borrowed (SparseArray_Sparse_Type.t_sparse t))
  val inv3 (_x : borrowed (SparseArray_Sparse_Type.t_sparse t)) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : borrowed (SparseArray_Sparse_Type.t_sparse t) . inv3 x = (inv8 ( * x) /\ inv8 ( ^ x))
  predicate invariant2 (self : borrowed t)
  val invariant2 (self : borrowed t) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : borrowed t)
  val inv2 (_x : borrowed t) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : borrowed t . inv2 x = true
  predicate invariant1 (self : t)
  val invariant1 (self : t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : t)
  val inv1 (_x : t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : t . inv1 x = true
  predicate invariant0 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv11 (shallow_model4 self)
  val invariant0 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv0 x = true
  use seq.Seq
  function shallow_model1 (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) : Seq.seq (Core_Option_Option_Type.t_option t)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 97 8 97 31] shallow_model2 ( * self)
  val shallow_model1 (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model1 self }
    
  use prelude.Ghost
  predicate resolve4 (self : borrowed usize) =
    [#"../../../../creusot-contracts/src/resolve.rs" 27 20 27 34]  ^ self =  * self
  val resolve4 (self : borrowed usize) : bool
    ensures { result = resolve4 self }
    
  use prelude.Slice
  predicate resolve_elswhere1 [@inline:trivial] (self : usize) (old' : Seq.seq usize) (fin : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere1 [@inline:trivial] (self : usize) (old' : Seq.seq usize) (fin : Seq.seq usize) : bool
    ensures { result = resolve_elswhere1 self old' fin }
    
  predicate has_value1 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value1 [@inline:trivial] (self : usize) (seq : Seq.seq usize) (out : usize) : bool
    ensures { result = has_value1 self seq out }
    
  predicate in_bounds1 [@inline:trivial] (self : usize) (seq : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds1 [@inline:trivial] (self : usize) (seq : Seq.seq usize) : bool
    ensures { result = in_bounds1 self seq }
    
  function shallow_model6 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : Seq.seq usize
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 97 8 97 31] shallow_model7 ( * self)
  val shallow_model6 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) : Seq.seq usize
    ensures { result = shallow_model6 self }
    
  val index_mut1 (self : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))) (index : usize) : borrowed usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 132 27 132 46] in_bounds1 index (shallow_model6 self)}
    requires {inv9 self}
    requires {inv5 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 133 26 133 54] has_value1 index (shallow_model6 self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 134 26 134 57] has_value1 index (shallow_model7 ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 135 26 135 62] resolve_elswhere1 index (shallow_model6 self) (shallow_model7 ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (shallow_model7 ( ^ self)) = Seq.length (shallow_model6 self) }
    ensures { inv10 result }
    
  predicate resolve3 (self : Ghost.ghost_ty ())
  val resolve3 (self : Ghost.ghost_ty ()) : bool
    ensures { result = resolve3 self }
    
  use prelude.Ghost
  function lemma_permutation0 [#"../sparse_array.rs" 104 4 104 38] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : ()
    
   =
    [#"../sparse_array.rs" 100 4 100 12] ()
  val lemma_permutation0 [#"../sparse_array.rs" 104 4 104 38] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : ()
    requires {[#"../sparse_array.rs" 101 15 101 34] SparseArray_Sparse_Type.sparse_n self = SparseArray_Sparse_Type.sparse_size self}
    requires {[#"../sparse_array.rs" 102 15 102 39] 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)}
    requires {[#"../sparse_array.rs" 104 25 104 29] inv8 self}
    ensures { result = lemma_permutation0 self i }
    
  axiom lemma_permutation0_spec : forall self : SparseArray_Sparse_Type.t_sparse t, i : int . ([#"../sparse_array.rs" 101 15 101 34] SparseArray_Sparse_Type.sparse_n self = SparseArray_Sparse_Type.sparse_size self) -> ([#"../sparse_array.rs" 102 15 102 39] 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) -> ([#"../sparse_array.rs" 104 25 104 29] inv8 self) -> ([#"../sparse_array.rs" 103 14 103 28] is_elt0 self i)
  predicate resolve2 (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) =
    [#"../../../../creusot-contracts/src/resolve.rs" 27 20 27 34]  ^ self =  * self
  val resolve2 (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) : bool
    ensures { result = resolve2 self }
    
  function shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] shallow_model7 self
  val shallow_model5 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    ensures { result = shallow_model5 self }
    
  val index0 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (index : usize) : usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 141 27 141 46] in_bounds1 index (shallow_model5 self)}
    requires {inv6 self}
    requires {inv5 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 142 26 142 54] has_value1 index (shallow_model5 self) result }
    ensures { inv7 result }
    
  predicate resolve1 (self : borrowed t) =
    [#"../../../../creusot-contracts/src/resolve.rs" 27 20 27 34]  ^ self =  * self
  val resolve1 (self : borrowed t) : bool
    ensures { result = resolve1 self }
    
  predicate resolve0 (self : t)
  val resolve0 (self : t) : bool
    ensures { result = resolve0 self }
    
  predicate resolve_elswhere0 [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 129 8 129 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere0 [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere0 self old' fin }
    
  predicate has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 122 20 122 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value0 [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value0 self seq out }
    
  predicate in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../../creusot-contracts/src/std/slice.rs" 115 20 115 37] UIntSize.to_int self < Seq.length seq
  val in_bounds0 [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds0 self seq }
    
  function shallow_model3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
   =
    [#"../../../../creusot-contracts/src/model.rs" 97 8 97 31] shallow_model4 ( * self)
  val shallow_model3 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) : Seq.seq t
    ensures { result = shallow_model3 self }
    
  val index_mut0 (self : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))) (index : usize) : borrowed t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 132 27 132 46] in_bounds0 index (shallow_model3 self)}
    requires {inv4 self}
    requires {inv5 index}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 133 26 133 54] has_value0 index (shallow_model3 self) ( * result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 134 26 134 57] has_value0 index (shallow_model4 ( ^ self)) ( ^ result) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 135 26 135 62] resolve_elswhere0 index (shallow_model3 self) (shallow_model4 ( ^ self)) }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 136 26 136 55] Seq.length (shallow_model4 ( ^ self)) = Seq.length (shallow_model3 self) }
    ensures { inv2 result }
    
  let rec cfg set [#"../sparse_array.rs" 112 4 112 41] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (SparseArray_Sparse_Type.t_sparse t)) (i : usize) (v : t) : ()
    requires {[#"../sparse_array.rs" 108 15 108 31] UIntSize.to_int i < Seq.length (shallow_model1 self)}
    requires {[#"../sparse_array.rs" 112 20 112 24] inv3 self}
    requires {[#"../sparse_array.rs" 112 36 112 37] inv1 v}
    ensures { [#"../sparse_array.rs" 109 14 109 43] Seq.length (shallow_model2 ( ^ self)) = Seq.length (shallow_model1 self) }
    ensures { [#"../sparse_array.rs" 110 4 110 95] forall j : int . 0 <= j /\ j < Seq.length (shallow_model1 self) /\ j <> UIntSize.to_int i -> Seq.get (shallow_model2 ( ^ self)) j = Seq.get (shallow_model1 self) j }
    ensures { [#"../sparse_array.rs" 111 14 111 37] Seq.get (shallow_model2 ( ^ self)) (UIntSize.to_int i) = Core_Option_Option_Type.C_Some v }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (SparseArray_Sparse_Type.t_sparse t) = self;
  var i : usize = i;
  var v : t = v;
  var _9 : borrowed t;
  var _10 : borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
  var index : usize;
  var _13 : usize;
  var _17 : bool;
  var _23 : usize;
  var _27 : Ghost.ghost_ty ();
  var _32 : borrowed usize;
  var _33 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _36 : borrowed usize;
  var _37 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    [#"../sparse_array.rs" 113 8 113 19] _10 <- Borrow.borrow_mut (SparseArray_Sparse_Type.sparse_values ( * self));
    [#"../sparse_array.rs" 113 8 113 19] self <- { self with current = (let SparseArray_Sparse_Type.C_Sparse x0 x1 x2 x3 x4 =  * self in SparseArray_Sparse_Type.C_Sparse x0 x1 ( ^ _10) x3 x4) };
    assume { inv0 ( ^ _10) };
    [#"../sparse_array.rs" 113 8 113 22] _9 <- ([#"../sparse_array.rs" 113 8 113 22] index_mut0 _10 ([#"../sparse_array.rs" 113 20 113 21] i));
    _10 <- any borrowed (Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global));
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    [#"../sparse_array.rs" 113 8 113 22] _9 <- { _9 with current = ([#"../sparse_array.rs" 113 25 113 26] v) };
    [#"../sparse_array.rs" 113 25 113 26] v <- any t;
    assert { [@expl:type invariant] inv1 ( * _9) };
    assume { resolve0 ( * _9) };
    assert { [@expl:type invariant] inv2 _9 };
    assume { resolve1 _9 };
    goto BB5
  }
  BB5 {
    [#"../sparse_array.rs" 114 20 114 31] _13 <- ([#"../sparse_array.rs" 114 20 114 31] index0 ([#"../sparse_array.rs" 114 20 114 28] SparseArray_Sparse_Type.sparse_idx ( * self)) ([#"../sparse_array.rs" 114 29 114 30] i));
    goto BB6
  }
  BB6 {
    [#"../sparse_array.rs" 114 20 114 31] index <- ([#"../sparse_array.rs" 114 20 114 31] _13);
    switch ([#"../sparse_array.rs" 115 13 115 27] ([#"../sparse_array.rs" 115 13 115 18] index) < ([#"../sparse_array.rs" 115 21 115 27] SparseArray_Sparse_Type.sparse_n ( * self)))
      | False -> goto BB7
      | True -> goto BB8
      end
  }
  BB7 {
    [#"../sparse_array.rs" 115 12 115 53] _17 <- ([#"../sparse_array.rs" 115 12 115 53] [#"../sparse_array.rs" 115 12 115 53] false);
    goto BB9
  }
  BB8 {
    [#"../sparse_array.rs" 115 31 115 47] _23 <- ([#"../sparse_array.rs" 115 31 115 47] index0 ([#"../sparse_array.rs" 115 31 115 40] SparseArray_Sparse_Type.sparse_back ( * self)) ([#"../sparse_array.rs" 115 41 115 46] index));
    goto BB10
  }
  BB9 {
    switch ([#"../sparse_array.rs" 115 11 115 53] not _17)
      | False -> goto BB15
      | True -> goto BB11
      end
  }
  BB10 {
    [#"../sparse_array.rs" 115 12 115 53] _17 <- ([#"../sparse_array.rs" 115 31 115 52] ([#"../sparse_array.rs" 115 31 115 47] _23) = ([#"../sparse_array.rs" 115 51 115 52] i));
    goto BB9
  }
  BB11 {
    [#"../sparse_array.rs" 117 12 117 40] _27 <- ([#"../sparse_array.rs" 117 12 117 40] Ghost.new ());
    goto BB12
  }
  BB12 {
    assume { resolve3 _27 };
    assert { [@expl:assertion] [#"../sparse_array.rs" 118 26 118 46] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n ( * self)) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size ( * self)) };
    [#"../sparse_array.rs" 120 12 120 20] _33 <- Borrow.borrow_mut (SparseArray_Sparse_Type.sparse_idx ( * self));
    [#"../sparse_array.rs" 120 12 120 20] self <- { self with current = (let SparseArray_Sparse_Type.C_Sparse x0 x1 x2 x3 x4 =  * self in SparseArray_Sparse_Type.C_Sparse x0 x1 x2 ( ^ _33) x4) };
    [#"../sparse_array.rs" 120 12 120 23] _32 <- ([#"../sparse_array.rs" 120 12 120 23] index_mut1 _33 ([#"../sparse_array.rs" 120 21 120 22] i));
    _33 <- any borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
    goto BB13
  }
  BB13 {
    [#"../sparse_array.rs" 120 12 120 32] _32 <- { _32 with current = ([#"../sparse_array.rs" 120 26 120 32] SparseArray_Sparse_Type.sparse_n ( * self)) };
    assume { resolve4 _32 };
    [#"../sparse_array.rs" 121 12 121 21] _37 <- Borrow.borrow_mut (SparseArray_Sparse_Type.sparse_back ( * self));
    [#"../sparse_array.rs" 121 12 121 21] self <- { self with current = (let SparseArray_Sparse_Type.C_Sparse x0 x1 x2 x3 x4 =  * self in SparseArray_Sparse_Type.C_Sparse x0 x1 x2 x3 ( ^ _37)) };
    [#"../sparse_array.rs" 121 12 121 29] _36 <- ([#"../sparse_array.rs" 121 12 121 29] index_mut1 _37 ([#"../sparse_array.rs" 121 22 121 28] SparseArray_Sparse_Type.sparse_n ( * self)));
    _37 <- any borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
    goto BB14
  }
  BB14 {
    [#"../sparse_array.rs" 121 12 121 33] _36 <- { _36 with current = ([#"../sparse_array.rs" 121 32 121 33] i) };
    assume { resolve4 _36 };
    [#"../sparse_array.rs" 122 12 122 23] self <- { self with current = (let SparseArray_Sparse_Type.C_Sparse x0 x1 x2 x3 x4 =  * self in SparseArray_Sparse_Type.C_Sparse x0 ([#"../sparse_array.rs" 122 12 122 23] SparseArray_Sparse_Type.sparse_n ( * self) + ([#"../sparse_array.rs" 122 22 122 23] [#"../sparse_array.rs" 122 22 122 23] (1 : usize))) x2 x3 x4) };
    assert { [@expl:type invariant] inv3 self };
    assume { resolve2 self };
    [#"../sparse_array.rs" 115 54 123 9] _0 <- ([#"../sparse_array.rs" 115 54 123 9] ());
    goto BB16
  }
  BB15 {
    assert { [@expl:type invariant] inv3 self };
    assume { resolve2 self };
    [#"../sparse_array.rs" 123 9 123 9] _0 <- ([#"../sparse_array.rs" 123 9 123 9] ());
    goto BB16
  }
  BB16 {
    goto BB17
  }
  BB17 {
    return _0
  }
  
end
module SparseArray_Create
  type t
  use prelude.UIntSize
  use seq.Seq
  predicate invariant6 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : Seq.seq usize) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Seq.seq usize)
  val inv6 (_x : Seq.seq usize) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Seq.seq usize . inv6 x = true
  predicate invariant5 (self : Seq.seq t)
  val invariant5 (self : Seq.seq t) : bool
    ensures { result = invariant5 self }
    
  predicate inv5 (_x : Seq.seq t)
  val inv5 (_x : Seq.seq t) : bool
    ensures { result = inv5 _x }
    
  axiom inv5 : forall x : Seq.seq t . inv5 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv4 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv4 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv4 _x }
    
  function shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model3 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv4 self}
    ensures { result = shallow_model3 self }
    
  axiom shallow_model3_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv4 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv6 (shallow_model3 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model3 self) <= UIntSize.to_int max0)
  predicate invariant4 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv6 (shallow_model3 self)
  val invariant4 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant4 self }
    
  axiom inv4 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv4 x = true
  predicate invariant3 (self : usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : usize) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : usize)
  val inv3 (_x : usize) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : usize . inv3 x = true
  use seq.Seq
  predicate inv2 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
  val inv2 (_x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv2 _x }
    
  function shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
  val shallow_model2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : Seq.seq t
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self}
    ensures { result = shallow_model2 self }
    
  axiom shallow_model2_spec : forall self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv2 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv5 (shallow_model2 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model2 self) <= UIntSize.to_int max0)
  predicate invariant2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv5 (shallow_model2 self)
  val invariant2 (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant2 self }
    
  axiom inv2 : forall x : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global) . inv2 x = true
  use Core_Option_Option_Type as Core_Option_Option_Type
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model3 self) ix
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    ensures { result = index_logic2 self ix }
    
  use seq.Seq
  use prelude.Borrow
  use seq.Seq
  use prelude.Mapping
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model2 self) ix
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) (ix : int) : t
    ensures { result = index_logic1 self ix }
    
  use SparseArray_Sparse_Type as SparseArray_Sparse_Type
  function is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool =
    [#"../sparse_array.rs" 73 20 74 52] UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) i) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) /\ UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_back self) (UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) i))) = i
  val is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse t) (i : int) : bool
    ensures { result = is_elt0 self i }
    
  function shallow_model1 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    
   =
    [#"../sparse_array.rs" 40 12 41 82] Seq.create (UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) (Mapping.from_fn (fun (i : int) -> if is_elt0 self i then
      Core_Option_Option_Type.C_Some (index_logic1 (SparseArray_Sparse_Type.sparse_values self) i)
    else
      Core_Option_Option_Type.C_None
    ))
  val shallow_model1 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse t) : Seq.seq (Core_Option_Option_Type.t_option t)
    ensures { result = shallow_model1 self }
    
  predicate invariant1 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) =
    [#"../sparse_array.rs" 50 8 61 9] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) <= UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model1 self) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model2 (SparseArray_Sparse_Type.sparse_values self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model3 (SparseArray_Sparse_Type.sparse_idx self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model3 (SparseArray_Sparse_Type.sparse_back self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ (forall i : int . 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) -> match index_logic2 (SparseArray_Sparse_Type.sparse_back self) i with
      | j -> 0 <= UIntSize.to_int j /\ UIntSize.to_int j < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) (UIntSize.to_int j)) = i
      end)
  val invariant1 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : SparseArray_Sparse_Type.t_sparse t)
  val inv1 (_x : SparseArray_Sparse_Type.t_sparse t) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : SparseArray_Sparse_Type.t_sparse t . inv1 x = (invariant1 x /\ match x with
    | SparseArray_Sparse_Type.C_Sparse size n values idx back -> true
    end)
  predicate invariant0 (self : t)
  val invariant0 (self : t) : bool
    ensures { result = invariant0 self }
    
  predicate inv0 (_x : t)
  val inv0 (_x : t) : bool
    ensures { result = inv0 _x }
    
  axiom inv0 : forall x : t . inv0 x = true
  use seq.Seq
  val from_elem1 (elem : usize) (n : usize) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
    requires {inv3 elem}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 157 22 157 41] Seq.length (shallow_model3 result) = UIntSize.to_int n }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 158 12 158 78] forall i : int . 0 <= i /\ i < UIntSize.to_int n -> index_logic2 result i = elem }
    ensures { inv4 result }
    
  val from_elem0 (elem : t) (n : usize) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    requires {inv0 elem}
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 157 22 157 41] Seq.length (shallow_model2 result) = UIntSize.to_int n }
    ensures { [#"../../../../creusot-contracts/src/std/vec.rs" 158 12 158 78] forall i : int . 0 <= i /\ i < UIntSize.to_int n -> index_logic1 result i = elem }
    ensures { inv2 result }
    
  predicate resolve0 (self : t)
  val resolve0 (self : t) : bool
    ensures { result = resolve0 self }
    
  let rec cfg create [#"../sparse_array.rs" 134 0 134 64] [@cfg:stackify] [@cfg:subregion_analysis] (sz : usize) (dummy : t) : SparseArray_Sparse_Type.t_sparse t
    requires {[#"../sparse_array.rs" 134 42 134 47] inv0 dummy}
    ensures { [#"../sparse_array.rs" 132 10 132 27] SparseArray_Sparse_Type.sparse_size result = sz }
    ensures { [#"../sparse_array.rs" 133 0 133 67] forall i : int . 0 <= i /\ i < UIntSize.to_int sz -> Seq.get (shallow_model1 result) i = Core_Option_Option_Type.C_None }
    ensures { [#"../sparse_array.rs" 134 55 134 64] inv1 result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : SparseArray_Sparse_Type.t_sparse t;
  var sz : usize = sz;
  var dummy : t = dummy;
  var _6 : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global);
  var _9 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _11 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    assert { [@expl:type invariant] inv0 dummy };
    assume { resolve0 dummy };
    [#"../../../../creusot-contracts/src/lib.rs" 195 8 195 40] _6 <- ([#"../sparse_array.rs" 135 37 135 52] from_elem0 ([#"../sparse_array.rs" 135 42 135 47] dummy) ([#"../sparse_array.rs" 135 49 135 51] sz));
    goto BB1
  }
  BB1 {
    [#"../../../../creusot-contracts/src/lib.rs" 195 8 195 40] _9 <- ([#"../sparse_array.rs" 135 59 135 70] from_elem1 ([#"../sparse_array.rs" 135 64 135 65] [#"../sparse_array.rs" 135 64 135 65] (0 : usize)) ([#"../sparse_array.rs" 135 67 135 69] sz));
    goto BB2
  }
  BB2 {
    [#"../../../../creusot-contracts/src/lib.rs" 195 8 195 40] _11 <- ([#"../sparse_array.rs" 135 78 135 89] from_elem1 ([#"../sparse_array.rs" 135 83 135 84] [#"../sparse_array.rs" 135 83 135 84] (0 : usize)) ([#"../sparse_array.rs" 135 86 135 88] sz));
    goto BB3
  }
  BB3 {
    [#"../sparse_array.rs" 135 4 135 91] _0 <- ([#"../sparse_array.rs" 135 4 135 91] SparseArray_Sparse_Type.C_Sparse ([#"../sparse_array.rs" 135 19 135 21] sz) ([#"../sparse_array.rs" 135 26 135 27] [#"../sparse_array.rs" 135 26 135 27] (0 : usize)) _6 _9 _11);
    _6 <- any Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global);
    _9 <- any Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
    _11 <- any Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module SparseArray_F
  use prelude.UIntSize
  use seq.Seq
  predicate invariant8 (self : Seq.seq usize) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant8 (self : Seq.seq usize) : bool
    ensures { result = invariant8 self }
    
  predicate inv8 (_x : Seq.seq usize)
  val inv8 (_x : Seq.seq usize) : bool
    ensures { result = inv8 _x }
    
  axiom inv8 : forall x : Seq.seq usize . inv8 x = true
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  let constant max0  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
  use seq.Seq
  predicate inv7 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global))
  val inv7 (_x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv7 _x }
    
  function shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
  val shallow_model7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : Seq.seq usize
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv7 self}
    ensures { result = shallow_model7 self }
    
  axiom shallow_model7_spec : forall self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv7 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv8 (shallow_model7 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model7 self) <= UIntSize.to_int max0)
  predicate invariant7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv8 (shallow_model7 self)
  val invariant7 (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant7 self }
    
  axiom inv7 : forall x : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global) . inv7 x = true
  use prelude.Int32
  predicate invariant6 (self : Seq.seq int32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant6 (self : Seq.seq int32) : bool
    ensures { result = invariant6 self }
    
  predicate inv6 (_x : Seq.seq int32)
  val inv6 (_x : Seq.seq int32) : bool
    ensures { result = inv6 _x }
    
  axiom inv6 : forall x : Seq.seq int32 . inv6 x = true
  use seq.Seq
  predicate inv5 (_x : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global))
  val inv5 (_x : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = inv5 _x }
    
  function shallow_model6 (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq int32
  val shallow_model6 (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) : Seq.seq int32
    requires {[#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv5 self}
    ensures { result = shallow_model6 self }
    
  axiom shallow_model6_spec : forall self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global) . ([#"../../../../creusot-contracts/src/std/vec.rs" 19 21 19 25] inv5 self) -> ([#"../../../../creusot-contracts/src/std/vec.rs" 19 4 19 36] inv6 (shallow_model6 self)) && ([#"../../../../creusot-contracts/src/std/vec.rs" 18 14 18 41] Seq.length (shallow_model6 self) <= UIntSize.to_int max0)
  predicate invariant5 (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../../creusot-contracts/src/std/vec.rs" 60 20 60 41] inv6 (shallow_model6 self)
  val invariant5 (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = invariant5 self }
    
  axiom inv5 : forall x : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global) . inv5 x = true
  use SparseArray_Sparse_Type as SparseArray_Sparse_Type
  use prelude.Borrow
  predicate invariant4 (self : borrowed (SparseArray_Sparse_Type.t_sparse int32)) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant4 (self : borrowed (SparseArray_Sparse_Type.t_sparse int32)) : bool
    ensures { result = invariant4 self }
    
  predicate inv0 (_x : SparseArray_Sparse_Type.t_sparse int32)
  val inv0 (_x : SparseArray_Sparse_Type.t_sparse int32) : bool
    ensures { result = inv0 _x }
    
  predicate inv4 (_x : borrowed (SparseArray_Sparse_Type.t_sparse int32))
  val inv4 (_x : borrowed (SparseArray_Sparse_Type.t_sparse int32)) : bool
    ensures { result = inv4 _x }
    
  axiom inv4 : forall x : borrowed (SparseArray_Sparse_Type.t_sparse int32) . inv4 x = (inv0 ( * x) /\ inv0 ( ^ x))
  use Core_Option_Option_Type as Core_Option_Option_Type
  predicate invariant3 (self : Core_Option_Option_Type.t_option int32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant3 (self : Core_Option_Option_Type.t_option int32) : bool
    ensures { result = invariant3 self }
    
  predicate inv3 (_x : Core_Option_Option_Type.t_option int32)
  val inv3 (_x : Core_Option_Option_Type.t_option int32) : bool
    ensures { result = inv3 _x }
    
  axiom inv3 : forall x : Core_Option_Option_Type.t_option int32 . inv3 x = true
  predicate invariant2 (self : SparseArray_Sparse_Type.t_sparse int32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant2 (self : SparseArray_Sparse_Type.t_sparse int32) : bool
    ensures { result = invariant2 self }
    
  predicate inv2 (_x : SparseArray_Sparse_Type.t_sparse int32)
  val inv2 (_x : SparseArray_Sparse_Type.t_sparse int32) : bool
    ensures { result = inv2 _x }
    
  axiom inv2 : forall x : SparseArray_Sparse_Type.t_sparse int32 . inv2 x = inv0 x
  predicate invariant1 (self : int32) =
    [#"../../../../creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant1 (self : int32) : bool
    ensures { result = invariant1 self }
    
  predicate inv1 (_x : int32)
  val inv1 (_x : int32) : bool
    ensures { result = inv1 _x }
    
  axiom inv1 : forall x : int32 . inv1 x = true
  use seq.Seq
  function index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model7 self) ix
  val index_logic2 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (ix : int) : usize
    ensures { result = index_logic2 self ix }
    
  use seq.Seq
  use seq.Seq
  use prelude.Mapping
  use seq.Seq
  function index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : int32
    
   =
    [#"../../../../creusot-contracts/src/logic/ops.rs" 20 8 20 31] Seq.get (shallow_model6 self) ix
  val index_logic1 [@inline:trivial] (self : Alloc_Vec_Vec_Type.t_vec int32 (Alloc_Alloc_Global_Type.t_global)) (ix : int) : int32
    ensures { result = index_logic1 self ix }
    
  function is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse int32) (i : int) : bool =
    [#"../sparse_array.rs" 73 20 74 52] UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) i) < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) /\ UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_back self) (UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) i))) = i
  val is_elt0 [#"../sparse_array.rs" 72 4 72 36] (self : SparseArray_Sparse_Type.t_sparse int32) (i : int) : bool
    ensures { result = is_elt0 self i }
    
  function shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse int32) : Seq.seq (Core_Option_Option_Type.t_option int32)
    
   =
    [#"../sparse_array.rs" 40 12 41 82] Seq.create (UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self)) (Mapping.from_fn (fun (i : int) -> if is_elt0 self i then
      Core_Option_Option_Type.C_Some (index_logic1 (SparseArray_Sparse_Type.sparse_values self) i)
    else
      Core_Option_Option_Type.C_None
    ))
  val shallow_model2 [#"../sparse_array.rs" 38 4 38 50] (self : SparseArray_Sparse_Type.t_sparse int32) : Seq.seq (Core_Option_Option_Type.t_option int32)
    ensures { result = shallow_model2 self }
    
  predicate invariant0 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse int32) =
    [#"../sparse_array.rs" 50 8 61 9] UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) <= UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model2 self) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model6 (SparseArray_Sparse_Type.sparse_values self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model7 (SparseArray_Sparse_Type.sparse_idx self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ Seq.length (shallow_model7 (SparseArray_Sparse_Type.sparse_back self)) = UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ (forall i : int . 0 <= i /\ i < UIntSize.to_int (SparseArray_Sparse_Type.sparse_n self) -> match index_logic2 (SparseArray_Sparse_Type.sparse_back self) i with
      | j -> 0 <= UIntSize.to_int j /\ UIntSize.to_int j < UIntSize.to_int (SparseArray_Sparse_Type.sparse_size self) /\ UIntSize.to_int (index_logic2 (SparseArray_Sparse_Type.sparse_idx self) (UIntSize.to_int j)) = i
      end)
  val invariant0 [#"../sparse_array.rs" 49 4 49 30] (self : SparseArray_Sparse_Type.t_sparse int32) : bool
    ensures { result = invariant0 self }
    
  axiom inv0 : forall x : SparseArray_Sparse_Type.t_sparse int32 . inv0 x = (invariant0 x /\ match x with
    | SparseArray_Sparse_Type.C_Sparse size n values idx back -> true
    end)
  use prelude.Int32
  use prelude.Int
  function shallow_model0 (self : int32) : int =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] Int32.to_int self
  val shallow_model0 (self : int32) : int
    ensures { result = shallow_model0 self }
    
  use seq.Seq
  function shallow_model4 (self : borrowed (SparseArray_Sparse_Type.t_sparse int32)) : Seq.seq (Core_Option_Option_Type.t_option int32)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 97 8 97 31] shallow_model2 ( * self)
  val shallow_model4 (self : borrowed (SparseArray_Sparse_Type.t_sparse int32)) : Seq.seq (Core_Option_Option_Type.t_option int32)
    ensures { result = shallow_model4 self }
    
  val set0 [#"../sparse_array.rs" 112 4 112 41] (self : borrowed (SparseArray_Sparse_Type.t_sparse int32)) (i : usize) (v : int32) : ()
    requires {[#"../sparse_array.rs" 108 15 108 31] UIntSize.to_int i < Seq.length (shallow_model4 self)}
    requires {[#"../sparse_array.rs" 112 20 112 24] inv4 self}
    requires {[#"../sparse_array.rs" 112 36 112 37] inv1 v}
    ensures { [#"../sparse_array.rs" 109 14 109 43] Seq.length (shallow_model2 ( ^ self)) = Seq.length (shallow_model4 self) }
    ensures { [#"../sparse_array.rs" 110 4 110 95] forall j : int . 0 <= j /\ j < Seq.length (shallow_model4 self) /\ j <> UIntSize.to_int i -> Seq.get (shallow_model2 ( ^ self)) j = Seq.get (shallow_model4 self) j }
    ensures { [#"../sparse_array.rs" 111 14 111 37] Seq.get (shallow_model2 ( ^ self)) (UIntSize.to_int i) = Core_Option_Option_Type.C_Some v }
    
  function shallow_model3 (self : SparseArray_Sparse_Type.t_sparse int32) : Seq.seq (Core_Option_Option_Type.t_option int32)
    
   =
    [#"../../../../creusot-contracts/src/model.rs" 79 8 79 31] shallow_model2 self
  val shallow_model3 (self : SparseArray_Sparse_Type.t_sparse int32) : Seq.seq (Core_Option_Option_Type.t_option int32)
    ensures { result = shallow_model3 self }
    
  val get0 [#"../sparse_array.rs" 89 4 89 45] (self : SparseArray_Sparse_Type.t_sparse int32) (i : usize) : Core_Option_Option_Type.t_option int32
    requires {[#"../sparse_array.rs" 80 15 80 31] UIntSize.to_int i < Seq.length (shallow_model3 self)}
    requires {[#"../sparse_array.rs" 89 16 89 20] inv2 self}
    ensures { [#"../sparse_array.rs" 81 14 84 5] match result with
      | Core_Option_Option_Type.C_None -> Seq.get (shallow_model3 self) (UIntSize.to_int i) = Core_Option_Option_Type.C_None
      | Core_Option_Option_Type.C_Some x -> Seq.get (shallow_model3 self) (UIntSize.to_int i) = Core_Option_Option_Type.C_Some x
      end }
    ensures { [#"../sparse_array.rs" 85 14 88 5] match Seq.get (shallow_model3 self) (UIntSize.to_int i) with
      | Core_Option_Option_Type.C_None -> result = Core_Option_Option_Type.C_None
      | Core_Option_Option_Type.C_Some _ -> true
      end }
    ensures { [#"../sparse_array.rs" 89 35 89 45] inv3 result }
    
  val create0 [#"../sparse_array.rs" 134 0 134 64] (sz : usize) (dummy : int32) : SparseArray_Sparse_Type.t_sparse int32
    requires {[#"../sparse_array.rs" 134 42 134 47] inv1 dummy}
    ensures { [#"../sparse_array.rs" 132 10 132 27] SparseArray_Sparse_Type.sparse_size result = sz }
    ensures { [#"../sparse_array.rs" 133 0 133 67] forall i : int . 0 <= i /\ i < UIntSize.to_int sz -> Seq.get (shallow_model2 result) i = Core_Option_Option_Type.C_None }
    ensures { [#"../sparse_array.rs" 134 55 134 64] inv0 result }
    
  let rec cfg f [#"../sparse_array.rs" 140 0 140 10] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var default : int32;
  var a : SparseArray_Sparse_Type.t_sparse int32;
  var b : SparseArray_Sparse_Type.t_sparse int32;
  var x : Core_Option_Option_Type.t_option int32;
  var y : Core_Option_Option_Type.t_option int32;
  var _12 : ();
  var _13 : borrowed (SparseArray_Sparse_Type.t_sparse int32);
  var _14 : ();
  var _15 : borrowed (SparseArray_Sparse_Type.t_sparse int32);
  var _16 : Core_Option_Option_Type.t_option int32;
  var _18 : Core_Option_Option_Type.t_option int32;
  var _24 : Core_Option_Option_Type.t_option int32;
  var _26 : Core_Option_Option_Type.t_option int32;
  var _30 : Core_Option_Option_Type.t_option int32;
  var _32 : Core_Option_Option_Type.t_option int32;
  var _36 : Core_Option_Option_Type.t_option int32;
  var _38 : Core_Option_Option_Type.t_option int32;
  {
    goto BB0
  }
  BB0 {
    [#"../sparse_array.rs" 141 18 141 19] default <- ([#"../sparse_array.rs" 141 18 141 19] [#"../sparse_array.rs" 141 18 141 19] (0 : int32));
    [#"../sparse_array.rs" 142 16 142 35] a <- ([#"../sparse_array.rs" 142 16 142 35] create0 ([#"../sparse_array.rs" 142 23 142 25] [#"../sparse_array.rs" 142 23 142 25] (10 : usize)) ([#"../sparse_array.rs" 142 27 142 34] default));
    goto BB1
  }
  BB1 {
    [#"../sparse_array.rs" 143 16 143 35] b <- ([#"../sparse_array.rs" 143 16 143 35] create0 ([#"../sparse_array.rs" 143 23 143 25] [#"../sparse_array.rs" 143 23 143 25] (20 : usize)) ([#"../sparse_array.rs" 143 27 143 34] default));
    goto BB2
  }
  BB2 {
    [#"../sparse_array.rs" 144 16 144 24] x <- ([#"../sparse_array.rs" 144 16 144 24] get0 ([#"../sparse_array.rs" 144 16 144 24] a) ([#"../sparse_array.rs" 144 22 144 23] [#"../sparse_array.rs" 144 22 144 23] (5 : usize)));
    goto BB3
  }
  BB3 {
    [#"../sparse_array.rs" 145 16 145 24] y <- ([#"../sparse_array.rs" 145 16 145 24] get0 ([#"../sparse_array.rs" 145 16 145 24] b) ([#"../sparse_array.rs" 145 22 145 23] [#"../sparse_array.rs" 145 22 145 23] (7 : usize)));
    goto BB4
  }
  BB4 {
    assert { [@expl:assertion] [#"../sparse_array.rs" 146 18 146 40] x = Core_Option_Option_Type.C_None /\ y = Core_Option_Option_Type.C_None };
    [#"../sparse_array.rs" 148 4 148 15] _13 <- Borrow.borrow_mut a;
    [#"../sparse_array.rs" 148 4 148 15] a <-  ^ _13;
    assume { inv0 ( ^ _13) };
    [#"../sparse_array.rs" 148 4 148 15] _12 <- ([#"../sparse_array.rs" 148 4 148 15] set0 _13 ([#"../sparse_array.rs" 148 10 148 11] [#"../sparse_array.rs" 148 10 148 11] (5 : usize)) ([#"../sparse_array.rs" 148 13 148 14] [#"../sparse_array.rs" 148 13 148 14] (1 : int32)));
    _13 <- any borrowed (SparseArray_Sparse_Type.t_sparse int32);
    goto BB5
  }
  BB5 {
    [#"../sparse_array.rs" 149 4 149 15] _15 <- Borrow.borrow_mut b;
    [#"../sparse_array.rs" 149 4 149 15] b <-  ^ _15;
    assume { inv0 ( ^ _15) };
    [#"../sparse_array.rs" 149 4 149 15] _14 <- ([#"../sparse_array.rs" 149 4 149 15] set0 _15 ([#"../sparse_array.rs" 149 10 149 11] [#"../sparse_array.rs" 149 10 149 11] (7 : usize)) ([#"../sparse_array.rs" 149 13 149 14] [#"../sparse_array.rs" 149 13 149 14] (2 : int32)));
    _15 <- any borrowed (SparseArray_Sparse_Type.t_sparse int32);
    goto BB6
  }
  BB6 {
    [#"../sparse_array.rs" 150 8 150 16] _16 <- ([#"../sparse_array.rs" 150 8 150 16] get0 ([#"../sparse_array.rs" 150 8 150 16] a) ([#"../sparse_array.rs" 150 14 150 15] [#"../sparse_array.rs" 150 14 150 15] (5 : usize)));
    goto BB7
  }
  BB7 {
    [#"../sparse_array.rs" 150 4 150 16] x <- ([#"../sparse_array.rs" 150 4 150 16] _16);
    [#"../sparse_array.rs" 150 4 150 16] _16 <- any Core_Option_Option_Type.t_option int32;
    [#"../sparse_array.rs" 151 8 151 16] _18 <- ([#"../sparse_array.rs" 151 8 151 16] get0 ([#"../sparse_array.rs" 151 8 151 16] b) ([#"../sparse_array.rs" 151 14 151 15] [#"../sparse_array.rs" 151 14 151 15] (7 : usize)));
    goto BB8
  }
  BB8 {
    [#"../sparse_array.rs" 151 4 151 16] y <- ([#"../sparse_array.rs" 151 4 151 16] _18);
    [#"../sparse_array.rs" 151 4 151 16] _18 <- any Core_Option_Option_Type.t_option int32;
    assert { [@expl:assertion] [#"../sparse_array.rs" 152 18 155 5] match x with
      | Core_Option_Option_Type.C_None -> false
      | Core_Option_Option_Type.C_Some z -> shallow_model0 z = 1
      end };
    assert { [@expl:assertion] [#"../sparse_array.rs" 156 18 159 5] match y with
      | Core_Option_Option_Type.C_None -> false
      | Core_Option_Option_Type.C_Some z -> shallow_model0 z = 2
      end };
    [#"../sparse_array.rs" 161 8 161 16] _24 <- ([#"../sparse_array.rs" 161 8 161 16] get0 ([#"../sparse_array.rs" 161 8 161 16] a) ([#"../sparse_array.rs" 161 14 161 15] [#"../sparse_array.rs" 161 14 161 15] (7 : usize)));
    goto BB9
  }
  BB9 {
    [#"../sparse_array.rs" 161 4 161 16] x <- ([#"../sparse_array.rs" 161 4 161 16] _24);
    [#"../sparse_array.rs" 161 4 161 16] _24 <- any Core_Option_Option_Type.t_option int32;
    [#"../sparse_array.rs" 162 8 162 16] _26 <- ([#"../sparse_array.rs" 162 8 162 16] get0 ([#"../sparse_array.rs" 162 8 162 16] b) ([#"../sparse_array.rs" 162 14 162 15] [#"../sparse_array.rs" 162 14 162 15] (5 : usize)));
    goto BB10
  }
  BB10 {
    [#"../sparse_array.rs" 162 4 162 16] y <- ([#"../sparse_array.rs" 162 4 162 16] _26);
    [#"../sparse_array.rs" 162 4 162 16] _26 <- any Core_Option_Option_Type.t_option int32;
    assert { [@expl:assertion] [#"../sparse_array.rs" 163 18 163 40] x = Core_Option_Option_Type.C_None /\ y = Core_Option_Option_Type.C_None };
    [#"../sparse_array.rs" 165 8 165 16] _30 <- ([#"../sparse_array.rs" 165 8 165 16] get0 ([#"../sparse_array.rs" 165 8 165 16] a) ([#"../sparse_array.rs" 165 14 165 15] [#"../sparse_array.rs" 165 14 165 15] (0 : usize)));
    goto BB11
  }
  BB11 {
    [#"../sparse_array.rs" 165 4 165 16] x <- ([#"../sparse_array.rs" 165 4 165 16] _30);
    [#"../sparse_array.rs" 165 4 165 16] _30 <- any Core_Option_Option_Type.t_option int32;
    [#"../sparse_array.rs" 166 8 166 16] _32 <- ([#"../sparse_array.rs" 166 8 166 16] get0 ([#"../sparse_array.rs" 166 8 166 16] b) ([#"../sparse_array.rs" 166 14 166 15] [#"../sparse_array.rs" 166 14 166 15] (0 : usize)));
    goto BB12
  }
  BB12 {
    [#"../sparse_array.rs" 166 4 166 16] y <- ([#"../sparse_array.rs" 166 4 166 16] _32);
    [#"../sparse_array.rs" 166 4 166 16] _32 <- any Core_Option_Option_Type.t_option int32;
    assert { [@expl:assertion] [#"../sparse_array.rs" 167 18 167 40] x = Core_Option_Option_Type.C_None /\ y = Core_Option_Option_Type.C_None };
    [#"../sparse_array.rs" 169 8 169 16] _36 <- ([#"../sparse_array.rs" 169 8 169 16] get0 ([#"../sparse_array.rs" 169 8 169 16] a) ([#"../sparse_array.rs" 169 14 169 15] [#"../sparse_array.rs" 169 14 169 15] (9 : usize)));
    goto BB13
  }
  BB13 {
    [#"../sparse_array.rs" 169 4 169 16] x <- ([#"../sparse_array.rs" 169 4 169 16] _36);
    [#"../sparse_array.rs" 169 4 169 16] _36 <- any Core_Option_Option_Type.t_option int32;
    [#"../sparse_array.rs" 170 8 170 16] _38 <- ([#"../sparse_array.rs" 170 8 170 16] get0 ([#"../sparse_array.rs" 170 8 170 16] b) ([#"../sparse_array.rs" 170 14 170 15] [#"../sparse_array.rs" 170 14 170 15] (9 : usize)));
    goto BB14
  }
  BB14 {
    [#"../sparse_array.rs" 170 4 170 16] y <- ([#"../sparse_array.rs" 170 4 170 16] _38);
    [#"../sparse_array.rs" 170 4 170 16] _38 <- any Core_Option_Option_Type.t_option int32;
    assert { [@expl:assertion] [#"../sparse_array.rs" 171 18 171 40] x = Core_Option_Option_Type.C_None /\ y = Core_Option_Option_Type.C_None };
    [#"../sparse_array.rs" 171 4 171 41] _0 <- ([#"../sparse_array.rs" 171 4 171 41] ());
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    return _0
  }
  
end
module SparseArray_Impl0
  type t
end
module SparseArray_Impl1
  type t
end
